#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RuntimeTransformer

#include "Basic.hpp"

#include "RuntimeTransformer_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class RuntimeTransformer.BaseGizmo
// 0x00B0 (0x02D0 - 0x0220)
class ABaseGizmo : public AActor
{
public:
	TMulticastInlineDelegate<void(ETransformationType GizmoType, bool bTransformInProgress, ETransformationDomain CurrentDomain)> OnGizmoStateChange;                                // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        RootScene;                                         // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ScalingScene;                                      // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          X_AxisBox;                                         // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          Y_AxisBox;                                         // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          Z_AxisBox;                                         // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x18];                                     // 0x0258(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GizmoSceneScaleFactor;                             // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraArcRadius;                                   // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x58];                                     // 0x0278(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterDomainComponent(class USceneComponent* Component, ETransformationDomain Domain);
	void SetTransformProgressState(bool bInProgress, ETransformationDomain CurrentDomain);

	ETransformationDomain GetTransformationDomain(class USceneComponent* ComponentHit) const;
	bool GetTransformProgressState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseGizmo">();
	}
	static class ABaseGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseGizmo>();
	}
};
static_assert(alignof(ABaseGizmo) == 0x000008, "Wrong alignment on ABaseGizmo");
static_assert(sizeof(ABaseGizmo) == 0x0002D0, "Wrong size on ABaseGizmo");
static_assert(offsetof(ABaseGizmo, OnGizmoStateChange) == 0x000220, "Member 'ABaseGizmo::OnGizmoStateChange' has a wrong offset!");
static_assert(offsetof(ABaseGizmo, RootScene) == 0x000230, "Member 'ABaseGizmo::RootScene' has a wrong offset!");
static_assert(offsetof(ABaseGizmo, ScalingScene) == 0x000238, "Member 'ABaseGizmo::ScalingScene' has a wrong offset!");
static_assert(offsetof(ABaseGizmo, X_AxisBox) == 0x000240, "Member 'ABaseGizmo::X_AxisBox' has a wrong offset!");
static_assert(offsetof(ABaseGizmo, Y_AxisBox) == 0x000248, "Member 'ABaseGizmo::Y_AxisBox' has a wrong offset!");
static_assert(offsetof(ABaseGizmo, Z_AxisBox) == 0x000250, "Member 'ABaseGizmo::Z_AxisBox' has a wrong offset!");
static_assert(offsetof(ABaseGizmo, GizmoSceneScaleFactor) == 0x000270, "Member 'ABaseGizmo::GizmoSceneScaleFactor' has a wrong offset!");
static_assert(offsetof(ABaseGizmo, CameraArcRadius) == 0x000274, "Member 'ABaseGizmo::CameraArcRadius' has a wrong offset!");

// Class RuntimeTransformer.FocusableObject
// 0x0000 (0x0028 - 0x0028)
class IFocusableObject final : public IInterface
{
public:
	void Focus(class ATransformerPawn* Caller, class USceneComponent* Component, bool bComponentBased);
	void OnNewTransformation(class ATransformerPawn* Caller, class USceneComponent* Component, const struct FTransform& NewTransform, bool bComponentBased);
	void Unfocus(class ATransformerPawn* Caller, class USceneComponent* Component, bool bComponentBased);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusableObject">();
	}
	static class IFocusableObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFocusableObject>();
	}
};
static_assert(alignof(IFocusableObject) == 0x000008, "Wrong alignment on IFocusableObject");
static_assert(sizeof(IFocusableObject) == 0x000028, "Wrong size on IFocusableObject");

// Class RuntimeTransformer.RotationGizmo
// 0x0010 (0x02E0 - 0x02D0)
class ARotationGizmo : public ABaseGizmo
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RotationGizmo">();
	}
	static class ARotationGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARotationGizmo>();
	}
};
static_assert(alignof(ARotationGizmo) == 0x000008, "Wrong alignment on ARotationGizmo");
static_assert(sizeof(ARotationGizmo) == 0x0002E0, "Wrong size on ARotationGizmo");

// Class RuntimeTransformer.ScaleGizmo
// 0x0028 (0x02F8 - 0x02D0)
class AScaleGizmo : public ABaseGizmo
{
public:
	float                                         ScalingFactor;                                     // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          XY_PlaneBox;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          YZ_PlaneBox;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          XZ_PlaneBox;                                       // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       XYZ_Sphere;                                        // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScaleGizmo">();
	}
	static class AScaleGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<AScaleGizmo>();
	}
};
static_assert(alignof(AScaleGizmo) == 0x000008, "Wrong alignment on AScaleGizmo");
static_assert(sizeof(AScaleGizmo) == 0x0002F8, "Wrong size on AScaleGizmo");
static_assert(offsetof(AScaleGizmo, ScalingFactor) == 0x0002D0, "Member 'AScaleGizmo::ScalingFactor' has a wrong offset!");
static_assert(offsetof(AScaleGizmo, XY_PlaneBox) == 0x0002D8, "Member 'AScaleGizmo::XY_PlaneBox' has a wrong offset!");
static_assert(offsetof(AScaleGizmo, YZ_PlaneBox) == 0x0002E0, "Member 'AScaleGizmo::YZ_PlaneBox' has a wrong offset!");
static_assert(offsetof(AScaleGizmo, XZ_PlaneBox) == 0x0002E8, "Member 'AScaleGizmo::XZ_PlaneBox' has a wrong offset!");
static_assert(offsetof(AScaleGizmo, XYZ_Sphere) == 0x0002F0, "Member 'AScaleGizmo::XYZ_Sphere' has a wrong offset!");

// Class RuntimeTransformer.TransformerPawn
// 0x0188 (0x0430 - 0x02A8)
class alignas(0x10) ATransformerPawn : public ADefaultPawn
{
public:
	bool                                          bIgnoreNonReplicatedObjects;                       // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumCloneReplicationTime;                       // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CloneReplicationCheckFrequency;                    // 0x02B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x5C];                                     // 0x02B4(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	ESpaceType                                    CurrentSpaceType;                                  // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_311[0x3F];                                     // 0x0311(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATranslationGizmo>          TranslationGizmoClass;                             // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ARotationGizmo>             RotationGizmoClass;                                // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AScaleGizmo>                ScaleGizmoClass;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ABaseGizmo>              Gizmo;                                             // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x1];                                      // 0x0370(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EGizmoPlacement                               GizmoPlacement;                                    // 0x0371(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETransformationType                           CurrentTransformation;                             // 0x0372(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_373[0x15];                                     // 0x0373(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETransformationType, float>              SnappingValues;                                    // 0x0388(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	TMap<ETransformationType, bool>               SnappingEnabled;                                   // 0x03D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	bool                                          bForceMobility;                                    // 0x0428(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRotateOnLocalAxis;                                // 0x0429(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTransformUFocusableObjects;                       // 0x042A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleSelectedInMultiSelection;                   // 0x042B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bComponentBased;                                   // 0x042C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42D[0x3];                                      // 0x042D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDeltaTransform(const struct FTransform& DeltaTransform);
	void ClearDomain();
	void CloneSelected(bool bSelectNewClones, bool bAppendToList);
	void DeselectActor(class AActor* Actor);
	TArray<class USceneComponent*> DeselectAll(bool bDestroyDeselected);
	void DeselectComponent(class USceneComponent* Component);
	bool HandleTracedObjects(const TArray<struct FHitResult>& HitResults, bool bAppendToList);
	void LogSelectedComponents();
	bool MouseTraceByChannel(float TraceDistance, ECollisionChannel TraceChannel, const TArray<class AActor*>& IgnoredActors, bool bAppendToList);
	bool MouseTraceByObjectTypes(float TraceDistance, const TArray<ECollisionChannel>& CollisionChannels, const TArray<class AActor*>& IgnoredActors, bool bAppendToList);
	bool MouseTraceByProfile(float TraceDistance, const class FName& ProfileName, const TArray<class AActor*>& IgnoredActors, bool bAppendToList);
	void MulticastApplyTransform(const struct FTransform& DeltaTransform);
	void MulticastClearDomain();
	void MulticastDeselectAll(bool bDestroySelected);
	void MulticastSetComponentBased(bool bIsComponentBased);
	void MulticastSetDomain(ETransformationDomain Domain);
	void MulticastSetRotateOnLocalAxis(bool bRotateLocalAxis);
	void MulticastSetSelectedComponents(const TArray<class USceneComponent*>& Components);
	void MulticastSetSpaceType(ESpaceType Space);
	void MulticastSetTransformationType(ETransformationType Transformation);
	void OnComponentSelectionChange(class USceneComponent* Component, bool bSelected, bool bImplementsUFocusable);
	void OnGizmoStateChanged(ETransformationType GizmoType, bool bTransformInProgress, ETransformationDomain Domain);
	void ReplicatedMouseTraceByChannel(float TraceDistance, ECollisionChannel CollisionChannel, bool bAppendToList);
	void ReplicatedMouseTraceByObjectTypes(float TraceDistance, const TArray<ECollisionChannel>& CollisionChannels, bool bAppendToList);
	void ReplicatedMouseTraceByProfile(float TraceDistance, const class FName& ProfileName, bool bAppendToList);
	void ReplicateFinishTransform();
	void SelectActor(class AActor* Actor, bool bAppendToList);
	void SelectComponent(class USceneComponent* Component, bool bAppendToList);
	void SelectMultipleActors(const TArray<class AActor*>& Actors, bool bAppendToList);
	void SelectMultipleComponents(const TArray<class USceneComponent*>& Components, bool bAppendToList);
	void ServerApplyTransform(const struct FTransform& DeltaTransform);
	void ServerClearDomain();
	void ServerCloneSelected(bool bSelectNewClones, bool bAppendToList);
	void ServerDeselectAll(bool bDestroySelected);
	void ServerSetComponentBased(bool bIsComponentBased);
	void ServerSetDomain(ETransformationDomain Domain);
	void ServerSetRotateOnLocalAxis(bool bRotateLocalAxis);
	void ServerSetSpaceType(ESpaceType Space);
	void ServerSetTransformationType(ETransformationType Transformation);
	void ServerSyncSelectedComponents();
	void ServerTraceByChannel(const struct FVector& StartLocation, const struct FVector& EndLocation, ECollisionChannel TraceChannel, bool bAppendToList);
	void ServerTraceByObjectTypes(const struct FVector& StartLocation, const struct FVector& EndLocation, const TArray<ECollisionChannel>& CollisionChannels, bool bAppendToList);
	void ServerTraceByProfile(const struct FVector& StartLocation, const struct FVector& EndLocation, const class FName& ProfileName, bool bAppendToList);
	void SetComponentBased(bool bIsComponentBased);
	void SetRotateOnLocalAxis(bool bRotateLocalAxis);
	void SetSnappingEnabled(ETransformationType TransformationType, bool bSnappingEnabled);
	void SetSnappingValue(ETransformationType TransformationType, float SnappingValue);
	void SetSpaceType(ESpaceType Type);
	void SetTransformationType(ETransformationType TransformationType);
	bool ShouldSelect(class AActor* OwnerActor, class USceneComponent* Component);
	bool TraceByChannel(const struct FVector& StartLocation, const struct FVector& EndLocation, ECollisionChannel TraceChannel, const TArray<class AActor*>& IgnoredActors, bool bAppendToList);
	bool TraceByObjectTypes(const struct FVector& StartLocation, const struct FVector& EndLocation, const TArray<ECollisionChannel>& CollisionChannels, const TArray<class AActor*>& IgnoredActors, bool bAppendToList);
	bool TraceByProfile(const struct FVector& StartLocation, const struct FVector& EndLocation, const class FName& ProfileName, const TArray<class AActor*>& IgnoredActors, bool bAppendToList);
	struct FTransform UpdateTransform(const struct FVector& LookingVector, const struct FVector& RayOrigin, const struct FVector& RayDirection);

	ETransformationDomain GetCurrentDomain(bool* TransformInProgress) const;
	void GetSelectedComponents(TArray<class USceneComponent*>* outComponentList, class USceneComponent** outGizmoPlacedComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransformerPawn">();
	}
	static class ATransformerPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATransformerPawn>();
	}
};
static_assert(alignof(ATransformerPawn) == 0x000010, "Wrong alignment on ATransformerPawn");
static_assert(sizeof(ATransformerPawn) == 0x000430, "Wrong size on ATransformerPawn");
static_assert(offsetof(ATransformerPawn, bIgnoreNonReplicatedObjects) == 0x0002A8, "Member 'ATransformerPawn::bIgnoreNonReplicatedObjects' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, MinimumCloneReplicationTime) == 0x0002AC, "Member 'ATransformerPawn::MinimumCloneReplicationTime' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, CloneReplicationCheckFrequency) == 0x0002B0, "Member 'ATransformerPawn::CloneReplicationCheckFrequency' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, CurrentSpaceType) == 0x000310, "Member 'ATransformerPawn::CurrentSpaceType' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, TranslationGizmoClass) == 0x000350, "Member 'ATransformerPawn::TranslationGizmoClass' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, RotationGizmoClass) == 0x000358, "Member 'ATransformerPawn::RotationGizmoClass' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, ScaleGizmoClass) == 0x000360, "Member 'ATransformerPawn::ScaleGizmoClass' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, Gizmo) == 0x000368, "Member 'ATransformerPawn::Gizmo' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, GizmoPlacement) == 0x000371, "Member 'ATransformerPawn::GizmoPlacement' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, CurrentTransformation) == 0x000372, "Member 'ATransformerPawn::CurrentTransformation' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, SnappingValues) == 0x000388, "Member 'ATransformerPawn::SnappingValues' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, SnappingEnabled) == 0x0003D8, "Member 'ATransformerPawn::SnappingEnabled' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, bForceMobility) == 0x000428, "Member 'ATransformerPawn::bForceMobility' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, bRotateOnLocalAxis) == 0x000429, "Member 'ATransformerPawn::bRotateOnLocalAxis' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, bTransformUFocusableObjects) == 0x00042A, "Member 'ATransformerPawn::bTransformUFocusableObjects' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, bToggleSelectedInMultiSelection) == 0x00042B, "Member 'ATransformerPawn::bToggleSelectedInMultiSelection' has a wrong offset!");
static_assert(offsetof(ATransformerPawn, bComponentBased) == 0x00042C, "Member 'ATransformerPawn::bComponentBased' has a wrong offset!");

// Class RuntimeTransformer.TranslationGizmo
// 0x0020 (0x02F0 - 0x02D0)
class ATranslationGizmo : public ABaseGizmo
{
public:
	class UBoxComponent*                          XY_PlaneBox;                                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          YZ_PlaneBox;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          XZ_PlaneBox;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       XYZ_Sphere;                                        // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TranslationGizmo">();
	}
	static class ATranslationGizmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATranslationGizmo>();
	}
};
static_assert(alignof(ATranslationGizmo) == 0x000008, "Wrong alignment on ATranslationGizmo");
static_assert(sizeof(ATranslationGizmo) == 0x0002F0, "Wrong size on ATranslationGizmo");
static_assert(offsetof(ATranslationGizmo, XY_PlaneBox) == 0x0002D0, "Member 'ATranslationGizmo::XY_PlaneBox' has a wrong offset!");
static_assert(offsetof(ATranslationGizmo, YZ_PlaneBox) == 0x0002D8, "Member 'ATranslationGizmo::YZ_PlaneBox' has a wrong offset!");
static_assert(offsetof(ATranslationGizmo, XZ_PlaneBox) == 0x0002E0, "Member 'ATranslationGizmo::XZ_PlaneBox' has a wrong offset!");
static_assert(offsetof(ATranslationGizmo, XYZ_Sphere) == 0x0002E8, "Member 'ATranslationGizmo::XYZ_Sphere' has a wrong offset!");

}

