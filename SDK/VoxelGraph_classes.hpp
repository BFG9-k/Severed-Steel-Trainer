#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VoxelGraph

#include "Basic.hpp"

#include "Voxel_structs.hpp"
#include "Voxel_classes.hpp"
#include "VoxelGraph_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class VoxelGraph.VoxelNode
// 0x0030 (0x0058 - 0x0028)
class UVoxelNode : public UObject
{
public:
	TArray<struct FVoxelPin>                      InputPins;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVoxelPin>                      OutputPins;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UVoxelGraphGenerator*                   Graph;                                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputPinCount;                                     // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode">();
	}
	static class UVoxelNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode>();
	}
};
static_assert(alignof(UVoxelNode) == 0x000008, "Wrong alignment on UVoxelNode");
static_assert(sizeof(UVoxelNode) == 0x000058, "Wrong size on UVoxelNode");
static_assert(offsetof(UVoxelNode, InputPins) == 0x000028, "Member 'UVoxelNode::InputPins' has a wrong offset!");
static_assert(offsetof(UVoxelNode, OutputPins) == 0x000038, "Member 'UVoxelNode::OutputPins' has a wrong offset!");
static_assert(offsetof(UVoxelNode, Graph) == 0x000048, "Member 'UVoxelNode::Graph' has a wrong offset!");
static_assert(offsetof(UVoxelNode, InputPinCount) == 0x000050, "Member 'UVoxelNode::InputPinCount' has a wrong offset!");

// Class VoxelGraph.VoxelNodeHelper
// 0x0040 (0x0098 - 0x0058)
class UVoxelNodeHelper : public UVoxelNode
{
public:
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNodeHelper">();
	}
	static class UVoxelNodeHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNodeHelper>();
	}
};
static_assert(alignof(UVoxelNodeHelper) == 0x000008, "Wrong alignment on UVoxelNodeHelper");
static_assert(sizeof(UVoxelNodeHelper) == 0x000098, "Wrong size on UVoxelNodeHelper");

// Class VoxelGraph.VoxelNode_HeightSplitter
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_HeightSplitter final : public UVoxelNodeHelper
{
public:
	int32                                         NumSplits;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_HeightSplitter">();
	}
	static class UVoxelNode_HeightSplitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_HeightSplitter>();
	}
};
static_assert(alignof(UVoxelNode_HeightSplitter) == 0x000008, "Wrong alignment on UVoxelNode_HeightSplitter");
static_assert(sizeof(UVoxelNode_HeightSplitter) == 0x0000A0, "Wrong size on UVoxelNode_HeightSplitter");
static_assert(offsetof(UVoxelNode_HeightSplitter, NumSplits) == 0x000098, "Member 'UVoxelNode_HeightSplitter::NumSplits' has a wrong offset!");

// Class VoxelGraph.VoxelGraphGeneratorHelper
// 0x0008 (0x0030 - 0x0028)
class UVoxelGraphGeneratorHelper : public UVoxelTransformableGenerator
{
public:
	bool                                          bEnableRangeAnalysis;                              // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphGeneratorHelper">();
	}
	static class UVoxelGraphGeneratorHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphGeneratorHelper>();
	}
};
static_assert(alignof(UVoxelGraphGeneratorHelper) == 0x000008, "Wrong alignment on UVoxelGraphGeneratorHelper");
static_assert(sizeof(UVoxelGraphGeneratorHelper) == 0x000030, "Wrong size on UVoxelGraphGeneratorHelper");
static_assert(offsetof(UVoxelGraphGeneratorHelper, bEnableRangeAnalysis) == 0x000028, "Member 'UVoxelGraphGeneratorHelper::bEnableRangeAnalysis' has a wrong offset!");

// Class VoxelGraph.VDI_Capsule_Graph
// 0x0008 (0x0038 - 0x0030)
class UVDI_Capsule_Graph final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Noise_Amplitude;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDI_Capsule_Graph">();
	}
	static class UVDI_Capsule_Graph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDI_Capsule_Graph>();
	}
};
static_assert(alignof(UVDI_Capsule_Graph) == 0x000008, "Wrong alignment on UVDI_Capsule_Graph");
static_assert(sizeof(UVDI_Capsule_Graph) == 0x000038, "Wrong size on UVDI_Capsule_Graph");
static_assert(offsetof(UVDI_Capsule_Graph, Noise_Amplitude) == 0x000030, "Member 'UVDI_Capsule_Graph::Noise_Amplitude' has a wrong offset!");
static_assert(offsetof(UVDI_Capsule_Graph, Seed) == 0x000034, "Member 'UVDI_Capsule_Graph::Seed' has a wrong offset!");

// Class VoxelGraph.VoxelGraphMacroInputOutputNode
// 0x0018 (0x0070 - 0x0058)
class UVoxelGraphMacroInputOutputNode : public UVoxelNode
{
public:
	TArray<struct FVoxelGraphMacroPin>            Pins;                                              // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UVoxelGraphMacro*                       Macro;                                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphMacroInputOutputNode">();
	}
	static class UVoxelGraphMacroInputOutputNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphMacroInputOutputNode>();
	}
};
static_assert(alignof(UVoxelGraphMacroInputOutputNode) == 0x000008, "Wrong alignment on UVoxelGraphMacroInputOutputNode");
static_assert(sizeof(UVoxelGraphMacroInputOutputNode) == 0x000070, "Wrong size on UVoxelGraphMacroInputOutputNode");
static_assert(offsetof(UVoxelGraphMacroInputOutputNode, Pins) == 0x000058, "Member 'UVoxelGraphMacroInputOutputNode::Pins' has a wrong offset!");
static_assert(offsetof(UVoxelGraphMacroInputOutputNode, Macro) == 0x000068, "Member 'UVoxelGraphMacroInputOutputNode::Macro' has a wrong offset!");

// Class VoxelGraph.VoxelGraphMacroOutputNode
// 0x0000 (0x0070 - 0x0070)
class UVoxelGraphMacroOutputNode final : public UVoxelGraphMacroInputOutputNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphMacroOutputNode">();
	}
	static class UVoxelGraphMacroOutputNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphMacroOutputNode>();
	}
};
static_assert(alignof(UVoxelGraphMacroOutputNode) == 0x000008, "Wrong alignment on UVoxelGraphMacroOutputNode");
static_assert(sizeof(UVoxelGraphMacroOutputNode) == 0x000070, "Wrong size on UVoxelGraphMacroOutputNode");

// Class VoxelGraph.VDI_Example_Crater_Graph
// 0x0000 (0x0030 - 0x0030)
class UVDI_Example_Crater_Graph final : public UVoxelGraphGeneratorHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDI_Example_Crater_Graph">();
	}
	static class UVDI_Example_Crater_Graph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDI_Example_Crater_Graph>();
	}
};
static_assert(alignof(UVDI_Example_Crater_Graph) == 0x000008, "Wrong alignment on UVDI_Example_Crater_Graph");
static_assert(sizeof(UVDI_Example_Crater_Graph) == 0x000030, "Wrong size on UVDI_Example_Crater_Graph");

// Class VoxelGraph.VDI_Ravine_Graph
// 0x0000 (0x0030 - 0x0030)
class UVDI_Ravine_Graph final : public UVoxelGraphGeneratorHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDI_Ravine_Graph">();
	}
	static class UVDI_Ravine_Graph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDI_Ravine_Graph>();
	}
};
static_assert(alignof(UVDI_Ravine_Graph) == 0x000008, "Wrong alignment on UVDI_Ravine_Graph");
static_assert(sizeof(UVDI_Ravine_Graph) == 0x000030, "Wrong size on UVDI_Ravine_Graph");

// Class VoxelGraph.VoxelLocalVariableBase
// 0x0000 (0x0058 - 0x0058)
class UVoxelLocalVariableBase : public UVoxelNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLocalVariableBase">();
	}
	static class UVoxelLocalVariableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelLocalVariableBase>();
	}
};
static_assert(alignof(UVoxelLocalVariableBase) == 0x000008, "Wrong alignment on UVoxelLocalVariableBase");
static_assert(sizeof(UVoxelLocalVariableBase) == 0x000058, "Wrong size on UVoxelLocalVariableBase");

// Class VoxelGraph.VDI_Sphere_Graph
// 0x0000 (0x0030 - 0x0030)
class UVDI_Sphere_Graph final : public UVoxelGraphGeneratorHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VDI_Sphere_Graph">();
	}
	static class UVDI_Sphere_Graph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVDI_Sphere_Graph>();
	}
};
static_assert(alignof(UVDI_Sphere_Graph) == 0x000008, "Wrong alignment on UVDI_Sphere_Graph");
static_assert(sizeof(UVDI_Sphere_Graph) == 0x000030, "Wrong size on UVDI_Sphere_Graph");

// Class VoxelGraph.VG_Example_Craters
// 0x0008 (0x0038 - 0x0030)
class UVG_Example_Craters final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Radius;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VG_Example_Craters">();
	}
	static class UVG_Example_Craters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVG_Example_Craters>();
	}
};
static_assert(alignof(UVG_Example_Craters) == 0x000008, "Wrong alignment on UVG_Example_Craters");
static_assert(sizeof(UVG_Example_Craters) == 0x000038, "Wrong size on UVG_Example_Craters");
static_assert(offsetof(UVG_Example_Craters, Radius) == 0x000030, "Member 'UVG_Example_Craters::Radius' has a wrong offset!");

// Class VoxelGraph.VoxelPureNode
// 0x0000 (0x0098 - 0x0098)
class UVoxelPureNode : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPureNode">();
	}
	static class UVoxelPureNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPureNode>();
	}
};
static_assert(alignof(UVoxelPureNode) == 0x000008, "Wrong alignment on UVoxelPureNode");
static_assert(sizeof(UVoxelPureNode) == 0x000098, "Wrong size on UVoxelPureNode");

// Class VoxelGraph.VoxelNode_FAdd
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FAdd final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FAdd">();
	}
	static class UVoxelNode_FAdd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FAdd>();
	}
};
static_assert(alignof(UVoxelNode_FAdd) == 0x000008, "Wrong alignment on UVoxelNode_FAdd");
static_assert(sizeof(UVoxelNode_FAdd) == 0x000098, "Wrong size on UVoxelNode_FAdd");

// Class VoxelGraph.VG_Example_Dunes
// 0x0018 (0x0048 - 0x0030)
class UVG_Example_Dunes final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Direction_X;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Direction_Y;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dune_Frequency;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Noise_Frequency;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VG_Example_Dunes">();
	}
	static class UVG_Example_Dunes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVG_Example_Dunes>();
	}
};
static_assert(alignof(UVG_Example_Dunes) == 0x000008, "Wrong alignment on UVG_Example_Dunes");
static_assert(sizeof(UVG_Example_Dunes) == 0x000048, "Wrong size on UVG_Example_Dunes");
static_assert(offsetof(UVG_Example_Dunes, Direction_X) == 0x000030, "Member 'UVG_Example_Dunes::Direction_X' has a wrong offset!");
static_assert(offsetof(UVG_Example_Dunes, Direction_Y) == 0x000034, "Member 'UVG_Example_Dunes::Direction_Y' has a wrong offset!");
static_assert(offsetof(UVG_Example_Dunes, Dune_Frequency) == 0x000038, "Member 'UVG_Example_Dunes::Dune_Frequency' has a wrong offset!");
static_assert(offsetof(UVG_Example_Dunes, Height) == 0x00003C, "Member 'UVG_Example_Dunes::Height' has a wrong offset!");
static_assert(offsetof(UVG_Example_Dunes, Noise_Frequency) == 0x000040, "Member 'UVG_Example_Dunes::Noise_Frequency' has a wrong offset!");

// Class VoxelGraph.VG_Example_Erosion
// 0x0068 (0x0098 - 0x0030)
class UVG_Example_Erosion final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Erosion_Material_Offset;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Erosion_Material_Strength;                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Erosion_Strength;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Rocks;                                             // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Snow;                                              // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Valleys_Height;                                    // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VG_Example_Erosion">();
	}
	static class UVG_Example_Erosion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVG_Example_Erosion>();
	}
};
static_assert(alignof(UVG_Example_Erosion) == 0x000008, "Wrong alignment on UVG_Example_Erosion");
static_assert(sizeof(UVG_Example_Erosion) == 0x000098, "Wrong size on UVG_Example_Erosion");
static_assert(offsetof(UVG_Example_Erosion, Erosion_Material_Offset) == 0x000030, "Member 'UVG_Example_Erosion::Erosion_Material_Offset' has a wrong offset!");
static_assert(offsetof(UVG_Example_Erosion, Erosion_Material_Strength) == 0x000034, "Member 'UVG_Example_Erosion::Erosion_Material_Strength' has a wrong offset!");
static_assert(offsetof(UVG_Example_Erosion, Erosion_Strength) == 0x000038, "Member 'UVG_Example_Erosion::Erosion_Strength' has a wrong offset!");
static_assert(offsetof(UVG_Example_Erosion, Height) == 0x00003C, "Member 'UVG_Example_Erosion::Height' has a wrong offset!");
static_assert(offsetof(UVG_Example_Erosion, Rocks) == 0x000040, "Member 'UVG_Example_Erosion::Rocks' has a wrong offset!");
static_assert(offsetof(UVG_Example_Erosion, Snow) == 0x000068, "Member 'UVG_Example_Erosion::Snow' has a wrong offset!");
static_assert(offsetof(UVG_Example_Erosion, Valleys_Height) == 0x000090, "Member 'UVG_Example_Erosion::Valleys_Height' has a wrong offset!");

// Class VoxelGraph.VoxelMaterialNode
// 0x0000 (0x0098 - 0x0098)
class UVoxelMaterialNode : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMaterialNode">();
	}
	static class UVoxelMaterialNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMaterialNode>();
	}
};
static_assert(alignof(UVoxelMaterialNode) == 0x000008, "Wrong alignment on UVoxelMaterialNode");
static_assert(sizeof(UVoxelMaterialNode) == 0x000098, "Wrong size on UVoxelMaterialNode");

// Class VoxelGraph.VoxelNode_GetIndex
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GetIndex final : public UVoxelMaterialNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetIndex">();
	}
	static class UVoxelNode_GetIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetIndex>();
	}
};
static_assert(alignof(UVoxelNode_GetIndex) == 0x000008, "Wrong alignment on UVoxelNode_GetIndex");
static_assert(sizeof(UVoxelNode_GetIndex) == 0x000098, "Wrong size on UVoxelNode_GetIndex");

// Class VoxelGraph.VG_Example_FastCraters
// 0x0000 (0x0030 - 0x0030)
class UVG_Example_FastCraters final : public UVoxelGraphGeneratorHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VG_Example_FastCraters">();
	}
	static class UVG_Example_FastCraters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVG_Example_FastCraters>();
	}
};
static_assert(alignof(UVG_Example_FastCraters) == 0x000008, "Wrong alignment on UVG_Example_FastCraters");
static_assert(sizeof(UVG_Example_FastCraters) == 0x000030, "Wrong size on UVG_Example_FastCraters");

// Class VoxelGraph.VG_Example_MultiIndex
// 0x00A0 (0x00D0 - 0x0030)
class UVG_Example_MultiIndex final : public UVoxelGraphGeneratorHelper
{
public:
	TSoftObjectPtr<class UMaterialInterface>      Layer_0;                                           // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Layer_1;                                           // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Layer_2;                                           // 0x0080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      Layer_3;                                           // 0x00A8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VG_Example_MultiIndex">();
	}
	static class UVG_Example_MultiIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVG_Example_MultiIndex>();
	}
};
static_assert(alignof(UVG_Example_MultiIndex) == 0x000008, "Wrong alignment on UVG_Example_MultiIndex");
static_assert(sizeof(UVG_Example_MultiIndex) == 0x0000D0, "Wrong size on UVG_Example_MultiIndex");
static_assert(offsetof(UVG_Example_MultiIndex, Layer_0) == 0x000030, "Member 'UVG_Example_MultiIndex::Layer_0' has a wrong offset!");
static_assert(offsetof(UVG_Example_MultiIndex, Layer_1) == 0x000058, "Member 'UVG_Example_MultiIndex::Layer_1' has a wrong offset!");
static_assert(offsetof(UVG_Example_MultiIndex, Layer_2) == 0x000080, "Member 'UVG_Example_MultiIndex::Layer_2' has a wrong offset!");
static_assert(offsetof(UVG_Example_MultiIndex, Layer_3) == 0x0000A8, "Member 'UVG_Example_MultiIndex::Layer_3' has a wrong offset!");

// Class VoxelGraph.VoxelNode_If
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_If : public UVoxelNodeHelper
{
public:
	EVoxelNodeIfBranchToUseForRangeAnalysis       BranchToUseForRangeAnalysis;                       // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_If">();
	}
	static class UVoxelNode_If* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_If>();
	}
};
static_assert(alignof(UVoxelNode_If) == 0x000008, "Wrong alignment on UVoxelNode_If");
static_assert(sizeof(UVoxelNode_If) == 0x0000A0, "Wrong size on UVoxelNode_If");
static_assert(offsetof(UVoxelNode_If, BranchToUseForRangeAnalysis) == 0x000098, "Member 'UVoxelNode_If::BranchToUseForRangeAnalysis' has a wrong offset!");

// Class VoxelGraph.VoxelNode_IfWithDefaultToFalse
// 0x0000 (0x00A0 - 0x00A0)
class UVoxelNode_IfWithDefaultToFalse final : public UVoxelNode_If
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IfWithDefaultToFalse">();
	}
	static class UVoxelNode_IfWithDefaultToFalse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IfWithDefaultToFalse>();
	}
};
static_assert(alignof(UVoxelNode_IfWithDefaultToFalse) == 0x000008, "Wrong alignment on UVoxelNode_IfWithDefaultToFalse");
static_assert(sizeof(UVoxelNode_IfWithDefaultToFalse) == 0x0000A0, "Wrong size on UVoxelNode_IfWithDefaultToFalse");

// Class VoxelGraph.VoxelExposedNode
// 0x00B8 (0x0150 - 0x0098)
class UVoxelExposedNode : public UVoxelNodeHelper
{
public:
	class FString                                 DisplayName;                                       // 0x0098(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UniqueName;                                        // 0x00A8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Category;                                          // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tooltip;                                           // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UIMin;                                             // 0x00D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UIMax;                                             // 0x00E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class FString>              CustomMetaData;                                    // 0x00F8(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bCanBeRenamed;                                     // 0x0148(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExposedNode">();
	}
	static class UVoxelExposedNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExposedNode>();
	}
};
static_assert(alignof(UVoxelExposedNode) == 0x000008, "Wrong alignment on UVoxelExposedNode");
static_assert(sizeof(UVoxelExposedNode) == 0x000150, "Wrong size on UVoxelExposedNode");
static_assert(offsetof(UVoxelExposedNode, DisplayName) == 0x000098, "Member 'UVoxelExposedNode::DisplayName' has a wrong offset!");
static_assert(offsetof(UVoxelExposedNode, UniqueName) == 0x0000A8, "Member 'UVoxelExposedNode::UniqueName' has a wrong offset!");
static_assert(offsetof(UVoxelExposedNode, Category) == 0x0000B0, "Member 'UVoxelExposedNode::Category' has a wrong offset!");
static_assert(offsetof(UVoxelExposedNode, Tooltip) == 0x0000C0, "Member 'UVoxelExposedNode::Tooltip' has a wrong offset!");
static_assert(offsetof(UVoxelExposedNode, Priority) == 0x0000D0, "Member 'UVoxelExposedNode::Priority' has a wrong offset!");
static_assert(offsetof(UVoxelExposedNode, UIMin) == 0x0000D8, "Member 'UVoxelExposedNode::UIMin' has a wrong offset!");
static_assert(offsetof(UVoxelExposedNode, UIMax) == 0x0000E8, "Member 'UVoxelExposedNode::UIMax' has a wrong offset!");
static_assert(offsetof(UVoxelExposedNode, CustomMetaData) == 0x0000F8, "Member 'UVoxelExposedNode::CustomMetaData' has a wrong offset!");
static_assert(offsetof(UVoxelExposedNode, bCanBeRenamed) == 0x000148, "Member 'UVoxelExposedNode::bCanBeRenamed' has a wrong offset!");

// Class VoxelGraph.VoxelAssetPickerNode
// 0x0000 (0x0150 - 0x0150)
class UVoxelAssetPickerNode : public UVoxelExposedNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelAssetPickerNode">();
	}
	static class UVoxelAssetPickerNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelAssetPickerNode>();
	}
};
static_assert(alignof(UVoxelAssetPickerNode) == 0x000008, "Wrong alignment on UVoxelAssetPickerNode");
static_assert(sizeof(UVoxelAssetPickerNode) == 0x000150, "Wrong size on UVoxelAssetPickerNode");

// Class VoxelGraph.VoxelNode_ILeftBitShift
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ILeftBitShift final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ILeftBitShift">();
	}
	static class UVoxelNode_ILeftBitShift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ILeftBitShift>();
	}
};
static_assert(alignof(UVoxelNode_ILeftBitShift) == 0x000008, "Wrong alignment on UVoxelNode_ILeftBitShift");
static_assert(sizeof(UVoxelNode_ILeftBitShift) == 0x000098, "Wrong size on UVoxelNode_ILeftBitShift");

// Class VoxelGraph.VoxelNode_FLess
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FLess final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FLess">();
	}
	static class UVoxelNode_FLess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FLess>();
	}
};
static_assert(alignof(UVoxelNode_FLess) == 0x000008, "Wrong alignment on UVoxelNode_FLess");
static_assert(sizeof(UVoxelNode_FLess) == 0x000098, "Wrong size on UVoxelNode_FLess");

// Class VoxelGraph.VoxelNode_FLessEqual
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FLessEqual final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FLessEqual">();
	}
	static class UVoxelNode_FLessEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FLessEqual>();
	}
};
static_assert(alignof(UVoxelNode_FLessEqual) == 0x000008, "Wrong alignment on UVoxelNode_FLessEqual");
static_assert(sizeof(UVoxelNode_FLessEqual) == 0x000098, "Wrong size on UVoxelNode_FLessEqual");

// Class VoxelGraph.VoxelNode_FGreater
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FGreater final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FGreater">();
	}
	static class UVoxelNode_FGreater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FGreater>();
	}
};
static_assert(alignof(UVoxelNode_FGreater) == 0x000008, "Wrong alignment on UVoxelNode_FGreater");
static_assert(sizeof(UVoxelNode_FGreater) == 0x000098, "Wrong size on UVoxelNode_FGreater");

// Class VoxelGraph.VoxelNode_FGreaterEqual
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FGreaterEqual final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FGreaterEqual">();
	}
	static class UVoxelNode_FGreaterEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FGreaterEqual>();
	}
};
static_assert(alignof(UVoxelNode_FGreaterEqual) == 0x000008, "Wrong alignment on UVoxelNode_FGreaterEqual");
static_assert(sizeof(UVoxelNode_FGreaterEqual) == 0x000098, "Wrong size on UVoxelNode_FGreaterEqual");

// Class VoxelGraph.VoxelNode_FEqual
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FEqual final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FEqual">();
	}
	static class UVoxelNode_FEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FEqual>();
	}
};
static_assert(alignof(UVoxelNode_FEqual) == 0x000008, "Wrong alignment on UVoxelNode_FEqual");
static_assert(sizeof(UVoxelNode_FEqual) == 0x000098, "Wrong size on UVoxelNode_FEqual");

// Class VoxelGraph.VoxelNode_ISubstract
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ISubstract final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ISubstract">();
	}
	static class UVoxelNode_ISubstract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ISubstract>();
	}
};
static_assert(alignof(UVoxelNode_ISubstract) == 0x000008, "Wrong alignment on UVoxelNode_ISubstract");
static_assert(sizeof(UVoxelNode_ISubstract) == 0x000098, "Wrong size on UVoxelNode_ISubstract");

// Class VoxelGraph.VoxelNode_FNotEqual
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FNotEqual final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FNotEqual">();
	}
	static class UVoxelNode_FNotEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FNotEqual>();
	}
};
static_assert(alignof(UVoxelNode_FNotEqual) == 0x000008, "Wrong alignment on UVoxelNode_FNotEqual");
static_assert(sizeof(UVoxelNode_FNotEqual) == 0x000098, "Wrong size on UVoxelNode_FNotEqual");

// Class VoxelGraph.VoxelNode_ILess
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ILess final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ILess">();
	}
	static class UVoxelNode_ILess* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ILess>();
	}
};
static_assert(alignof(UVoxelNode_ILess) == 0x000008, "Wrong alignment on UVoxelNode_ILess");
static_assert(sizeof(UVoxelNode_ILess) == 0x000098, "Wrong size on UVoxelNode_ILess");

// Class VoxelGraph.VoxelNode_BAnd
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_BAnd final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BAnd">();
	}
	static class UVoxelNode_BAnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BAnd>();
	}
};
static_assert(alignof(UVoxelNode_BAnd) == 0x000008, "Wrong alignment on UVoxelNode_BAnd");
static_assert(sizeof(UVoxelNode_BAnd) == 0x000098, "Wrong size on UVoxelNode_BAnd");

// Class VoxelGraph.VoxelNode_ILessEqual
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ILessEqual final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ILessEqual">();
	}
	static class UVoxelNode_ILessEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ILessEqual>();
	}
};
static_assert(alignof(UVoxelNode_ILessEqual) == 0x000008, "Wrong alignment on UVoxelNode_ILessEqual");
static_assert(sizeof(UVoxelNode_ILessEqual) == 0x000098, "Wrong size on UVoxelNode_ILessEqual");

// Class VoxelGraph.VoxelNode_IGreater
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IGreater final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IGreater">();
	}
	static class UVoxelNode_IGreater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IGreater>();
	}
};
static_assert(alignof(UVoxelNode_IGreater) == 0x000008, "Wrong alignment on UVoxelNode_IGreater");
static_assert(sizeof(UVoxelNode_IGreater) == 0x000098, "Wrong size on UVoxelNode_IGreater");

// Class VoxelGraph.VoxelNode_FloatOfInt
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FloatOfInt final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FloatOfInt">();
	}
	static class UVoxelNode_FloatOfInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FloatOfInt>();
	}
};
static_assert(alignof(UVoxelNode_FloatOfInt) == 0x000008, "Wrong alignment on UVoxelNode_FloatOfInt");
static_assert(sizeof(UVoxelNode_FloatOfInt) == 0x000098, "Wrong size on UVoxelNode_FloatOfInt");

// Class VoxelGraph.VoxelNode_IGreaterEqual
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IGreaterEqual final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IGreaterEqual">();
	}
	static class UVoxelNode_IGreaterEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IGreaterEqual>();
	}
};
static_assert(alignof(UVoxelNode_IGreaterEqual) == 0x000008, "Wrong alignment on UVoxelNode_IGreaterEqual");
static_assert(sizeof(UVoxelNode_IGreaterEqual) == 0x000098, "Wrong size on UVoxelNode_IGreaterEqual");

// Class VoxelGraph.VoxelNode_IEqual
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IEqual final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IEqual">();
	}
	static class UVoxelNode_IEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IEqual>();
	}
};
static_assert(alignof(UVoxelNode_IEqual) == 0x000008, "Wrong alignment on UVoxelNode_IEqual");
static_assert(sizeof(UVoxelNode_IEqual) == 0x000098, "Wrong size on UVoxelNode_IEqual");

// Class VoxelGraph.VoxelNode_IAdd
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IAdd final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IAdd">();
	}
	static class UVoxelNode_IAdd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IAdd>();
	}
};
static_assert(alignof(UVoxelNode_IAdd) == 0x000008, "Wrong alignment on UVoxelNode_IAdd");
static_assert(sizeof(UVoxelNode_IAdd) == 0x000098, "Wrong size on UVoxelNode_IAdd");

// Class VoxelGraph.VoxelNode_INotEqual
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_INotEqual final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_INotEqual">();
	}
	static class UVoxelNode_INotEqual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_INotEqual>();
	}
};
static_assert(alignof(UVoxelNode_INotEqual) == 0x000008, "Wrong alignment on UVoxelNode_INotEqual");
static_assert(sizeof(UVoxelNode_INotEqual) == 0x000098, "Wrong size on UVoxelNode_INotEqual");

// Class VoxelGraph.VoxelNode_BiomeMapSampler
// 0x0020 (0x0170 - 0x0150)
class UVoxelNode_BiomeMapSampler final : public UVoxelExposedNode
{
public:
	class UTexture2D*                             Texture;                                           // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Threshold;                                         // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBiomeMapElement>               Biomes;                                            // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BiomeMapSampler">();
	}
	static class UVoxelNode_BiomeMapSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BiomeMapSampler>();
	}
};
static_assert(alignof(UVoxelNode_BiomeMapSampler) == 0x000008, "Wrong alignment on UVoxelNode_BiomeMapSampler");
static_assert(sizeof(UVoxelNode_BiomeMapSampler) == 0x000170, "Wrong size on UVoxelNode_BiomeMapSampler");
static_assert(offsetof(UVoxelNode_BiomeMapSampler, Texture) == 0x000150, "Member 'UVoxelNode_BiomeMapSampler::Texture' has a wrong offset!");
static_assert(offsetof(UVoxelNode_BiomeMapSampler, Threshold) == 0x000158, "Member 'UVoxelNode_BiomeMapSampler::Threshold' has a wrong offset!");
static_assert(offsetof(UVoxelNode_BiomeMapSampler, Biomes) == 0x000160, "Member 'UVoxelNode_BiomeMapSampler::Biomes' has a wrong offset!");

// Class VoxelGraph.VoxelNode_SmoothStep
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SmoothStep final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SmoothStep">();
	}
	static class UVoxelNode_SmoothStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SmoothStep>();
	}
};
static_assert(alignof(UVoxelNode_SmoothStep) == 0x000008, "Wrong alignment on UVoxelNode_SmoothStep");
static_assert(sizeof(UVoxelNode_SmoothStep) == 0x000098, "Wrong size on UVoxelNode_SmoothStep");

// Class VoxelGraph.VoxelNode_BiomeMerge
// 0x0018 (0x0070 - 0x0058)
class UVoxelNode_BiomeMerge final : public UVoxelNode
{
public:
	TArray<class FString>                         Biomes;                                            // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BiomeMerge">();
	}
	static class UVoxelNode_BiomeMerge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BiomeMerge>();
	}
};
static_assert(alignof(UVoxelNode_BiomeMerge) == 0x000008, "Wrong alignment on UVoxelNode_BiomeMerge");
static_assert(sizeof(UVoxelNode_BiomeMerge) == 0x000070, "Wrong size on UVoxelNode_BiomeMerge");
static_assert(offsetof(UVoxelNode_BiomeMerge, Biomes) == 0x000058, "Member 'UVoxelNode_BiomeMerge::Biomes' has a wrong offset!");
static_assert(offsetof(UVoxelNode_BiomeMerge, Tolerance) == 0x000068, "Member 'UVoxelNode_BiomeMerge::Tolerance' has a wrong offset!");

// Class VoxelGraph.VoxelNodeWithDependencies
// 0x0000 (0x0098 - 0x0098)
class UVoxelNodeWithDependencies : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNodeWithDependencies">();
	}
	static class UVoxelNodeWithDependencies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNodeWithDependencies>();
	}
};
static_assert(alignof(UVoxelNodeWithDependencies) == 0x000008, "Wrong alignment on UVoxelNodeWithDependencies");
static_assert(sizeof(UVoxelNodeWithDependencies) == 0x000098, "Wrong size on UVoxelNodeWithDependencies");

// Class VoxelGraph.VoxelNode_MinusX
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_MinusX final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_MinusX">();
	}
	static class UVoxelNode_MinusX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_MinusX>();
	}
};
static_assert(alignof(UVoxelNode_MinusX) == 0x000008, "Wrong alignment on UVoxelNode_MinusX");
static_assert(sizeof(UVoxelNode_MinusX) == 0x000098, "Wrong size on UVoxelNode_MinusX");

// Class VoxelGraph.VoxelNodeWithContext
// 0x0000 (0x0098 - 0x0098)
class UVoxelNodeWithContext : public UVoxelNodeWithDependencies
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNodeWithContext">();
	}
	static class UVoxelNodeWithContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNodeWithContext>();
	}
};
static_assert(alignof(UVoxelNodeWithContext) == 0x000008, "Wrong alignment on UVoxelNodeWithContext");
static_assert(sizeof(UVoxelNodeWithContext) == 0x000098, "Wrong size on UVoxelNodeWithContext");

// Class VoxelGraph.VoxelNode_LOD
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_LOD final : public UVoxelNodeWithContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_LOD">();
	}
	static class UVoxelNode_LOD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_LOD>();
	}
};
static_assert(alignof(UVoxelNode_LOD) == 0x000008, "Wrong alignment on UVoxelNode_LOD");
static_assert(sizeof(UVoxelNode_LOD) == 0x000098, "Wrong size on UVoxelNode_LOD");

// Class VoxelGraph.VoxelNode_BNot
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_BNot final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BNot">();
	}
	static class UVoxelNode_BNot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BNot>();
	}
};
static_assert(alignof(UVoxelNode_BNot) == 0x000008, "Wrong alignment on UVoxelNode_BNot");
static_assert(sizeof(UVoxelNode_BNot) == 0x000098, "Wrong size on UVoxelNode_BNot");

// Class VoxelGraph.VoxelNode_VoxelSize
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_VoxelSize final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VoxelSize">();
	}
	static class UVoxelNode_VoxelSize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VoxelSize>();
	}
};
static_assert(alignof(UVoxelNode_VoxelSize) == 0x000008, "Wrong alignment on UVoxelNode_VoxelSize");
static_assert(sizeof(UVoxelNode_VoxelSize) == 0x000098, "Wrong size on UVoxelNode_VoxelSize");

// Class VoxelGraph.VoxelNode_WorldSize
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_WorldSize final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_WorldSize">();
	}
	static class UVoxelNode_WorldSize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_WorldSize>();
	}
};
static_assert(alignof(UVoxelNode_WorldSize) == 0x000008, "Wrong alignment on UVoxelNode_WorldSize");
static_assert(sizeof(UVoxelNode_WorldSize) == 0x000098, "Wrong size on UVoxelNode_WorldSize");

// Class VoxelGraph.VoxelNode_Lerp
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Lerp final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Lerp">();
	}
	static class UVoxelNode_Lerp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Lerp>();
	}
};
static_assert(alignof(UVoxelNode_Lerp) == 0x000008, "Wrong alignment on UVoxelNode_Lerp");
static_assert(sizeof(UVoxelNode_Lerp) == 0x000098, "Wrong size on UVoxelNode_Lerp");

// Class VoxelGraph.VoxelNode_CompileTimeConstant
// 0x0060 (0x00F8 - 0x0098)
class UVoxelNode_CompileTimeConstant final : public UVoxelNodeHelper
{
public:
	class FName                                   Name_0;                                            // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelPinCategory                             Type;                                              // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class FString>              Constants;                                         // 0x00A8(0x0050)(Edit, Transient, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CompileTimeConstant">();
	}
	static class UVoxelNode_CompileTimeConstant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CompileTimeConstant>();
	}
};
static_assert(alignof(UVoxelNode_CompileTimeConstant) == 0x000008, "Wrong alignment on UVoxelNode_CompileTimeConstant");
static_assert(sizeof(UVoxelNode_CompileTimeConstant) == 0x0000F8, "Wrong size on UVoxelNode_CompileTimeConstant");
static_assert(offsetof(UVoxelNode_CompileTimeConstant, Name_0) == 0x000098, "Member 'UVoxelNode_CompileTimeConstant::Name_0' has a wrong offset!");
static_assert(offsetof(UVoxelNode_CompileTimeConstant, Type) == 0x0000A0, "Member 'UVoxelNode_CompileTimeConstant::Type' has a wrong offset!");
static_assert(offsetof(UVoxelNode_CompileTimeConstant, Constants) == 0x0000A8, "Member 'UVoxelNode_CompileTimeConstant::Constants' has a wrong offset!");

// Class VoxelGraph.VoxelCoordinateNode
// 0x0000 (0x0098 - 0x0098)
class UVoxelCoordinateNode : public UVoxelNodeWithDependencies
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelCoordinateNode">();
	}
	static class UVoxelCoordinateNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelCoordinateNode>();
	}
};
static_assert(alignof(UVoxelCoordinateNode) == 0x000008, "Wrong alignment on UVoxelCoordinateNode");
static_assert(sizeof(UVoxelCoordinateNode) == 0x000098, "Wrong size on UVoxelCoordinateNode");

// Class VoxelGraph.VoxelNode_1MinusX
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_1MinusX final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_1MinusX">();
	}
	static class UVoxelNode_1MinusX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_1MinusX>();
	}
};
static_assert(alignof(UVoxelNode_1MinusX) == 0x000008, "Wrong alignment on UVoxelNode_1MinusX");
static_assert(sizeof(UVoxelNode_1MinusX) == 0x000098, "Wrong size on UVoxelNode_1MinusX");

// Class VoxelGraph.VoxelNode_XF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_XF final : public UVoxelCoordinateNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_XF">();
	}
	static class UVoxelNode_XF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_XF>();
	}
};
static_assert(alignof(UVoxelNode_XF) == 0x000008, "Wrong alignment on UVoxelNode_XF");
static_assert(sizeof(UVoxelNode_XF) == 0x000098, "Wrong size on UVoxelNode_XF");

// Class VoxelGraph.VoxelNode_YF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_YF final : public UVoxelCoordinateNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_YF">();
	}
	static class UVoxelNode_YF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_YF>();
	}
};
static_assert(alignof(UVoxelNode_YF) == 0x000008, "Wrong alignment on UVoxelNode_YF");
static_assert(sizeof(UVoxelNode_YF) == 0x000098, "Wrong size on UVoxelNode_YF");

// Class VoxelGraph.VoxelNode_Floor
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Floor final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Floor">();
	}
	static class UVoxelNode_Floor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Floor>();
	}
};
static_assert(alignof(UVoxelNode_Floor) == 0x000008, "Wrong alignment on UVoxelNode_Floor");
static_assert(sizeof(UVoxelNode_Floor) == 0x000098, "Wrong size on UVoxelNode_Floor");

// Class VoxelGraph.VoxelNode_ZF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ZF final : public UVoxelCoordinateNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ZF">();
	}
	static class UVoxelNode_ZF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ZF>();
	}
};
static_assert(alignof(UVoxelNode_ZF) == 0x000008, "Wrong alignment on UVoxelNode_ZF");
static_assert(sizeof(UVoxelNode_ZF) == 0x000098, "Wrong size on UVoxelNode_ZF");

// Class VoxelGraph.VoxelNode_GlobalX
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GlobalX final : public UVoxelCoordinateNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GlobalX">();
	}
	static class UVoxelNode_GlobalX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GlobalX>();
	}
};
static_assert(alignof(UVoxelNode_GlobalX) == 0x000008, "Wrong alignment on UVoxelNode_GlobalX");
static_assert(sizeof(UVoxelNode_GlobalX) == 0x000098, "Wrong size on UVoxelNode_GlobalX");

// Class VoxelGraph.VoxelNode_Pow
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Pow final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Pow">();
	}
	static class UVoxelNode_Pow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Pow>();
	}
};
static_assert(alignof(UVoxelNode_Pow) == 0x000008, "Wrong alignment on UVoxelNode_Pow");
static_assert(sizeof(UVoxelNode_Pow) == 0x000098, "Wrong size on UVoxelNode_Pow");

// Class VoxelGraph.VoxelNode_GlobalY
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GlobalY final : public UVoxelCoordinateNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GlobalY">();
	}
	static class UVoxelNode_GlobalY* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GlobalY>();
	}
};
static_assert(alignof(UVoxelNode_GlobalY) == 0x000008, "Wrong alignment on UVoxelNode_GlobalY");
static_assert(sizeof(UVoxelNode_GlobalY) == 0x000098, "Wrong size on UVoxelNode_GlobalY");

// Class VoxelGraph.VoxelNode_GlobalZ
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GlobalZ final : public UVoxelCoordinateNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GlobalZ">();
	}
	static class UVoxelNode_GlobalZ* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GlobalZ>();
	}
};
static_assert(alignof(UVoxelNode_GlobalZ) == 0x000008, "Wrong alignment on UVoxelNode_GlobalZ");
static_assert(sizeof(UVoxelNode_GlobalZ) == 0x000098, "Wrong size on UVoxelNode_GlobalZ");

// Class VoxelGraph.VoxelNode_SwitchFloat
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SwitchFloat final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SwitchFloat">();
	}
	static class UVoxelNode_SwitchFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SwitchFloat>();
	}
};
static_assert(alignof(UVoxelNode_SwitchFloat) == 0x000008, "Wrong alignment on UVoxelNode_SwitchFloat");
static_assert(sizeof(UVoxelNode_SwitchFloat) == 0x000098, "Wrong size on UVoxelNode_SwitchFloat");

// Class VoxelGraph.VoxelNode_LocalToGlobal
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_LocalToGlobal final : public UVoxelNodeWithContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_LocalToGlobal">();
	}
	static class UVoxelNode_LocalToGlobal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_LocalToGlobal>();
	}
};
static_assert(alignof(UVoxelNode_LocalToGlobal) == 0x000008, "Wrong alignment on UVoxelNode_LocalToGlobal");
static_assert(sizeof(UVoxelNode_LocalToGlobal) == 0x000098, "Wrong size on UVoxelNode_LocalToGlobal");

// Class VoxelGraph.VoxelNode_GlobalToLocal
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GlobalToLocal final : public UVoxelNodeWithContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GlobalToLocal">();
	}
	static class UVoxelNode_GlobalToLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GlobalToLocal>();
	}
};
static_assert(alignof(UVoxelNode_GlobalToLocal) == 0x000008, "Wrong alignment on UVoxelNode_GlobalToLocal");
static_assert(sizeof(UVoxelNode_GlobalToLocal) == 0x000098, "Wrong size on UVoxelNode_GlobalToLocal");

// Class VoxelGraph.VoxelNode_Sleep
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_Sleep final : public UVoxelNodeHelper
{
public:
	int32                                         NumberOfLoops;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Sleep">();
	}
	static class UVoxelNode_Sleep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Sleep>();
	}
};
static_assert(alignof(UVoxelNode_Sleep) == 0x000008, "Wrong alignment on UVoxelNode_Sleep");
static_assert(sizeof(UVoxelNode_Sleep) == 0x0000A0, "Wrong size on UVoxelNode_Sleep");
static_assert(offsetof(UVoxelNode_Sleep, NumberOfLoops) == 0x000098, "Member 'UVoxelNode_Sleep::NumberOfLoops' has a wrong offset!");

// Class VoxelGraph.VoxelNode_TransformVector
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_TransformVector final : public UVoxelNodeWithContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_TransformVector">();
	}
	static class UVoxelNode_TransformVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_TransformVector>();
	}
};
static_assert(alignof(UVoxelNode_TransformVector) == 0x000008, "Wrong alignment on UVoxelNode_TransformVector");
static_assert(sizeof(UVoxelNode_TransformVector) == 0x000098, "Wrong size on UVoxelNode_TransformVector");

// Class VoxelGraph.VoxelNode_InverseTransformVector
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_InverseTransformVector final : public UVoxelNodeWithContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_InverseTransformVector">();
	}
	static class UVoxelNode_InverseTransformVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_InverseTransformVector>();
	}
};
static_assert(alignof(UVoxelNode_InverseTransformVector) == 0x000008, "Wrong alignment on UVoxelNode_InverseTransformVector");
static_assert(sizeof(UVoxelNode_InverseTransformVector) == 0x000098, "Wrong size on UVoxelNode_InverseTransformVector");

// Class VoxelGraph.VoxelNode_Sin
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Sin final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Sin">();
	}
	static class UVoxelNode_Sin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Sin>();
	}
};
static_assert(alignof(UVoxelNode_Sin) == 0x000008, "Wrong alignment on UVoxelNode_Sin");
static_assert(sizeof(UVoxelNode_Sin) == 0x000098, "Wrong size on UVoxelNode_Sin");

// Class VoxelGraph.VoxelNode_Curve
// 0x0008 (0x0158 - 0x0150)
class UVoxelNode_Curve final : public UVoxelExposedNode
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Curve">();
	}
	static class UVoxelNode_Curve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Curve>();
	}
};
static_assert(alignof(UVoxelNode_Curve) == 0x000008, "Wrong alignment on UVoxelNode_Curve");
static_assert(sizeof(UVoxelNode_Curve) == 0x000158, "Wrong size on UVoxelNode_Curve");
static_assert(offsetof(UVoxelNode_Curve, Curve) == 0x000150, "Member 'UVoxelNode_Curve::Curve' has a wrong offset!");

// Class VoxelGraph.VoxelNode_CurveColor
// 0x0008 (0x0158 - 0x0150)
class UVoxelNode_CurveColor final : public UVoxelExposedNode
{
public:
	class UCurveLinearColor*                      Curve;                                             // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CurveColor">();
	}
	static class UVoxelNode_CurveColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CurveColor>();
	}
};
static_assert(alignof(UVoxelNode_CurveColor) == 0x000008, "Wrong alignment on UVoxelNode_CurveColor");
static_assert(sizeof(UVoxelNode_CurveColor) == 0x000158, "Wrong size on UVoxelNode_CurveColor");
static_assert(offsetof(UVoxelNode_CurveColor, Curve) == 0x000150, "Member 'UVoxelNode_CurveColor::Curve' has a wrong offset!");

// Class VoxelGraph.VoxelNode_SmartMin
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SmartMin final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SmartMin">();
	}
	static class UVoxelNode_SmartMin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SmartMin>();
	}
};
static_assert(alignof(UVoxelNode_SmartMin) == 0x000008, "Wrong alignment on UVoxelNode_SmartMin");
static_assert(sizeof(UVoxelNode_SmartMin) == 0x000098, "Wrong size on UVoxelNode_SmartMin");

// Class VoxelGraph.VoxelNode_DataAssetSampler
// 0x0010 (0x0160 - 0x0150)
class UVoxelNode_DataAssetSampler final : public UVoxelExposedNode
{
public:
	class UVoxelDataAsset*                        Asset;                                             // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBilinearInterpolation;                            // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x7];                                      // 0x0159(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_DataAssetSampler">();
	}
	static class UVoxelNode_DataAssetSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_DataAssetSampler>();
	}
};
static_assert(alignof(UVoxelNode_DataAssetSampler) == 0x000008, "Wrong alignment on UVoxelNode_DataAssetSampler");
static_assert(sizeof(UVoxelNode_DataAssetSampler) == 0x000160, "Wrong size on UVoxelNode_DataAssetSampler");
static_assert(offsetof(UVoxelNode_DataAssetSampler, Asset) == 0x000150, "Member 'UVoxelNode_DataAssetSampler::Asset' has a wrong offset!");
static_assert(offsetof(UVoxelNode_DataAssetSampler, bBilinearInterpolation) == 0x000158, "Member 'UVoxelNode_DataAssetSampler::bBilinearInterpolation' has a wrong offset!");

// Class VoxelGraph.VoxelNode_StaticClampFloat
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_StaticClampFloat final : public UVoxelNodeHelper
{
public:
	float                                         Min;                                               // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_StaticClampFloat">();
	}
	static class UVoxelNode_StaticClampFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_StaticClampFloat>();
	}
};
static_assert(alignof(UVoxelNode_StaticClampFloat) == 0x000008, "Wrong alignment on UVoxelNode_StaticClampFloat");
static_assert(sizeof(UVoxelNode_StaticClampFloat) == 0x0000A0, "Wrong size on UVoxelNode_StaticClampFloat");
static_assert(offsetof(UVoxelNode_StaticClampFloat, Min) == 0x000098, "Member 'UVoxelNode_StaticClampFloat::Min' has a wrong offset!");
static_assert(offsetof(UVoxelNode_StaticClampFloat, Max) == 0x00009C, "Member 'UVoxelNode_StaticClampFloat::Max' has a wrong offset!");

// Class VoxelGraph.VoxelNode_MakeMaterialFromSingleIndex
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_MakeMaterialFromSingleIndex final : public UVoxelMaterialNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_MakeMaterialFromSingleIndex">();
	}
	static class UVoxelNode_MakeMaterialFromSingleIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_MakeMaterialFromSingleIndex>();
	}
};
static_assert(alignof(UVoxelNode_MakeMaterialFromSingleIndex) == 0x000008, "Wrong alignment on UVoxelNode_MakeMaterialFromSingleIndex");
static_assert(sizeof(UVoxelNode_MakeMaterialFromSingleIndex) == 0x000098, "Wrong size on UVoxelNode_MakeMaterialFromSingleIndex");

// Class VoxelGraph.VoxelNode_GetDoubleIndex
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GetDoubleIndex final : public UVoxelMaterialNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetDoubleIndex">();
	}
	static class UVoxelNode_GetDoubleIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetDoubleIndex>();
	}
};
static_assert(alignof(UVoxelNode_GetDoubleIndex) == 0x000008, "Wrong alignment on UVoxelNode_GetDoubleIndex");
static_assert(sizeof(UVoxelNode_GetDoubleIndex) == 0x000098, "Wrong size on UVoxelNode_GetDoubleIndex");

// Class VoxelGraph.VoxelNode_Loge
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Loge final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Loge">();
	}
	static class UVoxelNode_Loge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Loge>();
	}
};
static_assert(alignof(UVoxelNode_Loge) == 0x000008, "Wrong alignment on UVoxelNode_Loge");
static_assert(sizeof(UVoxelNode_Loge) == 0x000098, "Wrong size on UVoxelNode_Loge");

// Class VoxelGraph.VoxelNode_MakeMaterialFromColor
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_MakeMaterialFromColor final : public UVoxelMaterialNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_MakeMaterialFromColor">();
	}
	static class UVoxelNode_MakeMaterialFromColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_MakeMaterialFromColor>();
	}
};
static_assert(alignof(UVoxelNode_MakeMaterialFromColor) == 0x000008, "Wrong alignment on UVoxelNode_MakeMaterialFromColor");
static_assert(sizeof(UVoxelNode_MakeMaterialFromColor) == 0x000098, "Wrong size on UVoxelNode_MakeMaterialFromColor");

// Class VoxelGraph.VoxelNode_MakeMaterialFromDoubleIndex
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_MakeMaterialFromDoubleIndex final : public UVoxelMaterialNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_MakeMaterialFromDoubleIndex">();
	}
	static class UVoxelNode_MakeMaterialFromDoubleIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_MakeMaterialFromDoubleIndex>();
	}
};
static_assert(alignof(UVoxelNode_MakeMaterialFromDoubleIndex) == 0x000008, "Wrong alignment on UVoxelNode_MakeMaterialFromDoubleIndex");
static_assert(sizeof(UVoxelNode_MakeMaterialFromDoubleIndex) == 0x000098, "Wrong size on UVoxelNode_MakeMaterialFromDoubleIndex");

// Class VoxelGraph.VoxelNode_Atan2
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Atan2 final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Atan2">();
	}
	static class UVoxelNode_Atan2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Atan2>();
	}
};
static_assert(alignof(UVoxelNode_Atan2) == 0x000008, "Wrong alignment on UVoxelNode_Atan2");
static_assert(sizeof(UVoxelNode_Atan2) == 0x000098, "Wrong size on UVoxelNode_Atan2");

// Class VoxelGraph.VoxelNode_CreateDoubleIndexMaterial
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_CreateDoubleIndexMaterial final : public UVoxelMaterialNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CreateDoubleIndexMaterial">();
	}
	static class UVoxelNode_CreateDoubleIndexMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CreateDoubleIndexMaterial>();
	}
};
static_assert(alignof(UVoxelNode_CreateDoubleIndexMaterial) == 0x000008, "Wrong alignment on UVoxelNode_CreateDoubleIndexMaterial");
static_assert(sizeof(UVoxelNode_CreateDoubleIndexMaterial) == 0x000098, "Wrong size on UVoxelNode_CreateDoubleIndexMaterial");

// Class VoxelGraph.VoxelSetterNode
// 0x0000 (0x0098 - 0x0098)
class UVoxelSetterNode : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSetterNode">();
	}
	static class UVoxelSetterNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSetterNode>();
	}
};
static_assert(alignof(UVoxelSetterNode) == 0x000008, "Wrong alignment on UVoxelSetterNode");
static_assert(sizeof(UVoxelSetterNode) == 0x000098, "Wrong size on UVoxelSetterNode");

// Class VoxelGraph.VoxelNode_Sinh
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Sinh final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Sinh">();
	}
	static class UVoxelNode_Sinh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Sinh>();
	}
};
static_assert(alignof(UVoxelNode_Sinh) == 0x000008, "Wrong alignment on UVoxelNode_Sinh");
static_assert(sizeof(UVoxelNode_Sinh) == 0x000098, "Wrong size on UVoxelNode_Sinh");

// Class VoxelGraph.VoxelNode_MaterialSetter
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_MaterialSetter : public UVoxelSetterNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_MaterialSetter">();
	}
	static class UVoxelNode_MaterialSetter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_MaterialSetter>();
	}
};
static_assert(alignof(UVoxelNode_MaterialSetter) == 0x000008, "Wrong alignment on UVoxelNode_MaterialSetter");
static_assert(sizeof(UVoxelNode_MaterialSetter) == 0x000098, "Wrong size on UVoxelNode_MaterialSetter");

// Class VoxelGraph.VoxelNode_SetDoubleIndex
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SetDoubleIndex final : public UVoxelNode_MaterialSetter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SetDoubleIndex">();
	}
	static class UVoxelNode_SetDoubleIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SetDoubleIndex>();
	}
};
static_assert(alignof(UVoxelNode_SetDoubleIndex) == 0x000008, "Wrong alignment on UVoxelNode_SetDoubleIndex");
static_assert(sizeof(UVoxelNode_SetDoubleIndex) == 0x000098, "Wrong size on UVoxelNode_SetDoubleIndex");

// Class VoxelGraph.VoxelNode_ISign
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ISign final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ISign">();
	}
	static class UVoxelNode_ISign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ISign>();
	}
};
static_assert(alignof(UVoxelNode_ISign) == 0x000008, "Wrong alignment on UVoxelNode_ISign");
static_assert(sizeof(UVoxelNode_ISign) == 0x000098, "Wrong size on UVoxelNode_ISign");

// Class VoxelGraph.VoxelNode_WorldGeneratorSampler
// 0x0078 (0x01C8 - 0x0150)
class UVoxelNode_WorldGeneratorSampler final : public UVoxelExposedNode
{
public:
	struct FVoxelGeneratorPicker                  WorldGenerator;                                    // 0x0150(0x0068)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Seeds;                                             // 0x01B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_WorldGeneratorSampler">();
	}
	static class UVoxelNode_WorldGeneratorSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_WorldGeneratorSampler>();
	}
};
static_assert(alignof(UVoxelNode_WorldGeneratorSampler) == 0x000008, "Wrong alignment on UVoxelNode_WorldGeneratorSampler");
static_assert(sizeof(UVoxelNode_WorldGeneratorSampler) == 0x0001C8, "Wrong size on UVoxelNode_WorldGeneratorSampler");
static_assert(offsetof(UVoxelNode_WorldGeneratorSampler, WorldGenerator) == 0x000150, "Member 'UVoxelNode_WorldGeneratorSampler::WorldGenerator' has a wrong offset!");
static_assert(offsetof(UVoxelNode_WorldGeneratorSampler, Seeds) == 0x0001B8, "Member 'UVoxelNode_WorldGeneratorSampler::Seeds' has a wrong offset!");

// Class VoxelGraph.VoxelNode_XI
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_XI final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_XI">();
	}
	static class UVoxelNode_XI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_XI>();
	}
};
static_assert(alignof(UVoxelNode_XI) == 0x000008, "Wrong alignment on UVoxelNode_XI");
static_assert(sizeof(UVoxelNode_XI) == 0x000098, "Wrong size on UVoxelNode_XI");

// Class VoxelGraph.VoxelNode_Tan
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Tan final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Tan">();
	}
	static class UVoxelNode_Tan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Tan>();
	}
};
static_assert(alignof(UVoxelNode_Tan) == 0x000008, "Wrong alignment on UVoxelNode_Tan");
static_assert(sizeof(UVoxelNode_Tan) == 0x000098, "Wrong size on UVoxelNode_Tan");

// Class VoxelGraph.VoxelNode_YI
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_YI final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_YI">();
	}
	static class UVoxelNode_YI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_YI>();
	}
};
static_assert(alignof(UVoxelNode_YI) == 0x000008, "Wrong alignment on UVoxelNode_YI");
static_assert(sizeof(UVoxelNode_YI) == 0x000098, "Wrong size on UVoxelNode_YI");

// Class VoxelGraph.VoxelNode_ZI
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ZI final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ZI">();
	}
	static class UVoxelNode_ZI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ZI>();
	}
};
static_assert(alignof(UVoxelNode_ZI) == 0x000008, "Wrong alignment on UVoxelNode_ZI");
static_assert(sizeof(UVoxelNode_ZI) == 0x000098, "Wrong size on UVoxelNode_ZI");

// Class VoxelGraph.VoxelNode_InverseTransformPositionXZ
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_InverseTransformPositionXZ final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_InverseTransformPositionXZ">();
	}
	static class UVoxelNode_InverseTransformPositionXZ* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_InverseTransformPositionXZ>();
	}
};
static_assert(alignof(UVoxelNode_InverseTransformPositionXZ) == 0x000008, "Wrong alignment on UVoxelNode_InverseTransformPositionXZ");
static_assert(sizeof(UVoxelNode_InverseTransformPositionXZ) == 0x000098, "Wrong size on UVoxelNode_InverseTransformPositionXZ");

// Class VoxelGraph.VoxelNode_PerlinWormDistance
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_PerlinWormDistance final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_PerlinWormDistance">();
	}
	static class UVoxelNode_PerlinWormDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_PerlinWormDistance>();
	}
};
static_assert(alignof(UVoxelNode_PerlinWormDistance) == 0x000008, "Wrong alignment on UVoxelNode_PerlinWormDistance");
static_assert(sizeof(UVoxelNode_PerlinWormDistance) == 0x000098, "Wrong size on UVoxelNode_PerlinWormDistance");

// Class VoxelGraph.VoxelExample_Cave
// 0x0040 (0x0070 - 0x0030)
class UVoxelExample_Cave final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Bottom_Noise_Frequency;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bottom_Noise_Scale;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Bottom_Noise_Seed;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Global_Height_Seed;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Top_Noise_Seed;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top_Noise_Frequency;                               // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top_Noise_Scale;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bottom_Top_Merge_Smoothness;                       // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Global_Height_Merge_Smoothness;                    // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Global_Height_Noise_Frequency;                     // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Global_Height_Noise_Scale;                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Global_Height_Offset;                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cave_Height;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cave_Radius;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cave_Walls_Smoothness;                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_Cave">();
	}
	static class UVoxelExample_Cave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_Cave>();
	}
};
static_assert(alignof(UVoxelExample_Cave) == 0x000008, "Wrong alignment on UVoxelExample_Cave");
static_assert(sizeof(UVoxelExample_Cave) == 0x000070, "Wrong size on UVoxelExample_Cave");
static_assert(offsetof(UVoxelExample_Cave, Bottom_Noise_Frequency) == 0x000030, "Member 'UVoxelExample_Cave::Bottom_Noise_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Bottom_Noise_Scale) == 0x000034, "Member 'UVoxelExample_Cave::Bottom_Noise_Scale' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Bottom_Noise_Seed) == 0x000038, "Member 'UVoxelExample_Cave::Bottom_Noise_Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Global_Height_Seed) == 0x00003C, "Member 'UVoxelExample_Cave::Global_Height_Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Top_Noise_Seed) == 0x000040, "Member 'UVoxelExample_Cave::Top_Noise_Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Top_Noise_Frequency) == 0x000044, "Member 'UVoxelExample_Cave::Top_Noise_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Top_Noise_Scale) == 0x000048, "Member 'UVoxelExample_Cave::Top_Noise_Scale' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Bottom_Top_Merge_Smoothness) == 0x00004C, "Member 'UVoxelExample_Cave::Bottom_Top_Merge_Smoothness' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Global_Height_Merge_Smoothness) == 0x000050, "Member 'UVoxelExample_Cave::Global_Height_Merge_Smoothness' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Global_Height_Noise_Frequency) == 0x000054, "Member 'UVoxelExample_Cave::Global_Height_Noise_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Global_Height_Noise_Scale) == 0x000058, "Member 'UVoxelExample_Cave::Global_Height_Noise_Scale' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Global_Height_Offset) == 0x00005C, "Member 'UVoxelExample_Cave::Global_Height_Offset' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Cave_Height) == 0x000060, "Member 'UVoxelExample_Cave::Cave_Height' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Cave_Radius) == 0x000064, "Member 'UVoxelExample_Cave::Cave_Radius' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cave, Cave_Walls_Smoothness) == 0x000068, "Member 'UVoxelExample_Cave::Cave_Walls_Smoothness' has a wrong offset!");

// Class VoxelGraph.VoxelNode_BreakColorInt
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_BreakColorInt final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BreakColorInt">();
	}
	static class UVoxelNode_BreakColorInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BreakColorInt>();
	}
};
static_assert(alignof(UVoxelNode_BreakColorInt) == 0x000008, "Wrong alignment on UVoxelNode_BreakColorInt");
static_assert(sizeof(UVoxelNode_BreakColorInt) == 0x000098, "Wrong size on UVoxelNode_BreakColorInt");

// Class VoxelGraph.VoxelExample_Cliffs
// 0x0030 (0x0060 - 0x0030)
class UVoxelExample_Cliffs final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Cliffs_Slope;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Overhangs;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Base_Shape_Frequency;                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Base_Shape_Offset;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Base_Shape_Seed;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sides_Noise_Seed;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Top_Noise_Seed;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sides_Noise_Amplitude;                             // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sides_Noise_Frequency;                             // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top_Noise_Frequency;                               // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top_Noise_Scale;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_Cliffs">();
	}
	static class UVoxelExample_Cliffs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_Cliffs>();
	}
};
static_assert(alignof(UVoxelExample_Cliffs) == 0x000008, "Wrong alignment on UVoxelExample_Cliffs");
static_assert(sizeof(UVoxelExample_Cliffs) == 0x000060, "Wrong size on UVoxelExample_Cliffs");
static_assert(offsetof(UVoxelExample_Cliffs, Cliffs_Slope) == 0x000030, "Member 'UVoxelExample_Cliffs::Cliffs_Slope' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Height) == 0x000034, "Member 'UVoxelExample_Cliffs::Height' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Overhangs) == 0x000038, "Member 'UVoxelExample_Cliffs::Overhangs' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Base_Shape_Frequency) == 0x00003C, "Member 'UVoxelExample_Cliffs::Base_Shape_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Base_Shape_Offset) == 0x000040, "Member 'UVoxelExample_Cliffs::Base_Shape_Offset' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Base_Shape_Seed) == 0x000044, "Member 'UVoxelExample_Cliffs::Base_Shape_Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Sides_Noise_Seed) == 0x000048, "Member 'UVoxelExample_Cliffs::Sides_Noise_Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Top_Noise_Seed) == 0x00004C, "Member 'UVoxelExample_Cliffs::Top_Noise_Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Sides_Noise_Amplitude) == 0x000050, "Member 'UVoxelExample_Cliffs::Sides_Noise_Amplitude' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Sides_Noise_Frequency) == 0x000054, "Member 'UVoxelExample_Cliffs::Sides_Noise_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Top_Noise_Frequency) == 0x000058, "Member 'UVoxelExample_Cliffs::Top_Noise_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Cliffs, Top_Noise_Scale) == 0x00005C, "Member 'UVoxelExample_Cliffs::Top_Noise_Scale' has a wrong offset!");

// Class VoxelGraph.VoxelExample_FloatingIslandOnion
// 0x0018 (0x0048 - 0x0030)
class UVoxelExample_FloatingIslandOnion final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Height;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Perturb_Amplitude;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Perturb_Frequency;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top_Noise_Frequency;                               // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top_Noise_Height;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_FloatingIslandOnion">();
	}
	static class UVoxelExample_FloatingIslandOnion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_FloatingIslandOnion>();
	}
};
static_assert(alignof(UVoxelExample_FloatingIslandOnion) == 0x000008, "Wrong alignment on UVoxelExample_FloatingIslandOnion");
static_assert(sizeof(UVoxelExample_FloatingIslandOnion) == 0x000048, "Wrong size on UVoxelExample_FloatingIslandOnion");
static_assert(offsetof(UVoxelExample_FloatingIslandOnion, Height) == 0x000030, "Member 'UVoxelExample_FloatingIslandOnion::Height' has a wrong offset!");
static_assert(offsetof(UVoxelExample_FloatingIslandOnion, Perturb_Amplitude) == 0x000034, "Member 'UVoxelExample_FloatingIslandOnion::Perturb_Amplitude' has a wrong offset!");
static_assert(offsetof(UVoxelExample_FloatingIslandOnion, Perturb_Frequency) == 0x000038, "Member 'UVoxelExample_FloatingIslandOnion::Perturb_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_FloatingIslandOnion, Seed) == 0x00003C, "Member 'UVoxelExample_FloatingIslandOnion::Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_FloatingIslandOnion, Top_Noise_Frequency) == 0x000040, "Member 'UVoxelExample_FloatingIslandOnion::Top_Noise_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_FloatingIslandOnion, Top_Noise_Height) == 0x000044, "Member 'UVoxelExample_FloatingIslandOnion::Top_Noise_Height' has a wrong offset!");

// Class VoxelGraph.VoxelNode_Acos
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Acos final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Acos">();
	}
	static class UVoxelNode_Acos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Acos>();
	}
};
static_assert(alignof(UVoxelNode_Acos) == 0x000008, "Wrong alignment on UVoxelNode_Acos");
static_assert(sizeof(UVoxelNode_Acos) == 0x000098, "Wrong size on UVoxelNode_Acos");

// Class VoxelGraph.VoxelExample_HeightmapComposition
// 0x00B0 (0x00E0 - 0x0030)
class UVoxelExample_HeightmapComposition final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Depth;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Flip_X;                                            // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Flip_Y;                                            // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UVoxelHeightmapAssetUINT16> heightmap_x0_y0;                                   // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVoxelHeightmapAssetUINT16> heightmap_x0_y1;                                   // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVoxelHeightmapAssetUINT16> heightmap_x1_y0;                                   // 0x0088(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVoxelHeightmapAssetUINT16> heightmap_x1_y1;                                   // 0x00B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size_X;                                            // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size_Y;                                            // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_HeightmapComposition">();
	}
	static class UVoxelExample_HeightmapComposition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_HeightmapComposition>();
	}
};
static_assert(alignof(UVoxelExample_HeightmapComposition) == 0x000008, "Wrong alignment on UVoxelExample_HeightmapComposition");
static_assert(sizeof(UVoxelExample_HeightmapComposition) == 0x0000E0, "Wrong size on UVoxelExample_HeightmapComposition");
static_assert(offsetof(UVoxelExample_HeightmapComposition, Depth) == 0x000030, "Member 'UVoxelExample_HeightmapComposition::Depth' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HeightmapComposition, Flip_X) == 0x000034, "Member 'UVoxelExample_HeightmapComposition::Flip_X' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HeightmapComposition, Flip_Y) == 0x000035, "Member 'UVoxelExample_HeightmapComposition::Flip_Y' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HeightmapComposition, heightmap_x0_y0) == 0x000038, "Member 'UVoxelExample_HeightmapComposition::heightmap_x0_y0' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HeightmapComposition, heightmap_x0_y1) == 0x000060, "Member 'UVoxelExample_HeightmapComposition::heightmap_x0_y1' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HeightmapComposition, heightmap_x1_y0) == 0x000088, "Member 'UVoxelExample_HeightmapComposition::heightmap_x1_y0' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HeightmapComposition, heightmap_x1_y1) == 0x0000B0, "Member 'UVoxelExample_HeightmapComposition::heightmap_x1_y1' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HeightmapComposition, Size_X) == 0x0000D8, "Member 'UVoxelExample_HeightmapComposition::Size_X' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HeightmapComposition, Size_Y) == 0x0000DC, "Member 'UVoxelExample_HeightmapComposition::Size_Y' has a wrong offset!");

// Class VoxelGraph.VoxelExample_HollowPlanet
// 0x0020 (0x0050 - 0x0030)
class UVoxelExample_HollowPlanet final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Intersection_Smoothness;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Noise_Bias;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Noise_Frequency;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Noise_Scale;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_IQ_Noise;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_HollowPlanet">();
	}
	static class UVoxelExample_HollowPlanet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_HollowPlanet>();
	}
};
static_assert(alignof(UVoxelExample_HollowPlanet) == 0x000008, "Wrong alignment on UVoxelExample_HollowPlanet");
static_assert(sizeof(UVoxelExample_HollowPlanet) == 0x000050, "Wrong size on UVoxelExample_HollowPlanet");
static_assert(offsetof(UVoxelExample_HollowPlanet, Intersection_Smoothness) == 0x000030, "Member 'UVoxelExample_HollowPlanet::Intersection_Smoothness' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HollowPlanet, Noise_Bias) == 0x000034, "Member 'UVoxelExample_HollowPlanet::Noise_Bias' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HollowPlanet, Noise_Frequency) == 0x000038, "Member 'UVoxelExample_HollowPlanet::Noise_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HollowPlanet, Noise_Scale) == 0x00003C, "Member 'UVoxelExample_HollowPlanet::Noise_Scale' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HollowPlanet, Radius) == 0x000040, "Member 'UVoxelExample_HollowPlanet::Radius' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HollowPlanet, Seed) == 0x000044, "Member 'UVoxelExample_HollowPlanet::Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_HollowPlanet, Use_IQ_Noise) == 0x000048, "Member 'UVoxelExample_HollowPlanet::Use_IQ_Noise' has a wrong offset!");

// Class VoxelGraph.VoxelNode_RGBToHSV
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_RGBToHSV final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_RGBToHSV">();
	}
	static class UVoxelNode_RGBToHSV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_RGBToHSV>();
	}
};
static_assert(alignof(UVoxelNode_RGBToHSV) == 0x000008, "Wrong alignment on UVoxelNode_RGBToHSV");
static_assert(sizeof(UVoxelNode_RGBToHSV) == 0x000098, "Wrong size on UVoxelNode_RGBToHSV");

// Class VoxelGraph.VoxelExample_IQNoise
// 0x0010 (0x0040 - 0x0030)
class UVoxelExample_IQNoise final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Frequency;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_IQNoise">();
	}
	static class UVoxelExample_IQNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_IQNoise>();
	}
};
static_assert(alignof(UVoxelExample_IQNoise) == 0x000008, "Wrong alignment on UVoxelExample_IQNoise");
static_assert(sizeof(UVoxelExample_IQNoise) == 0x000040, "Wrong size on UVoxelExample_IQNoise");
static_assert(offsetof(UVoxelExample_IQNoise, Frequency) == 0x000030, "Member 'UVoxelExample_IQNoise::Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_IQNoise, Height) == 0x000034, "Member 'UVoxelExample_IQNoise::Height' has a wrong offset!");
static_assert(offsetof(UVoxelExample_IQNoise, Seed) == 0x000038, "Member 'UVoxelExample_IQNoise::Seed' has a wrong offset!");

// Class VoxelGraph.VoxelExample_LayeredPlanet
// 0x0038 (0x0068 - 0x0030)
class UVoxelExample_LayeredPlanet final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Frequency;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             None1;                                             // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Slice_Mode;                                        // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_LayeredPlanet">();
	}
	static class UVoxelExample_LayeredPlanet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_LayeredPlanet>();
	}
};
static_assert(alignof(UVoxelExample_LayeredPlanet) == 0x000008, "Wrong alignment on UVoxelExample_LayeredPlanet");
static_assert(sizeof(UVoxelExample_LayeredPlanet) == 0x000068, "Wrong size on UVoxelExample_LayeredPlanet");
static_assert(offsetof(UVoxelExample_LayeredPlanet, Frequency) == 0x000030, "Member 'UVoxelExample_LayeredPlanet::Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_LayeredPlanet, None1) == 0x000038, "Member 'UVoxelExample_LayeredPlanet::None1' has a wrong offset!");
static_assert(offsetof(UVoxelExample_LayeredPlanet, Seed) == 0x000060, "Member 'UVoxelExample_LayeredPlanet::Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_LayeredPlanet, Slice_Mode) == 0x000064, "Member 'UVoxelExample_LayeredPlanet::Slice_Mode' has a wrong offset!");

// Class VoxelGraph.VoxelNode_NoiseNode
// 0x0040 (0x00D8 - 0x0098)
class UVoxelNode_NoiseNode : public UVoxelNodeWithContext
{
public:
	float                                         Frequency;                                         // 0x0098(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelNoiseInterpolation                      Interpolation;                                     // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        NumberOfSamples;                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVoxelRange>                    OutputRanges;                                      // 0x00A8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_NoiseNode">();
	}
	static class UVoxelNode_NoiseNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_NoiseNode>();
	}
};
static_assert(alignof(UVoxelNode_NoiseNode) == 0x000008, "Wrong alignment on UVoxelNode_NoiseNode");
static_assert(sizeof(UVoxelNode_NoiseNode) == 0x0000D8, "Wrong size on UVoxelNode_NoiseNode");
static_assert(offsetof(UVoxelNode_NoiseNode, Frequency) == 0x000098, "Member 'UVoxelNode_NoiseNode::Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelNode_NoiseNode, Interpolation) == 0x00009C, "Member 'UVoxelNode_NoiseNode::Interpolation' has a wrong offset!");
static_assert(offsetof(UVoxelNode_NoiseNode, NumberOfSamples) == 0x0000A0, "Member 'UVoxelNode_NoiseNode::NumberOfSamples' has a wrong offset!");
static_assert(offsetof(UVoxelNode_NoiseNode, Tolerance) == 0x0000A4, "Member 'UVoxelNode_NoiseNode::Tolerance' has a wrong offset!");
static_assert(offsetof(UVoxelNode_NoiseNode, OutputRanges) == 0x0000A8, "Member 'UVoxelNode_NoiseNode::OutputRanges' has a wrong offset!");

// Class VoxelGraph.VoxelNode_NoiseNodeWithDerivative
// 0x0008 (0x00E0 - 0x00D8)
class UVoxelNode_NoiseNodeWithDerivative : public UVoxelNode_NoiseNode
{
public:
	bool                                          bComputeDerivative;                                // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_NoiseNodeWithDerivative">();
	}
	static class UVoxelNode_NoiseNodeWithDerivative* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_NoiseNodeWithDerivative>();
	}
};
static_assert(alignof(UVoxelNode_NoiseNodeWithDerivative) == 0x000008, "Wrong alignment on UVoxelNode_NoiseNodeWithDerivative");
static_assert(sizeof(UVoxelNode_NoiseNodeWithDerivative) == 0x0000E0, "Wrong size on UVoxelNode_NoiseNodeWithDerivative");
static_assert(offsetof(UVoxelNode_NoiseNodeWithDerivative, bComputeDerivative) == 0x0000D8, "Member 'UVoxelNode_NoiseNodeWithDerivative::bComputeDerivative' has a wrong offset!");

// Class VoxelGraph.VoxelNode_2DPerlinNoise
// 0x0000 (0x00E0 - 0x00E0)
class UVoxelNode_2DPerlinNoise final : public UVoxelNode_NoiseNodeWithDerivative
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DPerlinNoise">();
	}
	static class UVoxelNode_2DPerlinNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DPerlinNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DPerlinNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DPerlinNoise");
static_assert(sizeof(UVoxelNode_2DPerlinNoise) == 0x0000E0, "Wrong size on UVoxelNode_2DPerlinNoise");

// Class VoxelGraph.VoxelExample_LayeredWorld
// 0x0038 (0x0068 - 0x0030)
class UVoxelExample_LayeredWorld final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Frequency;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             None1;                                             // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seed;                                              // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_LayeredWorld">();
	}
	static class UVoxelExample_LayeredWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_LayeredWorld>();
	}
};
static_assert(alignof(UVoxelExample_LayeredWorld) == 0x000008, "Wrong alignment on UVoxelExample_LayeredWorld");
static_assert(sizeof(UVoxelExample_LayeredWorld) == 0x000068, "Wrong size on UVoxelExample_LayeredWorld");
static_assert(offsetof(UVoxelExample_LayeredWorld, Frequency) == 0x000030, "Member 'UVoxelExample_LayeredWorld::Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_LayeredWorld, None1) == 0x000038, "Member 'UVoxelExample_LayeredWorld::None1' has a wrong offset!");
static_assert(offsetof(UVoxelExample_LayeredWorld, Seed) == 0x000060, "Member 'UVoxelExample_LayeredWorld::Seed' has a wrong offset!");

// Class VoxelGraph.VoxelExample_Planet
// 0x0068 (0x0098 - 0x0030)
class UVoxelExample_Planet final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Frequency;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Noise_Seed;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Noise_Strength;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveLinearColor>       PlanetColorCurve;                                  // 0x0040(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             PlanetCurve;                                       // 0x0068(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_Planet">();
	}
	static class UVoxelExample_Planet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_Planet>();
	}
};
static_assert(alignof(UVoxelExample_Planet) == 0x000008, "Wrong alignment on UVoxelExample_Planet");
static_assert(sizeof(UVoxelExample_Planet) == 0x000098, "Wrong size on UVoxelExample_Planet");
static_assert(offsetof(UVoxelExample_Planet, Frequency) == 0x000030, "Member 'UVoxelExample_Planet::Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Planet, Noise_Seed) == 0x000034, "Member 'UVoxelExample_Planet::Noise_Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Planet, Noise_Strength) == 0x000038, "Member 'UVoxelExample_Planet::Noise_Strength' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Planet, PlanetColorCurve) == 0x000040, "Member 'UVoxelExample_Planet::PlanetColorCurve' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Planet, PlanetCurve) == 0x000068, "Member 'UVoxelExample_Planet::PlanetCurve' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Planet, Radius) == 0x000090, "Member 'UVoxelExample_Planet::Radius' has a wrong offset!");

// Class VoxelGraph.VoxelNode_NormalizeSum
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_NormalizeSum final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_NormalizeSum">();
	}
	static class UVoxelNode_NormalizeSum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_NormalizeSum>();
	}
};
static_assert(alignof(UVoxelNode_NormalizeSum) == 0x000008, "Wrong alignment on UVoxelNode_NormalizeSum");
static_assert(sizeof(UVoxelNode_NormalizeSum) == 0x000098, "Wrong size on UVoxelNode_NormalizeSum");

// Class VoxelGraph.VoxelExample_Ravines
// 0x0018 (0x0048 - 0x0030)
class UVoxelExample_Ravines final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         _3D_Noise_Frequency;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _3D_Noise_Seed;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Bottom_Transition_Smoothness;                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Top_Transition_Smoothness;                         // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_Ravines">();
	}
	static class UVoxelExample_Ravines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_Ravines>();
	}
};
static_assert(alignof(UVoxelExample_Ravines) == 0x000008, "Wrong alignment on UVoxelExample_Ravines");
static_assert(sizeof(UVoxelExample_Ravines) == 0x000048, "Wrong size on UVoxelExample_Ravines");
static_assert(offsetof(UVoxelExample_Ravines, _3D_Noise_Frequency) == 0x000030, "Member 'UVoxelExample_Ravines::_3D_Noise_Frequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Ravines, _3D_Noise_Seed) == 0x000034, "Member 'UVoxelExample_Ravines::_3D_Noise_Seed' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Ravines, Bottom_Transition_Smoothness) == 0x000038, "Member 'UVoxelExample_Ravines::Bottom_Transition_Smoothness' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Ravines, Height) == 0x00003C, "Member 'UVoxelExample_Ravines::Height' has a wrong offset!");
static_assert(offsetof(UVoxelExample_Ravines, Top_Transition_Smoothness) == 0x000040, "Member 'UVoxelExample_Ravines::Top_Transition_Smoothness' has a wrong offset!");

// Class VoxelGraph.VoxelExample_RingWorld
// 0x0160 (0x0190 - 0x0030)
class UVoxelExample_RingWorld final : public UVoxelGraphGeneratorHelper
{
public:
	float                                         Radius;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RingEdgesHardness;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width_in_Degrees;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiverDepth;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RiverWidth;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BeachColor;                                        // 0x004C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MountainsColorHigh;                                // 0x005C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MountainsColorLowHigh;                             // 0x006C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MountainsColorLowLow;                              // 0x007C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             MoutainsMaskCurve;                                 // 0x0090(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PlainsColorHigh;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PlainsColorLow;                                    // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlainsNoiseFrequency;                              // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlainsNoiseHeight;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             PlainsNoiseStrengthCurve;                          // 0x00E0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             RingMainShapeCurve;                                // 0x0108(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RingOuterColor;                                    // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RiverColor;                                        // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             RiverDepthCurve;                                   // 0x0150(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MountainsNoiseFrequency;                           // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MountainsNoiseHeight;                              // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseNoiseFrquency;                                 // 0x0180(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseNoiseHeight;                                   // 0x0184(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseHeight;                                        // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_RingWorld">();
	}
	static class UVoxelExample_RingWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_RingWorld>();
	}
};
static_assert(alignof(UVoxelExample_RingWorld) == 0x000008, "Wrong alignment on UVoxelExample_RingWorld");
static_assert(sizeof(UVoxelExample_RingWorld) == 0x000190, "Wrong size on UVoxelExample_RingWorld");
static_assert(offsetof(UVoxelExample_RingWorld, Radius) == 0x000030, "Member 'UVoxelExample_RingWorld::Radius' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, RingEdgesHardness) == 0x000034, "Member 'UVoxelExample_RingWorld::RingEdgesHardness' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, Scale) == 0x000038, "Member 'UVoxelExample_RingWorld::Scale' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, Thickness) == 0x00003C, "Member 'UVoxelExample_RingWorld::Thickness' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, Width_in_Degrees) == 0x000040, "Member 'UVoxelExample_RingWorld::Width_in_Degrees' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, RiverDepth) == 0x000044, "Member 'UVoxelExample_RingWorld::RiverDepth' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, RiverWidth) == 0x000048, "Member 'UVoxelExample_RingWorld::RiverWidth' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, BeachColor) == 0x00004C, "Member 'UVoxelExample_RingWorld::BeachColor' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, MountainsColorHigh) == 0x00005C, "Member 'UVoxelExample_RingWorld::MountainsColorHigh' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, MountainsColorLowHigh) == 0x00006C, "Member 'UVoxelExample_RingWorld::MountainsColorLowHigh' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, MountainsColorLowLow) == 0x00007C, "Member 'UVoxelExample_RingWorld::MountainsColorLowLow' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, MoutainsMaskCurve) == 0x000090, "Member 'UVoxelExample_RingWorld::MoutainsMaskCurve' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, PlainsColorHigh) == 0x0000B8, "Member 'UVoxelExample_RingWorld::PlainsColorHigh' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, PlainsColorLow) == 0x0000C8, "Member 'UVoxelExample_RingWorld::PlainsColorLow' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, PlainsNoiseFrequency) == 0x0000D8, "Member 'UVoxelExample_RingWorld::PlainsNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, PlainsNoiseHeight) == 0x0000DC, "Member 'UVoxelExample_RingWorld::PlainsNoiseHeight' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, PlainsNoiseStrengthCurve) == 0x0000E0, "Member 'UVoxelExample_RingWorld::PlainsNoiseStrengthCurve' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, RingMainShapeCurve) == 0x000108, "Member 'UVoxelExample_RingWorld::RingMainShapeCurve' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, RingOuterColor) == 0x000130, "Member 'UVoxelExample_RingWorld::RingOuterColor' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, RiverColor) == 0x000140, "Member 'UVoxelExample_RingWorld::RiverColor' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, RiverDepthCurve) == 0x000150, "Member 'UVoxelExample_RingWorld::RiverDepthCurve' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, MountainsNoiseFrequency) == 0x000178, "Member 'UVoxelExample_RingWorld::MountainsNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, MountainsNoiseHeight) == 0x00017C, "Member 'UVoxelExample_RingWorld::MountainsNoiseHeight' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, BaseNoiseFrquency) == 0x000180, "Member 'UVoxelExample_RingWorld::BaseNoiseFrquency' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, BaseNoiseHeight) == 0x000184, "Member 'UVoxelExample_RingWorld::BaseNoiseHeight' has a wrong offset!");
static_assert(offsetof(UVoxelExample_RingWorld, BaseHeight) == 0x000188, "Member 'UVoxelExample_RingWorld::BaseHeight' has a wrong offset!");

// Class VoxelGraph.VoxelNode_MakeColorInt
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_MakeColorInt final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_MakeColorInt">();
	}
	static class UVoxelNode_MakeColorInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_MakeColorInt>();
	}
};
static_assert(alignof(UVoxelNode_MakeColorInt) == 0x000008, "Wrong alignment on UVoxelNode_MakeColorInt");
static_assert(sizeof(UVoxelNode_MakeColorInt) == 0x000098, "Wrong size on UVoxelNode_MakeColorInt");

// Class VoxelGraph.VoxelExample_Tool_NoisyColors
// 0x0010 (0x0040 - 0x0030)
class UVoxelExample_Tool_NoisyColors final : public UVoxelGraphGeneratorHelper
{
public:
	struct FLinearColor                           Color;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelExample_Tool_NoisyColors">();
	}
	static class UVoxelExample_Tool_NoisyColors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelExample_Tool_NoisyColors>();
	}
};
static_assert(alignof(UVoxelExample_Tool_NoisyColors) == 0x000008, "Wrong alignment on UVoxelExample_Tool_NoisyColors");
static_assert(sizeof(UVoxelExample_Tool_NoisyColors) == 0x000040, "Wrong size on UVoxelExample_Tool_NoisyColors");
static_assert(offsetof(UVoxelExample_Tool_NoisyColors, Color) == 0x000030, "Member 'UVoxelExample_Tool_NoisyColors::Color' has a wrong offset!");

// Class VoxelGraph.VoxelNode_SetColor
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SetColor final : public UVoxelNode_MaterialSetter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SetColor">();
	}
	static class UVoxelNode_SetColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SetColor>();
	}
};
static_assert(alignof(UVoxelNode_SetColor) == 0x000008, "Wrong alignment on UVoxelNode_SetColor");
static_assert(sizeof(UVoxelNode_SetColor) == 0x000098, "Wrong size on UVoxelNode_SetColor");

// Class VoxelGraph.VoxelNode_IMax
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IMax final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IMax">();
	}
	static class UVoxelNode_IMax* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IMax>();
	}
};
static_assert(alignof(UVoxelNode_IMax) == 0x000008, "Wrong alignment on UVoxelNode_IMax");
static_assert(sizeof(UVoxelNode_IMax) == 0x000098, "Wrong size on UVoxelNode_IMax");

// Class VoxelGraph.VoxelNode_SetSingleIndex
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SetSingleIndex final : public UVoxelNode_MaterialSetter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SetSingleIndex">();
	}
	static class UVoxelNode_SetSingleIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SetSingleIndex>();
	}
};
static_assert(alignof(UVoxelNode_SetSingleIndex) == 0x000008, "Wrong alignment on UVoxelNode_SetSingleIndex");
static_assert(sizeof(UVoxelNode_SetSingleIndex) == 0x000098, "Wrong size on UVoxelNode_SetSingleIndex");

// Class VoxelGraph.VoxelNode_SetMultiIndexWetness
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SetMultiIndexWetness final : public UVoxelNode_MaterialSetter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SetMultiIndexWetness">();
	}
	static class UVoxelNode_SetMultiIndexWetness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SetMultiIndexWetness>();
	}
};
static_assert(alignof(UVoxelNode_SetMultiIndexWetness) == 0x000008, "Wrong alignment on UVoxelNode_SetMultiIndexWetness");
static_assert(sizeof(UVoxelNode_SetMultiIndexWetness) == 0x000098, "Wrong size on UVoxelNode_SetMultiIndexWetness");

// Class VoxelGraph.VoxelNode_3DPerlinNoise
// 0x0000 (0x00E0 - 0x00E0)
class UVoxelNode_3DPerlinNoise final : public UVoxelNode_NoiseNodeWithDerivative
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DPerlinNoise">();
	}
	static class UVoxelNode_3DPerlinNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DPerlinNoise>();
	}
};
static_assert(alignof(UVoxelNode_3DPerlinNoise) == 0x000008, "Wrong alignment on UVoxelNode_3DPerlinNoise");
static_assert(sizeof(UVoxelNode_3DPerlinNoise) == 0x0000E0, "Wrong size on UVoxelNode_3DPerlinNoise");

// Class VoxelGraph.VoxelNode_AddMultiIndex
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_AddMultiIndex final : public UVoxelNode_MaterialSetter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_AddMultiIndex">();
	}
	static class UVoxelNode_AddMultiIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_AddMultiIndex>();
	}
};
static_assert(alignof(UVoxelNode_AddMultiIndex) == 0x000008, "Wrong alignment on UVoxelNode_AddMultiIndex");
static_assert(sizeof(UVoxelNode_AddMultiIndex) == 0x000098, "Wrong size on UVoxelNode_AddMultiIndex");

// Class VoxelGraph.VoxelNode_SetUVs
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_SetUVs final : public UVoxelNode_MaterialSetter
{
public:
	bool                                          bSetU;                                             // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetV;                                             // 0x0099(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SetUVs">();
	}
	static class UVoxelNode_SetUVs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SetUVs>();
	}
};
static_assert(alignof(UVoxelNode_SetUVs) == 0x000008, "Wrong alignment on UVoxelNode_SetUVs");
static_assert(sizeof(UVoxelNode_SetUVs) == 0x0000A0, "Wrong size on UVoxelNode_SetUVs");
static_assert(offsetof(UVoxelNode_SetUVs, bSetU) == 0x000098, "Member 'UVoxelNode_SetUVs::bSetU' has a wrong offset!");
static_assert(offsetof(UVoxelNode_SetUVs, bSetV) == 0x000099, "Member 'UVoxelNode_SetUVs::bSetV' has a wrong offset!");

// Class VoxelGraph.VoxelNode_FSubstract
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FSubstract final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FSubstract">();
	}
	static class UVoxelNode_FSubstract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FSubstract>();
	}
};
static_assert(alignof(UVoxelNode_FSubstract) == 0x000008, "Wrong alignment on UVoxelNode_FSubstract");
static_assert(sizeof(UVoxelNode_FSubstract) == 0x000098, "Wrong size on UVoxelNode_FSubstract");

// Class VoxelGraph.VoxelNode_SetNode
// 0x0028 (0x00C0 - 0x0098)
class UVoxelNode_SetNode : public UVoxelSetterNode
{
public:
	uint32                                        Index_0;                                           // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVoxelGraphOutput                      CachedOutput;                                      // 0x009C(0x0020)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SetNode">();
	}
	static class UVoxelNode_SetNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SetNode>();
	}
};
static_assert(alignof(UVoxelNode_SetNode) == 0x000008, "Wrong alignment on UVoxelNode_SetNode");
static_assert(sizeof(UVoxelNode_SetNode) == 0x0000C0, "Wrong size on UVoxelNode_SetNode");
static_assert(offsetof(UVoxelNode_SetNode, Index_0) == 0x000098, "Member 'UVoxelNode_SetNode::Index_0' has a wrong offset!");
static_assert(offsetof(UVoxelNode_SetNode, CachedOutput) == 0x00009C, "Member 'UVoxelNode_SetNode::CachedOutput' has a wrong offset!");

// Class VoxelGraph.VoxelNode_SetValueNode
// 0x0000 (0x00C0 - 0x00C0)
class UVoxelNode_SetValueNode final : public UVoxelNode_SetNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SetValueNode">();
	}
	static class UVoxelNode_SetValueNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SetValueNode>();
	}
};
static_assert(alignof(UVoxelNode_SetValueNode) == 0x000008, "Wrong alignment on UVoxelNode_SetValueNode");
static_assert(sizeof(UVoxelNode_SetValueNode) == 0x0000C0, "Wrong size on UVoxelNode_SetValueNode");

// Class VoxelGraph.VoxelNode_FMax
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FMax final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FMax">();
	}
	static class UVoxelNode_FMax* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FMax>();
	}
};
static_assert(alignof(UVoxelNode_FMax) == 0x000008, "Wrong alignment on UVoxelNode_FMax");
static_assert(sizeof(UVoxelNode_FMax) == 0x000098, "Wrong size on UVoxelNode_FMax");

// Class VoxelGraph.VoxelNode_FunctionSeparator
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FunctionSeparator final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FunctionSeparator">();
	}
	static class UVoxelNode_FunctionSeparator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FunctionSeparator>();
	}
};
static_assert(alignof(UVoxelNode_FunctionSeparator) == 0x000008, "Wrong alignment on UVoxelNode_FunctionSeparator");
static_assert(sizeof(UVoxelNode_FunctionSeparator) == 0x000098, "Wrong size on UVoxelNode_FunctionSeparator");

// Class VoxelGraph.VoxelNode_FlowMerge
// 0x0010 (0x0068 - 0x0058)
class UVoxelNode_FlowMerge final : public UVoxelNode
{
public:
	TArray<struct FVoxelNamedDataPin>             Types;                                             // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FlowMerge">();
	}
	static class UVoxelNode_FlowMerge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FlowMerge>();
	}
};
static_assert(alignof(UVoxelNode_FlowMerge) == 0x000008, "Wrong alignment on UVoxelNode_FlowMerge");
static_assert(sizeof(UVoxelNode_FlowMerge) == 0x000068, "Wrong size on UVoxelNode_FlowMerge");
static_assert(offsetof(UVoxelNode_FlowMerge, Types) == 0x000058, "Member 'UVoxelNode_FlowMerge::Types' has a wrong offset!");

// Class VoxelGraph.VoxelNode_3DValueNoise
// 0x0000 (0x00E0 - 0x00E0)
class UVoxelNode_3DValueNoise final : public UVoxelNode_NoiseNodeWithDerivative
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DValueNoise">();
	}
	static class UVoxelNode_3DValueNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DValueNoise>();
	}
};
static_assert(alignof(UVoxelNode_3DValueNoise) == 0x000008, "Wrong alignment on UVoxelNode_3DValueNoise");
static_assert(sizeof(UVoxelNode_3DValueNoise) == 0x0000E0, "Wrong size on UVoxelNode_3DValueNoise");

// Class VoxelGraph.VoxelNode_SampleFoliageMaterialIndex
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SampleFoliageMaterialIndex final : public UVoxelNodeWithContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SampleFoliageMaterialIndex">();
	}
	static class UVoxelNode_SampleFoliageMaterialIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SampleFoliageMaterialIndex>();
	}
};
static_assert(alignof(UVoxelNode_SampleFoliageMaterialIndex) == 0x000008, "Wrong alignment on UVoxelNode_SampleFoliageMaterialIndex");
static_assert(sizeof(UVoxelNode_SampleFoliageMaterialIndex) == 0x000098, "Wrong size on UVoxelNode_SampleFoliageMaterialIndex");

// Class VoxelGraph.VoxelNode_GetBiomeIndex
// 0x0008 (0x0158 - 0x0150)
class UVoxelNode_GetBiomeIndex final : public UVoxelExposedNode
{
public:
	class UVoxelFoliageBiomeBase*                 Biome;                                             // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetBiomeIndex">();
	}
	static class UVoxelNode_GetBiomeIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetBiomeIndex>();
	}
};
static_assert(alignof(UVoxelNode_GetBiomeIndex) == 0x000008, "Wrong alignment on UVoxelNode_GetBiomeIndex");
static_assert(sizeof(UVoxelNode_GetBiomeIndex) == 0x000158, "Wrong size on UVoxelNode_GetBiomeIndex");
static_assert(offsetof(UVoxelNode_GetBiomeIndex, Biome) == 0x000150, "Member 'UVoxelNode_GetBiomeIndex::Biome' has a wrong offset!");

// Class VoxelGraph.VoxelNode_CellularNoise
// 0x0008 (0x00E0 - 0x00D8)
class UVoxelNode_CellularNoise : public UVoxelNode_NoiseNode
{
public:
	EVoxelCellularDistanceFunction                DistanceFunction;                                  // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelCellularReturnType                      ReturnType;                                        // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Jitter;                                            // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CellularNoise">();
	}
	static class UVoxelNode_CellularNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CellularNoise>();
	}
};
static_assert(alignof(UVoxelNode_CellularNoise) == 0x000008, "Wrong alignment on UVoxelNode_CellularNoise");
static_assert(sizeof(UVoxelNode_CellularNoise) == 0x0000E0, "Wrong size on UVoxelNode_CellularNoise");
static_assert(offsetof(UVoxelNode_CellularNoise, DistanceFunction) == 0x0000D8, "Member 'UVoxelNode_CellularNoise::DistanceFunction' has a wrong offset!");
static_assert(offsetof(UVoxelNode_CellularNoise, ReturnType) == 0x0000D9, "Member 'UVoxelNode_CellularNoise::ReturnType' has a wrong offset!");
static_assert(offsetof(UVoxelNode_CellularNoise, Jitter) == 0x0000DC, "Member 'UVoxelNode_CellularNoise::Jitter' has a wrong offset!");

// Class VoxelGraph.VoxelNode_3DCellularNoise
// 0x0000 (0x00E0 - 0x00E0)
class UVoxelNode_3DCellularNoise final : public UVoxelNode_CellularNoise
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DCellularNoise">();
	}
	static class UVoxelNode_3DCellularNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DCellularNoise>();
	}
};
static_assert(alignof(UVoxelNode_3DCellularNoise) == 0x000008, "Wrong alignment on UVoxelNode_3DCellularNoise");
static_assert(sizeof(UVoxelNode_3DCellularNoise) == 0x0000E0, "Wrong size on UVoxelNode_3DCellularNoise");

// Class VoxelGraph.VoxelNode_2DGavoronoiNoise
// 0x0008 (0x00E0 - 0x00D8)
class UVoxelNode_2DGavoronoiNoise final : public UVoxelNode_NoiseNode
{
public:
	float                                         Jitter;                                            // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DGavoronoiNoise">();
	}
	static class UVoxelNode_2DGavoronoiNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DGavoronoiNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DGavoronoiNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DGavoronoiNoise");
static_assert(sizeof(UVoxelNode_2DGavoronoiNoise) == 0x0000E0, "Wrong size on UVoxelNode_2DGavoronoiNoise");
static_assert(offsetof(UVoxelNode_2DGavoronoiNoise, Jitter) == 0x0000D8, "Member 'UVoxelNode_2DGavoronoiNoise::Jitter' has a wrong offset!");

// Class VoxelGraph.VoxelNode_3DSimplexNoise
// 0x0000 (0x00D8 - 0x00D8)
class UVoxelNode_3DSimplexNoise final : public UVoxelNode_NoiseNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DSimplexNoise">();
	}
	static class UVoxelNode_3DSimplexNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DSimplexNoise>();
	}
};
static_assert(alignof(UVoxelNode_3DSimplexNoise) == 0x000008, "Wrong alignment on UVoxelNode_3DSimplexNoise");
static_assert(sizeof(UVoxelNode_3DSimplexNoise) == 0x0000D8, "Wrong size on UVoxelNode_3DSimplexNoise");

// Class VoxelGraph.VoxelNode_NoiseNodeFractal
// 0x0060 (0x0138 - 0x00D8)
class UVoxelNode_NoiseNodeFractal : public UVoxelNode_NoiseNode
{
public:
	int32                                         FractalOctaves;                                    // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FractalLacunarity;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FractalGain;                                       // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelNoiseFractalType                        FractalType;                                       // 0x00E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, uint8>                    LODToOctavesMap;                                   // 0x00E8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_NoiseNodeFractal">();
	}
	static class UVoxelNode_NoiseNodeFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_NoiseNodeFractal>();
	}
};
static_assert(alignof(UVoxelNode_NoiseNodeFractal) == 0x000008, "Wrong alignment on UVoxelNode_NoiseNodeFractal");
static_assert(sizeof(UVoxelNode_NoiseNodeFractal) == 0x000138, "Wrong size on UVoxelNode_NoiseNodeFractal");
static_assert(offsetof(UVoxelNode_NoiseNodeFractal, FractalOctaves) == 0x0000D8, "Member 'UVoxelNode_NoiseNodeFractal::FractalOctaves' has a wrong offset!");
static_assert(offsetof(UVoxelNode_NoiseNodeFractal, FractalLacunarity) == 0x0000DC, "Member 'UVoxelNode_NoiseNodeFractal::FractalLacunarity' has a wrong offset!");
static_assert(offsetof(UVoxelNode_NoiseNodeFractal, FractalGain) == 0x0000E0, "Member 'UVoxelNode_NoiseNodeFractal::FractalGain' has a wrong offset!");
static_assert(offsetof(UVoxelNode_NoiseNodeFractal, FractalType) == 0x0000E4, "Member 'UVoxelNode_NoiseNodeFractal::FractalType' has a wrong offset!");
static_assert(offsetof(UVoxelNode_NoiseNodeFractal, LODToOctavesMap) == 0x0000E8, "Member 'UVoxelNode_NoiseNodeFractal::LODToOctavesMap' has a wrong offset!");

// Class VoxelGraph.VoxelNode_2DGavoronoiNoiseFractal
// 0x0008 (0x0140 - 0x0138)
class UVoxelNode_2DGavoronoiNoiseFractal final : public UVoxelNode_NoiseNodeFractal
{
public:
	float                                         Jitter;                                            // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DGavoronoiNoiseFractal">();
	}
	static class UVoxelNode_2DGavoronoiNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DGavoronoiNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_2DGavoronoiNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_2DGavoronoiNoiseFractal");
static_assert(sizeof(UVoxelNode_2DGavoronoiNoiseFractal) == 0x000140, "Wrong size on UVoxelNode_2DGavoronoiNoiseFractal");
static_assert(offsetof(UVoxelNode_2DGavoronoiNoiseFractal, Jitter) == 0x000138, "Member 'UVoxelNode_2DGavoronoiNoiseFractal::Jitter' has a wrong offset!");

// Class VoxelGraph.VoxelNode_2DCubicNoise
// 0x0000 (0x00D8 - 0x00D8)
class UVoxelNode_2DCubicNoise final : public UVoxelNode_NoiseNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DCubicNoise">();
	}
	static class UVoxelNode_2DCubicNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DCubicNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DCubicNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DCubicNoise");
static_assert(sizeof(UVoxelNode_2DCubicNoise) == 0x0000D8, "Wrong size on UVoxelNode_2DCubicNoise");

// Class VoxelGraph.VoxelNode_NoiseNodeWithDerivativeFractal
// 0x0008 (0x0140 - 0x0138)
class UVoxelNode_NoiseNodeWithDerivativeFractal : public UVoxelNode_NoiseNodeFractal
{
public:
	bool                                          bComputeDerivative;                                // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_NoiseNodeWithDerivativeFractal">();
	}
	static class UVoxelNode_NoiseNodeWithDerivativeFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_NoiseNodeWithDerivativeFractal>();
	}
};
static_assert(alignof(UVoxelNode_NoiseNodeWithDerivativeFractal) == 0x000008, "Wrong alignment on UVoxelNode_NoiseNodeWithDerivativeFractal");
static_assert(sizeof(UVoxelNode_NoiseNodeWithDerivativeFractal) == 0x000140, "Wrong size on UVoxelNode_NoiseNodeWithDerivativeFractal");
static_assert(offsetof(UVoxelNode_NoiseNodeWithDerivativeFractal, bComputeDerivative) == 0x000138, "Member 'UVoxelNode_NoiseNodeWithDerivativeFractal::bComputeDerivative' has a wrong offset!");

// Class VoxelGraph.VoxelNode_2DErosion
// 0x0008 (0x0148 - 0x0140)
class UVoxelNode_2DErosion final : public UVoxelNode_NoiseNodeWithDerivativeFractal
{
public:
	float                                         Jitter;                                            // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DErosion">();
	}
	static class UVoxelNode_2DErosion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DErosion>();
	}
};
static_assert(alignof(UVoxelNode_2DErosion) == 0x000008, "Wrong alignment on UVoxelNode_2DErosion");
static_assert(sizeof(UVoxelNode_2DErosion) == 0x000148, "Wrong size on UVoxelNode_2DErosion");
static_assert(offsetof(UVoxelNode_2DErosion, Jitter) == 0x000140, "Member 'UVoxelNode_2DErosion::Jitter' has a wrong offset!");

// Class VoxelGraph.VoxelNode_GeneratorSamplerBase
// 0x0000 (0x0150 - 0x0150)
class UVoxelNode_GeneratorSamplerBase : public UVoxelExposedNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GeneratorSamplerBase">();
	}
	static class UVoxelNode_GeneratorSamplerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GeneratorSamplerBase>();
	}
};
static_assert(alignof(UVoxelNode_GeneratorSamplerBase) == 0x000008, "Wrong alignment on UVoxelNode_GeneratorSamplerBase");
static_assert(sizeof(UVoxelNode_GeneratorSamplerBase) == 0x000150, "Wrong size on UVoxelNode_GeneratorSamplerBase");

// Class VoxelGraph.VoxelNode_GeneratorMerge
// 0x0030 (0x0180 - 0x0150)
class UVoxelNode_GeneratorMerge final : public UVoxelNode_GeneratorSamplerBase
{
public:
	TArray<class FName>                           Outputs;                                           // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EVoxelMaterialConfig                          MaterialConfig;                                    // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVoxelGeneratorPicker>          Generators;                                        // 0x0168(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GeneratorMerge">();
	}
	static class UVoxelNode_GeneratorMerge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GeneratorMerge>();
	}
};
static_assert(alignof(UVoxelNode_GeneratorMerge) == 0x000008, "Wrong alignment on UVoxelNode_GeneratorMerge");
static_assert(sizeof(UVoxelNode_GeneratorMerge) == 0x000180, "Wrong size on UVoxelNode_GeneratorMerge");
static_assert(offsetof(UVoxelNode_GeneratorMerge, Outputs) == 0x000150, "Member 'UVoxelNode_GeneratorMerge::Outputs' has a wrong offset!");
static_assert(offsetof(UVoxelNode_GeneratorMerge, MaterialConfig) == 0x000160, "Member 'UVoxelNode_GeneratorMerge::MaterialConfig' has a wrong offset!");
static_assert(offsetof(UVoxelNode_GeneratorMerge, Generators) == 0x000168, "Member 'UVoxelNode_GeneratorMerge::Generators' has a wrong offset!");
static_assert(offsetof(UVoxelNode_GeneratorMerge, Tolerance) == 0x000178, "Member 'UVoxelNode_GeneratorMerge::Tolerance' has a wrong offset!");

// Class VoxelGraph.VoxelNode_CraterNoise
// 0x0008 (0x00E0 - 0x00D8)
class UVoxelNode_CraterNoise : public UVoxelNode_NoiseNode
{
public:
	float                                         Jitter;                                            // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffExponent;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CraterNoise">();
	}
	static class UVoxelNode_CraterNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CraterNoise>();
	}
};
static_assert(alignof(UVoxelNode_CraterNoise) == 0x000008, "Wrong alignment on UVoxelNode_CraterNoise");
static_assert(sizeof(UVoxelNode_CraterNoise) == 0x0000E0, "Wrong size on UVoxelNode_CraterNoise");
static_assert(offsetof(UVoxelNode_CraterNoise, Jitter) == 0x0000D8, "Member 'UVoxelNode_CraterNoise::Jitter' has a wrong offset!");
static_assert(offsetof(UVoxelNode_CraterNoise, FalloffExponent) == 0x0000DC, "Member 'UVoxelNode_CraterNoise::FalloffExponent' has a wrong offset!");

// Class VoxelGraph.VoxelNode_2DCraterNoise
// 0x0000 (0x00E0 - 0x00E0)
class UVoxelNode_2DCraterNoise final : public UVoxelNode_CraterNoise
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DCraterNoise">();
	}
	static class UVoxelNode_2DCraterNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DCraterNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DCraterNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DCraterNoise");
static_assert(sizeof(UVoxelNode_2DCraterNoise) == 0x0000E0, "Wrong size on UVoxelNode_2DCraterNoise");

// Class VoxelGraph.VoxelNode_SingleGeneratorSamplerBase
// 0x0068 (0x01B8 - 0x0150)
class UVoxelNode_SingleGeneratorSamplerBase : public UVoxelNode_GeneratorSamplerBase
{
public:
	struct FVoxelGeneratorPicker                  Generator;                                         // 0x0150(0x0068)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SingleGeneratorSamplerBase">();
	}
	static class UVoxelNode_SingleGeneratorSamplerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SingleGeneratorSamplerBase>();
	}
};
static_assert(alignof(UVoxelNode_SingleGeneratorSamplerBase) == 0x000008, "Wrong alignment on UVoxelNode_SingleGeneratorSamplerBase");
static_assert(sizeof(UVoxelNode_SingleGeneratorSamplerBase) == 0x0001B8, "Wrong size on UVoxelNode_SingleGeneratorSamplerBase");
static_assert(offsetof(UVoxelNode_SingleGeneratorSamplerBase, Generator) == 0x000150, "Member 'UVoxelNode_SingleGeneratorSamplerBase::Generator' has a wrong offset!");

// Class VoxelGraph.VoxelNode_GetGeneratorValue
// 0x0000 (0x01B8 - 0x01B8)
class UVoxelNode_GetGeneratorValue final : public UVoxelNode_SingleGeneratorSamplerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetGeneratorValue">();
	}
	static class UVoxelNode_GetGeneratorValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetGeneratorValue>();
	}
};
static_assert(alignof(UVoxelNode_GetGeneratorValue) == 0x000008, "Wrong alignment on UVoxelNode_GetGeneratorValue");
static_assert(sizeof(UVoxelNode_GetGeneratorValue) == 0x0001B8, "Wrong size on UVoxelNode_GetGeneratorValue");

// Class VoxelGraph.VoxelNode_IQNoiseBase
// 0x0000 (0x0140 - 0x0140)
class UVoxelNode_IQNoiseBase : public UVoxelNode_NoiseNodeWithDerivativeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IQNoiseBase">();
	}
	static class UVoxelNode_IQNoiseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IQNoiseBase>();
	}
};
static_assert(alignof(UVoxelNode_IQNoiseBase) == 0x000008, "Wrong alignment on UVoxelNode_IQNoiseBase");
static_assert(sizeof(UVoxelNode_IQNoiseBase) == 0x000140, "Wrong size on UVoxelNode_IQNoiseBase");

// Class VoxelGraph.VoxelNode_2DIQNoiseBase
// 0x0008 (0x0148 - 0x0140)
class UVoxelNode_2DIQNoiseBase : public UVoxelNode_IQNoiseBase
{
public:
	float                                         Rotation;                                          // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DIQNoiseBase">();
	}
	static class UVoxelNode_2DIQNoiseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DIQNoiseBase>();
	}
};
static_assert(alignof(UVoxelNode_2DIQNoiseBase) == 0x000008, "Wrong alignment on UVoxelNode_2DIQNoiseBase");
static_assert(sizeof(UVoxelNode_2DIQNoiseBase) == 0x000148, "Wrong size on UVoxelNode_2DIQNoiseBase");
static_assert(offsetof(UVoxelNode_2DIQNoiseBase, Rotation) == 0x000140, "Member 'UVoxelNode_2DIQNoiseBase::Rotation' has a wrong offset!");

// Class VoxelGraph.VoxelNode_GetGeneratorMaterial
// 0x0000 (0x01B8 - 0x01B8)
class UVoxelNode_GetGeneratorMaterial final : public UVoxelNode_SingleGeneratorSamplerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetGeneratorMaterial">();
	}
	static class UVoxelNode_GetGeneratorMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetGeneratorMaterial>();
	}
};
static_assert(alignof(UVoxelNode_GetGeneratorMaterial) == 0x000008, "Wrong alignment on UVoxelNode_GetGeneratorMaterial");
static_assert(sizeof(UVoxelNode_GetGeneratorMaterial) == 0x0001B8, "Wrong size on UVoxelNode_GetGeneratorMaterial");

// Class VoxelGraph.VoxelNode_GetGeneratorCustomOutput
// 0x0008 (0x01C0 - 0x01B8)
class UVoxelNode_GetGeneratorCustomOutput final : public UVoxelNode_SingleGeneratorSamplerBase
{
public:
	class FName                                   OutputName;                                        // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetGeneratorCustomOutput">();
	}
	static class UVoxelNode_GetGeneratorCustomOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetGeneratorCustomOutput>();
	}
};
static_assert(alignof(UVoxelNode_GetGeneratorCustomOutput) == 0x000008, "Wrong alignment on UVoxelNode_GetGeneratorCustomOutput");
static_assert(sizeof(UVoxelNode_GetGeneratorCustomOutput) == 0x0001C0, "Wrong size on UVoxelNode_GetGeneratorCustomOutput");
static_assert(offsetof(UVoxelNode_GetGeneratorCustomOutput, OutputName) == 0x0001B8, "Member 'UVoxelNode_GetGeneratorCustomOutput::OutputName' has a wrong offset!");

// Class VoxelGraph.VoxelNode_3DCubicNoise
// 0x0000 (0x00D8 - 0x00D8)
class UVoxelNode_3DCubicNoise final : public UVoxelNode_NoiseNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DCubicNoise">();
	}
	static class UVoxelNode_3DCubicNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DCubicNoise>();
	}
};
static_assert(alignof(UVoxelNode_3DCubicNoise) == 0x000008, "Wrong alignment on UVoxelNode_3DCubicNoise");
static_assert(sizeof(UVoxelNode_3DCubicNoise) == 0x0000D8, "Wrong size on UVoxelNode_3DCubicNoise");

// Class VoxelGraph.VoxelNode_GetLandscapeCollectionIndex
// 0x0008 (0x0158 - 0x0150)
class UVoxelNode_GetLandscapeCollectionIndex final : public UVoxelExposedNode
{
public:
	class FName                                   LayerName;                                         // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetLandscapeCollectionIndex">();
	}
	static class UVoxelNode_GetLandscapeCollectionIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetLandscapeCollectionIndex>();
	}
};
static_assert(alignof(UVoxelNode_GetLandscapeCollectionIndex) == 0x000008, "Wrong alignment on UVoxelNode_GetLandscapeCollectionIndex");
static_assert(sizeof(UVoxelNode_GetLandscapeCollectionIndex) == 0x000158, "Wrong size on UVoxelNode_GetLandscapeCollectionIndex");
static_assert(offsetof(UVoxelNode_GetLandscapeCollectionIndex, LayerName) == 0x000150, "Member 'UVoxelNode_GetLandscapeCollectionIndex::LayerName' has a wrong offset!");

// Class VoxelGraph.VoxelNode_GetMaterialCollectionIndex
// 0x0008 (0x0158 - 0x0150)
class UVoxelNode_GetMaterialCollectionIndex final : public UVoxelAssetPickerNode
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetMaterialCollectionIndex">();
	}
	static class UVoxelNode_GetMaterialCollectionIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetMaterialCollectionIndex>();
	}
};
static_assert(alignof(UVoxelNode_GetMaterialCollectionIndex) == 0x000008, "Wrong alignment on UVoxelNode_GetMaterialCollectionIndex");
static_assert(sizeof(UVoxelNode_GetMaterialCollectionIndex) == 0x000158, "Wrong size on UVoxelNode_GetMaterialCollectionIndex");
static_assert(offsetof(UVoxelNode_GetMaterialCollectionIndex, Material) == 0x000150, "Member 'UVoxelNode_GetMaterialCollectionIndex::Material' has a wrong offset!");

// Class VoxelGraph.VoxelNode_GradientPerturb
// 0x0000 (0x00D8 - 0x00D8)
class UVoxelNode_GradientPerturb : public UVoxelNode_NoiseNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GradientPerturb">();
	}
	static class UVoxelNode_GradientPerturb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GradientPerturb>();
	}
};
static_assert(alignof(UVoxelNode_GradientPerturb) == 0x000008, "Wrong alignment on UVoxelNode_GradientPerturb");
static_assert(sizeof(UVoxelNode_GradientPerturb) == 0x0000D8, "Wrong size on UVoxelNode_GradientPerturb");

// Class VoxelGraph.VoxelNode_GradientPerturbFractal
// 0x0000 (0x0138 - 0x0138)
class UVoxelNode_GradientPerturbFractal : public UVoxelNode_NoiseNodeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GradientPerturbFractal">();
	}
	static class UVoxelNode_GradientPerturbFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GradientPerturbFractal>();
	}
};
static_assert(alignof(UVoxelNode_GradientPerturbFractal) == 0x000008, "Wrong alignment on UVoxelNode_GradientPerturbFractal");
static_assert(sizeof(UVoxelNode_GradientPerturbFractal) == 0x000138, "Wrong size on UVoxelNode_GradientPerturbFractal");

// Class VoxelGraph.VoxelNode_IsSingleBool
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IsSingleBool final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IsSingleBool">();
	}
	static class UVoxelNode_IsSingleBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IsSingleBool>();
	}
};
static_assert(alignof(UVoxelNode_IsSingleBool) == 0x000008, "Wrong alignment on UVoxelNode_IsSingleBool");
static_assert(sizeof(UVoxelNode_IsSingleBool) == 0x000098, "Wrong size on UVoxelNode_IsSingleBool");

// Class VoxelGraph.VoxelNode_2DGradientPerturb
// 0x0000 (0x00D8 - 0x00D8)
class UVoxelNode_2DGradientPerturb final : public UVoxelNode_GradientPerturb
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DGradientPerturb">();
	}
	static class UVoxelNode_2DGradientPerturb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DGradientPerturb>();
	}
};
static_assert(alignof(UVoxelNode_2DGradientPerturb) == 0x000008, "Wrong alignment on UVoxelNode_2DGradientPerturb");
static_assert(sizeof(UVoxelNode_2DGradientPerturb) == 0x0000D8, "Wrong size on UVoxelNode_2DGradientPerturb");

// Class VoxelGraph.VoxelNode_2DGradientPerturbFractal
// 0x0000 (0x0138 - 0x0138)
class UVoxelNode_2DGradientPerturbFractal final : public UVoxelNode_GradientPerturbFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DGradientPerturbFractal">();
	}
	static class UVoxelNode_2DGradientPerturbFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DGradientPerturbFractal>();
	}
};
static_assert(alignof(UVoxelNode_2DGradientPerturbFractal) == 0x000008, "Wrong alignment on UVoxelNode_2DGradientPerturbFractal");
static_assert(sizeof(UVoxelNode_2DGradientPerturbFractal) == 0x000138, "Wrong size on UVoxelNode_2DGradientPerturbFractal");

// Class VoxelGraph.VoxelNode_CraterNoiseFractal
// 0x0008 (0x0140 - 0x0138)
class UVoxelNode_CraterNoiseFractal : public UVoxelNode_NoiseNodeFractal
{
public:
	float                                         Jitter;                                            // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FalloffExponent;                                   // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CraterNoiseFractal">();
	}
	static class UVoxelNode_CraterNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CraterNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_CraterNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_CraterNoiseFractal");
static_assert(sizeof(UVoxelNode_CraterNoiseFractal) == 0x000140, "Wrong size on UVoxelNode_CraterNoiseFractal");
static_assert(offsetof(UVoxelNode_CraterNoiseFractal, Jitter) == 0x000138, "Member 'UVoxelNode_CraterNoiseFractal::Jitter' has a wrong offset!");
static_assert(offsetof(UVoxelNode_CraterNoiseFractal, FalloffExponent) == 0x00013C, "Member 'UVoxelNode_CraterNoiseFractal::FalloffExponent' has a wrong offset!");

// Class VoxelGraph.VoxelNode_2DCraterNoiseFractal
// 0x0000 (0x0140 - 0x0140)
class UVoxelNode_2DCraterNoiseFractal final : public UVoxelNode_CraterNoiseFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DCraterNoiseFractal">();
	}
	static class UVoxelNode_2DCraterNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DCraterNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_2DCraterNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_2DCraterNoiseFractal");
static_assert(sizeof(UVoxelNode_2DCraterNoiseFractal) == 0x000140, "Wrong size on UVoxelNode_2DCraterNoiseFractal");

// Class VoxelGraph.VoxelNode_3DGradientPerturb
// 0x0000 (0x00D8 - 0x00D8)
class UVoxelNode_3DGradientPerturb final : public UVoxelNode_GradientPerturb
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DGradientPerturb">();
	}
	static class UVoxelNode_3DGradientPerturb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DGradientPerturb>();
	}
};
static_assert(alignof(UVoxelNode_3DGradientPerturb) == 0x000008, "Wrong alignment on UVoxelNode_3DGradientPerturb");
static_assert(sizeof(UVoxelNode_3DGradientPerturb) == 0x0000D8, "Wrong size on UVoxelNode_3DGradientPerturb");

// Class VoxelGraph.VoxelNode_3DGradientPerturbFractal
// 0x0000 (0x0138 - 0x0138)
class UVoxelNode_3DGradientPerturbFractal final : public UVoxelNode_GradientPerturbFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DGradientPerturbFractal">();
	}
	static class UVoxelNode_3DGradientPerturbFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DGradientPerturbFractal>();
	}
};
static_assert(alignof(UVoxelNode_3DGradientPerturbFractal) == 0x000008, "Wrong alignment on UVoxelNode_3DGradientPerturbFractal");
static_assert(sizeof(UVoxelNode_3DGradientPerturbFractal) == 0x000138, "Wrong size on UVoxelNode_3DGradientPerturbFractal");

// Class VoxelGraph.VoxelNode_3DIQNoiseBase
// 0x0010 (0x0150 - 0x0140)
class UVoxelNode_3DIQNoiseBase : public UVoxelNode_IQNoiseBase
{
public:
	struct FRotator                               Rotation;                                          // 0x0140(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DIQNoiseBase">();
	}
	static class UVoxelNode_3DIQNoiseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DIQNoiseBase>();
	}
};
static_assert(alignof(UVoxelNode_3DIQNoiseBase) == 0x000008, "Wrong alignment on UVoxelNode_3DIQNoiseBase");
static_assert(sizeof(UVoxelNode_3DIQNoiseBase) == 0x000150, "Wrong size on UVoxelNode_3DIQNoiseBase");
static_assert(offsetof(UVoxelNode_3DIQNoiseBase, Rotation) == 0x000140, "Member 'UVoxelNode_3DIQNoiseBase::Rotation' has a wrong offset!");

// Class VoxelGraph.VoxelGraphAssetNode
// 0x0068 (0x0100 - 0x0098)
class UVoxelGraphAssetNode : public UVoxelNodeWithContext
{
public:
	struct FVoxelGeneratorPicker                  DefaultGenerator;                                  // 0x0098(0x0068)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphAssetNode">();
	}
	static class UVoxelGraphAssetNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphAssetNode>();
	}
};
static_assert(alignof(UVoxelGraphAssetNode) == 0x000008, "Wrong alignment on UVoxelGraphAssetNode");
static_assert(sizeof(UVoxelGraphAssetNode) == 0x000100, "Wrong size on UVoxelGraphAssetNode");
static_assert(offsetof(UVoxelGraphAssetNode, DefaultGenerator) == 0x000098, "Member 'UVoxelGraphAssetNode::DefaultGenerator' has a wrong offset!");

// Class VoxelGraph.VoxelNode_EditGetValue
// 0x0000 (0x0100 - 0x0100)
class UVoxelNode_EditGetValue final : public UVoxelGraphAssetNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_EditGetValue">();
	}
	static class UVoxelNode_EditGetValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_EditGetValue>();
	}
};
static_assert(alignof(UVoxelNode_EditGetValue) == 0x000008, "Wrong alignment on UVoxelNode_EditGetValue");
static_assert(sizeof(UVoxelNode_EditGetValue) == 0x000100, "Wrong size on UVoxelNode_EditGetValue");

// Class VoxelGraph.VoxelNode_EditGetMaterial
// 0x0000 (0x0100 - 0x0100)
class UVoxelNode_EditGetMaterial final : public UVoxelGraphAssetNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_EditGetMaterial">();
	}
	static class UVoxelNode_EditGetMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_EditGetMaterial>();
	}
};
static_assert(alignof(UVoxelNode_EditGetMaterial) == 0x000008, "Wrong alignment on UVoxelNode_EditGetMaterial");
static_assert(sizeof(UVoxelNode_EditGetMaterial) == 0x000100, "Wrong size on UVoxelNode_EditGetMaterial");

// Class VoxelGraph.VoxelNode_EditGetCustomOutput
// 0x0008 (0x0108 - 0x0100)
class UVoxelNode_EditGetCustomOutput final : public UVoxelGraphAssetNode
{
public:
	class FName                                   OutputName;                                        // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_EditGetCustomOutput">();
	}
	static class UVoxelNode_EditGetCustomOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_EditGetCustomOutput>();
	}
};
static_assert(alignof(UVoxelNode_EditGetCustomOutput) == 0x000008, "Wrong alignment on UVoxelNode_EditGetCustomOutput");
static_assert(sizeof(UVoxelNode_EditGetCustomOutput) == 0x000108, "Wrong size on UVoxelNode_EditGetCustomOutput");
static_assert(offsetof(UVoxelNode_EditGetCustomOutput, OutputName) == 0x000100, "Member 'UVoxelNode_EditGetCustomOutput::OutputName' has a wrong offset!");

// Class VoxelGraph.VoxelNode_EditGetHardness
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_EditGetHardness final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_EditGetHardness">();
	}
	static class UVoxelNode_EditGetHardness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_EditGetHardness>();
	}
};
static_assert(alignof(UVoxelNode_EditGetHardness) == 0x000008, "Wrong alignment on UVoxelNode_EditGetHardness");
static_assert(sizeof(UVoxelNode_EditGetHardness) == 0x000098, "Wrong size on UVoxelNode_EditGetHardness");

// Class VoxelGraph.VoxelGraphDataItemConfig
// 0x0010 (0x0038 - 0x0028)
class UVoxelGraphDataItemConfig final : public UObject
{
public:
	TArray<class FName>                           Parameters;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphDataItemConfig">();
	}
	static class UVoxelGraphDataItemConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphDataItemConfig>();
	}
};
static_assert(alignof(UVoxelGraphDataItemConfig) == 0x000008, "Wrong alignment on UVoxelGraphDataItemConfig");
static_assert(sizeof(UVoxelGraphDataItemConfig) == 0x000038, "Wrong size on UVoxelGraphDataItemConfig");
static_assert(offsetof(UVoxelGraphDataItemConfig, Parameters) == 0x000028, "Member 'UVoxelGraphDataItemConfig::Parameters' has a wrong offset!");

// Class VoxelGraph.VoxelGraphGenerator
// 0x0118 (0x0140 - 0x0028)
class UVoxelGraphGenerator : public UVoxelTransformableGenerator
{
public:
	class UVoxelGraphOutputsConfig*               Outputs;                                           // 0x0028(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVoxelGraphOutput>              CustomOutputs;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bAutomaticPreview;                                 // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFlowMergeAndFunctionsWarnings;                // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCppClassInsteadOfGraph;                        // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GeneratedCppClass;                                 // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompileToCppOnSave;                               // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFilePath                              SaveLocation;                                      // 0x0078(0x0010)(Edit, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bBuiltinPluginGenerator;                           // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRangeAnalysis;                              // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebugGraph;                                 // 0x008A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFunctions;                                    // 0x008B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetailedErrors;                                   // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPinsIds;                                      // 0x008D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAxisDependencies;                             // 0x008E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelGraphGeneratorDebugLevel                DebugLevel;                                        // 0x008F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TargetToDebug;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FunctionToDebug;                                   // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelFunctionAxisDependencies                AxisDependenciesToDebug;                           // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NodesDepthScaleFactor;                             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideDataNodes;                                    // 0x00AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVoxelNode*>                     AllNodes;                                          // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UVoxelNode*>                     DebugNodes;                                        // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UVoxelNode*                             FirstNode;                                         // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  FirstNodePinId;                                    // 0x00D8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelGraphPreviewSettings*             PreviewSettings;                                   // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x50];                                      // 0x00F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphGenerator">();
	}
	static class UVoxelGraphGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphGenerator>();
	}
};
static_assert(alignof(UVoxelGraphGenerator) == 0x000008, "Wrong alignment on UVoxelGraphGenerator");
static_assert(sizeof(UVoxelGraphGenerator) == 0x000140, "Wrong size on UVoxelGraphGenerator");
static_assert(offsetof(UVoxelGraphGenerator, Outputs) == 0x000028, "Member 'UVoxelGraphGenerator::Outputs' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, CustomOutputs) == 0x000030, "Member 'UVoxelGraphGenerator::CustomOutputs' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bAutomaticPreview) == 0x000040, "Member 'UVoxelGraphGenerator::bAutomaticPreview' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bShowFlowMergeAndFunctionsWarnings) == 0x000041, "Member 'UVoxelGraphGenerator::bShowFlowMergeAndFunctionsWarnings' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bUseCppClassInsteadOfGraph) == 0x000042, "Member 'UVoxelGraphGenerator::bUseCppClassInsteadOfGraph' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, GeneratedCppClass) == 0x000048, "Member 'UVoxelGraphGenerator::GeneratedCppClass' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bCompileToCppOnSave) == 0x000070, "Member 'UVoxelGraphGenerator::bCompileToCppOnSave' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, SaveLocation) == 0x000078, "Member 'UVoxelGraphGenerator::SaveLocation' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bBuiltinPluginGenerator) == 0x000088, "Member 'UVoxelGraphGenerator::bBuiltinPluginGenerator' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bEnableRangeAnalysis) == 0x000089, "Member 'UVoxelGraphGenerator::bEnableRangeAnalysis' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bEnableDebugGraph) == 0x00008A, "Member 'UVoxelGraphGenerator::bEnableDebugGraph' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bShowFunctions) == 0x00008B, "Member 'UVoxelGraphGenerator::bShowFunctions' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bDetailedErrors) == 0x00008C, "Member 'UVoxelGraphGenerator::bDetailedErrors' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bShowPinsIds) == 0x00008D, "Member 'UVoxelGraphGenerator::bShowPinsIds' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bShowAxisDependencies) == 0x00008E, "Member 'UVoxelGraphGenerator::bShowAxisDependencies' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, DebugLevel) == 0x00008F, "Member 'UVoxelGraphGenerator::DebugLevel' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, TargetToDebug) == 0x000090, "Member 'UVoxelGraphGenerator::TargetToDebug' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, FunctionToDebug) == 0x0000A0, "Member 'UVoxelGraphGenerator::FunctionToDebug' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, AxisDependenciesToDebug) == 0x0000A4, "Member 'UVoxelGraphGenerator::AxisDependenciesToDebug' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, NodesDepthScaleFactor) == 0x0000A8, "Member 'UVoxelGraphGenerator::NodesDepthScaleFactor' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, bHideDataNodes) == 0x0000AC, "Member 'UVoxelGraphGenerator::bHideDataNodes' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, AllNodes) == 0x0000B0, "Member 'UVoxelGraphGenerator::AllNodes' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, DebugNodes) == 0x0000C0, "Member 'UVoxelGraphGenerator::DebugNodes' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, FirstNode) == 0x0000D0, "Member 'UVoxelGraphGenerator::FirstNode' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, FirstNodePinId) == 0x0000D8, "Member 'UVoxelGraphGenerator::FirstNodePinId' has a wrong offset!");
static_assert(offsetof(UVoxelGraphGenerator, PreviewSettings) == 0x0000E8, "Member 'UVoxelGraphGenerator::PreviewSettings' has a wrong offset!");

// Class VoxelGraph.VoxelGraphMacroInputNode
// 0x0000 (0x0070 - 0x0070)
class UVoxelGraphMacroInputNode final : public UVoxelGraphMacroInputOutputNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphMacroInputNode">();
	}
	static class UVoxelGraphMacroInputNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphMacroInputNode>();
	}
};
static_assert(alignof(UVoxelGraphMacroInputNode) == 0x000008, "Wrong alignment on UVoxelGraphMacroInputNode");
static_assert(sizeof(UVoxelGraphMacroInputNode) == 0x000070, "Wrong size on UVoxelGraphMacroInputNode");

// Class VoxelGraph.VoxelGraphMacro
// 0x0058 (0x0198 - 0x0140)
class UVoxelGraphMacro final : public UVoxelGraphGenerator
{
public:
	class FString                                 Tooltip;                                           // 0x0140(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Keywords;                                          // 0x0150(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomCategory;                                    // 0x0160(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomName;                                        // 0x0170(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInContextMenu;                                // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVectorOnlyNode;                                   // 0x0181(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182[0x6];                                      // 0x0182(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelGraphMacroInputNode*              InputNode;                                         // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelGraphMacroOutputNode*             OutputNode;                                        // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphMacro">();
	}
	static class UVoxelGraphMacro* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphMacro>();
	}
};
static_assert(alignof(UVoxelGraphMacro) == 0x000008, "Wrong alignment on UVoxelGraphMacro");
static_assert(sizeof(UVoxelGraphMacro) == 0x000198, "Wrong size on UVoxelGraphMacro");
static_assert(offsetof(UVoxelGraphMacro, Tooltip) == 0x000140, "Member 'UVoxelGraphMacro::Tooltip' has a wrong offset!");
static_assert(offsetof(UVoxelGraphMacro, Keywords) == 0x000150, "Member 'UVoxelGraphMacro::Keywords' has a wrong offset!");
static_assert(offsetof(UVoxelGraphMacro, CustomCategory) == 0x000160, "Member 'UVoxelGraphMacro::CustomCategory' has a wrong offset!");
static_assert(offsetof(UVoxelGraphMacro, CustomName) == 0x000170, "Member 'UVoxelGraphMacro::CustomName' has a wrong offset!");
static_assert(offsetof(UVoxelGraphMacro, bShowInContextMenu) == 0x000180, "Member 'UVoxelGraphMacro::bShowInContextMenu' has a wrong offset!");
static_assert(offsetof(UVoxelGraphMacro, bVectorOnlyNode) == 0x000181, "Member 'UVoxelGraphMacro::bVectorOnlyNode' has a wrong offset!");
static_assert(offsetof(UVoxelGraphMacro, InputNode) == 0x000188, "Member 'UVoxelGraphMacro::InputNode' has a wrong offset!");
static_assert(offsetof(UVoxelGraphMacro, OutputNode) == 0x000190, "Member 'UVoxelGraphMacro::OutputNode' has a wrong offset!");

// Class VoxelGraph.VoxelGraphMacroNode
// 0x0008 (0x0060 - 0x0058)
class UVoxelGraphMacroNode final : public UVoxelNode
{
public:
	class UVoxelGraphMacro*                       Macro;                                             // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphMacroNode">();
	}
	static class UVoxelGraphMacroNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphMacroNode>();
	}
};
static_assert(alignof(UVoxelGraphMacroNode) == 0x000008, "Wrong alignment on UVoxelGraphMacroNode");
static_assert(sizeof(UVoxelGraphMacroNode) == 0x000060, "Wrong size on UVoxelGraphMacroNode");
static_assert(offsetof(UVoxelGraphMacroNode, Macro) == 0x000058, "Member 'UVoxelGraphMacroNode::Macro' has a wrong offset!");

// Class VoxelGraph.VoxelGraphOutputsConfig
// 0x0010 (0x0038 - 0x0028)
class UVoxelGraphOutputsConfig final : public UObject
{
public:
	TArray<struct FVoxelGraphOutput>              Outputs;                                           // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphOutputsConfig">();
	}
	static class UVoxelGraphOutputsConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphOutputsConfig>();
	}
};
static_assert(alignof(UVoxelGraphOutputsConfig) == 0x000008, "Wrong alignment on UVoxelGraphOutputsConfig");
static_assert(sizeof(UVoxelGraphOutputsConfig) == 0x000038, "Wrong size on UVoxelGraphOutputsConfig");
static_assert(offsetof(UVoxelGraphOutputsConfig, Outputs) == 0x000028, "Member 'UVoxelGraphOutputsConfig::Outputs' has a wrong offset!");

// Class VoxelGraph.VoxelGraphPreviewSettings
// 0x00F0 (0x0118 - 0x0028)
class UVoxelGraphPreviewSettings final : public UObject
{
public:
	bool                                          bShowStats;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowValues;                                       // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MinValue;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MaxValue;                                          // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoxelIntBox                           PreviewedBounds;                                   // 0x0050(0x0018)(Edit, EditConst, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelGraphPreviewAxes                        LeftToRight;                                       // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelGraphPreviewAxes                        BottomToTop;                                       // 0x0069(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Resolution;                                        // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResolutionMultiplierLog;                           // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Center;                                            // 0x0074(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             PreviewedVoxel;                                    // 0x0080(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelGraphPreviewShowValue                   ShowValue;                                         // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelMaterialConfig                          MaterialConfig;                                    // 0x008D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelMaterialCollectionBase*           MaterialCollection;                                // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelPlaceableItemManager*             PlaceableItemManager;                              // 0x0098(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelSize;                                         // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelRenderType                              RenderType;                                        // 0x00A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelGraphPreviewType                        PreviewType2D;                                     // 0x00A5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawColoredDistanceField;                         // 0x00A6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelGraphMaterialPreviewType                MaterialPreviewType;                               // 0x00A7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MultiIndexToPreview;                               // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         IndexColors;                                       // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHybridMaterialRendering;                          // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CostPercentile;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumRangeAnalysisChunksPerAxis;                     // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeightmapMode;                                    // 0x00CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeightBasedColor;                                 // 0x00CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWater;                                      // 0x00CE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF[0x1];                                       // 0x00CF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Height;                                            // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LightDirection;                                    // 0x00D4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartBias;                                         // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSteps;                                          // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowDensity;                                     // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mesh;                                              // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     HeightmapMaterial;                                 // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SliceMaterial;                                     // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoNormalize;                                    // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NormalizeMinValue;                                 // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalizeMaxValue;                                 // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LODToPreview;                                      // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphPreviewSettings">();
	}
	static class UVoxelGraphPreviewSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphPreviewSettings>();
	}
};
static_assert(alignof(UVoxelGraphPreviewSettings) == 0x000008, "Wrong alignment on UVoxelGraphPreviewSettings");
static_assert(sizeof(UVoxelGraphPreviewSettings) == 0x000118, "Wrong size on UVoxelGraphPreviewSettings");
static_assert(offsetof(UVoxelGraphPreviewSettings, bShowStats) == 0x000028, "Member 'UVoxelGraphPreviewSettings::bShowStats' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, bShowValues) == 0x000029, "Member 'UVoxelGraphPreviewSettings::bShowValues' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, MinValue) == 0x000030, "Member 'UVoxelGraphPreviewSettings::MinValue' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, MaxValue) == 0x000040, "Member 'UVoxelGraphPreviewSettings::MaxValue' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, PreviewedBounds) == 0x000050, "Member 'UVoxelGraphPreviewSettings::PreviewedBounds' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, LeftToRight) == 0x000068, "Member 'UVoxelGraphPreviewSettings::LeftToRight' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, BottomToTop) == 0x000069, "Member 'UVoxelGraphPreviewSettings::BottomToTop' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, Resolution) == 0x00006C, "Member 'UVoxelGraphPreviewSettings::Resolution' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, ResolutionMultiplierLog) == 0x000070, "Member 'UVoxelGraphPreviewSettings::ResolutionMultiplierLog' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, Center) == 0x000074, "Member 'UVoxelGraphPreviewSettings::Center' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, PreviewedVoxel) == 0x000080, "Member 'UVoxelGraphPreviewSettings::PreviewedVoxel' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, ShowValue) == 0x00008C, "Member 'UVoxelGraphPreviewSettings::ShowValue' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, MaterialConfig) == 0x00008D, "Member 'UVoxelGraphPreviewSettings::MaterialConfig' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, MaterialCollection) == 0x000090, "Member 'UVoxelGraphPreviewSettings::MaterialCollection' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, PlaceableItemManager) == 0x000098, "Member 'UVoxelGraphPreviewSettings::PlaceableItemManager' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, VoxelSize) == 0x0000A0, "Member 'UVoxelGraphPreviewSettings::VoxelSize' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, RenderType) == 0x0000A4, "Member 'UVoxelGraphPreviewSettings::RenderType' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, PreviewType2D) == 0x0000A5, "Member 'UVoxelGraphPreviewSettings::PreviewType2D' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, bDrawColoredDistanceField) == 0x0000A6, "Member 'UVoxelGraphPreviewSettings::bDrawColoredDistanceField' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, MaterialPreviewType) == 0x0000A7, "Member 'UVoxelGraphPreviewSettings::MaterialPreviewType' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, MultiIndexToPreview) == 0x0000A8, "Member 'UVoxelGraphPreviewSettings::MultiIndexToPreview' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, IndexColors) == 0x0000B0, "Member 'UVoxelGraphPreviewSettings::IndexColors' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, bHybridMaterialRendering) == 0x0000C0, "Member 'UVoxelGraphPreviewSettings::bHybridMaterialRendering' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, CostPercentile) == 0x0000C4, "Member 'UVoxelGraphPreviewSettings::CostPercentile' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, NumRangeAnalysisChunksPerAxis) == 0x0000C8, "Member 'UVoxelGraphPreviewSettings::NumRangeAnalysisChunksPerAxis' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, bHeightmapMode) == 0x0000CC, "Member 'UVoxelGraphPreviewSettings::bHeightmapMode' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, bHeightBasedColor) == 0x0000CD, "Member 'UVoxelGraphPreviewSettings::bHeightBasedColor' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, bEnableWater) == 0x0000CE, "Member 'UVoxelGraphPreviewSettings::bEnableWater' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, Height) == 0x0000D0, "Member 'UVoxelGraphPreviewSettings::Height' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, LightDirection) == 0x0000D4, "Member 'UVoxelGraphPreviewSettings::LightDirection' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, StartBias) == 0x0000E0, "Member 'UVoxelGraphPreviewSettings::StartBias' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, MaxSteps) == 0x0000E4, "Member 'UVoxelGraphPreviewSettings::MaxSteps' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, Brightness) == 0x0000E8, "Member 'UVoxelGraphPreviewSettings::Brightness' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, ShadowDensity) == 0x0000EC, "Member 'UVoxelGraphPreviewSettings::ShadowDensity' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, Mesh) == 0x0000F0, "Member 'UVoxelGraphPreviewSettings::Mesh' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, HeightmapMaterial) == 0x0000F8, "Member 'UVoxelGraphPreviewSettings::HeightmapMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, SliceMaterial) == 0x000100, "Member 'UVoxelGraphPreviewSettings::SliceMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, bAutoNormalize) == 0x000108, "Member 'UVoxelGraphPreviewSettings::bAutoNormalize' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, NormalizeMinValue) == 0x00010C, "Member 'UVoxelGraphPreviewSettings::NormalizeMinValue' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, NormalizeMaxValue) == 0x000110, "Member 'UVoxelGraphPreviewSettings::NormalizeMaxValue' has a wrong offset!");
static_assert(offsetof(UVoxelGraphPreviewSettings, LODToPreview) == 0x000114, "Member 'UVoxelGraphPreviewSettings::LODToPreview' has a wrong offset!");

// Class VoxelGraph.VoxelNode_HeightmapSampler
// 0x0020 (0x0170 - 0x0150)
class UVoxelNode_HeightmapSampler final : public UVoxelExposedNode
{
public:
	bool                                          bFloatHeightmap;                                   // 0x0150(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelHeightmapAssetFloat*              HeightmapFloat;                                    // 0x0158(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelHeightmapAssetUINT16*             HeightmapUINT16;                                   // 0x0160(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelSamplerMode                             SamplerType;                                       // 0x0168(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenter;                                           // 0x0169(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_HeightmapSampler">();
	}
	static class UVoxelNode_HeightmapSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_HeightmapSampler>();
	}
};
static_assert(alignof(UVoxelNode_HeightmapSampler) == 0x000008, "Wrong alignment on UVoxelNode_HeightmapSampler");
static_assert(sizeof(UVoxelNode_HeightmapSampler) == 0x000170, "Wrong size on UVoxelNode_HeightmapSampler");
static_assert(offsetof(UVoxelNode_HeightmapSampler, bFloatHeightmap) == 0x000150, "Member 'UVoxelNode_HeightmapSampler::bFloatHeightmap' has a wrong offset!");
static_assert(offsetof(UVoxelNode_HeightmapSampler, HeightmapFloat) == 0x000158, "Member 'UVoxelNode_HeightmapSampler::HeightmapFloat' has a wrong offset!");
static_assert(offsetof(UVoxelNode_HeightmapSampler, HeightmapUINT16) == 0x000160, "Member 'UVoxelNode_HeightmapSampler::HeightmapUINT16' has a wrong offset!");
static_assert(offsetof(UVoxelNode_HeightmapSampler, SamplerType) == 0x000168, "Member 'UVoxelNode_HeightmapSampler::SamplerType' has a wrong offset!");
static_assert(offsetof(UVoxelNode_HeightmapSampler, bCenter) == 0x000169, "Member 'UVoxelNode_HeightmapSampler::bCenter' has a wrong offset!");

// Class VoxelGraph.VoxelNode_IfWithDefaultToTrue
// 0x0000 (0x00A0 - 0x00A0)
class UVoxelNode_IfWithDefaultToTrue final : public UVoxelNode_If
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IfWithDefaultToTrue">();
	}
	static class UVoxelNode_IfWithDefaultToTrue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IfWithDefaultToTrue>();
	}
};
static_assert(alignof(UVoxelNode_IfWithDefaultToTrue) == 0x000008, "Wrong alignment on UVoxelNode_IfWithDefaultToTrue");
static_assert(sizeof(UVoxelNode_IfWithDefaultToTrue) == 0x0000A0, "Wrong size on UVoxelNode_IfWithDefaultToTrue");

// Class VoxelGraph.VoxelLocalVariableDeclaration
// 0x0020 (0x0078 - 0x0058)
class UVoxelLocalVariableDeclaration final : public UVoxelLocalVariableBase
{
public:
	class FName                                   Name_0;                                            // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelPortalNodePinCategory                   Category;                                          // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  VariableGuid;                                      // 0x0064(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLocalVariableDeclaration">();
	}
	static class UVoxelLocalVariableDeclaration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelLocalVariableDeclaration>();
	}
};
static_assert(alignof(UVoxelLocalVariableDeclaration) == 0x000008, "Wrong alignment on UVoxelLocalVariableDeclaration");
static_assert(sizeof(UVoxelLocalVariableDeclaration) == 0x000078, "Wrong size on UVoxelLocalVariableDeclaration");
static_assert(offsetof(UVoxelLocalVariableDeclaration, Name_0) == 0x000058, "Member 'UVoxelLocalVariableDeclaration::Name_0' has a wrong offset!");
static_assert(offsetof(UVoxelLocalVariableDeclaration, Category) == 0x000060, "Member 'UVoxelLocalVariableDeclaration::Category' has a wrong offset!");
static_assert(offsetof(UVoxelLocalVariableDeclaration, VariableGuid) == 0x000064, "Member 'UVoxelLocalVariableDeclaration::VariableGuid' has a wrong offset!");

// Class VoxelGraph.VoxelLocalVariableUsage
// 0x0020 (0x0078 - 0x0058)
class UVoxelLocalVariableUsage final : public UVoxelLocalVariableBase
{
public:
	struct FVoxelPortalNodeSelector               Selector;                                          // 0x0058(0x0008)(Deprecated, NoDestructor, NativeAccessSpecifierPublic)
	class UVoxelLocalVariableDeclaration*         Declaration;                                       // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  DeclarationGuid;                                   // 0x0068(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLocalVariableUsage">();
	}
	static class UVoxelLocalVariableUsage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelLocalVariableUsage>();
	}
};
static_assert(alignof(UVoxelLocalVariableUsage) == 0x000008, "Wrong alignment on UVoxelLocalVariableUsage");
static_assert(sizeof(UVoxelLocalVariableUsage) == 0x000078, "Wrong size on UVoxelLocalVariableUsage");
static_assert(offsetof(UVoxelLocalVariableUsage, Selector) == 0x000058, "Member 'UVoxelLocalVariableUsage::Selector' has a wrong offset!");
static_assert(offsetof(UVoxelLocalVariableUsage, Declaration) == 0x000060, "Member 'UVoxelLocalVariableUsage::Declaration' has a wrong offset!");
static_assert(offsetof(UVoxelLocalVariableUsage, DeclarationGuid) == 0x000068, "Member 'UVoxelLocalVariableUsage::DeclarationGuid' has a wrong offset!");

// Class VoxelGraph.VoxelNode_GetColor
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GetColor final : public UVoxelMaterialNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetColor">();
	}
	static class UVoxelNode_GetColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetColor>();
	}
};
static_assert(alignof(UVoxelNode_GetColor) == 0x000008, "Wrong alignment on UVoxelNode_GetColor");
static_assert(sizeof(UVoxelNode_GetColor) == 0x000098, "Wrong size on UVoxelNode_GetColor");

// Class VoxelGraph.VoxelNode_GetUVChannel
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GetUVChannel final : public UVoxelMaterialNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetUVChannel">();
	}
	static class UVoxelNode_GetUVChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetUVChannel>();
	}
};
static_assert(alignof(UVoxelNode_GetUVChannel) == 0x000008, "Wrong alignment on UVoxelNode_GetUVChannel");
static_assert(sizeof(UVoxelNode_GetUVChannel) == 0x000098, "Wrong size on UVoxelNode_GetUVChannel");

// Class VoxelGraph.VoxelNode_FMin
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FMin final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FMin">();
	}
	static class UVoxelNode_FMin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FMin>();
	}
};
static_assert(alignof(UVoxelNode_FMin) == 0x000008, "Wrong alignment on UVoxelNode_FMin");
static_assert(sizeof(UVoxelNode_FMin) == 0x000098, "Wrong size on UVoxelNode_FMin");

// Class VoxelGraph.VoxelNode_IMin
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IMin final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IMin">();
	}
	static class UVoxelNode_IMin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IMin>();
	}
};
static_assert(alignof(UVoxelNode_IMin) == 0x000008, "Wrong alignment on UVoxelNode_IMin");
static_assert(sizeof(UVoxelNode_IMin) == 0x000098, "Wrong size on UVoxelNode_IMin");

// Class VoxelGraph.VoxelNode_FMultiply
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FMultiply final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FMultiply">();
	}
	static class UVoxelNode_FMultiply* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FMultiply>();
	}
};
static_assert(alignof(UVoxelNode_FMultiply) == 0x000008, "Wrong alignment on UVoxelNode_FMultiply");
static_assert(sizeof(UVoxelNode_FMultiply) == 0x000098, "Wrong size on UVoxelNode_FMultiply");

// Class VoxelGraph.VoxelNode_FDivide
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FDivide final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FDivide">();
	}
	static class UVoxelNode_FDivide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FDivide>();
	}
};
static_assert(alignof(UVoxelNode_FDivide) == 0x000008, "Wrong alignment on UVoxelNode_FDivide");
static_assert(sizeof(UVoxelNode_FDivide) == 0x000098, "Wrong size on UVoxelNode_FDivide");

// Class VoxelGraph.VoxelNode_IMultiply
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IMultiply final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IMultiply">();
	}
	static class UVoxelNode_IMultiply* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IMultiply>();
	}
};
static_assert(alignof(UVoxelNode_IMultiply) == 0x000008, "Wrong alignment on UVoxelNode_IMultiply");
static_assert(sizeof(UVoxelNode_IMultiply) == 0x000098, "Wrong size on UVoxelNode_IMultiply");

// Class VoxelGraph.VoxelNode_IDivide
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IDivide final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IDivide">();
	}
	static class UVoxelNode_IDivide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IDivide>();
	}
};
static_assert(alignof(UVoxelNode_IDivide) == 0x000008, "Wrong alignment on UVoxelNode_IDivide");
static_assert(sizeof(UVoxelNode_IDivide) == 0x000098, "Wrong size on UVoxelNode_IDivide");

// Class VoxelGraph.VoxelNode_IRightBitShift
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IRightBitShift final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IRightBitShift">();
	}
	static class UVoxelNode_IRightBitShift* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IRightBitShift>();
	}
};
static_assert(alignof(UVoxelNode_IRightBitShift) == 0x000008, "Wrong alignment on UVoxelNode_IRightBitShift");
static_assert(sizeof(UVoxelNode_IRightBitShift) == 0x000098, "Wrong size on UVoxelNode_IRightBitShift");

// Class VoxelGraph.VoxelNode_Round
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Round final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Round">();
	}
	static class UVoxelNode_Round* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Round>();
	}
};
static_assert(alignof(UVoxelNode_Round) == 0x000008, "Wrong alignment on UVoxelNode_Round");
static_assert(sizeof(UVoxelNode_Round) == 0x000098, "Wrong size on UVoxelNode_Round");

// Class VoxelGraph.VoxelNode_SafeLerp
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SafeLerp final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SafeLerp">();
	}
	static class UVoxelNode_SafeLerp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SafeLerp>();
	}
};
static_assert(alignof(UVoxelNode_SafeLerp) == 0x000008, "Wrong alignment on UVoxelNode_SafeLerp");
static_assert(sizeof(UVoxelNode_SafeLerp) == 0x000098, "Wrong size on UVoxelNode_SafeLerp");

// Class VoxelGraph.VoxelNode_Clamp
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Clamp final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Clamp">();
	}
	static class UVoxelNode_Clamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Clamp>();
	}
};
static_assert(alignof(UVoxelNode_Clamp) == 0x000008, "Wrong alignment on UVoxelNode_Clamp");
static_assert(sizeof(UVoxelNode_Clamp) == 0x000098, "Wrong size on UVoxelNode_Clamp");

// Class VoxelGraph.VoxelNode_BOr
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_BOr final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BOr">();
	}
	static class UVoxelNode_BOr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BOr>();
	}
};
static_assert(alignof(UVoxelNode_BOr) == 0x000008, "Wrong alignment on UVoxelNode_BOr");
static_assert(sizeof(UVoxelNode_BOr) == 0x000098, "Wrong size on UVoxelNode_BOr");

// Class VoxelGraph.VoxelNode_SwitchInt
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SwitchInt final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SwitchInt">();
	}
	static class UVoxelNode_SwitchInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SwitchInt>();
	}
};
static_assert(alignof(UVoxelNode_SwitchInt) == 0x000008, "Wrong alignment on UVoxelNode_SwitchInt");
static_assert(sizeof(UVoxelNode_SwitchInt) == 0x000098, "Wrong size on UVoxelNode_SwitchInt");

// Class VoxelGraph.VoxelNode_SwitchColor
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SwitchColor final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SwitchColor">();
	}
	static class UVoxelNode_SwitchColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SwitchColor>();
	}
};
static_assert(alignof(UVoxelNode_SwitchColor) == 0x000008, "Wrong alignment on UVoxelNode_SwitchColor");
static_assert(sizeof(UVoxelNode_SwitchColor) == 0x000098, "Wrong size on UVoxelNode_SwitchColor");

// Class VoxelGraph.VoxelNode_OneOverX
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_OneOverX final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_OneOverX">();
	}
	static class UVoxelNode_OneOverX* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_OneOverX>();
	}
};
static_assert(alignof(UVoxelNode_OneOverX) == 0x000008, "Wrong alignment on UVoxelNode_OneOverX");
static_assert(sizeof(UVoxelNode_OneOverX) == 0x000098, "Wrong size on UVoxelNode_OneOverX");

// Class VoxelGraph.VoxelNode_Sqrt
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Sqrt final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Sqrt">();
	}
	static class UVoxelNode_Sqrt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Sqrt>();
	}
};
static_assert(alignof(UVoxelNode_Sqrt) == 0x000008, "Wrong alignment on UVoxelNode_Sqrt");
static_assert(sizeof(UVoxelNode_Sqrt) == 0x000098, "Wrong size on UVoxelNode_Sqrt");

// Class VoxelGraph.VoxelNode_IMod
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IMod final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IMod">();
	}
	static class UVoxelNode_IMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IMod>();
	}
};
static_assert(alignof(UVoxelNode_IMod) == 0x000008, "Wrong alignment on UVoxelNode_IMod");
static_assert(sizeof(UVoxelNode_IMod) == 0x000098, "Wrong size on UVoxelNode_IMod");

// Class VoxelGraph.VoxelNode_FMod
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FMod final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FMod">();
	}
	static class UVoxelNode_FMod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FMod>();
	}
};
static_assert(alignof(UVoxelNode_FMod) == 0x000008, "Wrong alignment on UVoxelNode_FMod");
static_assert(sizeof(UVoxelNode_FMod) == 0x000098, "Wrong size on UVoxelNode_FMod");

// Class VoxelGraph.VoxelNode_FAbs
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FAbs final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FAbs">();
	}
	static class UVoxelNode_FAbs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FAbs>();
	}
};
static_assert(alignof(UVoxelNode_FAbs) == 0x000008, "Wrong alignment on UVoxelNode_FAbs");
static_assert(sizeof(UVoxelNode_FAbs) == 0x000098, "Wrong size on UVoxelNode_FAbs");

// Class VoxelGraph.VoxelNode_IAbs
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_IAbs final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IAbs">();
	}
	static class UVoxelNode_IAbs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IAbs>();
	}
};
static_assert(alignof(UVoxelNode_IAbs) == 0x000008, "Wrong alignment on UVoxelNode_IAbs");
static_assert(sizeof(UVoxelNode_IAbs) == 0x000098, "Wrong size on UVoxelNode_IAbs");

// Class VoxelGraph.VoxelNode_Ceil
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Ceil final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Ceil">();
	}
	static class UVoxelNode_Ceil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Ceil>();
	}
};
static_assert(alignof(UVoxelNode_Ceil) == 0x000008, "Wrong alignment on UVoxelNode_Ceil");
static_assert(sizeof(UVoxelNode_Ceil) == 0x000098, "Wrong size on UVoxelNode_Ceil");

// Class VoxelGraph.VoxelNode_VectorLength
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_VectorLength final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VectorLength">();
	}
	static class UVoxelNode_VectorLength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VectorLength>();
	}
};
static_assert(alignof(UVoxelNode_VectorLength) == 0x000008, "Wrong alignment on UVoxelNode_VectorLength");
static_assert(sizeof(UVoxelNode_VectorLength) == 0x000098, "Wrong size on UVoxelNode_VectorLength");

// Class VoxelGraph.VoxelNode_Fraction
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Fraction final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Fraction">();
	}
	static class UVoxelNode_Fraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Fraction>();
	}
};
static_assert(alignof(UVoxelNode_Fraction) == 0x000008, "Wrong alignment on UVoxelNode_Fraction");
static_assert(sizeof(UVoxelNode_Fraction) == 0x000098, "Wrong size on UVoxelNode_Fraction");

// Class VoxelGraph.VoxelNode_FSign
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_FSign final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FSign">();
	}
	static class UVoxelNode_FSign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FSign>();
	}
};
static_assert(alignof(UVoxelNode_FSign) == 0x000008, "Wrong alignment on UVoxelNode_FSign");
static_assert(sizeof(UVoxelNode_FSign) == 0x000098, "Wrong size on UVoxelNode_FSign");

// Class VoxelGraph.VoxelNode_InvSqrt
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_InvSqrt final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_InvSqrt">();
	}
	static class UVoxelNode_InvSqrt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_InvSqrt>();
	}
};
static_assert(alignof(UVoxelNode_InvSqrt) == 0x000008, "Wrong alignment on UVoxelNode_InvSqrt");
static_assert(sizeof(UVoxelNode_InvSqrt) == 0x000098, "Wrong size on UVoxelNode_InvSqrt");

// Class VoxelGraph.VoxelNode_Exp
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Exp final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Exp">();
	}
	static class UVoxelNode_Exp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Exp>();
	}
};
static_assert(alignof(UVoxelNode_Exp) == 0x000008, "Wrong alignment on UVoxelNode_Exp");
static_assert(sizeof(UVoxelNode_Exp) == 0x000098, "Wrong size on UVoxelNode_Exp");

// Class VoxelGraph.VoxelNode_Asin
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Asin final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Asin">();
	}
	static class UVoxelNode_Asin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Asin>();
	}
};
static_assert(alignof(UVoxelNode_Asin) == 0x000008, "Wrong alignment on UVoxelNode_Asin");
static_assert(sizeof(UVoxelNode_Asin) == 0x000098, "Wrong size on UVoxelNode_Asin");

// Class VoxelGraph.VoxelNode_Cos
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Cos final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Cos">();
	}
	static class UVoxelNode_Cos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Cos>();
	}
};
static_assert(alignof(UVoxelNode_Cos) == 0x000008, "Wrong alignment on UVoxelNode_Cos");
static_assert(sizeof(UVoxelNode_Cos) == 0x000098, "Wrong size on UVoxelNode_Cos");

// Class VoxelGraph.VoxelNode_SinCos
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SinCos final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SinCos">();
	}
	static class UVoxelNode_SinCos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SinCos>();
	}
};
static_assert(alignof(UVoxelNode_SinCos) == 0x000008, "Wrong alignment on UVoxelNode_SinCos");
static_assert(sizeof(UVoxelNode_SinCos) == 0x000098, "Wrong size on UVoxelNode_SinCos");

// Class VoxelGraph.VoxelNode_Atan
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Atan final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Atan">();
	}
	static class UVoxelNode_Atan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Atan>();
	}
};
static_assert(alignof(UVoxelNode_Atan) == 0x000008, "Wrong alignment on UVoxelNode_Atan");
static_assert(sizeof(UVoxelNode_Atan) == 0x000098, "Wrong size on UVoxelNode_Atan");

// Class VoxelGraph.VoxelNode_VectorRotateAngleAxis
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_VectorRotateAngleAxis final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VectorRotateAngleAxis">();
	}
	static class UVoxelNode_VectorRotateAngleAxis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VectorRotateAngleAxis>();
	}
};
static_assert(alignof(UVoxelNode_VectorRotateAngleAxis) == 0x000008, "Wrong alignment on UVoxelNode_VectorRotateAngleAxis");
static_assert(sizeof(UVoxelNode_VectorRotateAngleAxis) == 0x000098, "Wrong size on UVoxelNode_VectorRotateAngleAxis");

// Class VoxelGraph.VoxelNode_BreakColorFloat
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_BreakColorFloat final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BreakColorFloat">();
	}
	static class UVoxelNode_BreakColorFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BreakColorFloat>();
	}
};
static_assert(alignof(UVoxelNode_BreakColorFloat) == 0x000008, "Wrong alignment on UVoxelNode_BreakColorFloat");
static_assert(sizeof(UVoxelNode_BreakColorFloat) == 0x000098, "Wrong size on UVoxelNode_BreakColorFloat");

// Class VoxelGraph.VoxelNode_MakeColorFloat
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_MakeColorFloat final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_MakeColorFloat">();
	}
	static class UVoxelNode_MakeColorFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_MakeColorFloat>();
	}
};
static_assert(alignof(UVoxelNode_MakeColorFloat) == 0x000008, "Wrong alignment on UVoxelNode_MakeColorFloat");
static_assert(sizeof(UVoxelNode_MakeColorFloat) == 0x000098, "Wrong size on UVoxelNode_MakeColorFloat");

// Class VoxelGraph.VoxelNode_HSVToRGB
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_HSVToRGB final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_HSVToRGB">();
	}
	static class UVoxelNode_HSVToRGB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_HSVToRGB>();
	}
};
static_assert(alignof(UVoxelNode_HSVToRGB) == 0x000008, "Wrong alignment on UVoxelNode_HSVToRGB");
static_assert(sizeof(UVoxelNode_HSVToRGB) == 0x000098, "Wrong size on UVoxelNode_HSVToRGB");

// Class VoxelGraph.VoxelNode_Pi
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_Pi final : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Pi">();
	}
	static class UVoxelNode_Pi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Pi>();
	}
};
static_assert(alignof(UVoxelNode_Pi) == 0x000008, "Wrong alignment on UVoxelNode_Pi");
static_assert(sizeof(UVoxelNode_Pi) == 0x000098, "Wrong size on UVoxelNode_Pi");

// Class VoxelGraph.VoxelGraphNodeInterface
// 0x0020 (0x00B8 - 0x0098)
class UVoxelGraphNodeInterface final : public UEdGraphNode
{
public:
	class FString                                 InfoMsg;                                           // 0x0098(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WarningMsg;                                        // 0x00A8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGraphNodeInterface">();
	}
	static class UVoxelGraphNodeInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGraphNodeInterface>();
	}
};
static_assert(alignof(UVoxelGraphNodeInterface) == 0x000008, "Wrong alignment on UVoxelGraphNodeInterface");
static_assert(sizeof(UVoxelGraphNodeInterface) == 0x0000B8, "Wrong size on UVoxelGraphNodeInterface");
static_assert(offsetof(UVoxelGraphNodeInterface, InfoMsg) == 0x000098, "Member 'UVoxelGraphNodeInterface::InfoMsg' has a wrong offset!");
static_assert(offsetof(UVoxelGraphNodeInterface, WarningMsg) == 0x0000A8, "Member 'UVoxelGraphNodeInterface::WarningMsg' has a wrong offset!");

// Class VoxelGraph.VoxelNode_2DValueNoise
// 0x0000 (0x00E0 - 0x00E0)
class UVoxelNode_2DValueNoise final : public UVoxelNode_NoiseNodeWithDerivative
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DValueNoise">();
	}
	static class UVoxelNode_2DValueNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DValueNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DValueNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DValueNoise");
static_assert(sizeof(UVoxelNode_2DValueNoise) == 0x0000E0, "Wrong size on UVoxelNode_2DValueNoise");

// Class VoxelGraph.VoxelNode_2DValueNoiseFractal
// 0x0000 (0x0140 - 0x0140)
class UVoxelNode_2DValueNoiseFractal final : public UVoxelNode_NoiseNodeWithDerivativeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DValueNoiseFractal">();
	}
	static class UVoxelNode_2DValueNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DValueNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_2DValueNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_2DValueNoiseFractal");
static_assert(sizeof(UVoxelNode_2DValueNoiseFractal) == 0x000140, "Wrong size on UVoxelNode_2DValueNoiseFractal");

// Class VoxelGraph.VoxelNode_2DPerlinNoiseFractal
// 0x0000 (0x0140 - 0x0140)
class UVoxelNode_2DPerlinNoiseFractal final : public UVoxelNode_NoiseNodeWithDerivativeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DPerlinNoiseFractal">();
	}
	static class UVoxelNode_2DPerlinNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DPerlinNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_2DPerlinNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_2DPerlinNoiseFractal");
static_assert(sizeof(UVoxelNode_2DPerlinNoiseFractal) == 0x000140, "Wrong size on UVoxelNode_2DPerlinNoiseFractal");

// Class VoxelGraph.VoxelNode_2DSimplexNoise
// 0x0000 (0x00D8 - 0x00D8)
class UVoxelNode_2DSimplexNoise final : public UVoxelNode_NoiseNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DSimplexNoise">();
	}
	static class UVoxelNode_2DSimplexNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DSimplexNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DSimplexNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DSimplexNoise");
static_assert(sizeof(UVoxelNode_2DSimplexNoise) == 0x0000D8, "Wrong size on UVoxelNode_2DSimplexNoise");

// Class VoxelGraph.VoxelNode_2DSimplexNoiseFractal
// 0x0000 (0x0138 - 0x0138)
class UVoxelNode_2DSimplexNoiseFractal final : public UVoxelNode_NoiseNodeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DSimplexNoiseFractal">();
	}
	static class UVoxelNode_2DSimplexNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DSimplexNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_2DSimplexNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_2DSimplexNoiseFractal");
static_assert(sizeof(UVoxelNode_2DSimplexNoiseFractal) == 0x000138, "Wrong size on UVoxelNode_2DSimplexNoiseFractal");

// Class VoxelGraph.VoxelNode_2DCubicNoiseFractal
// 0x0000 (0x0138 - 0x0138)
class UVoxelNode_2DCubicNoiseFractal final : public UVoxelNode_NoiseNodeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DCubicNoiseFractal">();
	}
	static class UVoxelNode_2DCubicNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DCubicNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_2DCubicNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_2DCubicNoiseFractal");
static_assert(sizeof(UVoxelNode_2DCubicNoiseFractal) == 0x000138, "Wrong size on UVoxelNode_2DCubicNoiseFractal");

// Class VoxelGraph.VoxelNode_3DValueNoiseFractal
// 0x0000 (0x0140 - 0x0140)
class UVoxelNode_3DValueNoiseFractal final : public UVoxelNode_NoiseNodeWithDerivativeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DValueNoiseFractal">();
	}
	static class UVoxelNode_3DValueNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DValueNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_3DValueNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_3DValueNoiseFractal");
static_assert(sizeof(UVoxelNode_3DValueNoiseFractal) == 0x000140, "Wrong size on UVoxelNode_3DValueNoiseFractal");

// Class VoxelGraph.VoxelNode_3DPerlinNoiseFractal
// 0x0000 (0x0140 - 0x0140)
class UVoxelNode_3DPerlinNoiseFractal final : public UVoxelNode_NoiseNodeWithDerivativeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DPerlinNoiseFractal">();
	}
	static class UVoxelNode_3DPerlinNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DPerlinNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_3DPerlinNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_3DPerlinNoiseFractal");
static_assert(sizeof(UVoxelNode_3DPerlinNoiseFractal) == 0x000140, "Wrong size on UVoxelNode_3DPerlinNoiseFractal");

// Class VoxelGraph.VoxelNode_3DSimplexNoiseFractal
// 0x0000 (0x0138 - 0x0138)
class UVoxelNode_3DSimplexNoiseFractal final : public UVoxelNode_NoiseNodeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DSimplexNoiseFractal">();
	}
	static class UVoxelNode_3DSimplexNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DSimplexNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_3DSimplexNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_3DSimplexNoiseFractal");
static_assert(sizeof(UVoxelNode_3DSimplexNoiseFractal) == 0x000138, "Wrong size on UVoxelNode_3DSimplexNoiseFractal");

// Class VoxelGraph.VoxelNode_3DCubicNoiseFractal
// 0x0000 (0x0138 - 0x0138)
class UVoxelNode_3DCubicNoiseFractal final : public UVoxelNode_NoiseNodeFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DCubicNoiseFractal">();
	}
	static class UVoxelNode_3DCubicNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DCubicNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_3DCubicNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_3DCubicNoiseFractal");
static_assert(sizeof(UVoxelNode_3DCubicNoiseFractal) == 0x000138, "Wrong size on UVoxelNode_3DCubicNoiseFractal");

// Class VoxelGraph.VoxelNode_2DCellularNoise
// 0x0000 (0x00E0 - 0x00E0)
class UVoxelNode_2DCellularNoise final : public UVoxelNode_CellularNoise
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DCellularNoise">();
	}
	static class UVoxelNode_2DCellularNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DCellularNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DCellularNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DCellularNoise");
static_assert(sizeof(UVoxelNode_2DCellularNoise) == 0x0000E0, "Wrong size on UVoxelNode_2DCellularNoise");

// Class VoxelGraph.VoxelNode_2DIQNoise
// 0x0000 (0x0148 - 0x0148)
class UVoxelNode_2DIQNoise final : public UVoxelNode_2DIQNoiseBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DIQNoise">();
	}
	static class UVoxelNode_2DIQNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DIQNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DIQNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DIQNoise");
static_assert(sizeof(UVoxelNode_2DIQNoise) == 0x000148, "Wrong size on UVoxelNode_2DIQNoise");

// Class VoxelGraph.VoxelNode_3DIQNoise
// 0x0000 (0x0150 - 0x0150)
class UVoxelNode_3DIQNoise final : public UVoxelNode_3DIQNoiseBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DIQNoise">();
	}
	static class UVoxelNode_3DIQNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DIQNoise>();
	}
};
static_assert(alignof(UVoxelNode_3DIQNoise) == 0x000008, "Wrong alignment on UVoxelNode_3DIQNoise");
static_assert(sizeof(UVoxelNode_3DIQNoise) == 0x000150, "Wrong size on UVoxelNode_3DIQNoise");

// Class VoxelGraph.VoxelNode_3DCraterNoise
// 0x0000 (0x00E0 - 0x00E0)
class UVoxelNode_3DCraterNoise final : public UVoxelNode_CraterNoise
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DCraterNoise">();
	}
	static class UVoxelNode_3DCraterNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DCraterNoise>();
	}
};
static_assert(alignof(UVoxelNode_3DCraterNoise) == 0x000008, "Wrong alignment on UVoxelNode_3DCraterNoise");
static_assert(sizeof(UVoxelNode_3DCraterNoise) == 0x0000E0, "Wrong size on UVoxelNode_3DCraterNoise");

// Class VoxelGraph.VoxelNode_3DCraterNoiseFractal
// 0x0000 (0x0140 - 0x0140)
class UVoxelNode_3DCraterNoiseFractal final : public UVoxelNode_CraterNoiseFractal
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DCraterNoiseFractal">();
	}
	static class UVoxelNode_3DCraterNoiseFractal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DCraterNoiseFractal>();
	}
};
static_assert(alignof(UVoxelNode_3DCraterNoiseFractal) == 0x000008, "Wrong alignment on UVoxelNode_3DCraterNoiseFractal");
static_assert(sizeof(UVoxelNode_3DCraterNoiseFractal) == 0x000140, "Wrong size on UVoxelNode_3DCraterNoiseFractal");

// Class VoxelGraph.VoxelNode_RangeAnalysisDebuggerFloat
// 0x00A8 (0x0140 - 0x0098)
class UVoxelNode_RangeAnalysisDebuggerFloat final : public UVoxelNodeHelper
{
public:
	float                                         Min;                                               // 0x0098(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x009C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GraphMin;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GraphMax;                                          // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GraphStep;                                         // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Curve;                                             // 0x00B0(0x0088)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_RangeAnalysisDebuggerFloat">();
	}
	static class UVoxelNode_RangeAnalysisDebuggerFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_RangeAnalysisDebuggerFloat>();
	}
};
static_assert(alignof(UVoxelNode_RangeAnalysisDebuggerFloat) == 0x000008, "Wrong alignment on UVoxelNode_RangeAnalysisDebuggerFloat");
static_assert(sizeof(UVoxelNode_RangeAnalysisDebuggerFloat) == 0x000140, "Wrong size on UVoxelNode_RangeAnalysisDebuggerFloat");
static_assert(offsetof(UVoxelNode_RangeAnalysisDebuggerFloat, Min) == 0x000098, "Member 'UVoxelNode_RangeAnalysisDebuggerFloat::Min' has a wrong offset!");
static_assert(offsetof(UVoxelNode_RangeAnalysisDebuggerFloat, Max) == 0x00009C, "Member 'UVoxelNode_RangeAnalysisDebuggerFloat::Max' has a wrong offset!");
static_assert(offsetof(UVoxelNode_RangeAnalysisDebuggerFloat, GraphMin) == 0x0000A0, "Member 'UVoxelNode_RangeAnalysisDebuggerFloat::GraphMin' has a wrong offset!");
static_assert(offsetof(UVoxelNode_RangeAnalysisDebuggerFloat, GraphMax) == 0x0000A4, "Member 'UVoxelNode_RangeAnalysisDebuggerFloat::GraphMax' has a wrong offset!");
static_assert(offsetof(UVoxelNode_RangeAnalysisDebuggerFloat, GraphStep) == 0x0000A8, "Member 'UVoxelNode_RangeAnalysisDebuggerFloat::GraphStep' has a wrong offset!");
static_assert(offsetof(UVoxelNode_RangeAnalysisDebuggerFloat, Curve) == 0x0000B0, "Member 'UVoxelNode_RangeAnalysisDebuggerFloat::Curve' has a wrong offset!");

// Class VoxelGraph.VoxelNode_RangeUnion
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_RangeUnion final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_RangeUnion">();
	}
	static class UVoxelNode_RangeUnion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_RangeUnion>();
	}
};
static_assert(alignof(UVoxelNode_RangeUnion) == 0x000008, "Wrong alignment on UVoxelNode_RangeUnion");
static_assert(sizeof(UVoxelNode_RangeUnion) == 0x000098, "Wrong size on UVoxelNode_RangeUnion");

// Class VoxelGraph.VoxelNode_GetRangeAnalysis
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_GetRangeAnalysis final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_GetRangeAnalysis">();
	}
	static class UVoxelNode_GetRangeAnalysis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_GetRangeAnalysis>();
	}
};
static_assert(alignof(UVoxelNode_GetRangeAnalysis) == 0x000008, "Wrong alignment on UVoxelNode_GetRangeAnalysis");
static_assert(sizeof(UVoxelNode_GetRangeAnalysis) == 0x000098, "Wrong size on UVoxelNode_GetRangeAnalysis");

// Class VoxelGraph.VoxelNode_SmartMax
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SmartMax final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SmartMax">();
	}
	static class UVoxelNode_SmartMax* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SmartMax>();
	}
};
static_assert(alignof(UVoxelNode_SmartMax) == 0x000008, "Wrong alignment on UVoxelNode_SmartMax");
static_assert(sizeof(UVoxelNode_SmartMax) == 0x000098, "Wrong size on UVoxelNode_SmartMax");

// Class VoxelGraph.VoxelNode_FloatParameter
// 0x0008 (0x0158 - 0x0150)
class UVoxelNode_FloatParameter final : public UVoxelExposedNode
{
public:
	float                                         Value;                                             // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_FloatParameter">();
	}
	static class UVoxelNode_FloatParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_FloatParameter>();
	}
};
static_assert(alignof(UVoxelNode_FloatParameter) == 0x000008, "Wrong alignment on UVoxelNode_FloatParameter");
static_assert(sizeof(UVoxelNode_FloatParameter) == 0x000158, "Wrong size on UVoxelNode_FloatParameter");
static_assert(offsetof(UVoxelNode_FloatParameter, Value) == 0x000150, "Member 'UVoxelNode_FloatParameter::Value' has a wrong offset!");

// Class VoxelGraph.VoxelNode_IntParameter
// 0x0008 (0x0158 - 0x0150)
class UVoxelNode_IntParameter final : public UVoxelExposedNode
{
public:
	int32                                         Value;                                             // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_IntParameter">();
	}
	static class UVoxelNode_IntParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_IntParameter>();
	}
};
static_assert(alignof(UVoxelNode_IntParameter) == 0x000008, "Wrong alignment on UVoxelNode_IntParameter");
static_assert(sizeof(UVoxelNode_IntParameter) == 0x000158, "Wrong size on UVoxelNode_IntParameter");
static_assert(offsetof(UVoxelNode_IntParameter, Value) == 0x000150, "Member 'UVoxelNode_IntParameter::Value' has a wrong offset!");

// Class VoxelGraph.VoxelNode_ColorParameter
// 0x0010 (0x0160 - 0x0150)
class UVoxelNode_ColorParameter final : public UVoxelExposedNode
{
public:
	struct FLinearColor                           Color;                                             // 0x0150(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ColorParameter">();
	}
	static class UVoxelNode_ColorParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ColorParameter>();
	}
};
static_assert(alignof(UVoxelNode_ColorParameter) == 0x000008, "Wrong alignment on UVoxelNode_ColorParameter");
static_assert(sizeof(UVoxelNode_ColorParameter) == 0x000160, "Wrong size on UVoxelNode_ColorParameter");
static_assert(offsetof(UVoxelNode_ColorParameter, Color) == 0x000150, "Member 'UVoxelNode_ColorParameter::Color' has a wrong offset!");

// Class VoxelGraph.VoxelNode_BoolParameter
// 0x0008 (0x0158 - 0x0150)
class UVoxelNode_BoolParameter final : public UVoxelExposedNode
{
public:
	bool                                          Value;                                             // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BoolParameter">();
	}
	static class UVoxelNode_BoolParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BoolParameter>();
	}
};
static_assert(alignof(UVoxelNode_BoolParameter) == 0x000008, "Wrong alignment on UVoxelNode_BoolParameter");
static_assert(sizeof(UVoxelNode_BoolParameter) == 0x000158, "Wrong size on UVoxelNode_BoolParameter");
static_assert(offsetof(UVoxelNode_BoolParameter, Value) == 0x000150, "Member 'UVoxelNode_BoolParameter::Value' has a wrong offset!");

// Class VoxelGraph.VoxelNode_DataItemSample
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_DataItemSample final : public UVoxelNodeWithContext
{
public:
	int32                                         Mask;                                              // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelDataItemCombineMode                     CombineMode;                                       // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_DataItemSample">();
	}
	static class UVoxelNode_DataItemSample* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_DataItemSample>();
	}
};
static_assert(alignof(UVoxelNode_DataItemSample) == 0x000008, "Wrong alignment on UVoxelNode_DataItemSample");
static_assert(sizeof(UVoxelNode_DataItemSample) == 0x0000A0, "Wrong size on UVoxelNode_DataItemSample");
static_assert(offsetof(UVoxelNode_DataItemSample, Mask) == 0x000098, "Member 'UVoxelNode_DataItemSample::Mask' has a wrong offset!");
static_assert(offsetof(UVoxelNode_DataItemSample, CombineMode) == 0x00009C, "Member 'UVoxelNode_DataItemSample::CombineMode' has a wrong offset!");

// Class VoxelGraph.VoxelNode_DataItemParameters
// 0x0058 (0x00F0 - 0x0098)
class UVoxelNode_DataItemParameters final : public UVoxelNodeWithContext
{
public:
	class UVoxelGraphDataItemConfig*              Config;                                            // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      PreviewValues;                                     // 0x00A0(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_DataItemParameters">();
	}
	static class UVoxelNode_DataItemParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_DataItemParameters>();
	}
};
static_assert(alignof(UVoxelNode_DataItemParameters) == 0x000008, "Wrong alignment on UVoxelNode_DataItemParameters");
static_assert(sizeof(UVoxelNode_DataItemParameters) == 0x0000F0, "Wrong size on UVoxelNode_DataItemParameters");
static_assert(offsetof(UVoxelNode_DataItemParameters, Config) == 0x000098, "Member 'UVoxelNode_DataItemParameters::Config' has a wrong offset!");
static_assert(offsetof(UVoxelNode_DataItemParameters, PreviewValues) == 0x0000A0, "Member 'UVoxelNode_DataItemParameters::PreviewValues' has a wrong offset!");

// Class VoxelGraph.VoxelNode_RandomFloat
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_RandomFloat final : public UVoxelNodeHelper
{
public:
	float                                         Min;                                               // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_RandomFloat">();
	}
	static class UVoxelNode_RandomFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_RandomFloat>();
	}
};
static_assert(alignof(UVoxelNode_RandomFloat) == 0x000008, "Wrong alignment on UVoxelNode_RandomFloat");
static_assert(sizeof(UVoxelNode_RandomFloat) == 0x0000A0, "Wrong size on UVoxelNode_RandomFloat");
static_assert(offsetof(UVoxelNode_RandomFloat, Min) == 0x000098, "Member 'UVoxelNode_RandomFloat::Min' has a wrong offset!");
static_assert(offsetof(UVoxelNode_RandomFloat, Max) == 0x00009C, "Member 'UVoxelNode_RandomFloat::Max' has a wrong offset!");

// Class VoxelGraph.VoxelNode_RandomInt
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_RandomInt final : public UVoxelNodeHelper
{
public:
	int32                                         Min;                                               // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_RandomInt">();
	}
	static class UVoxelNode_RandomInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_RandomInt>();
	}
};
static_assert(alignof(UVoxelNode_RandomInt) == 0x000008, "Wrong alignment on UVoxelNode_RandomInt");
static_assert(sizeof(UVoxelNode_RandomInt) == 0x0000A0, "Wrong size on UVoxelNode_RandomInt");
static_assert(offsetof(UVoxelNode_RandomInt, Min) == 0x000098, "Member 'UVoxelNode_RandomInt::Min' has a wrong offset!");
static_assert(offsetof(UVoxelNode_RandomInt, Max) == 0x00009C, "Member 'UVoxelNode_RandomInt::Max' has a wrong offset!");

// Class VoxelGraph.VoxelSDFNode
// 0x0000 (0x0098 - 0x0098)
class UVoxelSDFNode : public UVoxelPureNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSDFNode">();
	}
	static class UVoxelSDFNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSDFNode>();
	}
};
static_assert(alignof(UVoxelSDFNode) == 0x000008, "Wrong alignment on UVoxelSDFNode");
static_assert(sizeof(UVoxelSDFNode) == 0x000098, "Wrong size on UVoxelSDFNode");

// Class VoxelGraph.VoxelNode_SphereSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SphereSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SphereSDF">();
	}
	static class UVoxelNode_SphereSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SphereSDF>();
	}
};
static_assert(alignof(UVoxelNode_SphereSDF) == 0x000008, "Wrong alignment on UVoxelNode_SphereSDF");
static_assert(sizeof(UVoxelNode_SphereSDF) == 0x000098, "Wrong size on UVoxelNode_SphereSDF");

// Class VoxelGraph.VoxelNode_BoxSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_BoxSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_BoxSDF">();
	}
	static class UVoxelNode_BoxSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_BoxSDF>();
	}
};
static_assert(alignof(UVoxelNode_BoxSDF) == 0x000008, "Wrong alignment on UVoxelNode_BoxSDF");
static_assert(sizeof(UVoxelNode_BoxSDF) == 0x000098, "Wrong size on UVoxelNode_BoxSDF");

// Class VoxelGraph.VoxelNode_RoundBoxSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_RoundBoxSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_RoundBoxSDF">();
	}
	static class UVoxelNode_RoundBoxSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_RoundBoxSDF>();
	}
};
static_assert(alignof(UVoxelNode_RoundBoxSDF) == 0x000008, "Wrong alignment on UVoxelNode_RoundBoxSDF");
static_assert(sizeof(UVoxelNode_RoundBoxSDF) == 0x000098, "Wrong size on UVoxelNode_RoundBoxSDF");

// Class VoxelGraph.VoxelNode_TorusSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_TorusSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_TorusSDF">();
	}
	static class UVoxelNode_TorusSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_TorusSDF>();
	}
};
static_assert(alignof(UVoxelNode_TorusSDF) == 0x000008, "Wrong alignment on UVoxelNode_TorusSDF");
static_assert(sizeof(UVoxelNode_TorusSDF) == 0x000098, "Wrong size on UVoxelNode_TorusSDF");

// Class VoxelGraph.VoxelNode_CappedTorusSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_CappedTorusSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CappedTorusSDF">();
	}
	static class UVoxelNode_CappedTorusSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CappedTorusSDF>();
	}
};
static_assert(alignof(UVoxelNode_CappedTorusSDF) == 0x000008, "Wrong alignment on UVoxelNode_CappedTorusSDF");
static_assert(sizeof(UVoxelNode_CappedTorusSDF) == 0x000098, "Wrong size on UVoxelNode_CappedTorusSDF");

// Class VoxelGraph.VoxelNode_LinkSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_LinkSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_LinkSDF">();
	}
	static class UVoxelNode_LinkSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_LinkSDF>();
	}
};
static_assert(alignof(UVoxelNode_LinkSDF) == 0x000008, "Wrong alignment on UVoxelNode_LinkSDF");
static_assert(sizeof(UVoxelNode_LinkSDF) == 0x000098, "Wrong size on UVoxelNode_LinkSDF");

// Class VoxelGraph.VoxelNode_CylinderSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_CylinderSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CylinderSDF">();
	}
	static class UVoxelNode_CylinderSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CylinderSDF>();
	}
};
static_assert(alignof(UVoxelNode_CylinderSDF) == 0x000008, "Wrong alignment on UVoxelNode_CylinderSDF");
static_assert(sizeof(UVoxelNode_CylinderSDF) == 0x000098, "Wrong size on UVoxelNode_CylinderSDF");

// Class VoxelGraph.VoxelNode_ConeSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ConeSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ConeSDF">();
	}
	static class UVoxelNode_ConeSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ConeSDF>();
	}
};
static_assert(alignof(UVoxelNode_ConeSDF) == 0x000008, "Wrong alignment on UVoxelNode_ConeSDF");
static_assert(sizeof(UVoxelNode_ConeSDF) == 0x000098, "Wrong size on UVoxelNode_ConeSDF");

// Class VoxelGraph.VoxelNode_ConeFastSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_ConeFastSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_ConeFastSDF">();
	}
	static class UVoxelNode_ConeFastSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_ConeFastSDF>();
	}
};
static_assert(alignof(UVoxelNode_ConeFastSDF) == 0x000008, "Wrong alignment on UVoxelNode_ConeFastSDF");
static_assert(sizeof(UVoxelNode_ConeFastSDF) == 0x000098, "Wrong size on UVoxelNode_ConeFastSDF");

// Class VoxelGraph.VoxelNode_InfiniteConeSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_InfiniteConeSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_InfiniteConeSDF">();
	}
	static class UVoxelNode_InfiniteConeSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_InfiniteConeSDF>();
	}
};
static_assert(alignof(UVoxelNode_InfiniteConeSDF) == 0x000008, "Wrong alignment on UVoxelNode_InfiniteConeSDF");
static_assert(sizeof(UVoxelNode_InfiniteConeSDF) == 0x000098, "Wrong size on UVoxelNode_InfiniteConeSDF");

// Class VoxelGraph.VoxelNode_PlaneSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_PlaneSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_PlaneSDF">();
	}
	static class UVoxelNode_PlaneSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_PlaneSDF>();
	}
};
static_assert(alignof(UVoxelNode_PlaneSDF) == 0x000008, "Wrong alignment on UVoxelNode_PlaneSDF");
static_assert(sizeof(UVoxelNode_PlaneSDF) == 0x000098, "Wrong size on UVoxelNode_PlaneSDF");

// Class VoxelGraph.VoxelNode_HexPrismSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_HexPrismSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_HexPrismSDF">();
	}
	static class UVoxelNode_HexPrismSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_HexPrismSDF>();
	}
};
static_assert(alignof(UVoxelNode_HexPrismSDF) == 0x000008, "Wrong alignment on UVoxelNode_HexPrismSDF");
static_assert(sizeof(UVoxelNode_HexPrismSDF) == 0x000098, "Wrong size on UVoxelNode_HexPrismSDF");

// Class VoxelGraph.VoxelNode_TriPrismSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_TriPrismSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_TriPrismSDF">();
	}
	static class UVoxelNode_TriPrismSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_TriPrismSDF>();
	}
};
static_assert(alignof(UVoxelNode_TriPrismSDF) == 0x000008, "Wrong alignment on UVoxelNode_TriPrismSDF");
static_assert(sizeof(UVoxelNode_TriPrismSDF) == 0x000098, "Wrong size on UVoxelNode_TriPrismSDF");

// Class VoxelGraph.VoxelNode_CapsuleSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_CapsuleSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CapsuleSDF">();
	}
	static class UVoxelNode_CapsuleSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CapsuleSDF>();
	}
};
static_assert(alignof(UVoxelNode_CapsuleSDF) == 0x000008, "Wrong alignment on UVoxelNode_CapsuleSDF");
static_assert(sizeof(UVoxelNode_CapsuleSDF) == 0x000098, "Wrong size on UVoxelNode_CapsuleSDF");

// Class VoxelGraph.VoxelNode_VerticalCapsuleSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_VerticalCapsuleSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VerticalCapsuleSDF">();
	}
	static class UVoxelNode_VerticalCapsuleSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VerticalCapsuleSDF>();
	}
};
static_assert(alignof(UVoxelNode_VerticalCapsuleSDF) == 0x000008, "Wrong alignment on UVoxelNode_VerticalCapsuleSDF");
static_assert(sizeof(UVoxelNode_VerticalCapsuleSDF) == 0x000098, "Wrong size on UVoxelNode_VerticalCapsuleSDF");

// Class VoxelGraph.VoxelNode_VerticalCappedCylinderSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_VerticalCappedCylinderSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VerticalCappedCylinderSDF">();
	}
	static class UVoxelNode_VerticalCappedCylinderSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VerticalCappedCylinderSDF>();
	}
};
static_assert(alignof(UVoxelNode_VerticalCappedCylinderSDF) == 0x000008, "Wrong alignment on UVoxelNode_VerticalCappedCylinderSDF");
static_assert(sizeof(UVoxelNode_VerticalCappedCylinderSDF) == 0x000098, "Wrong size on UVoxelNode_VerticalCappedCylinderSDF");

// Class VoxelGraph.VoxelNode_CappedCylinderSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_CappedCylinderSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CappedCylinderSDF">();
	}
	static class UVoxelNode_CappedCylinderSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CappedCylinderSDF>();
	}
};
static_assert(alignof(UVoxelNode_CappedCylinderSDF) == 0x000008, "Wrong alignment on UVoxelNode_CappedCylinderSDF");
static_assert(sizeof(UVoxelNode_CappedCylinderSDF) == 0x000098, "Wrong size on UVoxelNode_CappedCylinderSDF");

// Class VoxelGraph.VoxelNode_RoundedCylinderSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_RoundedCylinderSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_RoundedCylinderSDF">();
	}
	static class UVoxelNode_RoundedCylinderSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_RoundedCylinderSDF>();
	}
};
static_assert(alignof(UVoxelNode_RoundedCylinderSDF) == 0x000008, "Wrong alignment on UVoxelNode_RoundedCylinderSDF");
static_assert(sizeof(UVoxelNode_RoundedCylinderSDF) == 0x000098, "Wrong size on UVoxelNode_RoundedCylinderSDF");

// Class VoxelGraph.VoxelNode_VerticalCappedConeSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_VerticalCappedConeSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VerticalCappedConeSDF">();
	}
	static class UVoxelNode_VerticalCappedConeSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VerticalCappedConeSDF>();
	}
};
static_assert(alignof(UVoxelNode_VerticalCappedConeSDF) == 0x000008, "Wrong alignment on UVoxelNode_VerticalCappedConeSDF");
static_assert(sizeof(UVoxelNode_VerticalCappedConeSDF) == 0x000098, "Wrong size on UVoxelNode_VerticalCappedConeSDF");

// Class VoxelGraph.VoxelNode_CappedConeSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_CappedConeSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_CappedConeSDF">();
	}
	static class UVoxelNode_CappedConeSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_CappedConeSDF>();
	}
};
static_assert(alignof(UVoxelNode_CappedConeSDF) == 0x000008, "Wrong alignment on UVoxelNode_CappedConeSDF");
static_assert(sizeof(UVoxelNode_CappedConeSDF) == 0x000098, "Wrong size on UVoxelNode_CappedConeSDF");

// Class VoxelGraph.VoxelNode_SolidAngleSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SolidAngleSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SolidAngleSDF">();
	}
	static class UVoxelNode_SolidAngleSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SolidAngleSDF>();
	}
};
static_assert(alignof(UVoxelNode_SolidAngleSDF) == 0x000008, "Wrong alignment on UVoxelNode_SolidAngleSDF");
static_assert(sizeof(UVoxelNode_SolidAngleSDF) == 0x000098, "Wrong size on UVoxelNode_SolidAngleSDF");

// Class VoxelGraph.VoxelNode_VerticalRoundConeSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_VerticalRoundConeSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VerticalRoundConeSDF">();
	}
	static class UVoxelNode_VerticalRoundConeSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VerticalRoundConeSDF>();
	}
};
static_assert(alignof(UVoxelNode_VerticalRoundConeSDF) == 0x000008, "Wrong alignment on UVoxelNode_VerticalRoundConeSDF");
static_assert(sizeof(UVoxelNode_VerticalRoundConeSDF) == 0x000098, "Wrong size on UVoxelNode_VerticalRoundConeSDF");

// Class VoxelGraph.VoxelNode_RoundConeSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_RoundConeSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_RoundConeSDF">();
	}
	static class UVoxelNode_RoundConeSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_RoundConeSDF>();
	}
};
static_assert(alignof(UVoxelNode_RoundConeSDF) == 0x000008, "Wrong alignment on UVoxelNode_RoundConeSDF");
static_assert(sizeof(UVoxelNode_RoundConeSDF) == 0x000098, "Wrong size on UVoxelNode_RoundConeSDF");

// Class VoxelGraph.VoxelNode_EllipsoidSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_EllipsoidSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_EllipsoidSDF">();
	}
	static class UVoxelNode_EllipsoidSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_EllipsoidSDF>();
	}
};
static_assert(alignof(UVoxelNode_EllipsoidSDF) == 0x000008, "Wrong alignment on UVoxelNode_EllipsoidSDF");
static_assert(sizeof(UVoxelNode_EllipsoidSDF) == 0x000098, "Wrong size on UVoxelNode_EllipsoidSDF");

// Class VoxelGraph.VoxelNode_OctahedronSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_OctahedronSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_OctahedronSDF">();
	}
	static class UVoxelNode_OctahedronSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_OctahedronSDF>();
	}
};
static_assert(alignof(UVoxelNode_OctahedronSDF) == 0x000008, "Wrong alignment on UVoxelNode_OctahedronSDF");
static_assert(sizeof(UVoxelNode_OctahedronSDF) == 0x000098, "Wrong size on UVoxelNode_OctahedronSDF");

// Class VoxelGraph.VoxelNode_OctahedronFastSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_OctahedronFastSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_OctahedronFastSDF">();
	}
	static class UVoxelNode_OctahedronFastSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_OctahedronFastSDF>();
	}
};
static_assert(alignof(UVoxelNode_OctahedronFastSDF) == 0x000008, "Wrong alignment on UVoxelNode_OctahedronFastSDF");
static_assert(sizeof(UVoxelNode_OctahedronFastSDF) == 0x000098, "Wrong size on UVoxelNode_OctahedronFastSDF");

// Class VoxelGraph.VoxelNode_PyramidSDF
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_PyramidSDF final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_PyramidSDF">();
	}
	static class UVoxelNode_PyramidSDF* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_PyramidSDF>();
	}
};
static_assert(alignof(UVoxelNode_PyramidSDF) == 0x000008, "Wrong alignment on UVoxelNode_PyramidSDF");
static_assert(sizeof(UVoxelNode_PyramidSDF) == 0x000098, "Wrong size on UVoxelNode_PyramidSDF");

// Class VoxelGraph.VoxelNode_SmoothUnion
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SmoothUnion final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SmoothUnion">();
	}
	static class UVoxelNode_SmoothUnion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SmoothUnion>();
	}
};
static_assert(alignof(UVoxelNode_SmoothUnion) == 0x000008, "Wrong alignment on UVoxelNode_SmoothUnion");
static_assert(sizeof(UVoxelNode_SmoothUnion) == 0x000098, "Wrong size on UVoxelNode_SmoothUnion");

// Class VoxelGraph.VoxelNode_SmoothSubtraction
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SmoothSubtraction final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SmoothSubtraction">();
	}
	static class UVoxelNode_SmoothSubtraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SmoothSubtraction>();
	}
};
static_assert(alignof(UVoxelNode_SmoothSubtraction) == 0x000008, "Wrong alignment on UVoxelNode_SmoothSubtraction");
static_assert(sizeof(UVoxelNode_SmoothSubtraction) == 0x000098, "Wrong size on UVoxelNode_SmoothSubtraction");

// Class VoxelGraph.VoxelNode_SmoothIntersection
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_SmoothIntersection final : public UVoxelSDFNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_SmoothIntersection">();
	}
	static class UVoxelNode_SmoothIntersection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_SmoothIntersection>();
	}
};
static_assert(alignof(UVoxelNode_SmoothIntersection) == 0x000008, "Wrong alignment on UVoxelNode_SmoothIntersection");
static_assert(sizeof(UVoxelNode_SmoothIntersection) == 0x000098, "Wrong size on UVoxelNode_SmoothIntersection");

// Class VoxelGraph.VoxelSeedNode
// 0x0000 (0x0098 - 0x0098)
class UVoxelSeedNode : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSeedNode">();
	}
	static class UVoxelSeedNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSeedNode>();
	}
};
static_assert(alignof(UVoxelSeedNode) == 0x000008, "Wrong alignment on UVoxelSeedNode");
static_assert(sizeof(UVoxelSeedNode) == 0x000098, "Wrong size on UVoxelSeedNode");

// Class VoxelGraph.VoxelNode_Seed
// 0x0010 (0x0160 - 0x0150)
class UVoxelNode_Seed final : public UVoxelExposedNode
{
public:
	int32                                         DefaultValue;                                      // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_0;                                            // 0x0154(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_Seed">();
	}
	static class UVoxelNode_Seed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_Seed>();
	}
};
static_assert(alignof(UVoxelNode_Seed) == 0x000008, "Wrong alignment on UVoxelNode_Seed");
static_assert(sizeof(UVoxelNode_Seed) == 0x000160, "Wrong size on UVoxelNode_Seed");
static_assert(offsetof(UVoxelNode_Seed, DefaultValue) == 0x000150, "Member 'UVoxelNode_Seed::DefaultValue' has a wrong offset!");
static_assert(offsetof(UVoxelNode_Seed, Name_0) == 0x000154, "Member 'UVoxelNode_Seed::Name_0' has a wrong offset!");

// Class VoxelGraph.VoxelNode_AddSeeds
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_AddSeeds final : public UVoxelSeedNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_AddSeeds">();
	}
	static class UVoxelNode_AddSeeds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_AddSeeds>();
	}
};
static_assert(alignof(UVoxelNode_AddSeeds) == 0x000008, "Wrong alignment on UVoxelNode_AddSeeds");
static_assert(sizeof(UVoxelNode_AddSeeds) == 0x000098, "Wrong size on UVoxelNode_AddSeeds");

// Class VoxelGraph.VoxelNode_MakeSeeds
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_MakeSeeds final : public UVoxelSeedNode
{
public:
	int32                                         NumOutputs;                                        // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_MakeSeeds">();
	}
	static class UVoxelNode_MakeSeeds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_MakeSeeds>();
	}
};
static_assert(alignof(UVoxelNode_MakeSeeds) == 0x000008, "Wrong alignment on UVoxelNode_MakeSeeds");
static_assert(sizeof(UVoxelNode_MakeSeeds) == 0x0000A0, "Wrong size on UVoxelNode_MakeSeeds");
static_assert(offsetof(UVoxelNode_MakeSeeds, NumOutputs) == 0x000098, "Member 'UVoxelNode_MakeSeeds::NumOutputs' has a wrong offset!");

// Class VoxelGraph.VoxelNode_TextureSampler
// 0x0010 (0x0160 - 0x0150)
class UVoxelNode_TextureSampler final : public UVoxelExposedNode
{
public:
	class UTexture2D*                             Texture;                                           // 0x0150(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBilinearInterpolation;                            // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelSamplerMode                             Mode;                                              // 0x0159(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_TextureSampler">();
	}
	static class UVoxelNode_TextureSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_TextureSampler>();
	}
};
static_assert(alignof(UVoxelNode_TextureSampler) == 0x000008, "Wrong alignment on UVoxelNode_TextureSampler");
static_assert(sizeof(UVoxelNode_TextureSampler) == 0x000160, "Wrong size on UVoxelNode_TextureSampler");
static_assert(offsetof(UVoxelNode_TextureSampler, Texture) == 0x000150, "Member 'UVoxelNode_TextureSampler::Texture' has a wrong offset!");
static_assert(offsetof(UVoxelNode_TextureSampler, bBilinearInterpolation) == 0x000158, "Member 'UVoxelNode_TextureSampler::bBilinearInterpolation' has a wrong offset!");
static_assert(offsetof(UVoxelNode_TextureSampler, Mode) == 0x000159, "Member 'UVoxelNode_TextureSampler::Mode' has a wrong offset!");

// Class VoxelGraph.VoxelNode_VoxelTextureSampler
// 0x0020 (0x0170 - 0x0150)
class UVoxelNode_VoxelTextureSampler final : public UVoxelExposedNode
{
public:
	bool                                          bBilinearInterpolation;                            // 0x0150(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelSamplerMode                             Mode;                                              // 0x0151(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_152[0x6];                                      // 0x0152(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelFloatTexture                     Texture;                                           // 0x0158(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VoxelTextureSampler">();
	}
	static class UVoxelNode_VoxelTextureSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VoxelTextureSampler>();
	}
};
static_assert(alignof(UVoxelNode_VoxelTextureSampler) == 0x000008, "Wrong alignment on UVoxelNode_VoxelTextureSampler");
static_assert(sizeof(UVoxelNode_VoxelTextureSampler) == 0x000170, "Wrong size on UVoxelNode_VoxelTextureSampler");
static_assert(offsetof(UVoxelNode_VoxelTextureSampler, bBilinearInterpolation) == 0x000150, "Member 'UVoxelNode_VoxelTextureSampler::bBilinearInterpolation' has a wrong offset!");
static_assert(offsetof(UVoxelNode_VoxelTextureSampler, Mode) == 0x000151, "Member 'UVoxelNode_VoxelTextureSampler::Mode' has a wrong offset!");
static_assert(offsetof(UVoxelNode_VoxelTextureSampler, Texture) == 0x000158, "Member 'UVoxelNode_VoxelTextureSampler::Texture' has a wrong offset!");

// Class VoxelGraph.VoxelNode_VoronoiNoiseBase
// 0x0008 (0x00A0 - 0x0098)
class UVoxelNode_VoronoiNoiseBase : public UVoxelNodeHelper
{
public:
	bool                                          bComputeNeighbors;                                 // 0x0098(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Dimension;                                         // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_VoronoiNoiseBase">();
	}
	static class UVoxelNode_VoronoiNoiseBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_VoronoiNoiseBase>();
	}
};
static_assert(alignof(UVoxelNode_VoronoiNoiseBase) == 0x000008, "Wrong alignment on UVoxelNode_VoronoiNoiseBase");
static_assert(sizeof(UVoxelNode_VoronoiNoiseBase) == 0x0000A0, "Wrong size on UVoxelNode_VoronoiNoiseBase");
static_assert(offsetof(UVoxelNode_VoronoiNoiseBase, bComputeNeighbors) == 0x000098, "Member 'UVoxelNode_VoronoiNoiseBase::bComputeNeighbors' has a wrong offset!");
static_assert(offsetof(UVoxelNode_VoronoiNoiseBase, Dimension) == 0x00009C, "Member 'UVoxelNode_VoronoiNoiseBase::Dimension' has a wrong offset!");

// Class VoxelGraph.VoxelNode_2DVoronoiNoise
// 0x0000 (0x00A0 - 0x00A0)
class UVoxelNode_2DVoronoiNoise final : public UVoxelNode_VoronoiNoiseBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DVoronoiNoise">();
	}
	static class UVoxelNode_2DVoronoiNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DVoronoiNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DVoronoiNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DVoronoiNoise");
static_assert(sizeof(UVoxelNode_2DVoronoiNoise) == 0x0000A0, "Wrong size on UVoxelNode_2DVoronoiNoise");

// Class VoxelGraph.VoxelNode_2DWhiteNoise
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_2DWhiteNoise final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_2DWhiteNoise">();
	}
	static class UVoxelNode_2DWhiteNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_2DWhiteNoise>();
	}
};
static_assert(alignof(UVoxelNode_2DWhiteNoise) == 0x000008, "Wrong alignment on UVoxelNode_2DWhiteNoise");
static_assert(sizeof(UVoxelNode_2DWhiteNoise) == 0x000098, "Wrong size on UVoxelNode_2DWhiteNoise");

// Class VoxelGraph.VoxelNode_3DWhiteNoise
// 0x0000 (0x0098 - 0x0098)
class UVoxelNode_3DWhiteNoise final : public UVoxelNodeHelper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNode_3DWhiteNoise">();
	}
	static class UVoxelNode_3DWhiteNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNode_3DWhiteNoise>();
	}
};
static_assert(alignof(UVoxelNode_3DWhiteNoise) == 0x000008, "Wrong alignment on UVoxelNode_3DWhiteNoise");
static_assert(sizeof(UVoxelNode_3DWhiteNoise) == 0x000098, "Wrong size on UVoxelNode_3DWhiteNoise");

}

