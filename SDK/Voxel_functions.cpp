#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Voxel

#include "Basic.hpp"

#include "Voxel_classes.hpp"
#include "Voxel_parameters.hpp"


namespace SDK
{

// Function Voxel.VoxelBlueprintLibrary.Add_IntVectorIntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelBlueprintLibrary::Add_IntVectorIntVector(const struct FIntVector& Left, const struct FIntVector& Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Add_IntVectorIntVector");

	Params::VoxelBlueprintLibrary_Add_IntVectorIntVector Parms{};

	Parms.Left = std::move(Left);
	Parms.Right = std::move(Right);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.AddNeighborsToSet
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSet<struct FIntVector>                 InSet                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSet<struct FIntVector>                 OutSet                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::AddNeighborsToSet(const TSet<struct FIntVector>& InSet, TSet<struct FIntVector>* OutSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "AddNeighborsToSet");

	Params::VoxelBlueprintLibrary_AddNeighborsToSet Parms{};

	Parms.InSet = std::move(InSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSet != nullptr)
		*OutSet = std::move(Parms.OutSet);
}


// Function Voxel.VoxelBlueprintLibrary.ApplyLODSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::ApplyLODSettings(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ApplyLODSettings");

	Params::VoxelBlueprintLibrary_ApplyLODSettings Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.ApplyNewMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::ApplyNewMaterials(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ApplyNewMaterials");

	Params::VoxelBlueprintLibrary_ApplyNewMaterials Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.ApplyPaintMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (Parm, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMaterial                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelMaterial UVoxelBlueprintLibrary::ApplyPaintMaterial(const struct FVoxelMaterial& Material, const struct FVoxelPaintMaterial& PaintMaterial, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ApplyPaintMaterial");

	Params::VoxelBlueprintLibrary_ApplyPaintMaterial Parms{};

	Parms.Material = std::move(Material);
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.AreCollisionsEnabled
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LOD                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::AreCollisionsEnabled(class AVoxelWorld* World, const struct FVector& Position, int32* LOD, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "AreCollisionsEnabled");

	Params::VoxelBlueprintLibrary_AreCollisionsEnabled Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LOD != nullptr)
		*LOD = Parms.LOD;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.BindVoxelChunkEvents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FVoxelIntBox& Bounds)>OnActivate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FVoxelIntBox& Bounds)>OnDeactivate                                           (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bFireExistingOnes                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChunkSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActivationDistanceInChunks                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::BindVoxelChunkEvents(class AVoxelWorld* World, TDelegate<void(const struct FVoxelIntBox& Bounds)> OnActivate, TDelegate<void(const struct FVoxelIntBox& Bounds)> OnDeactivate, bool bFireExistingOnes, int32 ChunkSize, int32 ActivationDistanceInChunks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "BindVoxelChunkEvents");

	Params::VoxelBlueprintLibrary_BindVoxelChunkEvents Parms{};

	Parms.World = World;
	Parms.OnActivate = OnActivate;
	Parms.OnDeactivate = OnDeactivate;
	Parms.bFireExistingOnes = bFireExistingOnes;
	Parms.ChunkSize = ChunkSize;
	Parms.ActivationDistanceInChunks = ActivationDistanceInChunks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.BindVoxelGenerationEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FVoxelIntBox& Bounds)>OnGenerate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bFireExistingOnes                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ChunkSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GenerationDistanceInChunks                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::BindVoxelGenerationEvent(class AVoxelWorld* World, TDelegate<void(const struct FVoxelIntBox& Bounds)> OnGenerate, bool bFireExistingOnes, int32 ChunkSize, int32 GenerationDistanceInChunks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "BindVoxelGenerationEvent");

	Params::VoxelBlueprintLibrary_BindVoxelGenerationEvent Parms{};

	Parms.World = World;
	Parms.OnGenerate = OnGenerate;
	Parms.bFireExistingOnes = bFireExistingOnes;
	Parms.ChunkSize = ChunkSize;
	Parms.GenerationDistanceInChunks = GenerationDistanceInChunks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.ClearAllData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::ClearAllData(class AVoxelWorld* World, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ClearAllData");

	Params::VoxelBlueprintLibrary_ClearAllData Parms{};

	Parms.World = World;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.ClearDirtyData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::ClearDirtyData(class AVoxelWorld* World, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ClearDirtyData");

	Params::VoxelBlueprintLibrary_ClearDirtyData Parms{};

	Parms.World = World;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.ClearFrames
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::ClearFrames(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ClearFrames");

	Params::VoxelBlueprintLibrary_ClearFrames Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.ClearMaterialData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::ClearMaterialData(class AVoxelWorld* World, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ClearMaterialData");

	Params::VoxelBlueprintLibrary_ClearMaterialData Parms{};

	Parms.World = World;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.ClearValueData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::ClearValueData(class AVoxelWorld* World, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ClearValueData");

	Params::VoxelBlueprintLibrary_ClearValueData Parms{};

	Parms.World = World;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.CompactVoxelTexturePool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::CompactVoxelTexturePool(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CompactVoxelTexturePool");

	Params::VoxelBlueprintLibrary_CompactVoxelTexturePool Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.CreateColorPaintMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelPaintMaterialColor         Color                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelPaintMaterial UVoxelBlueprintLibrary::CreateColorPaintMaterial(const struct FVoxelPaintMaterialColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateColorPaintMaterial");

	Params::VoxelBlueprintLibrary_CreateColorPaintMaterial Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateFiveWayBlendPaintMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelPaintMaterialFiveWayBlend  FiveWayBlend                                           (Parm, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelPaintMaterial UVoxelBlueprintLibrary::CreateFiveWayBlendPaintMaterial(const struct FVoxelPaintMaterialFiveWayBlend& FiveWayBlend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateFiveWayBlendPaintMaterial");

	Params::VoxelBlueprintLibrary_CreateFiveWayBlendPaintMaterial Parms{};

	Parms.FiveWayBlend = std::move(FiveWayBlend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateMultiIndexPaintMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelPaintMaterialMultiIndex    MultiIndex                                             (Parm, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelPaintMaterial UVoxelBlueprintLibrary::CreateMultiIndexPaintMaterial(const struct FVoxelPaintMaterialMultiIndex& MultiIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateMultiIndexPaintMaterial");

	Params::VoxelBlueprintLibrary_CreateMultiIndexPaintMaterial Parms{};

	Parms.MultiIndex = std::move(MultiIndex);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateMultiIndexRawPaintMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelPaintMaterialMultiIndexRaw MultiIndexRaw                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelPaintMaterial UVoxelBlueprintLibrary::CreateMultiIndexRawPaintMaterial(const struct FVoxelPaintMaterialMultiIndexRaw& MultiIndexRaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateMultiIndexRawPaintMaterial");

	Params::VoxelBlueprintLibrary_CreateMultiIndexRawPaintMaterial Parms{};

	Parms.MultiIndexRaw = std::move(MultiIndexRaw);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateMultiIndexWetnessPaintMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelPaintMaterialMultiIndexWetnessMultiIndexWetness                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelPaintMaterial UVoxelBlueprintLibrary::CreateMultiIndexWetnessPaintMaterial(const struct FVoxelPaintMaterialMultiIndexWetness& MultiIndexWetness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateMultiIndexWetnessPaintMaterial");

	Params::VoxelBlueprintLibrary_CreateMultiIndexWetnessPaintMaterial Parms{};

	Parms.MultiIndexWetness = std::move(MultiIndexWetness);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateOrUpdateTextureFromVoxelColorTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelColorTexture               VoxelTexture                                           (Parm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Texture                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UVoxelBlueprintLibrary::CreateOrUpdateTextureFromVoxelColorTexture(const struct FVoxelColorTexture& VoxelTexture, class UTexture2D*& Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateOrUpdateTextureFromVoxelColorTexture");

	Params::VoxelBlueprintLibrary_CreateOrUpdateTextureFromVoxelColorTexture Parms{};

	Parms.VoxelTexture = std::move(VoxelTexture);
	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Texture = Parms.Texture;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateOrUpdateTextureFromVoxelFloatTexture
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               VoxelTexture                                           (Parm, NativeAccessSpecifierPublic)
// class UTexture2D*                       Texture                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UVoxelBlueprintLibrary::CreateOrUpdateTextureFromVoxelFloatTexture(const struct FVoxelFloatTexture& VoxelTexture, class UTexture2D*& Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateOrUpdateTextureFromVoxelFloatTexture");

	Params::VoxelBlueprintLibrary_CreateOrUpdateTextureFromVoxelFloatTexture Parms{};

	Parms.VoxelTexture = std::move(VoxelTexture);
	Parms.Texture = Texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Texture = Parms.Texture;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateSingleIndexPaintMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelPaintMaterialSingleIndex   SingleIndex                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelPaintMaterial UVoxelBlueprintLibrary::CreateSingleIndexPaintMaterial(const struct FVoxelPaintMaterialSingleIndex& SingleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateSingleIndexPaintMaterial");

	Params::VoxelBlueprintLibrary_CreateSingleIndexPaintMaterial Parms{};

	Parms.SingleIndex = std::move(SingleIndex);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateTextureFromVoxelColorTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelColorTexture               VoxelTexture                                           (Parm, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UVoxelBlueprintLibrary::CreateTextureFromVoxelColorTexture(const struct FVoxelColorTexture& VoxelTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateTextureFromVoxelColorTexture");

	Params::VoxelBlueprintLibrary_CreateTextureFromVoxelColorTexture Parms{};

	Parms.VoxelTexture = std::move(VoxelTexture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateTextureFromVoxelFloatTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               VoxelTexture                                           (Parm, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UVoxelBlueprintLibrary::CreateTextureFromVoxelFloatTexture(const struct FVoxelFloatTexture& VoxelTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateTextureFromVoxelFloatTexture");

	Params::VoxelBlueprintLibrary_CreateTextureFromVoxelFloatTexture Parms{};

	Parms.VoxelTexture = std::move(VoxelTexture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateToolRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelToolRenderingRef           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelToolRenderingRef UVoxelBlueprintLibrary::CreateToolRendering(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateToolRendering");

	Params::VoxelBlueprintLibrary_CreateToolRendering Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateUVPaintMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelPaintMaterialUV            UV                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelPaintMaterial UVoxelBlueprintLibrary::CreateUVPaintMaterial(const struct FVoxelPaintMaterialUV& UV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateUVPaintMaterial");

	Params::VoxelBlueprintLibrary_CreateUVPaintMaterial Parms{};

	Parms.UV = std::move(UV);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateVoxelColorTextureFromVoxelFloatTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               Texture                                                (Parm, NativeAccessSpecifierPublic)
// EVoxelRGBA                              Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNormalize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelColorTexture               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelColorTexture UVoxelBlueprintLibrary::CreateVoxelColorTextureFromVoxelFloatTexture(const struct FVoxelFloatTexture& Texture, EVoxelRGBA Channel, bool bNormalize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateVoxelColorTextureFromVoxelFloatTexture");

	Params::VoxelBlueprintLibrary_CreateVoxelColorTextureFromVoxelFloatTexture Parms{};

	Parms.Texture = std::move(Texture);
	Parms.Channel = Channel;
	Parms.bNormalize = bNormalize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.CreateVoxelFloatTextureFromTextureChannel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelRGBA                              Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelFloatTexture               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelFloatTexture UVoxelBlueprintLibrary::CreateVoxelFloatTextureFromTextureChannel(class UTexture2D* Texture, EVoxelRGBA Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "CreateVoxelFloatTextureFromTextureChannel");

	Params::VoxelBlueprintLibrary_CreateVoxelFloatTextureFromTextureChannel Parms{};

	Parms.Texture = Texture;
	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.DestroyToolRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelToolRenderingRef           Ref                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::DestroyToolRendering(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "DestroyToolRendering");

	Params::VoxelBlueprintLibrary_DestroyToolRendering Parms{};

	Parms.World = World;
	Parms.Ref = std::move(Ref);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.Divide_IntVectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelBlueprintLibrary::Divide_IntVectorInt(const struct FIntVector& Left, int32 Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Divide_IntVectorInt");

	Params::VoxelBlueprintLibrary_Divide_IntVectorInt Parms{};

	Parms.Left = std::move(Left);
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetAllVoxelWorldsContainingPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AVoxelWorld*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AVoxelWorld*> UVoxelBlueprintLibrary::GetAllVoxelWorldsContainingPosition(class UObject* WorldContextObject, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetAllVoxelWorldsContainingPosition");

	Params::VoxelBlueprintLibrary_GetAllVoxelWorldsContainingPosition Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetAllVoxelWorldsOverlappingActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AVoxelWorld*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AVoxelWorld*> UVoxelBlueprintLibrary::GetAllVoxelWorldsOverlappingActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetAllVoxelWorldsOverlappingActor");

	Params::VoxelBlueprintLibrary_GetAllVoxelWorldsOverlappingActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetAllVoxelWorldsOverlappingBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Box                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class AVoxelWorld*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AVoxelWorld*> UVoxelBlueprintLibrary::GetAllVoxelWorldsOverlappingBox(class UObject* WorldContextObject, const struct FBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetAllVoxelWorldsOverlappingBox");

	Params::VoxelBlueprintLibrary_GetAllVoxelWorldsOverlappingBox Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetBounds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelBlueprintLibrary::GetBounds(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetBounds");

	Params::VoxelBlueprintLibrary_GetBounds Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UVoxelBlueprintLibrary::GetColor(const struct FVoxelMaterial& Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetColor");

	Params::VoxelBlueprintLibrary_GetColor Parms{};

	Parms.Material = std::move(Material);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetEstimatedCollisionsMemoryUsageInMB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelBlueprintLibrary::GetEstimatedCollisionsMemoryUsageInMB(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetEstimatedCollisionsMemoryUsageInMB");

	Params::VoxelBlueprintLibrary_GetEstimatedCollisionsMemoryUsageInMB Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetFloatOutput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelBlueprintLibrary::GetFloatOutput(class AVoxelWorld* World, class FName Name_0, float X, float Y, float Z, float DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetFloatOutput");

	Params::VoxelBlueprintLibrary_GetFloatOutput Parms{};

	Parms.World = World;
	Parms.Name_0 = Name_0;
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetHistoryPosition
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelBlueprintLibrary::GetHistoryPosition(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetHistoryPosition");

	Params::VoxelBlueprintLibrary_GetHistoryPosition Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetIntOutput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelBlueprintLibrary::GetIntOutput(class AVoxelWorld* World, class FName Name_0, float X, float Y, float Z, int32 DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetIntOutput");

	Params::VoxelBlueprintLibrary_GetIntOutput Parms{};

	Parms.World = World;
	Parms.Name_0 = Name_0;
	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetMax_Intvector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelBlueprintLibrary::GetMax_Intvector(const struct FIntVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetMax_Intvector");

	Params::VoxelBlueprintLibrary_GetMax_Intvector Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetMemoryUsageInMB
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EVoxelMemoryUsageType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelBlueprintLibrary::GetMemoryUsageInMB(EVoxelMemoryUsageType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetMemoryUsageInMB");

	Params::VoxelBlueprintLibrary_GetMemoryUsageInMB Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetMin_Intvector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelBlueprintLibrary::GetMin_Intvector(const struct FIntVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetMin_Intvector");

	Params::VoxelBlueprintLibrary_GetMin_Intvector Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetMultiIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSortByStrength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength0                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Index0                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength1                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Index1                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength2                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Index2                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength3                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Index3                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Wetness                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::GetMultiIndex(const struct FVoxelMaterial& Material, bool bSortByStrength, float* Strength0, uint8* Index0, float* Strength1, uint8* Index1, float* Strength2, uint8* Index2, float* Strength3, uint8* Index3, float* Wetness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetMultiIndex");

	Params::VoxelBlueprintLibrary_GetMultiIndex Parms{};

	Parms.Material = std::move(Material);
	Parms.bSortByStrength = bSortByStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Strength0 != nullptr)
		*Strength0 = Parms.Strength0;

	if (Index0 != nullptr)
		*Index0 = Parms.Index0;

	if (Strength1 != nullptr)
		*Strength1 = Parms.Strength1;

	if (Index1 != nullptr)
		*Index1 = Parms.Index1;

	if (Strength2 != nullptr)
		*Strength2 = Parms.Strength2;

	if (Index2 != nullptr)
		*Index2 = Parms.Index2;

	if (Strength3 != nullptr)
		*Strength3 = Parms.Strength3;

	if (Index3 != nullptr)
		*Index3 = Parms.Index3;

	if (Wetness != nullptr)
		*Wetness = Parms.Wetness;
}


// Function Voxel.VoxelBlueprintLibrary.GetNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelBlueprintLibrary::GetNormal(class AVoxelWorld* World, const struct FIntVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetNormal");

	Params::VoxelBlueprintLibrary_GetNormal Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetNumberOfVoxelThreads
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelBlueprintLibrary::GetNumberOfVoxelThreads()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetNumberOfVoxelThreads");

	Params::VoxelBlueprintLibrary_GetNumberOfVoxelThreads Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetPeakMemoryUsageInMB
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EVoxelMemoryUsageType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelBlueprintLibrary::GetPeakMemoryUsageInMB(EVoxelMemoryUsageType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetPeakMemoryUsageInMB");

	Params::VoxelBlueprintLibrary_GetPeakMemoryUsageInMB Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetRawMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   R                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   G                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   A                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   U0                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   V0                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   U1                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   v1                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   U2                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   v2                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   U3                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   V3                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::GetRawMaterial(const struct FVoxelMaterial& Material, uint8* R, uint8* G, uint8* B, uint8* A, uint8* U0, uint8* V0, uint8* U1, uint8* v1, uint8* U2, uint8* v2, uint8* U3, uint8* V3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetRawMaterial");

	Params::VoxelBlueprintLibrary_GetRawMaterial Parms{};

	Parms.Material = std::move(Material);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (R != nullptr)
		*R = Parms.R;

	if (G != nullptr)
		*G = Parms.G;

	if (B != nullptr)
		*B = Parms.B;

	if (A != nullptr)
		*A = Parms.A;

	if (U0 != nullptr)
		*U0 = Parms.U0;

	if (V0 != nullptr)
		*V0 = Parms.V0;

	if (U1 != nullptr)
		*U1 = Parms.U1;

	if (v1 != nullptr)
		*v1 = Parms.v1;

	if (U2 != nullptr)
		*U2 = Parms.U2;

	if (v2 != nullptr)
		*v2 = Parms.v2;

	if (U3 != nullptr)
		*U3 = Parms.U3;

	if (V3 != nullptr)
		*V3 = Parms.V3;
}


// Function Voxel.VoxelBlueprintLibrary.GetRenderBoundsOverlappingDataBounds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     DataBounds                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LOD                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelBlueprintLibrary::GetRenderBoundsOverlappingDataBounds(class AVoxelWorld* World, const struct FVoxelIntBox& DataBounds, int32 LOD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetRenderBoundsOverlappingDataBounds");

	Params::VoxelBlueprintLibrary_GetRenderBoundsOverlappingDataBounds Parms{};

	Parms.World = World;
	Parms.DataBounds = std::move(DataBounds);
	Parms.LOD = LOD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetSingleIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UVoxelBlueprintLibrary::GetSingleIndex(const struct FVoxelMaterial& Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetSingleIndex");

	Params::VoxelBlueprintLibrary_GetSingleIndex Parms{};

	Parms.Material = std::move(Material);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetTaskCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelBlueprintLibrary::GetTaskCount(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetTaskCount");

	Params::VoxelBlueprintLibrary_GetTaskCount Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetUV
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UVoxelBlueprintLibrary::GetUV(const struct FVoxelMaterial& Material, int32 Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetUV");

	Params::VoxelBlueprintLibrary_GetUV Parms{};

	Parms.Material = std::move(Material);
	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetVoxelColorTextureSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelColorTexture               Texture                                                (Parm, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UVoxelBlueprintLibrary::GetVoxelColorTextureSize(const struct FVoxelColorTexture& Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetVoxelColorTextureSize");

	Params::VoxelBlueprintLibrary_GetVoxelColorTextureSize Parms{};

	Parms.Texture = std::move(Texture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetVoxelFloatTextureSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelFloatTexture               Texture                                                (Parm, NativeAccessSpecifierPublic)
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UVoxelBlueprintLibrary::GetVoxelFloatTextureSize(const struct FVoxelFloatTexture& Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetVoxelFloatTextureSize");

	Params::VoxelBlueprintLibrary_GetVoxelFloatTextureSize Parms{};

	Parms.Texture = std::move(Texture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetVoxelWorldContainingPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVoxelWorld* UVoxelBlueprintLibrary::GetVoxelWorldContainingPosition(class UObject* WorldContextObject, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetVoxelWorldContainingPosition");

	Params::VoxelBlueprintLibrary_GetVoxelWorldContainingPosition Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetVoxelWorldOverlappingActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVoxelWorld* UVoxelBlueprintLibrary::GetVoxelWorldOverlappingActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetVoxelWorldOverlappingActor");

	Params::VoxelBlueprintLibrary_GetVoxelWorldOverlappingActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.GetVoxelWorldOverlappingBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Box                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVoxelWorld* UVoxelBlueprintLibrary::GetVoxelWorldOverlappingBox(class UObject* WorldContextObject, const struct FBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "GetVoxelWorldOverlappingBox");

	Params::VoxelBlueprintLibrary_GetVoxelWorldOverlappingBox Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.HasMaterialData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::HasMaterialData(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "HasMaterialData");

	Params::VoxelBlueprintLibrary_HasMaterialData Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.HasValueData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::HasValueData(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "HasValueData");

	Params::VoxelBlueprintLibrary_HasValueData Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.IntervalContains_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelFloatInterval              Interval                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::IntervalContains_Float(const struct FVoxelFloatInterval& Interval, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "IntervalContains_Float");

	Params::VoxelBlueprintLibrary_IntervalContains_Float Parms{};

	Parms.Interval = std::move(Interval);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.IntervalContains_Int32
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelInt32Interval              Interval                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::IntervalContains_Int32(const struct FVoxelInt32Interval& Interval, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "IntervalContains_Int32");

	Params::VoxelBlueprintLibrary_IntervalContains_Int32 Parms{};

	Parms.Interval = std::move(Interval);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.IsValidRef
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelToolRenderingRef           Ref                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::IsValidRef(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "IsValidRef");

	Params::VoxelBlueprintLibrary_IsValidRef Parms{};

	Parms.World = World;
	Parms.Ref = std::move(Ref);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.IsVoxelColorTextureValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelFloatTexture               Texture                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::IsVoxelColorTextureValid(const struct FVoxelFloatTexture& Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "IsVoxelColorTextureValid");

	Params::VoxelBlueprintLibrary_IsVoxelColorTextureValid Parms{};

	Parms.Texture = std::move(Texture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.IsVoxelFloatTextureValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelFloatTexture               Texture                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::IsVoxelFloatTextureValid(const struct FVoxelFloatTexture& Texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "IsVoxelFloatTextureValid");

	Params::VoxelBlueprintLibrary_IsVoxelFloatTextureValid Parms{};

	Parms.Texture = std::move(Texture);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.IsVoxelPluginPro
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::IsVoxelPluginPro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "IsVoxelPluginPro");

	Params::VoxelBlueprintLibrary_IsVoxelPluginPro Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.IsVoxelWorldFoliageLoading
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::IsVoxelWorldFoliageLoading(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "IsVoxelWorldFoliageLoading");

	Params::VoxelBlueprintLibrary_IsVoxelWorldFoliageLoading Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.IsVoxelWorldMeshLoading
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::IsVoxelWorldMeshLoading(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "IsVoxelWorldMeshLoading");

	Params::VoxelBlueprintLibrary_IsVoxelWorldMeshLoading Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.LogMemoryStats
// (Final, Native, Static, Public, BlueprintCallable)

void UVoxelBlueprintLibrary::LogMemoryStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "LogMemoryStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.MakeColorMaterial
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMaterial                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelMaterial UVoxelBlueprintLibrary::MakeColorMaterial(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "MakeColorMaterial");

	Params::VoxelBlueprintLibrary_MakeColorMaterial Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.MakeIntBoxFromGlobalPositionAndRadius
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GlobalPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelBlueprintLibrary::MakeIntBoxFromGlobalPositionAndRadius(class AVoxelWorld* World, const struct FVector& GlobalPosition, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "MakeIntBoxFromGlobalPositionAndRadius");

	Params::VoxelBlueprintLibrary_MakeIntBoxFromGlobalPositionAndRadius Parms{};

	Parms.World = World;
	Parms.GlobalPosition = std::move(GlobalPosition);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.MakeMaterialMask
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    U0                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    V0                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    U1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    v1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    U2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    v2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    U3                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    V3                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelBlueprintLibrary::MakeMaterialMask(bool R, bool G, bool B, bool A, bool U0, bool V0, bool U1, bool v1, bool U2, bool v2, bool U3, bool V3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "MakeMaterialMask");

	Params::VoxelBlueprintLibrary_MakeMaterialMask Parms{};

	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;
	Parms.U0 = U0;
	Parms.V0 = V0;
	Parms.U1 = U1;
	Parms.v1 = v1;
	Parms.U2 = U2;
	Parms.v2 = v2;
	Parms.U3 = U3;
	Parms.V3 = V3;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.MakeRawMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   U0                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   V0                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   U1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   v1                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   U2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   v2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   U3                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   V3                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMaterial                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelMaterial UVoxelBlueprintLibrary::MakeRawMaterial(uint8 R, uint8 G, uint8 B, uint8 A, uint8 U0, uint8 V0, uint8 U1, uint8 v1, uint8 U2, uint8 v2, uint8 U3, uint8 V3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "MakeRawMaterial");

	Params::VoxelBlueprintLibrary_MakeRawMaterial Parms{};

	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;
	Parms.U0 = U0;
	Parms.V0 = V0;
	Parms.U1 = U1;
	Parms.v1 = v1;
	Parms.U2 = U2;
	Parms.v2 = v2;
	Parms.U3 = U3;
	Parms.V3 = V3;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.MakeSingleIndexMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMaterial                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelMaterial UVoxelBlueprintLibrary::MakeSingleIndexMaterial(uint8 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "MakeSingleIndexMaterial");

	Params::VoxelBlueprintLibrary_MakeSingleIndexMaterial Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.MarkSpawnersDirty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::MarkSpawnersDirty(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "MarkSpawnersDirty");

	Params::VoxelBlueprintLibrary_MarkSpawnersDirty Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.Multiply_IntIntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelBlueprintLibrary::Multiply_IntIntVector(int32 Left, const struct FIntVector& Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Multiply_IntIntVector");

	Params::VoxelBlueprintLibrary_Multiply_IntIntVector Parms{};

	Parms.Left = Left;
	Parms.Right = std::move(Right);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.Multiply_IntVectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelBlueprintLibrary::Multiply_IntVectorInt(const struct FIntVector& Left, int32 Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Multiply_IntVectorInt");

	Params::VoxelBlueprintLibrary_Multiply_IntVectorInt Parms{};

	Parms.Left = std::move(Left);
	Parms.Right = Right;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.Multiply_IntVectorIntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelBlueprintLibrary::Multiply_IntVectorIntVector(const struct FIntVector& Left, const struct FIntVector& Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Multiply_IntVectorIntVector");

	Params::VoxelBlueprintLibrary_Multiply_IntVectorIntVector Parms{};

	Parms.Left = std::move(Left);
	Parms.Right = std::move(Right);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.NumberOfCores
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelBlueprintLibrary::NumberOfCores()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "NumberOfCores");

	Params::VoxelBlueprintLibrary_NumberOfCores Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.RaiseError
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::RaiseError(const class FString& Message, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "RaiseError");

	Params::VoxelBlueprintLibrary_RaiseError Parms{};

	Parms.Message = std::move(Message);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.RaiseInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::RaiseInfo(const class FString& Message, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "RaiseInfo");

	Params::VoxelBlueprintLibrary_RaiseInfo Parms{};

	Parms.Message = std::move(Message);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.RaiseWarning
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::RaiseWarning(const class FString& Message, class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "RaiseWarning");

	Params::VoxelBlueprintLibrary_RaiseWarning Parms{};

	Parms.Message = std::move(Message);
	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.RecomputeComponentPositions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::RecomputeComponentPositions(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "RecomputeComponentPositions");

	Params::VoxelBlueprintLibrary_RecomputeComponentPositions Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.Recreate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSaveData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::Recreate(class AVoxelWorld* World, bool bSaveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Recreate");

	Params::VoxelBlueprintLibrary_Recreate Parms{};

	Parms.World = World;
	Parms.bSaveData = bSaveData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.RecreateRender
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::RecreateRender(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "RecreateRender");

	Params::VoxelBlueprintLibrary_RecreateRender Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.RecreateSpawners
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::RecreateSpawners(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "RecreateSpawners");

	Params::VoxelBlueprintLibrary_RecreateSpawners Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.Redo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVoxelIntBox>             OutUpdatedBounds                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::Redo(class AVoxelWorld* World, TArray<struct FVoxelIntBox>* OutUpdatedBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Redo");

	Params::VoxelBlueprintLibrary_Redo Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUpdatedBounds != nullptr)
		*OutUpdatedBounds = std::move(Parms.OutUpdatedBounds);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.RegenerateSpawners
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::RegenerateSpawners(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "RegenerateSpawners");

	Params::VoxelBlueprintLibrary_RegenerateSpawners Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.SaveFrame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::SaveFrame(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "SaveFrame");

	Params::VoxelBlueprintLibrary_SaveFrame Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.ScaleData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::ScaleData(class AVoxelWorld* World, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "ScaleData");

	Params::VoxelBlueprintLibrary_ScaleData Parms{};

	Parms.World = World;
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.SetNumberOfVoxelThreads
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::SetNumberOfVoxelThreads(int32 Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "SetNumberOfVoxelThreads");

	Params::VoxelBlueprintLibrary_SetNumberOfVoxelThreads Parms{};

	Parms.Number = Number;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.SetToolRenderingBounds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelToolRenderingRef           Ref                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox                             Bounds                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::SetToolRenderingBounds(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref, const struct FBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "SetToolRenderingBounds");

	Params::VoxelBlueprintLibrary_SetToolRenderingBounds Parms{};

	Parms.World = World;
	Parms.Ref = std::move(Ref);
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.SetToolRenderingEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelToolRenderingRef           Ref                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::SetToolRenderingEnabled(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "SetToolRenderingEnabled");

	Params::VoxelBlueprintLibrary_SetToolRenderingEnabled Parms{};

	Parms.World = World;
	Parms.Ref = std::move(Ref);
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.SetToolRenderingMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelToolRenderingRef           Ref                                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::SetToolRenderingMaterial(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref, class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "SetToolRenderingMaterial");

	Params::VoxelBlueprintLibrary_SetToolRenderingMaterial Parms{};

	Parms.World = World;
	Parms.Ref = std::move(Ref);
	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.Substract_IntVectorIntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelBlueprintLibrary::Substract_IntVectorIntVector(const struct FIntVector& Left, const struct FIntVector& Right)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Substract_IntVectorIntVector");

	Params::VoxelBlueprintLibrary_Substract_IntVectorIntVector Parms{};

	Parms.Left = std::move(Left);
	Parms.Right = std::move(Right);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.TransformGlobalBoxToVoxelBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             Box                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelBlueprintLibrary::TransformGlobalBoxToVoxelBox(class AVoxelWorld* World, const struct FBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "TransformGlobalBoxToVoxelBox");

	Params::VoxelBlueprintLibrary_TransformGlobalBoxToVoxelBox Parms{};

	Parms.World = World;
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.TransformVoxelBoxToGlobalBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UVoxelBlueprintLibrary::TransformVoxelBoxToGlobalBox(class AVoxelWorld* World, const struct FVoxelIntBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "TransformVoxelBoxToGlobalBox");

	Params::VoxelBlueprintLibrary_TransformVoxelBoxToGlobalBox Parms{};

	Parms.World = World;
	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.Undo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVoxelIntBox>             OutUpdatedBounds                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelBlueprintLibrary::Undo(class AVoxelWorld* World, TArray<struct FVoxelIntBox>* OutUpdatedBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "Undo");

	Params::VoxelBlueprintLibrary_Undo Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUpdatedBounds != nullptr)
		*OutUpdatedBounds = std::move(Parms.OutUpdatedBounds);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintLibrary.UpdateAll
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::UpdateAll(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "UpdateAll");

	Params::VoxelBlueprintLibrary_UpdateAll Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.UpdateBounds
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::UpdateBounds(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "UpdateBounds");

	Params::VoxelBlueprintLibrary_UpdateBounds Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelBlueprintLibrary.UpdatePosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBlueprintLibrary::UpdatePosition(class AVoxelWorld* World, const struct FIntVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBlueprintLibrary", "UpdatePosition");

	Params::VoxelBlueprintLibrary_UpdatePosition Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelInvokerComponentBase.RefreshAllVoxelInvokers
// (Final, Native, Static, Public, BlueprintCallable)

void UVoxelInvokerComponentBase::RefreshAllVoxelInvokers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelInvokerComponentBase", "RefreshAllVoxelInvokers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelInvokerComponentBase.GetInvokerSettings
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelInvokerSettings            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelInvokerSettings UVoxelInvokerComponentBase::GetInvokerSettings(class AVoxelWorld* VoxelWorld) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelInvokerComponentBase", "GetInvokerSettings");

	Params::VoxelInvokerComponentBase_GetInvokerSettings Parms{};

	Parms.VoxelWorld = VoxelWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelInvokerComponentBase.GetInvokerVoxelPosition
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelInvokerComponentBase::GetInvokerVoxelPosition(class AVoxelWorld* VoxelWorld) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelInvokerComponentBase", "GetInvokerVoxelPosition");

	Params::VoxelInvokerComponentBase_GetInvokerVoxelPosition Parms{};

	Parms.VoxelWorld = VoxelWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelInvokerComponentBase.IsLocalInvoker
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelInvokerComponentBase::IsLocalInvoker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelInvokerComponentBase", "IsLocalInvoker");

	Params::VoxelInvokerComponentBase_IsLocalInvoker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelInvokerComponentBase.ShouldUseInvoker
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelInvokerComponentBase::ShouldUseInvoker(class AVoxelWorld* VoxelWorld) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelInvokerComponentBase", "ShouldUseInvoker");

	Params::VoxelInvokerComponentBase_ShouldUseInvoker Parms{};

	Parms.VoxelWorld = VoxelWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSimpleInvokerComponent.GetInvokerGlobalPosition
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelSimpleInvokerComponent::GetInvokerGlobalPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelSimpleInvokerComponent", "GetInvokerGlobalPosition");

	Params::VoxelSimpleInvokerComponent_GetInvokerGlobalPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelPlaceableItemActor.K2_AddItemToWorld
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelPlaceableItemActor::K2_AddItemToWorld(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelPlaceableItemActor", "K2_AddItemToWorld");

	Params::VoxelPlaceableItemActor_K2_AddItemToWorld Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelPlaceableItemActor.K2_GetPriority
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AVoxelPlaceableItemActor::K2_GetPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelPlaceableItemActor", "K2_GetPriority");

	Params::VoxelPlaceableItemActor_K2_GetPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelAssetTools.AddDisableEditsBox
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelDisableEditsBoxItemReferenceReference                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::AddDisableEditsBox(struct FVoxelDisableEditsBoxItemReference* Reference, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "AddDisableEditsBox");

	Params::VoxelAssetTools_AddDisableEditsBox Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reference != nullptr)
		*Reference = std::move(Parms.Reference);
}


// Function Voxel.VoxelAssetTools.AddDisableEditsBoxAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelDisableEditsBoxItemReferenceReference                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::AddDisableEditsBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelDisableEditsBoxItemReference* Reference, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "AddDisableEditsBoxAsync");

	Params::VoxelAssetTools_AddDisableEditsBoxAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reference != nullptr)
		*Reference = std::move(Parms.Reference);
}


// Function Voxel.VoxelAssetTools.CreateDataAssetFromWorldSection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCopyMaterials                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelDataAsset*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelDataAsset* UVoxelAssetTools::CreateDataAssetFromWorldSection(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bCopyMaterials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "CreateDataAssetFromWorldSection");

	Params::VoxelAssetTools_CreateDataAssetFromWorldSection Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bCopyMaterials = bCopyMaterials;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelAssetTools.ImportAsset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelTransformableGeneratorInstanceWrapper*Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSubtractive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelAssetMergeMode                    MergeMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::ImportAsset(class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, bool bSubtractive, EVoxelAssetMergeMode MergeMode, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "ImportAsset");

	Params::VoxelAssetTools_ImportAsset Parms{};

	Parms.World = World;
	Parms.Asset = Asset;
	Parms.Transform = std::move(Transform);
	Parms.Bounds = std::move(Bounds);
	Parms.bSubtractive = bSubtractive;
	Parms.MergeMode = MergeMode;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelAssetTools.ImportAssetAsReference
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVoxelAssetItemReference         Reference                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelTransformableGeneratorInstanceWrapper*Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::ImportAssetAsReference(struct FVoxelAssetItemReference* Reference, class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, int32 Priority, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "ImportAssetAsReference");

	Params::VoxelAssetTools_ImportAssetAsReference Parms{};

	Parms.World = World;
	Parms.Asset = Asset;
	Parms.Transform = std::move(Transform);
	Parms.Bounds = std::move(Bounds);
	Parms.Priority = Priority;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reference != nullptr)
		*Reference = std::move(Parms.Reference);
}


// Function Voxel.VoxelAssetTools.ImportAssetAsReferenceAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelAssetItemReference         Reference                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelTransformableGeneratorInstanceWrapper*Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::ImportAssetAsReferenceAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelAssetItemReference* Reference, class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, int32 Priority, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "ImportAssetAsReferenceAsync");

	Params::VoxelAssetTools_ImportAssetAsReferenceAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Asset = Asset;
	Parms.Transform = std::move(Transform);
	Parms.Bounds = std::move(Bounds);
	Parms.Priority = Priority;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Reference != nullptr)
		*Reference = std::move(Parms.Reference);
}


// Function Voxel.VoxelAssetTools.ImportAssetAsync
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelTransformableGeneratorInstanceWrapper*Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSubtractive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelAssetMergeMode                    MergeMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::ImportAssetAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, bool bSubtractive, EVoxelAssetMergeMode MergeMode, bool bConvertToVoxelSpace, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "ImportAssetAsync");

	Params::VoxelAssetTools_ImportAssetAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Asset = Asset;
	Parms.Transform = std::move(Transform);
	Parms.Bounds = std::move(Bounds);
	Parms.bSubtractive = bSubtractive;
	Parms.MergeMode = MergeMode;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelAssetTools.ImportDataAssetFast
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelDataAsset*                  Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelAssetMergeMode                    MergeMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::ImportDataAssetFast(class AVoxelWorld* World, class UVoxelDataAsset* Asset, const struct FVector& Position, EVoxelAssetMergeMode MergeMode, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "ImportDataAssetFast");

	Params::VoxelAssetTools_ImportDataAssetFast Parms{};

	Parms.World = World;
	Parms.Asset = Asset;
	Parms.Position = std::move(Position);
	Parms.MergeMode = MergeMode;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelAssetTools.ImportDataAssetFastAsync
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelDataAsset*                  Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelAssetMergeMode                    MergeMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::ImportDataAssetFastAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, class UVoxelDataAsset* Asset, const struct FVector& Position, EVoxelAssetMergeMode MergeMode, bool bConvertToVoxelSpace, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "ImportDataAssetFastAsync");

	Params::VoxelAssetTools_ImportDataAssetFastAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Asset = Asset;
	Parms.Position = std::move(Position);
	Parms.MergeMode = MergeMode;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelAssetTools.ImportModifierAsset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelTransformableGeneratorInstanceWrapper*Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bModifyValues                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bModifyMaterials                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockEntireWorld                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::ImportModifierAsset(class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, bool bModifyValues, bool bModifyMaterials, bool bLockEntireWorld, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "ImportModifierAsset");

	Params::VoxelAssetTools_ImportModifierAsset Parms{};

	Parms.World = World;
	Parms.Asset = Asset;
	Parms.Transform = std::move(Transform);
	Parms.Bounds = std::move(Bounds);
	Parms.bModifyValues = bModifyValues;
	Parms.bModifyMaterials = bModifyMaterials;
	Parms.bLockEntireWorld = bLockEntireWorld;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelAssetTools.ImportModifierAssetAsync
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelTransformableGeneratorInstanceWrapper*Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bModifyValues                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bModifyMaterials                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockEntireWorld                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::ImportModifierAssetAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, bool bModifyValues, bool bModifyMaterials, bool bLockEntireWorld, bool bConvertToVoxelSpace, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "ImportModifierAssetAsync");

	Params::VoxelAssetTools_ImportModifierAssetAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Asset = Asset;
	Parms.Transform = std::move(Transform);
	Parms.Bounds = std::move(Bounds);
	Parms.bModifyValues = bModifyValues;
	Parms.bModifyMaterials = bModifyMaterials;
	Parms.bLockEntireWorld = bLockEntireWorld;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelAssetTools.InvertDataAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UVoxelDataAsset*                  Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelDataAsset*                  InvertedAsset                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelAssetTools::InvertDataAsset(class UVoxelDataAsset* Asset, class UVoxelDataAsset** InvertedAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "InvertDataAsset");

	Params::VoxelAssetTools_InvertDataAsset Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InvertedAsset != nullptr)
		*InvertedAsset = Parms.InvertedAsset;
}


// Function Voxel.VoxelAssetTools.SetDataAssetMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UVoxelDataAsset*                  Asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelDataAsset*                  NewAsset                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UVoxelAssetTools::SetDataAssetMaterial(class UVoxelDataAsset* Asset, class UVoxelDataAsset** NewAsset, const struct FVoxelMaterial& Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelAssetTools", "SetDataAssetMaterial");

	Params::VoxelAssetTools_SetDataAssetMaterial Parms{};

	Parms.Asset = Asset;
	Parms.Material = std::move(Material);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NewAsset != nullptr)
		*NewAsset = Parms.NewAsset;
}


// Function Voxel.VoxelMaterialCollectionBase.GetIndexMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UVoxelMaterialCollectionBase::GetIndexMaterial(uint8 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelMaterialCollectionBase", "GetIndexMaterial");

	Params::VoxelMaterialCollectionBase_GetIndexMaterial Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMaterialCollectionBase.GetMaterialIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelMaterialCollectionBase::GetMaterialIndex(class FName Name_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelMaterialCollectionBase", "GetMaterialIndex");

	Params::VoxelMaterialCollectionBase_GetMaterialIndex Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMaterialCollectionBase.GetMaterials
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FVoxelMaterialCollectionMaterialInfo>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVoxelMaterialCollectionMaterialInfo> UVoxelMaterialCollectionBase::GetMaterials() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelMaterialCollectionBase", "GetMaterials");

	Params::VoxelMaterialCollectionBase_GetMaterials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintMaterialCollectionInterface.GetMaterialForIndex
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelCubicFace                         Face                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UVoxelBlueprintMaterialCollectionInterface::GetMaterialForIndex(int32 Index_0, EVoxelCubicFace Face)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBlueprintMaterialCollectionInterface", "GetMaterialForIndex");

	Params::VoxelBlueprintMaterialCollectionInterface_GetMaterialForIndex Parms{};

	Parms.Index_0 = Index_0;
	Parms.Face = Face;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintMaterialCollectionInterface.GetMaterialForIndices
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<uint8>                           Indices                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* UVoxelBlueprintMaterialCollectionInterface::GetMaterialForIndices(const TArray<uint8>& Indices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBlueprintMaterialCollectionInterface", "GetMaterialForIndices");

	Params::VoxelBlueprintMaterialCollectionInterface_GetMaterialForIndices Parms{};

	Parms.Indices = std::move(Indices);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintMaterialCollectionInterface.GetMaterials
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<struct FVoxelMaterialCollectionMaterialInfo>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVoxelMaterialCollectionMaterialInfo> UVoxelBlueprintMaterialCollectionInterface::GetMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBlueprintMaterialCollectionInterface", "GetMaterials");

	Params::VoxelBlueprintMaterialCollectionInterface_GetMaterials Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBlueprintMaterialCollectionInterface.InitializeCollection
// (Event, Public, BlueprintEvent)

void UVoxelBlueprintMaterialCollectionInterface::InitializeCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBlueprintMaterialCollectionInterface", "InitializeCollection");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Voxel.VoxelToolsBase.GetModifiedVoxelMaterialsBounds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelMaterial>   ModifiedVoxels                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelToolsBase::GetModifiedVoxelMaterialsBounds(const TArray<struct FModifiedVoxelMaterial>& ModifiedVoxels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelToolsBase", "GetModifiedVoxelMaterialsBounds");

	Params::VoxelToolsBase_GetModifiedVoxelMaterialsBounds Parms{};

	Parms.ModifiedVoxels = std::move(ModifiedVoxels);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolsBase.GetModifiedVoxelValuesBounds
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedVoxels                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelToolsBase::GetModifiedVoxelValuesBounds(const TArray<struct FModifiedVoxelValue>& ModifiedVoxels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelToolsBase", "GetModifiedVoxelValuesBounds");

	Params::VoxelToolsBase_GetModifiedVoxelValuesBounds Parms{};

	Parms.ModifiedVoxels = std::move(ModifiedVoxels);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelBoxTools.AddBox
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBoxTools::AddBox(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBoxTools", "AddBox");

	Params::VoxelBoxTools_AddBox Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Bounds = std::move(Bounds);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelBoxTools.AddBoxAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBoxTools::AddBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBoxTools", "AddBoxAsync");

	Params::VoxelBoxTools_AddBoxAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Bounds = std::move(Bounds);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelBoxTools.RemoveBox
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBoxTools::RemoveBox(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBoxTools", "RemoveBox");

	Params::VoxelBoxTools_RemoveBox Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Bounds = std::move(Bounds);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelBoxTools.RemoveBoxAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBoxTools::RemoveBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBoxTools", "RemoveBoxAsync");

	Params::VoxelBoxTools_RemoveBoxAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Bounds = std::move(Bounds);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelBoxTools.SetMaterialBox
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBoxTools::SetMaterialBox(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, const struct FVoxelPaintMaterial& PaintMaterial, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBoxTools", "SetMaterialBox");

	Params::VoxelBoxTools_SetMaterialBox Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Bounds = std::move(Bounds);
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelBoxTools.SetMaterialBoxAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBoxTools::SetMaterialBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, const struct FVoxelPaintMaterial& PaintMaterial, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBoxTools", "SetMaterialBoxAsync");

	Params::VoxelBoxTools_SetMaterialBoxAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Bounds = std::move(Bounds);
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelBoxTools.SetValueBox
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBoxTools::SetValueBox(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, float Value, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBoxTools", "SetValueBox");

	Params::VoxelBoxTools_SetValueBox Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Bounds = std::move(Bounds);
	Parms.Value = Value;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelBoxTools.SetValueBoxAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelBoxTools::SetValueBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, float Value, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelBoxTools", "SetValueBoxAsync");

	Params::VoxelBoxTools_SetValueBoxAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Bounds = std::move(Bounds);
	Parms.Value = Value;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelCookingLibrary.CookVoxelData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelCookingSettings            Settings                                               (Parm, NativeAccessSpecifierPublic)
// struct FVoxelCookedData                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelCookedData UVoxelCookingLibrary::CookVoxelData(const struct FVoxelCookingSettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelCookingLibrary", "CookVoxelData");

	Params::VoxelCookingLibrary_CookVoxelData Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelCookingLibrary.CookVoxelDataWithSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelCookingSettings            Settings                                               (Parm, NativeAccessSpecifierPublic)
// struct FVoxelUncompressedWorldSave      Save                                                   (Parm, NativeAccessSpecifierPublic)
// struct FVoxelCookedData                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelCookedData UVoxelCookingLibrary::CookVoxelDataWithSave(const struct FVoxelCookingSettings& Settings, const struct FVoxelUncompressedWorldSave& Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelCookingLibrary", "CookVoxelDataWithSave");

	Params::VoxelCookingLibrary_CookVoxelDataWithSave Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Save = std::move(Save);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelCookingLibrary.LoadCookedVoxelData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelCookedData                 CookedData                                             (Parm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelCookingLibrary::LoadCookedVoxelData(const struct FVoxelCookedData& CookedData, class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelCookingLibrary", "LoadCookedVoxelData");

	Params::VoxelCookingLibrary_LoadCookedVoxelData Parms{};

	Parms.CookedData = std::move(CookedData);
	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelCookingLibrary.MakeVoxelCookingSettingsFromVoxelWorld
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelCookingSettings            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelCookingSettings UVoxelCookingLibrary::MakeVoxelCookingSettingsFromVoxelWorld(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelCookingLibrary", "MakeVoxelCookingSettingsFromVoxelWorld");

	Params::VoxelCookingLibrary_MakeVoxelCookingSettingsFromVoxelWorld Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelCubicLibrary.GetCubicVoxelPositionFromHit
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitNormal                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSelectVoxelOutside                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelCubicLibrary::GetCubicVoxelPositionFromHit(class AVoxelWorld* World, const struct FVector& HitPosition, const struct FVector& HitNormal, bool bSelectVoxelOutside)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelCubicLibrary", "GetCubicVoxelPositionFromHit");

	Params::VoxelCubicLibrary_GetCubicVoxelPositionFromHit Parms{};

	Parms.World = World;
	Parms.HitPosition = std::move(HitPosition);
	Parms.HitNormal = std::move(HitNormal);
	Parms.bSelectVoxelOutside = bSelectVoxelOutside;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelCubicLibrary.GetCubicVoxelValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelCubicLibrary::GetCubicVoxelValue(class AVoxelWorld* World, const struct FIntVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelCubicLibrary", "GetCubicVoxelValue");

	Params::VoxelCubicLibrary_GetCubicVoxelValue Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelCubicLibrary.SetCubicVoxelValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelCubicLibrary::SetCubicVoxelValue(class AVoxelWorld* World, const struct FIntVector& Position, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelCubicLibrary", "SetCubicVoxelValue");

	Params::VoxelCubicLibrary_SetCubicVoxelValue Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataAsset.GetBounds
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelDataAsset::GetBounds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelDataAsset", "GetBounds");

	Params::VoxelDataAsset_GetBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelDataAsset.GetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelDataAsset::GetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelDataAsset", "GetSize");

	Params::VoxelDataAsset_GetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelDataItemActor.K2_AddItemToWorld
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelDataItemActor::K2_AddItemToWorld(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelDataItemActor", "K2_AddItemToWorld");

	Params::VoxelDataItemActor_K2_AddItemToWorld Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataItemActor.ScheduleRefresh
// (Final, Native, Public, BlueprintCallable)

void AVoxelDataItemActor::ScheduleRefresh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelDataItemActor", "ScheduleRefresh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CacheMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CacheMaterials(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bMultiThreaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CacheMaterials");

	Params::VoxelDataTools_CacheMaterials Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bMultiThreaded = bMultiThreaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CacheMaterialsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CacheMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CacheMaterialsAsync");

	Params::VoxelDataTools_CacheMaterialsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CacheValues
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CacheValues(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bMultiThreaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CacheValues");

	Params::VoxelDataTools_CacheValues Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bMultiThreaded = bMultiThreaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CacheValuesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CacheValuesAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CacheValuesAsync");

	Params::VoxelDataTools_CacheValuesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CheckForSingleMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CheckForSingleMaterials(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CheckForSingleMaterials");

	Params::VoxelDataTools_CheckForSingleMaterials Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CheckForSingleMaterialsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CheckForSingleMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CheckForSingleMaterialsAsync");

	Params::VoxelDataTools_CheckForSingleMaterialsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CheckForSingleValues
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CheckForSingleValues(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CheckForSingleValues");

	Params::VoxelDataTools_CheckForSingleValues Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CheckForSingleValuesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CheckForSingleValuesAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CheckForSingleValuesAsync");

	Params::VoxelDataTools_CheckForSingleValuesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CheckIfSameAsGenerator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CheckIfSameAsGenerator(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CheckIfSameAsGenerator");

	Params::VoxelDataTools_CheckIfSameAsGenerator Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CheckIfSameAsGeneratorAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CheckIfSameAsGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CheckIfSameAsGeneratorAsync");

	Params::VoxelDataTools_CheckIfSameAsGeneratorAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.ClearCachedMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::ClearCachedMaterials(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "ClearCachedMaterials");

	Params::VoxelDataTools_ClearCachedMaterials Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.ClearCachedMaterialsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::ClearCachedMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "ClearCachedMaterialsAsync");

	Params::VoxelDataTools_ClearCachedMaterialsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.ClearCachedValues
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::ClearCachedValues(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "ClearCachedValues");

	Params::VoxelDataTools_ClearCachedValues Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.ClearCachedValuesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::ClearCachedValuesAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "ClearCachedValuesAsync");

	Params::VoxelDataTools_ClearCachedValuesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.ClearUnusedMaterials
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::ClearUnusedMaterials(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "ClearUnusedMaterials");

	Params::VoxelDataTools_ClearUnusedMaterials Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.ClearUnusedMaterialsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::ClearUnusedMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "ClearUnusedMaterialsAsync");

	Params::VoxelDataTools_ClearUnusedMaterialsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.CompressIntoHeightmap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelHeightmapAsset*             HeightmapAsset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHeightmapAssetMatchesWorld                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::CompressIntoHeightmap(class AVoxelWorld* World, class UVoxelHeightmapAsset* HeightmapAsset, bool bHeightmapAssetMatchesWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "CompressIntoHeightmap");

	Params::VoxelDataTools_CompressIntoHeightmap Parms{};

	Parms.World = World;
	Parms.HeightmapAsset = HeightmapAsset;
	Parms.bHeightmapAssetMatchesWorld = bHeightmapAssetMatchesWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.FindClosestNonEmptyVoxel
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVoxelFindClosestNonEmptyVoxelResultResult                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReadMaterial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::FindClosestNonEmptyVoxel(struct FVoxelFindClosestNonEmptyVoxelResult* Result, class AVoxelWorld* World, const struct FVector& Position, bool bReadMaterial, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "FindClosestNonEmptyVoxel");

	Params::VoxelDataTools_FindClosestNonEmptyVoxel Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.bReadMaterial = bReadMaterial;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Voxel.VoxelDataTools.FindClosestNonEmptyVoxelAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelFindClosestNonEmptyVoxelResultResult                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReadMaterial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::FindClosestNonEmptyVoxelAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelFindClosestNonEmptyVoxelResult* Result, class AVoxelWorld* World, const struct FVector& Position, bool bReadMaterial, bool bConvertToVoxelSpace, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "FindClosestNonEmptyVoxelAsync");

	Params::VoxelDataTools_FindClosestNonEmptyVoxelAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.bReadMaterial = bReadMaterial;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function Voxel.VoxelDataTools.GetCompressedSave
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelCompressedWorldSave        OutSave                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetCompressedSave(class AVoxelWorld* World, struct FVoxelCompressedWorldSave* OutSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetCompressedSave");

	Params::VoxelDataTools_GetCompressedSave Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSave != nullptr)
		*OutSave = std::move(Parms.OutSave);
}


// Function Voxel.VoxelDataTools.GetCompressedSaveAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelCompressedWorldSave        OutSave                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetCompressedSaveAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, struct FVoxelCompressedWorldSave* OutSave, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetCompressedSaveAsync");

	Params::VoxelDataTools_GetCompressedSaveAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSave != nullptr)
		*OutSave = std::move(Parms.OutSave);
}


// Function Voxel.VoxelDataTools.GetDataMemoryUsageInMB
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelDataMemoryUsageInMB        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelDataMemoryUsageInMB UVoxelDataTools::GetDataMemoryUsageInMB(class AVoxelWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetDataMemoryUsageInMB");

	Params::VoxelDataTools_GetDataMemoryUsageInMB Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelDataTools.GetInterpolatedValue
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetInterpolatedValue(float* Value, class AVoxelWorld* World, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetInterpolatedValue");

	Params::VoxelDataTools_GetInterpolatedValue Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Voxel.VoxelDataTools.GetMaterial
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVoxelMaterial                   Material                                               (Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetMaterial(struct FVoxelMaterial* Material, class AVoxelWorld* World, const struct FIntVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetMaterial");

	Params::VoxelDataTools_GetMaterial Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Material != nullptr)
		*Material = std::move(Parms.Material);
}


// Function Voxel.VoxelDataTools.GetMaterialAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelMaterial                   Material                                               (Parm, OutParm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetMaterialAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelMaterial* Material, class AVoxelWorld* World, const struct FIntVector& Position, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetMaterialAsync");

	Params::VoxelDataTools_GetMaterialAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Material != nullptr)
		*Material = std::move(Parms.Material);
}


// Function Voxel.VoxelDataTools.GetSave
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelUncompressedWorldSave      OutSave                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetSave(class AVoxelWorld* World, struct FVoxelUncompressedWorldSave* OutSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetSave");

	Params::VoxelDataTools_GetSave Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSave != nullptr)
		*OutSave = std::move(Parms.OutSave);
}


// Function Voxel.VoxelDataTools.GetSaveAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelUncompressedWorldSave      OutSave                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetSaveAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, struct FVoxelUncompressedWorldSave* OutSave, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetSaveAsync");

	Params::VoxelDataTools_GetSaveAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSave != nullptr)
		*OutSave = std::move(Parms.OutSave);
}


// Function Voxel.VoxelDataTools.GetValue
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetValue(float* Value, class AVoxelWorld* World, const struct FIntVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetValue");

	Params::VoxelDataTools_GetValue Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Voxel.VoxelDataTools.GetValueAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetValueAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float* Value, class AVoxelWorld* World, const struct FIntVector& Position, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetValueAsync");

	Params::VoxelDataTools_GetValueAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function Voxel.VoxelDataTools.GetVoxelsValueAndMaterial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVoxelValueMaterial>      Voxels                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntVector>               Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetVoxelsValueAndMaterial(TArray<struct FVoxelValueMaterial>* Voxels, class AVoxelWorld* World, const TArray<struct FIntVector>& Positions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetVoxelsValueAndMaterial");

	Params::VoxelDataTools_GetVoxelsValueAndMaterial Parms{};

	Parms.World = World;
	Parms.Positions = std::move(Positions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Voxels != nullptr)
		*Voxels = std::move(Parms.Voxels);
}


// Function Voxel.VoxelDataTools.GetVoxelsValueAndMaterialAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FVoxelValueMaterial>      Voxels                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntVector>               Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::GetVoxelsValueAndMaterialAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FVoxelValueMaterial>* Voxels, class AVoxelWorld* World, const TArray<struct FIntVector>& Positions, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "GetVoxelsValueAndMaterialAsync");

	Params::VoxelDataTools_GetVoxelsValueAndMaterialAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Positions = std::move(Positions);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Voxels != nullptr)
		*Voxels = std::move(Parms.Voxels);
}


// Function Voxel.VoxelDataTools.LoadFromCompressedSave
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelCompressedWorldSave        Save                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelDataTools::LoadFromCompressedSave(const class AVoxelWorld* World, const struct FVoxelCompressedWorldSave& Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "LoadFromCompressedSave");

	Params::VoxelDataTools_LoadFromCompressedSave Parms{};

	Parms.World = World;
	Parms.Save = std::move(Save);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelDataTools.LoadFromSave
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelUncompressedWorldSave      Save                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelDataTools::LoadFromSave(const class AVoxelWorld* World, const struct FVoxelUncompressedWorldSave& Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "LoadFromSave");

	Params::VoxelDataTools_LoadFromSave Parms{};

	Parms.World = World;
	Parms.Save = std::move(Save);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelDataTools.RoundToGenerator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreserveNormals                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::RoundToGenerator(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bPreserveNormals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "RoundToGenerator");

	Params::VoxelDataTools_RoundToGenerator Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bPreserveNormals = bPreserveNormals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.RoundToGeneratorAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPreserveNormals                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::RoundToGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bPreserveNormals, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "RoundToGeneratorAsync");

	Params::VoxelDataTools_RoundToGeneratorAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bPreserveNormals = bPreserveNormals;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.RoundVoxels
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::RoundVoxels(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "RoundVoxels");

	Params::VoxelDataTools_RoundVoxels Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.RoundVoxelsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::RoundVoxelsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "RoundVoxelsAsync");

	Params::VoxelDataTools_RoundVoxelsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.SetBoxAsDirty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDirtyValues                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDirtyMaterials                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::SetBoxAsDirty(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bDirtyValues, bool bDirtyMaterials)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "SetBoxAsDirty");

	Params::VoxelDataTools_SetBoxAsDirty Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bDirtyValues = bDirtyValues;
	Parms.bDirtyMaterials = bDirtyMaterials;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.SetBoxAsDirtyAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDirtyValues                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDirtyMaterials                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::SetBoxAsDirtyAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bDirtyValues, bool bDirtyMaterials, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "SetBoxAsDirtyAsync");

	Params::VoxelDataTools_SetBoxAsDirtyAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bDirtyValues = bDirtyValues;
	Parms.bDirtyMaterials = bDirtyMaterials;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.SetMaterial
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::SetMaterial(class AVoxelWorld* World, const struct FIntVector& Position, const struct FVoxelMaterial& Material, int32 Mask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "SetMaterial");

	Params::VoxelDataTools_SetMaterial Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.Material = std::move(Material);
	Parms.Mask = Mask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.SetMaterialAsync
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMaterial                   Material                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::SetMaterialAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FIntVector& Position, const struct FVoxelMaterial& Material, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "SetMaterialAsync");

	Params::VoxelDataTools_SetMaterialAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.Material = std::move(Material);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.SetValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::SetValue(class AVoxelWorld* World, const struct FIntVector& Position, float Value, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "SetValue");

	Params::VoxelDataTools_SetValue Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.Value = Value;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDataTools.SetValueAsync
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDataTools::SetValueAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FIntVector& Position, float Value, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDataTools", "SetValueAsync");

	Params::VoxelDataTools_SetValueAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.Value = Value;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDebugUtilities.DebugVoxelsInsideBounds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebugDensities                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDebugUtilities::DebugVoxelsInsideBounds(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, const struct FLinearColor& Color, float LifeTime, float Thickness, bool bDebugDensities, const struct FLinearColor& TextColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDebugUtilities", "DebugVoxelsInsideBounds");

	Params::VoxelDebugUtilities_DebugVoxelsInsideBounds Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.Color = std::move(Color);
	Parms.LifeTime = LifeTime;
	Parms.Thickness = Thickness;
	Parms.bDebugDensities = bDebugDensities;
	Parms.TextColor = std::move(TextColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDebugUtilities.DrawDataOctree
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelDataType                          DataType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowSingle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowCached                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           SingleColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           SingleDirtyColor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           CachedColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           DirtyColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDebugUtilities::DrawDataOctree(class AVoxelWorld* World, EVoxelDataType DataType, float LifeTime, bool bShowSingle, bool bShowCached, const struct FColor& SingleColor, const struct FColor& SingleDirtyColor, const struct FColor& CachedColor, const struct FColor& DirtyColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDebugUtilities", "DrawDataOctree");

	Params::VoxelDebugUtilities_DrawDataOctree Parms{};

	Parms.World = World;
	Parms.DataType = DataType;
	Parms.LifeTime = LifeTime;
	Parms.bShowSingle = bShowSingle;
	Parms.bShowCached = bShowCached;
	Parms.SingleColor = std::move(SingleColor);
	Parms.SingleDirtyColor = std::move(SingleDirtyColor);
	Parms.CachedColor = std::move(CachedColor);
	Parms.DirtyColor = std::move(DirtyColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelDebugUtilities.DrawDebugIntBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelDebugUtilities::DrawDebugIntBox(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, const struct FTransform& Transform, float LifeTime, float Thickness, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelDebugUtilities", "DrawDebugIntBox");

	Params::VoxelDebugUtilities_DrawDebugIntBox Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.Transform = std::move(Transform);
	Parms.LifeTime = LifeTime;
	Parms.Thickness = Thickness;
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelErosion.GetSedimentTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelFloatTexture UVoxelErosion::GetSedimentTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelErosion", "GetSedimentTexture");

	Params::VoxelErosion_GetSedimentTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelErosion.GetTerrainHeightTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelFloatTexture UVoxelErosion::GetTerrainHeightTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelErosion", "GetTerrainHeightTexture");

	Params::VoxelErosion_GetTerrainHeightTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelErosion.GetWaterHeightTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelFloatTexture UVoxelErosion::GetWaterHeightTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelErosion", "GetWaterHeightTexture");

	Params::VoxelErosion_GetWaterHeightTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelErosion.Initialize
// (Final, Native, Public, BlueprintCallable)

void UVoxelErosion::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelErosion", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelErosion.Step
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelErosion::Step(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelErosion", "Step");

	Params::VoxelErosion_Step Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelErosion.IsInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelErosion::IsInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelErosion", "IsInitialized");

	Params::VoxelErosion_IsInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.Deproject
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelToolTickData               TickData                                               (Parm, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPosition                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDirection                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelTool::Deproject(const struct FVoxelToolTickData& TickData, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "Deproject");

	Params::VoxelTool_Deproject Parms{};

	Parms.TickData = std::move(TickData);
	Parms.ScreenPosition = std::move(ScreenPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WorldPosition != nullptr)
		*WorldPosition = std::move(Parms.WorldPosition);

	if (WorldDirection != nullptr)
		*WorldDirection = std::move(Parms.WorldDirection);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.GetAxis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelToolTickData               TickData                                               (Parm, NativeAccessSpecifierPublic)
// class FName                             Axis                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelTool::GetAxis(const struct FVoxelToolTickData& TickData, class FName Axis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "GetAxis");

	Params::VoxelTool_GetAxis Parms{};

	Parms.TickData = std::move(TickData);
	Parms.Axis = Axis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.GetRayDirection
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelToolTickData               TickData                                               (Parm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelTool::GetRayDirection(const struct FVoxelToolTickData& TickData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "GetRayDirection");

	Params::VoxelTool_GetRayDirection Parms{};

	Parms.TickData = std::move(TickData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.GetRayOrigin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelToolTickData               TickData                                               (Parm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelTool::GetRayOrigin(const struct FVoxelToolTickData& TickData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "GetRayOrigin");

	Params::VoxelTool_GetRayOrigin Parms{};

	Parms.TickData = std::move(TickData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.IsAlternativeMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelToolTickData               TickData                                               (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelTool::IsAlternativeMode(const struct FVoxelToolTickData& TickData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "IsAlternativeMode");

	Params::VoxelTool_IsAlternativeMode Parms{};

	Parms.TickData = std::move(TickData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.IsKeyDown
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelToolTickData               TickData                                               (Parm, NativeAccessSpecifierPublic)
// class FName                             Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelTool::IsKeyDown(const struct FVoxelToolTickData& TickData, class FName Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "IsKeyDown");

	Params::VoxelTool_IsKeyDown Parms{};

	Parms.TickData = std::move(TickData);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.MakeToolAxes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   BrushSizeDelta                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FalloffDelta                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StrengthDelta                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, float>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, float> UVoxelTool::MakeToolAxes(float BrushSizeDelta, float FalloffDelta, float StrengthDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "MakeToolAxes");

	Params::VoxelTool_MakeToolAxes Parms{};

	Parms.BrushSizeDelta = BrushSizeDelta;
	Parms.FalloffDelta = FalloffDelta;
	Parms.StrengthDelta = StrengthDelta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.MakeToolKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bAlternativeMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, bool>                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, bool> UVoxelTool::MakeToolKeys(bool bAlternativeMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "MakeToolKeys");

	Params::VoxelTool_MakeToolKeys Parms{};

	Parms.bAlternativeMode = bAlternativeMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.MakeVoxelTool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UVoxelTool>           ToolClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelTool*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelTool* UVoxelTool::MakeVoxelTool(TSubclassOf<class UVoxelTool> ToolClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "MakeVoxelTool");

	Params::VoxelTool_MakeVoxelTool Parms{};

	Parms.ToolClass = ToolClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.MakeVoxelToolTickData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEdit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, bool>                 Keys                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<class FName, float>                Axes                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        MousePosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CameraDirection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelToolTickData               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelToolTickData UVoxelTool::MakeVoxelToolTickData(class APlayerController* PlayerController, bool bEdit, const TMap<class FName, bool>& Keys, const TMap<class FName, float>& Axes, const struct FVector2D& MousePosition, const struct FVector& CameraDirection, ECollisionChannel CollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTool", "MakeVoxelToolTickData");

	Params::VoxelTool_MakeVoxelToolTickData Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bEdit = bEdit;
	Parms.Keys = std::move(Keys);
	Parms.Axes = std::move(Axes);
	Parms.MousePosition = std::move(MousePosition);
	Parms.CameraDirection = std::move(CameraDirection);
	Parms.CollisionChannel = CollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.Apply
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, bool>                 Keys                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<class FName, float>                Axes                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UVoxelTool::Apply(class AVoxelWorld* World, const struct FVector& Position, const struct FVector& Normal, const TMap<class FName, bool>& Keys, const TMap<class FName, float>& Axes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelTool", "Apply");

	Params::VoxelTool_Apply Parms{};

	Parms.World = World;
	Parms.Position = std::move(Position);
	Parms.Normal = std::move(Normal);
	Parms.Keys = std::move(Keys);
	Parms.Axes = std::move(Axes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelTool.DisableTool
// (Native, Public, BlueprintCallable)

void UVoxelTool::DisableTool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelTool", "DisableTool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelTool.EnableTool
// (Native, Public, BlueprintCallable)

void UVoxelTool::EnableTool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelTool", "EnableTool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelTool.K2_AdvancedTick
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelToolTickData               TickData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FVector& Position, const struct FVector& Normal)>DoEditOverride                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

void UVoxelTool::K2_AdvancedTick(class UObject* WorldContextObject, const struct FVoxelToolTickData& TickData, const TDelegate<void(const struct FVector& Position, const struct FVector& Normal)>& DoEditOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelTool", "K2_AdvancedTick");

	Params::VoxelTool_K2_AdvancedTick Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TickData = std::move(TickData);
	Parms.DoEditOverride = DoEditOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelTool.K2_SimpleTick
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEdit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, bool>                 Keys                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TMap<class FName, float>                Axes                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FVector& Position, const struct FVector& Normal)>DoEditOverride                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelTool::K2_SimpleTick(class APlayerController* PlayerController, bool bEdit, const TMap<class FName, bool>& Keys, const TMap<class FName, float>& Axes, const TDelegate<void(const struct FVector& Position, const struct FVector& Normal)>& DoEditOverride, ECollisionChannel CollisionChannel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelTool", "K2_SimpleTick");

	Params::VoxelTool_K2_SimpleTick Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bEdit = bEdit;
	Parms.Keys = std::move(Keys);
	Parms.Axes = std::move(Axes);
	Parms.DoEditOverride = DoEditOverride;
	Parms.CollisionChannel = CollisionChannel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelTool.GetToolName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UVoxelTool::GetToolName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelTool", "GetToolName");

	Params::VoxelTool_GetToolName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTool.GetVoxelWorld
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AVoxelWorld*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVoxelWorld* UVoxelTool::GetVoxelWorld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelTool", "GetVoxelWorld");

	Params::VoxelTool_GetVoxelWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.K2_DoEdit
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FVoxelIntBoxWithValidity         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelIntBoxWithValidity UVoxelToolBase::K2_DoEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "K2_DoEdit");

	Params::VoxelToolBase_K2_DoEdit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.K2_Tick
// (Event, Public, BlueprintEvent)

void UVoxelToolBase::K2_Tick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "K2_Tick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Voxel.VoxelToolBase.K2_UpdateRender
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*         OverlayMaterialInstance                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         MeshMaterialInstance                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelToolBase::K2_UpdateRender(class UMaterialInstanceDynamic* OverlayMaterialInstance, class UMaterialInstanceDynamic* MeshMaterialInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "K2_UpdateRender");

	Params::VoxelToolBase_K2_UpdateRender Parms{};

	Parms.OverlayMaterialInstance = OverlayMaterialInstance;
	Parms.MeshMaterialInstance = MeshMaterialInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelToolBase.SetToolOverlayBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBox                             Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UVoxelToolBase::SetToolOverlayBounds(const struct FBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "SetToolOverlayBounds");

	Params::VoxelToolBase_SetToolOverlayBounds Parms{};

	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelToolBase.UpdateToolMesh
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      Mesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelToolBase::UpdateToolMesh(class UStaticMesh* Mesh, class UMaterialInterface* Material, const struct FTransform& Transform, class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "UpdateToolMesh");

	Params::VoxelToolBase_UpdateToolMesh Parms{};

	Parms.Mesh = Mesh;
	Parms.Material = Material;
	Parms.Transform = std::move(Transform);
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelToolBase.CanEdit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelToolBase::CanEdit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "CanEdit");

	Params::VoxelToolBase_CanEdit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetBoundsToCache
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelToolBase::GetBoundsToCache(const struct FVoxelIntBox& Bounds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetBoundsToCache");

	Params::VoxelToolBase_GetBoundsToCache Parms{};

	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetDeltaTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelToolBase::GetDeltaTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetDeltaTime");

	Params::VoxelToolBase_GetDeltaTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetLastFrameTickData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVoxelToolTickData         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FVoxelToolTickData UVoxelToolBase::GetLastFrameTickData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetLastFrameTickData");

	Params::VoxelToolBase_GetLastFrameTickData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetMouseMovementSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelToolBase::GetMouseMovementSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetMouseMovementSize");

	Params::VoxelToolBase_GetMouseMovementSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetTickData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVoxelToolTickData         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FVoxelToolTickData UVoxelToolBase::GetTickData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetTickData");

	Params::VoxelToolBase_GetTickData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetToolDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelToolBase::GetToolDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetToolDirection");

	Params::VoxelToolBase_GetToolDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetToolNormal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelToolBase::GetToolNormal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetToolNormal");

	Params::VoxelToolBase_GetToolNormal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetToolPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelToolBase::GetToolPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetToolPosition");

	Params::VoxelToolBase_GetToolPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetToolPreviewPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelToolBase::GetToolPreviewPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetToolPreviewPosition");

	Params::VoxelToolBase_GetToolPreviewPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.GetValueAfterAxisInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelToolBase::GetValueAfterAxisInput(class FName AxisName, float CurrentValue, float Min, float Max) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "GetValueAfterAxisInput");

	Params::VoxelToolBase_GetValueAfterAxisInput Parms{};

	Parms.AxisName = AxisName;
	Parms.CurrentValue = CurrentValue;
	Parms.Min = Min;
	Parms.Max = Max;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolBase.K2_GetToolConfig
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FVoxelToolBaseConfig             InConfig                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelToolBaseConfig             OutConfig                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoxelToolBase::K2_GetToolConfig(const struct FVoxelToolBaseConfig& InConfig, struct FVoxelToolBaseConfig* OutConfig) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "K2_GetToolConfig");

	Params::VoxelToolBase_K2_GetToolConfig Parms{};

	Parms.InConfig = std::move(InConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConfig != nullptr)
		*OutConfig = std::move(Parms.OutConfig);
}


// Function Voxel.VoxelToolBase.LastFrameCanEdit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelToolBase::LastFrameCanEdit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolBase", "LastFrameCanEdit");

	Params::VoxelToolBase_LastFrameCanEdit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorCache.MakeGeneratorInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVoxelGeneratorPicker            Picker                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelGeneratorInstanceWrapper*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelGeneratorInstanceWrapper* UVoxelGeneratorCache::MakeGeneratorInstance(const struct FVoxelGeneratorPicker& Picker) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelGeneratorCache", "MakeGeneratorInstance");

	Params::VoxelGeneratorCache_MakeGeneratorInstance Parms{};

	Parms.Picker = std::move(Picker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorCache.MakeTransformableGeneratorInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVoxelTransformableGeneratorPickerPicker                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelTransformableGeneratorInstanceWrapper*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelTransformableGeneratorInstanceWrapper* UVoxelGeneratorCache::MakeTransformableGeneratorInstance(const struct FVoxelTransformableGeneratorPicker& Picker) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelGeneratorCache", "MakeTransformableGeneratorInstance");

	Params::VoxelGeneratorCache_MakeTransformableGeneratorInstance Parms{};

	Parms.Picker = std::move(Picker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorInstanceWrapper.IsValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelGeneratorInstanceWrapper::IsValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelGeneratorInstanceWrapper", "IsValid");

	Params::VoxelGeneratorInstanceWrapper_IsValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTransformableGeneratorInstanceWrapper.IsValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelTransformableGeneratorInstanceWrapper::IsValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelTransformableGeneratorInstanceWrapper", "IsValid");

	Params::VoxelTransformableGeneratorInstanceWrapper_IsValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.CreateColorTextureFromGenerator
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelColorTexture               OutTexture                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// class UVoxelGeneratorInstanceWrapper*   Generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutputName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelGeneratorTools::CreateColorTextureFromGenerator(struct FVoxelColorTexture* OutTexture, class UVoxelGeneratorInstanceWrapper* Generator, class FName OutputName, int32 SizeX, int32 SizeY, float Scale, int32 StartX, int32 StartY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "CreateColorTextureFromGenerator");

	Params::VoxelGeneratorTools_CreateColorTextureFromGenerator Parms{};

	Parms.Generator = Generator;
	Parms.OutputName = OutputName;
	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;
	Parms.Scale = Scale;
	Parms.StartX = StartX;
	Parms.StartY = StartY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTexture != nullptr)
		*OutTexture = std::move(Parms.OutTexture);
}


// Function Voxel.VoxelGeneratorTools.CreateColorTextureFromGeneratorAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelColorTexture               OutTexture                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// class UVoxelGeneratorInstanceWrapper*   Generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutputName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelGeneratorTools::CreateColorTextureFromGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelColorTexture* OutTexture, class UVoxelGeneratorInstanceWrapper* Generator, class FName OutputName, int32 SizeX, int32 SizeY, float Scale, int32 StartX, int32 StartY, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "CreateColorTextureFromGeneratorAsync");

	Params::VoxelGeneratorTools_CreateColorTextureFromGeneratorAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Generator = Generator;
	Parms.OutputName = OutputName;
	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;
	Parms.Scale = Scale;
	Parms.StartX = StartX;
	Parms.StartY = StartY;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTexture != nullptr)
		*OutTexture = std::move(Parms.OutTexture);
}


// Function Voxel.VoxelGeneratorTools.CreateFloatTextureFromGenerator
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               OutTexture                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// class UVoxelGeneratorInstanceWrapper*   Generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutputName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelGeneratorTools::CreateFloatTextureFromGenerator(struct FVoxelFloatTexture* OutTexture, class UVoxelGeneratorInstanceWrapper* Generator, class FName OutputName, int32 SizeX, int32 SizeY, float Scale, int32 StartX, int32 StartY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "CreateFloatTextureFromGenerator");

	Params::VoxelGeneratorTools_CreateFloatTextureFromGenerator Parms{};

	Parms.Generator = Generator;
	Parms.OutputName = OutputName;
	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;
	Parms.Scale = Scale;
	Parms.StartX = StartX;
	Parms.StartY = StartY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTexture != nullptr)
		*OutTexture = std::move(Parms.OutTexture);
}


// Function Voxel.VoxelGeneratorTools.CreateFloatTextureFromGeneratorAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelFloatTexture               OutTexture                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// class UVoxelGeneratorInstanceWrapper*   Generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutputName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelGeneratorTools::CreateFloatTextureFromGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelFloatTexture* OutTexture, class UVoxelGeneratorInstanceWrapper* Generator, class FName OutputName, int32 SizeX, int32 SizeY, float Scale, int32 StartX, int32 StartY, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "CreateFloatTextureFromGeneratorAsync");

	Params::VoxelGeneratorTools_CreateFloatTextureFromGeneratorAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Generator = Generator;
	Parms.OutputName = OutputName;
	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;
	Parms.Scale = Scale;
	Parms.StartX = StartX;
	Parms.StartY = StartY;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTexture != nullptr)
		*OutTexture = std::move(Parms.OutTexture);
}


// Function Voxel.VoxelGeneratorTools.IsValid_GeneratorPicker
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelGeneratorPicker            GeneratorPicker                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelGeneratorTools::IsValid_GeneratorPicker(const struct FVoxelGeneratorPicker& GeneratorPicker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "IsValid_GeneratorPicker");

	Params::VoxelGeneratorTools_IsValid_GeneratorPicker Parms{};

	Parms.GeneratorPicker = std::move(GeneratorPicker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.IsValid_TransformableGeneratorPicker
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelTransformableGeneratorPickerGeneratorPicker                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelGeneratorTools::IsValid_TransformableGeneratorPicker(const struct FVoxelTransformableGeneratorPicker& GeneratorPicker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "IsValid_TransformableGeneratorPicker");

	Params::VoxelGeneratorTools_IsValid_TransformableGeneratorPicker Parms{};

	Parms.GeneratorPicker = std::move(GeneratorPicker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.MakeGeneratorInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelGeneratorPicker            GeneratorPicker                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelGeneratorInit              GeneratorInit                                          (Parm, NativeAccessSpecifierPublic)
// class UVoxelGeneratorInstanceWrapper*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelGeneratorInstanceWrapper* UVoxelGeneratorTools::MakeGeneratorInstance(const struct FVoxelGeneratorPicker& GeneratorPicker, const struct FVoxelGeneratorInit& GeneratorInit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "MakeGeneratorInstance");

	Params::VoxelGeneratorTools_MakeGeneratorInstance Parms{};

	Parms.GeneratorPicker = std::move(GeneratorPicker);
	Parms.GeneratorInit = std::move(GeneratorInit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.MakeGeneratorPickerFromClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UVoxelGenerator>      GeneratorClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelGeneratorPicker            ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelGeneratorPicker UVoxelGeneratorTools::MakeGeneratorPickerFromClass(TSubclassOf<class UVoxelGenerator> GeneratorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "MakeGeneratorPickerFromClass");

	Params::VoxelGeneratorTools_MakeGeneratorPickerFromClass Parms{};

	Parms.GeneratorClass = GeneratorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.MakeGeneratorPickerFromObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UVoxelGenerator*                  Generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelGeneratorPicker            ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelGeneratorPicker UVoxelGeneratorTools::MakeGeneratorPickerFromObject(class UVoxelGenerator* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "MakeGeneratorPickerFromObject");

	Params::VoxelGeneratorTools_MakeGeneratorPickerFromObject Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.MakeTransformableGeneratorInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelTransformableGeneratorPickerGeneratorPicker                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelGeneratorInit              GeneratorInit                                          (Parm, NativeAccessSpecifierPublic)
// class UVoxelTransformableGeneratorInstanceWrapper*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelTransformableGeneratorInstanceWrapper* UVoxelGeneratorTools::MakeTransformableGeneratorInstance(const struct FVoxelTransformableGeneratorPicker& GeneratorPicker, const struct FVoxelGeneratorInit& GeneratorInit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "MakeTransformableGeneratorInstance");

	Params::VoxelGeneratorTools_MakeTransformableGeneratorInstance Parms{};

	Parms.GeneratorPicker = std::move(GeneratorPicker);
	Parms.GeneratorInit = std::move(GeneratorInit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.MakeTransformableGeneratorPickerFromClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UVoxelTransformableGenerator>GeneratorClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelTransformableGeneratorPickerReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelTransformableGeneratorPicker UVoxelGeneratorTools::MakeTransformableGeneratorPickerFromClass(TSubclassOf<class UVoxelTransformableGenerator> GeneratorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "MakeTransformableGeneratorPickerFromClass");

	Params::VoxelGeneratorTools_MakeTransformableGeneratorPickerFromClass Parms{};

	Parms.GeneratorClass = GeneratorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.MakeTransformableGeneratorPickerFromObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UVoxelTransformableGenerator*     Generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelTransformableGeneratorPickerReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelTransformableGeneratorPicker UVoxelGeneratorTools::MakeTransformableGeneratorPickerFromObject(class UVoxelTransformableGenerator* Generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "MakeTransformableGeneratorPickerFromObject");

	Params::VoxelGeneratorTools_MakeTransformableGeneratorPickerFromObject Parms{};

	Parms.Generator = Generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.SetGeneratorParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelGeneratorPicker            Picker                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UniqueName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelGeneratorTools::SetGeneratorParameter(const struct FVoxelGeneratorPicker& Picker, class FName UniqueName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "SetGeneratorParameter");

	Params::VoxelGeneratorTools_SetGeneratorParameter Parms{};

	Parms.Picker = std::move(Picker);
	Parms.UniqueName = UniqueName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelGeneratorTools.SetTransformableGeneratorParameter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelTransformableGeneratorPickerPicker                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UniqueName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelGeneratorTools::SetTransformableGeneratorParameter(const struct FVoxelTransformableGeneratorPicker& Picker, class FName UniqueName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelGeneratorTools", "SetTransformableGeneratorParameter");

	Params::VoxelGeneratorTools_SetTransformableGeneratorParameter Parms{};

	Parms.Picker = std::move(Picker);
	Parms.UniqueName = UniqueName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelHeightmapAsset.GetHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelHeightmapAsset::GetHeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelHeightmapAsset", "GetHeight");

	Params::VoxelHeightmapAsset_GetHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelHeightmapAsset.GetWidth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelHeightmapAsset::GetWidth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelHeightmapAsset", "GetWidth");

	Params::VoxelHeightmapAsset_GetWidth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.AddBox
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     BoxToAdd                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::AddBox(const struct FVoxelIntBox& Box, const struct FVoxelIntBox& BoxToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "AddBox");

	Params::VoxelIntBoxLibrary_AddBox Parms{};

	Parms.Box = std::move(Box);
	Parms.BoxToAdd = std::move(BoxToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.AddPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Point                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::AddPoint(const struct FVoxelIntBox& Box, const struct FIntVector& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "AddPoint");

	Params::VoxelIntBoxLibrary_AddPoint Parms{};

	Parms.Box = std::move(Box);
	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.ApplyTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::ApplyTransform(const struct FVoxelIntBox& Box, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "ApplyTransform");

	Params::VoxelIntBoxLibrary_ApplyTransform Parms{};

	Parms.Box = std::move(Box);
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.BreakIntBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Min                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Max                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelIntBoxLibrary::BreakIntBox(const struct FVoxelIntBox& Box, struct FIntVector* Min, struct FIntVector* Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "BreakIntBox");

	Params::VoxelIntBoxLibrary_BreakIntBox Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Min != nullptr)
		*Min = std::move(Parms.Min);

	if (Max != nullptr)
		*Max = std::move(Parms.Max);
}


// Function Voxel.VoxelIntBoxLibrary.BreakIntBoxWithValidity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBoxWithValidity         BoxWithValidity                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Box                                                    (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsValid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelIntBoxLibrary::BreakIntBoxWithValidity(const struct FVoxelIntBoxWithValidity& BoxWithValidity, struct FVoxelIntBox* Box, bool* bIsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "BreakIntBoxWithValidity");

	Params::VoxelIntBoxLibrary_BreakIntBoxWithValidity Parms{};

	Parms.BoxWithValidity = std::move(BoxWithValidity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Box != nullptr)
		*Box = std::move(Parms.Box);

	if (bIsValid != nullptr)
		*bIsValid = Parms.bIsValid;
}


// Function Voxel.VoxelIntBoxLibrary.Center
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::Center(const struct FVoxelIntBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Center");

	Params::VoxelIntBoxLibrary_Center Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.Contains
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Other                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelIntBoxLibrary::Contains(const struct FVoxelIntBox& Box, const struct FVoxelIntBox& Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Contains");

	Params::VoxelIntBoxLibrary_Contains Parms{};

	Parms.Box = std::move(Box);
	Parms.Other = std::move(Other);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.Conv_IntBoxToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     IntBox                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UVoxelIntBoxLibrary::Conv_IntBoxToString(const struct FVoxelIntBox& IntBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Conv_IntBoxToString");

	Params::VoxelIntBoxLibrary_Conv_IntBoxToString Parms{};

	Parms.IntBox = std::move(IntBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.Conv_IntVectorToVoxelIntBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::Conv_IntVectorToVoxelIntBox(const struct FIntVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Conv_IntVectorToVoxelIntBox");

	Params::VoxelIntBoxLibrary_Conv_IntVectorToVoxelIntBox Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.EqualEqual_IntBoxIntBox
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     A                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     B                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelIntBoxLibrary::EqualEqual_IntBoxIntBox(const struct FVoxelIntBox& A, const struct FVoxelIntBox& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "EqualEqual_IntBoxIntBox");

	Params::VoxelIntBoxLibrary_EqualEqual_IntBoxIntBox Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.Extend
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::Extend(const struct FVoxelIntBox& Box, int32 Extent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Extend");

	Params::VoxelIntBoxLibrary_Extend Parms{};

	Parms.Box = std::move(Box);
	Parms.Extent = Extent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.Extend_IntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::Extend_IntVector(const struct FVoxelIntBox& Box, const struct FIntVector& Extent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Extend_IntVector");

	Params::VoxelIntBoxLibrary_Extend_IntVector Parms{};

	Parms.Box = std::move(Box);
	Parms.Extent = std::move(Extent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.GetCenter
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelIntBoxLibrary::GetCenter(const struct FVoxelIntBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "GetCenter");

	Params::VoxelIntBoxLibrary_GetCenter Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.GetCorners
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntVector>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FIntVector> UVoxelIntBoxLibrary::GetCorners(const struct FVoxelIntBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "GetCorners");

	Params::VoxelIntBoxLibrary_GetCorners Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.GetSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector UVoxelIntBoxLibrary::GetSize(const struct FVoxelIntBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "GetSize");

	Params::VoxelIntBoxLibrary_GetSize Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.InfiniteBox
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::InfiniteBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "InfiniteBox");

	Params::VoxelIntBoxLibrary_InfiniteBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.Intersect
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Other                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelIntBoxLibrary::Intersect(const struct FVoxelIntBox& Box, const struct FVoxelIntBox& Other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Intersect");

	Params::VoxelIntBoxLibrary_Intersect Parms{};

	Parms.Box = std::move(Box);
	Parms.Other = std::move(Other);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.IsIntVectorInsideBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelIntBoxLibrary::IsIntVectorInsideBox(const struct FVoxelIntBox& Box, const struct FIntVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "IsIntVectorInsideBox");

	Params::VoxelIntBoxLibrary_IsIntVectorInsideBox Parms{};

	Parms.Box = std::move(Box);
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.IsValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelIntBoxLibrary::IsValid(const struct FVoxelIntBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "IsValid");

	Params::VoxelIntBoxLibrary_IsValid Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.IsVectorInsideBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelIntBoxLibrary::IsVectorInsideBox(const struct FVoxelIntBox& Box, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "IsVectorInsideBox");

	Params::VoxelIntBoxLibrary_IsVectorInsideBox Parms{};

	Parms.Box = std::move(Box);
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.MakeBoxFromLocalPositionAndRadius
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::MakeBoxFromLocalPositionAndRadius(const struct FIntVector& Position, int32 Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "MakeBoxFromLocalPositionAndRadius");

	Params::VoxelIntBoxLibrary_MakeBoxFromLocalPositionAndRadius Parms{};

	Parms.Position = std::move(Position);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.MakeBoxFromPositionAndRadius
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::MakeBoxFromPositionAndRadius(const struct FVector& Position, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "MakeBoxFromPositionAndRadius");

	Params::VoxelIntBoxLibrary_MakeBoxFromPositionAndRadius Parms{};

	Parms.Position = std::move(Position);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.MakeIntBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector                       Min                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Max                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::MakeIntBox(const struct FIntVector& Min, const struct FIntVector& Max)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "MakeIntBox");

	Params::VoxelIntBoxLibrary_MakeIntBox Parms{};

	Parms.Min = std::move(Min);
	Parms.Max = std::move(Max);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.MakeIntBoxFromPoints
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>                  Points                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::MakeIntBoxFromPoints(const TArray<struct FVector>& Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "MakeIntBoxFromPoints");

	Params::VoxelIntBoxLibrary_MakeIntBoxFromPoints Parms{};

	Parms.Points = std::move(Points);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.MakeIntBoxWithValidity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsValid                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBoxWithValidity         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelIntBoxWithValidity UVoxelIntBoxLibrary::MakeIntBoxWithValidity(const struct FVoxelIntBox& Box, bool bIsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "MakeIntBoxWithValidity");

	Params::VoxelIntBoxLibrary_MakeIntBoxWithValidity Parms{};

	Parms.Box = std::move(Box);
	Parms.bIsValid = bIsValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.NotEqual_IntBoxIntBox
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     A                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     B                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelIntBoxLibrary::NotEqual_IntBoxIntBox(const struct FVoxelIntBox& A, const struct FVoxelIntBox& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "NotEqual_IntBoxIntBox");

	Params::VoxelIntBoxLibrary_NotEqual_IntBoxIntBox Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.Overlap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     A                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     B                                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::Overlap(const struct FVoxelIntBox& A, const struct FVoxelIntBox& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Overlap");

	Params::VoxelIntBoxLibrary_Overlap Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.RemoveTranslation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::RemoveTranslation(const struct FVoxelIntBox& Box)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "RemoveTranslation");

	Params::VoxelIntBoxLibrary_RemoveTranslation Parms{};

	Parms.Box = std::move(Box);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.Scale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Scale_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::Scale(const struct FVoxelIntBox& Box, int32 Scale_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "Scale");

	Params::VoxelIntBoxLibrary_Scale Parms{};

	Parms.Box = std::move(Box);
	Parms.Scale_0 = Scale_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelIntBoxLibrary.TranslateBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelIntBoxLibrary::TranslateBox(const struct FVoxelIntBox& Box, const struct FIntVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelIntBoxLibrary", "TranslateBox");

	Params::VoxelIntBoxLibrary_TranslateBox Parms{};

	Parms.Box = std::move(Box);
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelLevelTools.Level
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdditive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelLevelTools::Level(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Falloff, float Height, bool bAdditive, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelLevelTools", "Level");

	Params::VoxelLevelTools_Level Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Falloff = Falloff;
	Parms.Height = Height;
	Parms.bAdditive = bAdditive;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelLevelTools.LevelAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdditive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelLevelTools::LevelAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Falloff, float Height, bool bAdditive, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelLevelTools", "LevelAsync");

	Params::VoxelLevelTools_LevelAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Falloff = Falloff;
	Parms.Height = Height;
	Parms.bAdditive = bAdditive;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelMagicaVoxSceneActor.ApplyVoxelSize
// (Final, Native, Public, BlueprintCallable)

void AVoxelMagicaVoxSceneActor::ApplyVoxelSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelMagicaVoxSceneActor", "ApplyVoxelSize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelMagicaVoxSceneActor.SetScene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVoxelMagicaVoxScene*             Scene                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelMagicaVoxSceneActor::SetScene(class UVoxelMagicaVoxScene* Scene)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelMagicaVoxSceneActor", "SetScene");

	Params::VoxelMagicaVoxSceneActor_SetScene Parms{};

	Parms.Scene = Scene;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelMathLibrary.GetHalton1D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelHaltonStream               Stream                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoxelMathLibrary::GetHalton1D(const struct FVoxelHaltonStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMathLibrary", "GetHalton1D");

	Params::VoxelMathLibrary_GetHalton1D Parms{};

	Parms.Stream = std::move(Stream);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMathLibrary.GetHalton2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelHaltonStream               Stream                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UVoxelMathLibrary::GetHalton2D(const struct FVoxelHaltonStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMathLibrary", "GetHalton2D");

	Params::VoxelMathLibrary_GetHalton2D Parms{};

	Parms.Stream = std::move(Stream);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMathLibrary.GetHalton3D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelHaltonStream               Stream                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelMathLibrary::GetHalton3D(const struct FVoxelHaltonStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMathLibrary", "GetHalton3D");

	Params::VoxelMathLibrary_GetHalton3D Parms{};

	Parms.Stream = std::move(Stream);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMathLibrary.GetUnitVectorFromRandom
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Random                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelMathLibrary::GetUnitVectorFromRandom(const struct FVector2D& Random)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMathLibrary", "GetUnitVectorFromRandom");

	Params::VoxelMathLibrary_GetUnitVectorFromRandom Parms{};

	Parms.Random = std::move(Random);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMathLibrary.MakeHaltonStream
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   InitialSeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelHaltonStream               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FVoxelHaltonStream UVoxelMathLibrary::MakeHaltonStream(int32 InitialSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMathLibrary", "MakeHaltonStream");

	Params::VoxelMathLibrary_MakeHaltonStream Parms{};

	Parms.InitialSeed = InitialSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMathLibrary.ResetHaltonStream
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelHaltonStream               Stream                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoxelMathLibrary::ResetHaltonStream(const struct FVoxelHaltonStream& Stream)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMathLibrary", "ResetHaltonStream");

	Params::VoxelMathLibrary_ResetHaltonStream Parms{};

	Parms.Stream = std::move(Stream);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelMeshImporterLibrary.ConvertMeshToVoxels
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelMeshImporterInputData*      Mesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSubtractive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMeshImporterSettings       Settings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelMeshImporterRenderTargetCacheRenderTargetCache                                      (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UVoxelDataAsset*                  Asset                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLeaks                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelMeshImporterLibrary::ConvertMeshToVoxels(class UObject* WorldContextObject, class UVoxelMeshImporterInputData* Mesh, const struct FTransform& Transform, bool bSubtractive, const struct FVoxelMeshImporterSettings& Settings, struct FVoxelMeshImporterRenderTargetCache& RenderTargetCache, class UVoxelDataAsset** Asset, int32* NumLeaks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMeshImporterLibrary", "ConvertMeshToVoxels");

	Params::VoxelMeshImporterLibrary_ConvertMeshToVoxels Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Mesh = Mesh;
	Parms.Transform = std::move(Transform);
	Parms.bSubtractive = bSubtractive;
	Parms.Settings = std::move(Settings);
	Parms.RenderTargetCache = std::move(RenderTargetCache);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	RenderTargetCache = std::move(Parms.RenderTargetCache);

	if (Asset != nullptr)
		*Asset = Parms.Asset;

	if (NumLeaks != nullptr)
		*NumLeaks = Parms.NumLeaks;
}


// Function Voxel.VoxelMeshImporterLibrary.ConvertMeshToVoxels_NoMaterials
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelMeshImporterInputData*      Mesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSubtractive                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelMeshImporterSettingsBase   Settings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UVoxelDataAsset*                  Asset                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumLeaks                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelMeshImporterLibrary::ConvertMeshToVoxels_NoMaterials(class UObject* WorldContextObject, class UVoxelMeshImporterInputData* Mesh, const struct FTransform& Transform, bool bSubtractive, const struct FVoxelMeshImporterSettingsBase& Settings, class UVoxelDataAsset** Asset, int32* NumLeaks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMeshImporterLibrary", "ConvertMeshToVoxels_NoMaterials");

	Params::VoxelMeshImporterLibrary_ConvertMeshToVoxels_NoMaterials Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Mesh = Mesh;
	Parms.Transform = std::move(Transform);
	Parms.bSubtractive = bSubtractive;
	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Asset != nullptr)
		*Asset = Parms.Asset;

	if (NumLeaks != nullptr)
		*NumLeaks = Parms.NumLeaks;
}


// Function Voxel.VoxelMeshImporterLibrary.CreateMeshDataFromStaticMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVoxelMeshImporterInputData*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelMeshImporterInputData* UVoxelMeshImporterLibrary::CreateMeshDataFromStaticMesh(class UStaticMesh* StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMeshImporterLibrary", "CreateMeshDataFromStaticMesh");

	Params::VoxelMeshImporterLibrary_CreateMeshDataFromStaticMesh Parms{};

	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMeshImporterLibrary.CreateTextureFromMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* UVoxelMeshImporterLibrary::CreateTextureFromMaterial(class UObject* WorldContextObject, class UMaterialInterface* Material, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelMeshImporterLibrary", "CreateTextureFromMaterial");

	Params::VoxelMeshImporterLibrary_CreateTextureFromMaterial Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Material = Material;
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMultiplayerTcpInterface.ConnectToServer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           OutError                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelMultiplayerTcpInterface::ConnectToServer(class FString* OutError, const class FString& IP, int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelMultiplayerTcpInterface", "ConnectToServer");

	Params::VoxelMultiplayerTcpInterface_ConnectToServer Parms{};

	Parms.IP = std::move(IP);
	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutError != nullptr)
		*OutError = std::move(Parms.OutError);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelMultiplayerTcpInterface.StartServer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           OutError                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelMultiplayerTcpInterface::StartServer(class FString* OutError, const class FString& IP, int32 Port)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelMultiplayerTcpInterface", "StartServer");

	Params::VoxelMultiplayerTcpInterface_StartServer Parms{};

	Parms.IP = std::move(IP);
	Parms.Port = Port;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutError != nullptr)
		*OutError = std::move(Parms.OutError);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelNoClippingComponent.ShouldUseVoxelWorld
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelNoClippingComponent::ShouldUseVoxelWorld(class AVoxelWorld* VoxelWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelNoClippingComponent", "ShouldUseVoxelWorld");

	Params::VoxelNoClippingComponent_ShouldUseVoxelWorld Parms{};

	Parms.VoxelWorld = VoxelWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelPhysicsTools.ApplyVoxelPhysics
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<TScriptInterface<class IVoxelPhysicsPartSpawnerResult>>Results                                                (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TScriptInterface<class IVoxelPhysicsPartSpawner>PartSpawner                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// int32                                   MinParts                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelPartType                          PhysicsType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelPhysicsTools::ApplyVoxelPhysics(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<TScriptInterface<class IVoxelPhysicsPartSpawnerResult>>* Results, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, TScriptInterface<class IVoxelPhysicsPartSpawner> PartSpawner, int32 MinParts, bool bDebug, bool bHideLatentWarnings, EVoxelPartType PhysicsType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelPhysicsTools", "ApplyVoxelPhysics");

	Params::VoxelPhysicsTools_ApplyVoxelPhysics Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.PartSpawner = PartSpawner;
	Parms.MinParts = MinParts;
	Parms.bDebug = bDebug;
	Parms.bHideLatentWarnings = bHideLatentWarnings;
	Parms.PhysicsType = PhysicsType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function Voxel.VoxelWorld.CreateMultiplayerInterfaceInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVoxelMultiplayerInterface*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelMultiplayerInterface* AVoxelWorld::CreateMultiplayerInterfaceInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "CreateMultiplayerInterfaceInstance");

	Params::VoxelWorld_CreateMultiplayerInterfaceInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.CreateWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVoxelWorldCreateInfo            Info                                                   (Parm, NativeAccessSpecifierPublic)

void AVoxelWorld::CreateWorld(const struct FVoxelWorldCreateInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "CreateWorld");

	Params::VoxelWorld_CreateWorld Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelWorld.DestroyWorld
// (Final, Native, Public, BlueprintCallable)

void AVoxelWorld::DestroyWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "DestroyWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelWorld.SetCollisionResponseToChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECollisionChannel                       Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionResponse                      NewResponse                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelWorld::SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse NewResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "SetCollisionResponseToChannel");

	Params::VoxelWorld_SetCollisionResponseToChannel Parms{};

	Parms.Channel = Channel;
	Parms.NewResponse = NewResponse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelWorld.SetGeneratorClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UVoxelGenerator>      NewGeneratorClass                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelWorld::SetGeneratorClass(TSubclassOf<class UVoxelGenerator> NewGeneratorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "SetGeneratorClass");

	Params::VoxelWorld_SetGeneratorClass Parms{};

	Parms.NewGeneratorClass = NewGeneratorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelWorld.SetGeneratorObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVoxelGenerator*                  NewGenerator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelWorld::SetGeneratorObject(class UVoxelGenerator* NewGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "SetGeneratorObject");

	Params::VoxelWorld_SetGeneratorObject Parms{};

	Parms.NewGenerator = NewGenerator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelWorld.SetRenderOctreeDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewDepth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelWorld::SetRenderOctreeDepth(int32 NewDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "SetRenderOctreeDepth");

	Params::VoxelWorld_SetRenderOctreeDepth Parms{};

	Parms.NewDepth = NewDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelWorld.SetWorldSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewWorldSizeInVoxels                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelWorld::SetWorldSize(int32 NewWorldSizeInVoxels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "SetWorldSize");

	Params::VoxelWorld_SetWorldSize Parms{};

	Parms.NewWorldSizeInVoxels = NewWorldSizeInVoxels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelWorld.ApplyCollisionSettingsToRoot
// (Final, Native, Public, BlueprintCallable, Const)

void AVoxelWorld::ApplyCollisionSettingsToRoot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "ApplyCollisionSettingsToRoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelWorld.GetGeneratorCache
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVoxelGeneratorCache*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelGeneratorCache* AVoxelWorld::GetGeneratorCache() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "GetGeneratorCache");

	Params::VoxelWorld_GetGeneratorCache Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.GetGeneratorInit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVoxelGeneratorInit              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelGeneratorInit AVoxelWorld::GetGeneratorInit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "GetGeneratorInit");

	Params::VoxelWorld_GetGeneratorInit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.GetMultiplayerInterfaceInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVoxelMultiplayerInterface*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelMultiplayerInterface* AVoxelWorld::GetMultiplayerInterfaceInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "GetMultiplayerInterfaceInstance");

	Params::VoxelWorld_GetMultiplayerInterfaceInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.GetNeighboringPositions
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          GlobalPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIntVector>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FIntVector> AVoxelWorld::GetNeighboringPositions(const struct FVector& GlobalPosition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "GetNeighboringPositions");

	Params::VoxelWorld_GetNeighboringPositions Parms{};

	Parms.GlobalPosition = std::move(GlobalPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.IsCreated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVoxelWorld::IsCreated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "IsCreated");

	Params::VoxelWorld_IsCreated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.IsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVoxelWorld::IsLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "IsLoaded");

	Params::VoxelWorld_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.K2_GlobalToLocal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelWorldCoordinatesRounding          Rounding                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntVector AVoxelWorld::K2_GlobalToLocal(const struct FVector& Position, EVoxelWorldCoordinatesRounding Rounding) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "K2_GlobalToLocal");

	Params::VoxelWorld_K2_GlobalToLocal Parms{};

	Parms.Position = std::move(Position);
	Parms.Rounding = Rounding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.K2_GlobalToLocalBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox AVoxelWorld::K2_GlobalToLocalBounds(const struct FBox& Bounds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "K2_GlobalToLocalBounds");

	Params::VoxelWorld_K2_GlobalToLocalBounds Parms{};

	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.K2_GlobalToLocalFloat
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AVoxelWorld::K2_GlobalToLocalFloat(const struct FVector& Position) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "K2_GlobalToLocalFloat");

	Params::VoxelWorld_K2_GlobalToLocalFloat Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.K2_LocalToGlobal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntVector                       Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AVoxelWorld::K2_LocalToGlobal(const struct FIntVector& Position) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "K2_LocalToGlobal");

	Params::VoxelWorld_K2_LocalToGlobal Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.K2_LocalToGlobalBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVoxelIntBox                     Bounds                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox AVoxelWorld::K2_LocalToGlobalBounds(const struct FVoxelIntBox& Bounds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "K2_LocalToGlobalBounds");

	Params::VoxelWorld_K2_LocalToGlobalBounds Parms{};

	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelWorld.K2_LocalToGlobalFloat
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AVoxelWorld::K2_LocalToGlobalFloat(const struct FVector& Position) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorld", "K2_LocalToGlobalFloat");

	Params::VoxelWorld_K2_LocalToGlobalFloat Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelPlaceableItemManager.AddDataItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVoxelDataItemConstructionInfo   Info                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelPlaceableItemManager::AddDataItem(const struct FVoxelDataItemConstructionInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelPlaceableItemManager", "AddDataItem");

	Params::VoxelPlaceableItemManager_AddDataItem Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelPlaceableItemManager.DrawDebugLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelPlaceableItemManager::DrawDebugLine(const struct FVector& Start, const struct FVector& End, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelPlaceableItemManager", "DrawDebugLine");

	Params::VoxelPlaceableItemManager_DrawDebugLine Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelPlaceableItemManager.DrawDebugPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelPlaceableItemManager::DrawDebugPoint(const struct FVector& Position, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelPlaceableItemManager", "DrawDebugPoint");

	Params::VoxelPlaceableItemManager_DrawDebugPoint Parms{};

	Parms.Position = std::move(Position);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelPlaceableItemManager.OnClear
// (Native, Event, Public, BlueprintEvent)

void UVoxelPlaceableItemManager::OnClear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelPlaceableItemManager", "OnClear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelPlaceableItemManager.OnGenerate
// (Native, Event, Public, BlueprintEvent)

void UVoxelPlaceableItemManager::OnGenerate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelPlaceableItemManager", "OnGenerate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelPlaceableItemManager.GetGeneratorCache
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVoxelGeneratorCache*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelGeneratorCache* UVoxelPlaceableItemManager::GetGeneratorCache() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelPlaceableItemManager", "GetGeneratorCache");

	Params::VoxelPlaceableItemManager_GetGeneratorCache Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelPlaceableItemsUtilities.AddWorms
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(const struct FVector& Start, const struct FVector& End, float Radius)>AddWorm                                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelPerlinWormsSettings        Settings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UVoxelPlaceableItemsUtilities::AddWorms(TDelegate<void(const struct FVector& Start, const struct FVector& End, float Radius)> AddWorm, const struct FVoxelPerlinWormsSettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelPlaceableItemsUtilities", "AddWorms");

	Params::VoxelPlaceableItemsUtilities_AddWorms Parms{};

	Parms.AddWorm = AddWorm;
	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelProceduralMeshComponent.AreVoxelCollisionsFrozen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      VoxelWorld                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelProceduralMeshComponent::AreVoxelCollisionsFrozen(const class AVoxelWorld* VoxelWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProceduralMeshComponent", "AreVoxelCollisionsFrozen");

	Params::VoxelProceduralMeshComponent_AreVoxelCollisionsFrozen Parms{};

	Parms.VoxelWorld = VoxelWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelProceduralMeshComponent.SetVoxelCollisionsFrozen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      VoxelWorld                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFrozen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelProceduralMeshComponent::SetVoxelCollisionsFrozen(const class AVoxelWorld* VoxelWorld, bool bFrozen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProceduralMeshComponent", "SetVoxelCollisionsFrozen");

	Params::VoxelProceduralMeshComponent_SetVoxelCollisionsFrozen Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.bFrozen = bFrozen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelProceduralMeshComponent.InitChunk
// (Event, Public, BlueprintEvent)
// Parameters:
// uint8                                   ChunkLOD                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ChunkBounds                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelProceduralMeshComponent::InitChunk(uint8 ChunkLOD, const struct FVoxelIntBox& ChunkBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelProceduralMeshComponent", "InitChunk");

	Params::VoxelProceduralMeshComponent_InitChunk Parms{};

	Parms.ChunkLOD = ChunkLOD;
	Parms.ChunkBounds = std::move(ChunkBounds);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Voxel.VoxelProjectionTools.CreateSurfaceVoxelsFromHits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVoxelProjectionHit>      Hits                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsVoxels         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsVoxels UVoxelProjectionTools::CreateSurfaceVoxelsFromHits(const TArray<struct FVoxelProjectionHit>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProjectionTools", "CreateSurfaceVoxelsFromHits");

	Params::VoxelProjectionTools_CreateSurfaceVoxelsFromHits Parms{};

	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelProjectionTools.CreateSurfaceVoxelsFromHitsWithExactValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVoxelProjectionHit>      Hits                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsVoxels         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsVoxels UVoxelProjectionTools::CreateSurfaceVoxelsFromHitsWithExactValues(class AVoxelWorld* World, const TArray<struct FVoxelProjectionHit>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProjectionTools", "CreateSurfaceVoxelsFromHitsWithExactValues");

	Params::VoxelProjectionTools_CreateSurfaceVoxelsFromHitsWithExactValues Parms{};

	Parms.World = World;
	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelProjectionTools.FindProjectionVoxels
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVoxelProjectionHit>      Hits                                                   (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelLineTraceParameters        Parameters                                             (Parm, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelProjectionShape                   Shape                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NumRays                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelProjectionTools::FindProjectionVoxels(TArray<struct FVoxelProjectionHit>* Hits, class AVoxelWorld* World, const struct FVoxelLineTraceParameters& Parameters, const struct FVector& Position, const struct FVector& Direction, float Radius, EVoxelProjectionShape Shape, float NumRays, float MaxDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProjectionTools", "FindProjectionVoxels");

	Params::VoxelProjectionTools_FindProjectionVoxels Parms{};

	Parms.World = World;
	Parms.Parameters = std::move(Parameters);
	Parms.Position = std::move(Position);
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;
	Parms.Shape = Shape;
	Parms.NumRays = NumRays;
	Parms.MaxDistance = MaxDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hits != nullptr)
		*Hits = std::move(Parms.Hits);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelProjectionTools.FindProjectionVoxelsAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FVoxelProjectionHit>      Hits                                                   (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelLineTraceParameters        Parameters                                             (Parm, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelProjectionShape                   Shape                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NumRays                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoxelProjectionTools::FindProjectionVoxelsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FVoxelProjectionHit>* Hits, class AVoxelWorld* World, const struct FVoxelLineTraceParameters& Parameters, const struct FVector& Position, const struct FVector& Direction, float Radius, EVoxelProjectionShape Shape, float NumRays, float MaxDistance, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProjectionTools", "FindProjectionVoxelsAsync");

	Params::VoxelProjectionTools_FindProjectionVoxelsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Parameters = std::move(Parameters);
	Parms.Position = std::move(Position);
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;
	Parms.Shape = Shape;
	Parms.NumRays = NumRays;
	Parms.MaxDistance = MaxDistance;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hits != nullptr)
		*Hits = std::move(Parms.Hits);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelProjectionTools.GetHitsAverageNormal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVoxelProjectionHit>      Hits                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelProjectionTools::GetHitsAverageNormal(const TArray<struct FVoxelProjectionHit>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProjectionTools", "GetHitsAverageNormal");

	Params::VoxelProjectionTools_GetHitsAverageNormal Parms{};

	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelProjectionTools.GetHitsAveragePosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FVoxelProjectionHit>      Hits                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UVoxelProjectionTools::GetHitsAveragePosition(const TArray<struct FVoxelProjectionHit>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProjectionTools", "GetHitsAveragePosition");

	Params::VoxelProjectionTools_GetHitsAveragePosition Parms{};

	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelProjectionTools.GetHitsPositions
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVoxelProjectionHit>      Hits                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FIntVector>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FIntVector> UVoxelProjectionTools::GetHitsPositions(const TArray<struct FVoxelProjectionHit>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProjectionTools", "GetHitsPositions");

	Params::VoxelProjectionTools_GetHitsPositions Parms{};

	Parms.Hits = std::move(Hits);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelProjectionTools.MakeVoxelLineTraceParameters
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<ECollisionChannel>               CollisionChannelsToIgnore                              (Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TraceHitColor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelLineTraceParameters        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelLineTraceParameters UVoxelProjectionTools::MakeVoxelLineTraceParameters(const TArray<ECollisionChannel>& CollisionChannelsToIgnore, const TArray<class AActor*>& ActorsToIgnore, ECollisionChannel CollisionChannel, EDrawDebugTrace DrawDebugType, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelProjectionTools", "MakeVoxelLineTraceParameters");

	Params::VoxelProjectionTools_MakeVoxelLineTraceParameters Parms{};

	Parms.CollisionChannelsToIgnore = std::move(CollisionChannelsToIgnore);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.CollisionChannel = CollisionChannel;
	Parms.DrawDebugType = DrawDebugType;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSaveUtilities.CompressVoxelSave
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelUncompressedWorldSave      UncompressedSave                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVoxelCompressedWorldSave        OutCompressedSave                                      (Parm, OutParm, NativeAccessSpecifierPublic)

void UVoxelSaveUtilities::CompressVoxelSave(const struct FVoxelUncompressedWorldSave& UncompressedSave, struct FVoxelCompressedWorldSave* OutCompressedSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSaveUtilities", "CompressVoxelSave");

	Params::VoxelSaveUtilities_CompressVoxelSave Parms{};

	Parms.UncompressedSave = std::move(UncompressedSave);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCompressedSave != nullptr)
		*OutCompressedSave = std::move(Parms.OutCompressedSave);
}


// Function Voxel.VoxelSaveUtilities.DecompressVoxelSave
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelCompressedWorldSave        CompressedSave                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVoxelUncompressedWorldSave      OutUncompressedSave                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoxelSaveUtilities::DecompressVoxelSave(const struct FVoxelCompressedWorldSave& CompressedSave, struct FVoxelUncompressedWorldSave* OutUncompressedSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSaveUtilities", "DecompressVoxelSave");

	Params::VoxelSaveUtilities_DecompressVoxelSave Parms{};

	Parms.CompressedSave = std::move(CompressedSave);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUncompressedSave != nullptr)
		*OutUncompressedSave = std::move(Parms.OutUncompressedSave);

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSphereTools.AddSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::AddSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "AddSphere");

	Params::VoxelSphereTools_AddSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.AddSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::AddSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "AddSphereAsync");

	Params::VoxelSphereTools_AddSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.ApplyKernelSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CenterMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FirstDegreeNeighborMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SecondDegreeNeighborMultiplier                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ThirdDegreeNeighborMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::ApplyKernelSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float CenterMultiplier, float FirstDegreeNeighborMultiplier, float SecondDegreeNeighborMultiplier, float ThirdDegreeNeighborMultiplier, int32 NumIterations, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "ApplyKernelSphere");

	Params::VoxelSphereTools_ApplyKernelSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.CenterMultiplier = CenterMultiplier;
	Parms.FirstDegreeNeighborMultiplier = FirstDegreeNeighborMultiplier;
	Parms.SecondDegreeNeighborMultiplier = SecondDegreeNeighborMultiplier;
	Parms.ThirdDegreeNeighborMultiplier = ThirdDegreeNeighborMultiplier;
	Parms.NumIterations = NumIterations;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.ApplyKernelSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CenterMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FirstDegreeNeighborMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SecondDegreeNeighborMultiplier                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ThirdDegreeNeighborMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::ApplyKernelSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float CenterMultiplier, float FirstDegreeNeighborMultiplier, float SecondDegreeNeighborMultiplier, float ThirdDegreeNeighborMultiplier, int32 NumIterations, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "ApplyKernelSphereAsync");

	Params::VoxelSphereTools_ApplyKernelSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.CenterMultiplier = CenterMultiplier;
	Parms.FirstDegreeNeighborMultiplier = FirstDegreeNeighborMultiplier;
	Parms.SecondDegreeNeighborMultiplier = SecondDegreeNeighborMultiplier;
	Parms.ThirdDegreeNeighborMultiplier = ThirdDegreeNeighborMultiplier;
	Parms.NumIterations = NumIterations;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.ApplyMaterialKernelSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CenterMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FirstDegreeNeighborMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SecondDegreeNeighborMultiplier                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ThirdDegreeNeighborMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::ApplyMaterialKernelSphere(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float CenterMultiplier, float FirstDegreeNeighborMultiplier, float SecondDegreeNeighborMultiplier, float ThirdDegreeNeighborMultiplier, int32 NumIterations, int32 Mask, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "ApplyMaterialKernelSphere");

	Params::VoxelSphereTools_ApplyMaterialKernelSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.CenterMultiplier = CenterMultiplier;
	Parms.FirstDegreeNeighborMultiplier = FirstDegreeNeighborMultiplier;
	Parms.SecondDegreeNeighborMultiplier = SecondDegreeNeighborMultiplier;
	Parms.ThirdDegreeNeighborMultiplier = ThirdDegreeNeighborMultiplier;
	Parms.NumIterations = NumIterations;
	Parms.Mask = Mask;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.ApplyMaterialKernelSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CenterMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FirstDegreeNeighborMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SecondDegreeNeighborMultiplier                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ThirdDegreeNeighborMultiplier                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::ApplyMaterialKernelSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float CenterMultiplier, float FirstDegreeNeighborMultiplier, float SecondDegreeNeighborMultiplier, float ThirdDegreeNeighborMultiplier, int32 NumIterations, int32 Mask, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "ApplyMaterialKernelSphereAsync");

	Params::VoxelSphereTools_ApplyMaterialKernelSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.CenterMultiplier = CenterMultiplier;
	Parms.FirstDegreeNeighborMultiplier = FirstDegreeNeighborMultiplier;
	Parms.SecondDegreeNeighborMultiplier = SecondDegreeNeighborMultiplier;
	Parms.ThirdDegreeNeighborMultiplier = ThirdDegreeNeighborMultiplier;
	Parms.NumIterations = NumIterations;
	Parms.Mask = Mask;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RemoveCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RemoveCapsule(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FRotator& Rotation, float Radius, float HalfHeight, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RemoveCapsule");

	Params::VoxelSphereTools_RemoveCapsule Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RemoveCapsuleAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RemoveCapsuleAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FRotator& Rotation, float Radius, float HalfHeight, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RemoveCapsuleAsync");

	Params::VoxelSphereTools_RemoveCapsuleAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RemoveSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RemoveSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RemoveSphere");

	Params::VoxelSphereTools_RemoveSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RemoveSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RemoveSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RemoveSphereAsync");

	Params::VoxelSphereTools_RemoveSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RemoveSphereWithDurability
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelInt32Interval              Interval                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RemoveSphereWithDurability(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, const struct FVoxelInt32Interval& Interval, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RemoveSphereWithDurability");

	Params::VoxelSphereTools_RemoveSphereWithDurability Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Interval = std::move(Interval);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RemoveSphereWithDurabilityAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelInt32Interval              Interval                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RemoveSphereWithDurabilityAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, const struct FVoxelInt32Interval& Interval, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RemoveSphereWithDurabilityAsync");

	Params::VoxelSphereTools_RemoveSphereWithDurabilityAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Interval = std::move(Interval);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RevertSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HistoryPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRevertValues                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRevertMaterials                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RevertSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, int32 HistoryPosition, bool bRevertValues, bool bRevertMaterials, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RevertSphere");

	Params::VoxelSphereTools_RevertSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.HistoryPosition = HistoryPosition;
	Parms.bRevertValues = bRevertValues;
	Parms.bRevertMaterials = bRevertMaterials;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RevertSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HistoryPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRevertValues                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRevertMaterials                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RevertSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, int32 HistoryPosition, bool bRevertValues, bool bRevertMaterials, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RevertSphereAsync");

	Params::VoxelSphereTools_RevertSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.HistoryPosition = HistoryPosition;
	Parms.bRevertValues = bRevertValues;
	Parms.bRevertMaterials = bRevertMaterials;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RevertSphereToGenerator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRevertValues                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRevertMaterials                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RevertSphereToGenerator(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bRevertValues, bool bRevertMaterials, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RevertSphereToGenerator");

	Params::VoxelSphereTools_RevertSphereToGenerator Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.bRevertValues = bRevertValues;
	Parms.bRevertMaterials = bRevertMaterials;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.RevertSphereToGeneratorAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRevertValues                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRevertMaterials                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::RevertSphereToGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bRevertValues, bool bRevertMaterials, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "RevertSphereToGeneratorAsync");

	Params::VoxelSphereTools_RevertSphereToGeneratorAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.bRevertValues = bRevertValues;
	Parms.bRevertMaterials = bRevertMaterials;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SetMaterialInCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SetMaterialInCapsule(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FRotator& Rotation, float Radius, float HalfHeight, const struct FVoxelPaintMaterial& PaintMaterial, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SetMaterialInCapsule");

	Params::VoxelSphereTools_SetMaterialInCapsule Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SetMaterialInCapsuleAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SetMaterialInCapsuleAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FRotator& Rotation, float Radius, float HalfHeight, const struct FVoxelPaintMaterial& PaintMaterial, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SetMaterialInCapsuleAsync");

	Params::VoxelSphereTools_SetMaterialInCapsuleAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Rotation = std::move(Rotation);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SetMaterialSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelFalloff                           FalloffType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SetMaterialSphere(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, const struct FVoxelPaintMaterial& PaintMaterial, float Strength, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SetMaterialSphere");

	Params::VoxelSphereTools_SetMaterialSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.Strength = Strength;
	Parms.FalloffType = FalloffType;
	Parms.Falloff = Falloff;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SetMaterialSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelFalloff                           FalloffType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SetMaterialSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, const struct FVoxelPaintMaterial& PaintMaterial, float Strength, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SetMaterialSphereAsync");

	Params::VoxelSphereTools_SetMaterialSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.Strength = Strength;
	Parms.FalloffType = FalloffType;
	Parms.Falloff = Falloff;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SetValueSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SetValueSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Value, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SetValueSphere");

	Params::VoxelSphereTools_SetValueSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Value = Value;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SetValueSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SetValueSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Value, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SetValueSphereAsync");

	Params::VoxelSphereTools_SetValueSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Value = Value;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SmoothMaterialSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelFalloff                           FalloffType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SmoothMaterialSphere(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Strength, int32 NumIterations, int32 Mask, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SmoothMaterialSphere");

	Params::VoxelSphereTools_SmoothMaterialSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.NumIterations = NumIterations;
	Parms.Mask = Mask;
	Parms.FalloffType = FalloffType;
	Parms.Falloff = Falloff;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SmoothMaterialSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Mask                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelFalloff                           FalloffType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SmoothMaterialSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Strength, int32 NumIterations, int32 Mask, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SmoothMaterialSphereAsync");

	Params::VoxelSphereTools_SmoothMaterialSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.NumIterations = NumIterations;
	Parms.Mask = Mask;
	Parms.FalloffType = FalloffType;
	Parms.Falloff = Falloff;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SmoothSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelFalloff                           FalloffType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SmoothSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Strength, int32 NumIterations, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SmoothSphere");

	Params::VoxelSphereTools_SmoothSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.NumIterations = NumIterations;
	Parms.FalloffType = FalloffType;
	Parms.Falloff = Falloff;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.SmoothSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumIterations                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelFalloff                           FalloffType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::SmoothSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Strength, int32 NumIterations, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "SmoothSphereAsync");

	Params::VoxelSphereTools_SmoothSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.NumIterations = NumIterations;
	Parms.FalloffType = FalloffType;
	Parms.Falloff = Falloff;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.TrimSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdditive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::TrimSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FVector& Normal, float Radius, float Falloff, bool bAdditive, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "TrimSphere");

	Params::VoxelSphereTools_TrimSphere Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Normal = std::move(Normal);
	Parms.Radius = Radius;
	Parms.Falloff = Falloff;
	Parms.bAdditive = bAdditive;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSphereTools.TrimSphereAsync
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdditive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSphereTools::TrimSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FVector& Normal, float Radius, float Falloff, bool bAdditive, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSphereTools", "TrimSphereAsync");

	Params::VoxelSphereTools_TrimSphereAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.Position = std::move(Position);
	Parms.Normal = std::move(Normal);
	Parms.Radius = Radius;
	Parms.Falloff = Falloff;
	Parms.bAdditive = bAdditive;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSurfaceEditTools.EditVoxelMaterials
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsProcessedVoxels                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceEditTools::EditVoxelMaterials(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelPaintMaterial& PaintMaterial, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceEditTools", "EditVoxelMaterials");

	Params::VoxelSurfaceEditTools_EditVoxelMaterials Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.ProcessedVoxels = std::move(ProcessedVoxels);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSurfaceEditTools.EditVoxelMaterialsAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelPaintMaterial              PaintMaterial                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsProcessedVoxels                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceEditTools::EditVoxelMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelPaintMaterial& PaintMaterial, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceEditTools", "EditVoxelMaterialsAsync");

	Params::VoxelSurfaceEditTools_EditVoxelMaterialsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.PaintMaterial = std::move(PaintMaterial);
	Parms.ProcessedVoxels = std::move(ProcessedVoxels);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSurfaceEditTools.EditVoxelValues
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsProcessedVoxels                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DistanceDivisor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceEditTools::EditVoxelValues(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, float DistanceDivisor, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceEditTools", "EditVoxelValues");

	Params::VoxelSurfaceEditTools_EditVoxelValues Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.ProcessedVoxels = std::move(ProcessedVoxels);
	Parms.DistanceDivisor = DistanceDivisor;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSurfaceEditTools.EditVoxelValuesAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModifiedValues                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsProcessedVoxels                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DistanceDivisor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedValues                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceEditTools::EditVoxelValuesAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, float DistanceDivisor, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceEditTools", "EditVoxelValuesAsync");

	Params::VoxelSurfaceEditTools_EditVoxelValuesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.ProcessedVoxels = std::move(ProcessedVoxels);
	Parms.DistanceDivisor = DistanceDivisor;
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedValues = bRecordModifiedValues;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedValues != nullptr)
		*ModifiedValues = std::move(Parms.ModifiedValues);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSurfaceEditTools.PropagateVoxelMaterials
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsProcessedVoxels                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceEditTools::PropagateVoxelMaterials(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceEditTools", "PropagateVoxelMaterials");

	Params::VoxelSurfaceEditTools_PropagateVoxelMaterials Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.ProcessedVoxels = std::move(ProcessedVoxels);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bUpdateRender = bUpdateRender;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSurfaceEditTools.PropagateVoxelMaterialsAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelMaterial>   ModifiedMaterials                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     EditedBounds                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsProcessedVoxels                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRecordModifiedMaterials                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateRender                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceEditTools::PropagateVoxelMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceEditTools", "PropagateVoxelMaterialsAsync");

	Params::VoxelSurfaceEditTools_PropagateVoxelMaterialsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.VoxelWorld = VoxelWorld;
	Parms.ProcessedVoxels = std::move(ProcessedVoxels);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.bRecordModifiedMaterials = bRecordModifiedMaterials;
	Parms.bUpdateRender = bUpdateRender;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ModifiedMaterials != nullptr)
		*ModifiedMaterials = std::move(Parms.ModifiedMaterials);

	if (EditedBounds != nullptr)
		*EditedBounds = std::move(Parms.EditedBounds);
}


// Function Voxel.VoxelSurfaceTools.AddToStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelSurfaceEditsStack          Stack                                                  (Parm, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStackElement   Element                                                (Parm, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStack          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsStack UVoxelSurfaceTools::AddToStack(const struct FVoxelSurfaceEditsStack& Stack, const struct FVoxelSurfaceEditsStackElement& Element)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "AddToStack");

	Params::VoxelSurfaceTools_AddToStack Parms{};

	Parms.Stack = std::move(Stack);
	Parms.Element = std::move(Element);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.ApplyConstantStrength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStackElement   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsStackElement UVoxelSurfaceTools::ApplyConstantStrength(float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "ApplyConstantStrength");

	Params::VoxelSurfaceTools_ApplyConstantStrength Parms{};

	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.ApplyFalloff
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelFalloff                           FalloffType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStackElement   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsStackElement UVoxelSurfaceTools::ApplyFalloff(class AVoxelWorld* World, EVoxelFalloff FalloffType, const struct FVector& Center, float Radius, float Falloff, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "ApplyFalloff");

	Params::VoxelSurfaceTools_ApplyFalloff Parms{};

	Parms.World = World;
	Parms.FalloffType = FalloffType;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.Falloff = Falloff;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.ApplyFlatten
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlanePoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelSDFMergeMode                      MergeMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStackElement   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsStackElement UVoxelSurfaceTools::ApplyFlatten(class AVoxelWorld* World, const struct FVector& PlanePoint, const struct FVector& PlaneNormal, EVoxelSDFMergeMode MergeMode, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "ApplyFlatten");

	Params::VoxelSurfaceTools_ApplyFlatten Parms{};

	Parms.World = World;
	Parms.PlanePoint = std::move(PlanePoint);
	Parms.PlaneNormal = std::move(PlaneNormal);
	Parms.MergeMode = MergeMode;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.ApplyStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelSurfaceEditsVoxels         Voxels                                                 (Parm, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStack          Stack                                                  (Parm, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsProcessedVoxels UVoxelSurfaceTools::ApplyStack(const struct FVoxelSurfaceEditsVoxels& Voxels, const struct FVoxelSurfaceEditsStack& Stack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "ApplyStack");

	Params::VoxelSurfaceTools_ApplyStack Parms{};

	Parms.Voxels = std::move(Voxels);
	Parms.Stack = std::move(Stack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.ApplyStackAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsProcessedVoxels                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsVoxels         Voxels                                                 (Parm, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStack          Stack                                                  (Parm, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceTools::ApplyStackAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelSurfaceEditsProcessedVoxels* ProcessedVoxels, const struct FVoxelSurfaceEditsVoxels& Voxels, const struct FVoxelSurfaceEditsStack& Stack, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "ApplyStackAsync");

	Params::VoxelSurfaceTools_ApplyStackAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Voxels = std::move(Voxels);
	Parms.Stack = std::move(Stack);
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ProcessedVoxels != nullptr)
		*ProcessedVoxels = std::move(Parms.ProcessedVoxels);
}


// Function Voxel.VoxelSurfaceTools.ApplyStrengthCurve
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      StrengthCurve                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStackElement   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsStackElement UVoxelSurfaceTools::ApplyStrengthCurve(class AVoxelWorld* World, const struct FVector& Center, float Radius, class UCurveFloat* StrengthCurve, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "ApplyStrengthCurve");

	Params::VoxelSurfaceTools_ApplyStrengthCurve Parms{};

	Parms.World = World;
	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.StrengthCurve = StrengthCurve;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.ApplyStrengthMask
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelFloatTexture               Mask                                                   (Parm, NativeAccessSpecifierPublic)
// struct FVector                          EditPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaleX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaleY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneNormal                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PlaneTangent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelSamplerMode                       SamplerMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStackElement   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsStackElement UVoxelSurfaceTools::ApplyStrengthMask(class AVoxelWorld* World, const struct FVoxelFloatTexture& Mask, const struct FVector& EditPosition, float ScaleX, float ScaleY, const struct FVector& PlaneNormal, const struct FVector& PlaneTangent, EVoxelSamplerMode SamplerMode, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "ApplyStrengthMask");

	Params::VoxelSurfaceTools_ApplyStrengthMask Parms{};

	Parms.World = World;
	Parms.Mask = std::move(Mask);
	Parms.EditPosition = std::move(EditPosition);
	Parms.ScaleX = ScaleX;
	Parms.ScaleY = ScaleY;
	Parms.PlaneNormal = std::move(PlaneNormal);
	Parms.PlaneTangent = std::move(PlaneTangent);
	Parms.SamplerMode = SamplerMode;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.ApplyTerrace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   TerraceHeightInVoxels                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ImmutableVoxels                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsStackElement   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelSurfaceEditsStackElement UVoxelSurfaceTools::ApplyTerrace(int32 TerraceHeightInVoxels, float Angle, int32 ImmutableVoxels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "ApplyTerrace");

	Params::VoxelSurfaceTools_ApplyTerrace Parms{};

	Parms.TerraceHeightInVoxels = TerraceHeightInVoxels;
	Parms.Angle = Angle;
	Parms.ImmutableVoxels = ImmutableVoxels;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.DebugSurfaceVoxels
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsProcessedVoxelsProcessedVoxels                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   LifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceTools::DebugSurfaceVoxels(class AVoxelWorld* World, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, float LifeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "DebugSurfaceVoxels");

	Params::VoxelSurfaceTools_DebugSurfaceVoxels Parms{};

	Parms.World = World;
	Parms.ProcessedVoxels = std::move(ProcessedVoxels);
	Parms.LifeTime = LifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelSurfaceTools.FindSurfaceVoxels
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelSurfaceEditsVoxels         Voxels                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bComputeNormals                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceTools::FindSurfaceVoxels(struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bComputeNormals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "FindSurfaceVoxels");

	Params::VoxelSurfaceTools_FindSurfaceVoxels Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bComputeNormals = bComputeNormals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Voxels != nullptr)
		*Voxels = std::move(Parms.Voxels);
}


// Function Voxel.VoxelSurfaceTools.FindSurfaceVoxels2D
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelSurfaceEditsVoxels         Voxels                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bComputeNormals                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceTools::FindSurfaceVoxels2D(struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bComputeNormals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "FindSurfaceVoxels2D");

	Params::VoxelSurfaceTools_FindSurfaceVoxels2D Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bComputeNormals = bComputeNormals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Voxels != nullptr)
		*Voxels = std::move(Parms.Voxels);
}


// Function Voxel.VoxelSurfaceTools.FindSurfaceVoxels2DAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsVoxels         Voxels                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bComputeNormals                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceTools::FindSurfaceVoxels2DAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bComputeNormals, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "FindSurfaceVoxels2DAsync");

	Params::VoxelSurfaceTools_FindSurfaceVoxels2DAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bComputeNormals = bComputeNormals;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Voxels != nullptr)
		*Voxels = std::move(Parms.Voxels);
}


// Function Voxel.VoxelSurfaceTools.FindSurfaceVoxelsAsync
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVoxelSurfaceEditsVoxels         Voxels                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bComputeNormals                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHideLatentWarnings                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceTools::FindSurfaceVoxelsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bComputeNormals, bool bHideLatentWarnings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "FindSurfaceVoxelsAsync");

	Params::VoxelSurfaceTools_FindSurfaceVoxelsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bComputeNormals = bComputeNormals;
	Parms.bHideLatentWarnings = bHideLatentWarnings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Voxels != nullptr)
		*Voxels = std::move(Parms.Voxels);
}


// Function Voxel.VoxelSurfaceTools.FindSurfaceVoxelsFromDistanceField
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FVoxelSurfaceEditsVoxels         Voxels                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMultiThreaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelComputeDevice                     ComputeDevice                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceTools::FindSurfaceVoxelsFromDistanceField(struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, EVoxelComputeDevice ComputeDevice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "FindSurfaceVoxelsFromDistanceField");

	Params::VoxelSurfaceTools_FindSurfaceVoxelsFromDistanceField Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.bMultiThreaded = bMultiThreaded;
	Parms.ComputeDevice = ComputeDevice;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Voxels != nullptr)
		*Voxels = std::move(Parms.Voxels);
}


// Function Voxel.VoxelSurfaceTools.GetBounds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVoxelSurfaceEditsProcessedVoxelsVoxels                                                 (Parm, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVoxelIntBox UVoxelSurfaceTools::GetBounds(const struct FVoxelSurfaceEditsProcessedVoxels& Voxels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "GetBounds");

	Params::VoxelSurfaceTools_GetBounds Parms{};

	Parms.Voxels = std::move(Voxels);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelSurfaceTools.GetStrengthMaskScale
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ScaleX                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaleY                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelFloatTexture               Mask                                                   (Parm, NativeAccessSpecifierPublic)
// float                                   SizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConvertToVoxelSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelSurfaceTools::GetStrengthMaskScale(float* ScaleX, float* ScaleY, class AVoxelWorld* World, const struct FVoxelFloatTexture& Mask, float SizeX, float SizeY, bool bConvertToVoxelSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelSurfaceTools", "GetStrengthMaskScale");

	Params::VoxelSurfaceTools_GetStrengthMaskScale Parms{};

	Parms.World = World;
	Parms.Mask = std::move(Mask);
	Parms.SizeX = SizeX;
	Parms.SizeY = SizeY;
	Parms.bConvertToVoxelSpace = bConvertToVoxelSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ScaleX != nullptr)
		*ScaleX = Parms.ScaleX;

	if (ScaleY != nullptr)
		*ScaleY = Parms.ScaleY;
}


// Function Voxel.VoxelTestLibrary.ReadValues
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AVoxelWorld*                      World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelTestValues                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelTestValues UVoxelTestLibrary::ReadValues(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTestLibrary", "ReadValues");

	Params::VoxelTestLibrary_ReadValues Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTestLibrary.TestValues
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelTestValues                 ValuesA                                                (Parm, NativeAccessSpecifierPublic)
// struct FVoxelTestValues                 ValuesB                                                (Parm, NativeAccessSpecifierPublic)

void UVoxelTestLibrary::TestValues(const struct FVoxelTestValues& ValuesA, const struct FVoxelTestValues& ValuesB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTestLibrary", "TestValues");

	Params::VoxelTestLibrary_TestValues Parms{};

	Parms.ValuesA = std::move(ValuesA);
	Parms.ValuesB = std::move(ValuesB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelTextureTools.Maximum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               Texture                                                (Parm, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelFloatTexture               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelFloatTexture UVoxelTextureTools::Maximum(const struct FVoxelFloatTexture& Texture, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTextureTools", "Maximum");

	Params::VoxelTextureTools_Maximum Parms{};

	Parms.Texture = std::move(Texture);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelTextureTools.Minimum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FVoxelFloatTexture               Texture                                                (Parm, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelFloatTexture               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FVoxelFloatTexture UVoxelTextureTools::Minimum(const struct FVoxelFloatTexture& Texture, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelTextureTools", "Minimum");

	Params::VoxelTextureTools_Minimum Parms{};

	Parms.Texture = std::move(Texture);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolLibrary.UpdateSphereOverlayMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UVoxelToolBase*                   Tool                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         OverlayMaterialInstance                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelFalloff                           FalloffType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Falloff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelToolLibrary::UpdateSphereOverlayMaterial(class UVoxelToolBase* Tool, class UMaterialInstanceDynamic* OverlayMaterialInstance, EVoxelFalloff FalloffType, float Falloff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("VoxelToolLibrary", "UpdateSphereOverlayMaterial");

	Params::VoxelToolLibrary_UpdateSphereOverlayMaterial Parms{};

	Parms.Tool = Tool;
	Parms.OverlayMaterialInstance = OverlayMaterialInstance;
	Parms.FalloffType = FalloffType;
	Parms.Falloff = Falloff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelToolManager.CreateDefaultTools
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLoadBlueprints                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelToolManager::CreateDefaultTools(bool bLoadBlueprints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolManager", "CreateDefaultTools");

	Params::VoxelToolManager_CreateDefaultTools Parms{};

	Parms.bLoadBlueprints = bLoadBlueprints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelToolManager.SetActiveTool
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVoxelTool*                       NewActiveTool                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelToolManager::SetActiveTool(class UVoxelTool* NewActiveTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolManager", "SetActiveTool");

	Params::VoxelToolManager_SetActiveTool Parms{};

	Parms.NewActiveTool = NewActiveTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelToolManager.SetActiveToolByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UVoxelTool>           NewActiveTool                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelToolManager::SetActiveToolByClass(TSubclassOf<class UVoxelTool> NewActiveTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolManager", "SetActiveToolByClass");

	Params::VoxelToolManager_SetActiveToolByClass Parms{};

	Parms.NewActiveTool = NewActiveTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelToolManager.SetActiveToolByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             NewActiveTool                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoxelToolManager::SetActiveToolByName(class FName NewActiveTool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolManager", "SetActiveToolByName");

	Params::VoxelToolManager_SetActiveToolByName Parms{};

	Parms.NewActiveTool = NewActiveTool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Voxel.VoxelToolManager.GetActiveTool
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVoxelTool*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelTool* UVoxelToolManager::GetActiveTool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolManager", "GetActiveTool");

	Params::VoxelToolManager_GetActiveTool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolManager.GetTools
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UVoxelTool*>         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class UVoxelTool*> UVoxelToolManager::GetTools() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolManager", "GetTools");

	Params::VoxelToolManager_GetTools Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Voxel.VoxelToolManager.K2_GetSharedConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVoxelToolSharedConfig*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVoxelToolSharedConfig* UVoxelToolManager::K2_GetSharedConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelToolManager", "K2_GetSharedConfig");

	Params::VoxelToolManager_K2_GetSharedConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

