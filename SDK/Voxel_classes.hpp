#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Voxel

#include "Basic.hpp"

#include "PhysicsCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Voxel_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Landscape_classes.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class Voxel.VoxelBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FIntVector Add_IntVectorIntVector(const struct FIntVector& Left, const struct FIntVector& Right);
	static void AddNeighborsToSet(const TSet<struct FIntVector>& InSet, TSet<struct FIntVector>* OutSet);
	static void ApplyLODSettings(class AVoxelWorld* World);
	static void ApplyNewMaterials(class AVoxelWorld* World);
	static struct FVoxelMaterial ApplyPaintMaterial(const struct FVoxelMaterial& Material, const struct FVoxelPaintMaterial& PaintMaterial, float Strength);
	static bool AreCollisionsEnabled(class AVoxelWorld* World, const struct FVector& Position, int32* LOD, bool bConvertToVoxelSpace);
	static void BindVoxelChunkEvents(class AVoxelWorld* World, TDelegate<void(const struct FVoxelIntBox& Bounds)> OnActivate, TDelegate<void(const struct FVoxelIntBox& Bounds)> OnDeactivate, bool bFireExistingOnes, int32 ChunkSize, int32 ActivationDistanceInChunks);
	static void BindVoxelGenerationEvent(class AVoxelWorld* World, TDelegate<void(const struct FVoxelIntBox& Bounds)> OnGenerate, bool bFireExistingOnes, int32 ChunkSize, int32 GenerationDistanceInChunks);
	static void ClearAllData(class AVoxelWorld* World, bool bUpdateRender);
	static void ClearDirtyData(class AVoxelWorld* World, bool bUpdateRender);
	static void ClearFrames(class AVoxelWorld* World);
	static void ClearMaterialData(class AVoxelWorld* World, bool bUpdateRender);
	static void ClearValueData(class AVoxelWorld* World, bool bUpdateRender);
	static void CompactVoxelTexturePool(class AVoxelWorld* World);
	static struct FVoxelPaintMaterial CreateColorPaintMaterial(const struct FVoxelPaintMaterialColor& Color);
	static struct FVoxelPaintMaterial CreateFiveWayBlendPaintMaterial(const struct FVoxelPaintMaterialFiveWayBlend& FiveWayBlend);
	static struct FVoxelPaintMaterial CreateMultiIndexPaintMaterial(const struct FVoxelPaintMaterialMultiIndex& MultiIndex);
	static struct FVoxelPaintMaterial CreateMultiIndexRawPaintMaterial(const struct FVoxelPaintMaterialMultiIndexRaw& MultiIndexRaw);
	static struct FVoxelPaintMaterial CreateMultiIndexWetnessPaintMaterial(const struct FVoxelPaintMaterialMultiIndexWetness& MultiIndexWetness);
	static class UTexture2D* CreateOrUpdateTextureFromVoxelColorTexture(const struct FVoxelColorTexture& VoxelTexture, class UTexture2D*& Texture);
	static class UTexture2D* CreateOrUpdateTextureFromVoxelFloatTexture(const struct FVoxelFloatTexture& VoxelTexture, class UTexture2D*& Texture);
	static struct FVoxelPaintMaterial CreateSingleIndexPaintMaterial(const struct FVoxelPaintMaterialSingleIndex& SingleIndex);
	static class UTexture2D* CreateTextureFromVoxelColorTexture(const struct FVoxelColorTexture& VoxelTexture);
	static class UTexture2D* CreateTextureFromVoxelFloatTexture(const struct FVoxelFloatTexture& VoxelTexture);
	static struct FVoxelToolRenderingRef CreateToolRendering(class AVoxelWorld* World);
	static struct FVoxelPaintMaterial CreateUVPaintMaterial(const struct FVoxelPaintMaterialUV& UV);
	static struct FVoxelColorTexture CreateVoxelColorTextureFromVoxelFloatTexture(const struct FVoxelFloatTexture& Texture, EVoxelRGBA Channel, bool bNormalize);
	static struct FVoxelFloatTexture CreateVoxelFloatTextureFromTextureChannel(class UTexture2D* Texture, EVoxelRGBA Channel);
	static void DestroyToolRendering(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref);
	static struct FIntVector Divide_IntVectorInt(const struct FIntVector& Left, int32 Right);
	static TArray<class AVoxelWorld*> GetAllVoxelWorldsContainingPosition(class UObject* WorldContextObject, const struct FVector& Position);
	static TArray<class AVoxelWorld*> GetAllVoxelWorldsOverlappingActor(class AActor* Actor);
	static TArray<class AVoxelWorld*> GetAllVoxelWorldsOverlappingBox(class UObject* WorldContextObject, const struct FBox& Box);
	static struct FVoxelIntBox GetBounds(class AVoxelWorld* World);
	static struct FLinearColor GetColor(const struct FVoxelMaterial& Material);
	static float GetEstimatedCollisionsMemoryUsageInMB(class AVoxelWorld* World);
	static float GetFloatOutput(class AVoxelWorld* World, class FName Name_0, float X, float Y, float Z, float DefaultValue);
	static int32 GetHistoryPosition(class AVoxelWorld* World);
	static int32 GetIntOutput(class AVoxelWorld* World, class FName Name_0, float X, float Y, float Z, int32 DefaultValue);
	static int32 GetMax_Intvector(const struct FIntVector& Vector);
	static float GetMemoryUsageInMB(EVoxelMemoryUsageType Type);
	static int32 GetMin_Intvector(const struct FIntVector& Vector);
	static void GetMultiIndex(const struct FVoxelMaterial& Material, bool bSortByStrength, float* Strength0, uint8* Index0, float* Strength1, uint8* Index1, float* Strength2, uint8* Index2, float* Strength3, uint8* Index3, float* Wetness);
	static struct FVector GetNormal(class AVoxelWorld* World, const struct FIntVector& Position);
	static int32 GetNumberOfVoxelThreads();
	static float GetPeakMemoryUsageInMB(EVoxelMemoryUsageType Type);
	static void GetRawMaterial(const struct FVoxelMaterial& Material, uint8* R, uint8* G, uint8* B, uint8* A, uint8* U0, uint8* V0, uint8* U1, uint8* v1, uint8* U2, uint8* v2, uint8* U3, uint8* V3);
	static struct FVoxelIntBox GetRenderBoundsOverlappingDataBounds(class AVoxelWorld* World, const struct FVoxelIntBox& DataBounds, int32 LOD);
	static uint8 GetSingleIndex(const struct FVoxelMaterial& Material);
	static int32 GetTaskCount(class AVoxelWorld* World);
	static struct FVector2D GetUV(const struct FVoxelMaterial& Material, int32 Channel);
	static struct FIntPoint GetVoxelColorTextureSize(const struct FVoxelColorTexture& Texture);
	static struct FIntPoint GetVoxelFloatTextureSize(const struct FVoxelFloatTexture& Texture);
	static class AVoxelWorld* GetVoxelWorldContainingPosition(class UObject* WorldContextObject, const struct FVector& Position);
	static class AVoxelWorld* GetVoxelWorldOverlappingActor(class AActor* Actor);
	static class AVoxelWorld* GetVoxelWorldOverlappingBox(class UObject* WorldContextObject, const struct FBox& Box);
	static bool HasMaterialData(class AVoxelWorld* World);
	static bool HasValueData(class AVoxelWorld* World);
	static bool IntervalContains_Float(const struct FVoxelFloatInterval& Interval, float Value);
	static bool IntervalContains_Int32(const struct FVoxelInt32Interval& Interval, int32 Value);
	static bool IsValidRef(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref);
	static bool IsVoxelColorTextureValid(const struct FVoxelFloatTexture& Texture);
	static bool IsVoxelFloatTextureValid(const struct FVoxelFloatTexture& Texture);
	static bool IsVoxelPluginPro();
	static bool IsVoxelWorldFoliageLoading(class AVoxelWorld* World);
	static bool IsVoxelWorldMeshLoading(class AVoxelWorld* World);
	static void LogMemoryStats();
	static struct FVoxelMaterial MakeColorMaterial(const struct FLinearColor& Color);
	static struct FVoxelIntBox MakeIntBoxFromGlobalPositionAndRadius(class AVoxelWorld* World, const struct FVector& GlobalPosition, float Radius);
	static int32 MakeMaterialMask(bool R, bool G, bool B, bool A, bool U0, bool V0, bool U1, bool v1, bool U2, bool v2, bool U3, bool V3);
	static struct FVoxelMaterial MakeRawMaterial(uint8 R, uint8 G, uint8 B, uint8 A, uint8 U0, uint8 V0, uint8 U1, uint8 v1, uint8 U2, uint8 v2, uint8 U3, uint8 V3);
	static struct FVoxelMaterial MakeSingleIndexMaterial(uint8 Index_0);
	static void MarkSpawnersDirty(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static struct FIntVector Multiply_IntIntVector(int32 Left, const struct FIntVector& Right);
	static struct FIntVector Multiply_IntVectorInt(const struct FIntVector& Left, int32 Right);
	static struct FIntVector Multiply_IntVectorIntVector(const struct FIntVector& Left, const struct FIntVector& Right);
	static int32 NumberOfCores();
	static void RaiseError(const class FString& Message, class UObject* Object);
	static void RaiseInfo(const class FString& Message, class UObject* Object);
	static void RaiseWarning(const class FString& Message, class UObject* Object);
	static void RecomputeComponentPositions(class AVoxelWorld* World);
	static void Recreate(class AVoxelWorld* World, bool bSaveData);
	static void RecreateRender(class AVoxelWorld* World);
	static void RecreateSpawners(class AVoxelWorld* World);
	static bool Redo(class AVoxelWorld* World, TArray<struct FVoxelIntBox>* OutUpdatedBounds);
	static void RegenerateSpawners(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void SaveFrame(class AVoxelWorld* World);
	static void ScaleData(class AVoxelWorld* World, const struct FVector& Scale);
	static void SetNumberOfVoxelThreads(int32 Number);
	static void SetToolRenderingBounds(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref, const struct FBox& Bounds);
	static void SetToolRenderingEnabled(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref, bool bEnabled);
	static void SetToolRenderingMaterial(class AVoxelWorld* World, const struct FVoxelToolRenderingRef& Ref, class UMaterialInterface* Material);
	static struct FIntVector Substract_IntVectorIntVector(const struct FIntVector& Left, const struct FIntVector& Right);
	static struct FVoxelIntBox TransformGlobalBoxToVoxelBox(class AVoxelWorld* World, const struct FBox& Box);
	static struct FBox TransformVoxelBoxToGlobalBox(class AVoxelWorld* World, const struct FVoxelIntBox& Box);
	static bool Undo(class AVoxelWorld* World, TArray<struct FVoxelIntBox>* OutUpdatedBounds);
	static void UpdateAll(class AVoxelWorld* World);
	static void UpdateBounds(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void UpdatePosition(class AVoxelWorld* World, const struct FIntVector& Position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBlueprintLibrary">();
	}
	static class UVoxelBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBlueprintLibrary>();
	}
};
static_assert(alignof(UVoxelBlueprintLibrary) == 0x000008, "Wrong alignment on UVoxelBlueprintLibrary");
static_assert(sizeof(UVoxelBlueprintLibrary) == 0x000028, "Wrong size on UVoxelBlueprintLibrary");

// Class Voxel.VoxelInvokerComponentBase
// 0x0000 (0x0200 - 0x0200)
class UVoxelInvokerComponentBase : public USceneComponent
{
public:
	bool                                          bIsInvokerEnabled;                                 // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEditorOnlyInvoker;                                // 0x01F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForEvents;                                     // 0x01FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForPriorities;                                 // 0x01FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void RefreshAllVoxelInvokers();

	struct FVoxelInvokerSettings GetInvokerSettings(class AVoxelWorld* VoxelWorld) const;
	struct FIntVector GetInvokerVoxelPosition(class AVoxelWorld* VoxelWorld) const;
	bool IsLocalInvoker() const;
	bool ShouldUseInvoker(class AVoxelWorld* VoxelWorld) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelInvokerComponentBase">();
	}
	static class UVoxelInvokerComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelInvokerComponentBase>();
	}
};
static_assert(alignof(UVoxelInvokerComponentBase) == 0x000010, "Wrong alignment on UVoxelInvokerComponentBase");
static_assert(sizeof(UVoxelInvokerComponentBase) == 0x000200, "Wrong size on UVoxelInvokerComponentBase");
static_assert(offsetof(UVoxelInvokerComponentBase, bIsInvokerEnabled) == 0x0001F8, "Member 'UVoxelInvokerComponentBase::bIsInvokerEnabled' has a wrong offset!");
static_assert(offsetof(UVoxelInvokerComponentBase, bEditorOnlyInvoker) == 0x0001F9, "Member 'UVoxelInvokerComponentBase::bEditorOnlyInvoker' has a wrong offset!");
static_assert(offsetof(UVoxelInvokerComponentBase, bUseForEvents) == 0x0001FA, "Member 'UVoxelInvokerComponentBase::bUseForEvents' has a wrong offset!");
static_assert(offsetof(UVoxelInvokerComponentBase, bUseForPriorities) == 0x0001FB, "Member 'UVoxelInvokerComponentBase::bUseForPriorities' has a wrong offset!");

// Class Voxel.VoxelSimpleInvokerComponent
// 0x0020 (0x0220 - 0x0200)
class UVoxelSimpleInvokerComponent : public UVoxelInvokerComponentBase
{
public:
	bool                                          bUseForLOD;                                        // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODToSet;                                          // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODRange;                                          // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForCollisions;                                 // 0x020C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionsRange;                                   // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForNavmesh;                                    // 0x0214(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NavmeshRange;                                      // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetInvokerGlobalPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSimpleInvokerComponent">();
	}
	static class UVoxelSimpleInvokerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSimpleInvokerComponent>();
	}
};
static_assert(alignof(UVoxelSimpleInvokerComponent) == 0x000010, "Wrong alignment on UVoxelSimpleInvokerComponent");
static_assert(sizeof(UVoxelSimpleInvokerComponent) == 0x000220, "Wrong size on UVoxelSimpleInvokerComponent");
static_assert(offsetof(UVoxelSimpleInvokerComponent, bUseForLOD) == 0x000200, "Member 'UVoxelSimpleInvokerComponent::bUseForLOD' has a wrong offset!");
static_assert(offsetof(UVoxelSimpleInvokerComponent, LODToSet) == 0x000204, "Member 'UVoxelSimpleInvokerComponent::LODToSet' has a wrong offset!");
static_assert(offsetof(UVoxelSimpleInvokerComponent, LODRange) == 0x000208, "Member 'UVoxelSimpleInvokerComponent::LODRange' has a wrong offset!");
static_assert(offsetof(UVoxelSimpleInvokerComponent, bUseForCollisions) == 0x00020C, "Member 'UVoxelSimpleInvokerComponent::bUseForCollisions' has a wrong offset!");
static_assert(offsetof(UVoxelSimpleInvokerComponent, CollisionsRange) == 0x000210, "Member 'UVoxelSimpleInvokerComponent::CollisionsRange' has a wrong offset!");
static_assert(offsetof(UVoxelSimpleInvokerComponent, bUseForNavmesh) == 0x000214, "Member 'UVoxelSimpleInvokerComponent::bUseForNavmesh' has a wrong offset!");
static_assert(offsetof(UVoxelSimpleInvokerComponent, NavmeshRange) == 0x000218, "Member 'UVoxelSimpleInvokerComponent::NavmeshRange' has a wrong offset!");

// Class Voxel.VoxelInvokerAutoCameraComponent
// 0x0000 (0x0220 - 0x0220)
class UVoxelInvokerAutoCameraComponent final : public UVoxelSimpleInvokerComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelInvokerAutoCameraComponent">();
	}
	static class UVoxelInvokerAutoCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelInvokerAutoCameraComponent>();
	}
};
static_assert(alignof(UVoxelInvokerAutoCameraComponent) == 0x000010, "Wrong alignment on UVoxelInvokerAutoCameraComponent");
static_assert(sizeof(UVoxelInvokerAutoCameraComponent) == 0x000220, "Wrong size on UVoxelInvokerAutoCameraComponent");

// Class Voxel.AssetActorPrimitiveComponent
// 0x0000 (0x0450 - 0x0450)
class UAssetActorPrimitiveComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetActorPrimitiveComponent">();
	}
	static class UAssetActorPrimitiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetActorPrimitiveComponent>();
	}
};
static_assert(alignof(UAssetActorPrimitiveComponent) == 0x000010, "Wrong alignment on UAssetActorPrimitiveComponent");
static_assert(sizeof(UAssetActorPrimitiveComponent) == 0x000450, "Wrong size on UAssetActorPrimitiveComponent");

// Class Voxel.VoxelPlaceableItemActor
// 0x0010 (0x0230 - 0x0220)
class AVoxelPlaceableItemActor : public AActor
{
public:
	class AVoxelWorld*                            PreviewWorld;                                      // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyImportIntoPreviewWorld;                       // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_AddItemToWorld(class AVoxelWorld* World);

	int32 K2_GetPriority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPlaceableItemActor">();
	}
	static class AVoxelPlaceableItemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelPlaceableItemActor>();
	}
};
static_assert(alignof(AVoxelPlaceableItemActor) == 0x000008, "Wrong alignment on AVoxelPlaceableItemActor");
static_assert(sizeof(AVoxelPlaceableItemActor) == 0x000230, "Wrong size on AVoxelPlaceableItemActor");
static_assert(offsetof(AVoxelPlaceableItemActor, PreviewWorld) == 0x000220, "Member 'AVoxelPlaceableItemActor::PreviewWorld' has a wrong offset!");
static_assert(offsetof(AVoxelPlaceableItemActor, bOnlyImportIntoPreviewWorld) == 0x000228, "Member 'AVoxelPlaceableItemActor::bOnlyImportIntoPreviewWorld' has a wrong offset!");

// Class Voxel.VoxelAssetActor
// 0x00A8 (0x02D8 - 0x0230)
class AVoxelAssetActor final : public AVoxelPlaceableItemActor
{
public:
	struct FVoxelTransformableGeneratorPicker     Generator;                                         // 0x0230(0x0068)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideAssetBounds;                              // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelIntBox                           AssetBounds;                                       // 0x02A0(0x0018)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportAsReference;                                // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubtractiveAsset;                                 // 0x02B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelAssetMergeMode                          MergeMode;                                         // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnNewVoxelWorld;                               // 0x02BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulatePhysics;                                  // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PreviewLOD;                                        // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelAssetActorPreviewUpdateType             UpdateType;                                        // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoundAssetPosition;                               // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoundAssetRotation;                               // 0x02C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CA[0x2];                                      // 0x02CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        MaxPreviewChunks;                                  // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        Root;                                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelAssetActor">();
	}
	static class AVoxelAssetActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelAssetActor>();
	}
};
static_assert(alignof(AVoxelAssetActor) == 0x000008, "Wrong alignment on AVoxelAssetActor");
static_assert(sizeof(AVoxelAssetActor) == 0x0002D8, "Wrong size on AVoxelAssetActor");
static_assert(offsetof(AVoxelAssetActor, Generator) == 0x000230, "Member 'AVoxelAssetActor::Generator' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, Priority) == 0x000298, "Member 'AVoxelAssetActor::Priority' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, bOverrideAssetBounds) == 0x00029C, "Member 'AVoxelAssetActor::bOverrideAssetBounds' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, AssetBounds) == 0x0002A0, "Member 'AVoxelAssetActor::AssetBounds' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, bImportAsReference) == 0x0002B8, "Member 'AVoxelAssetActor::bImportAsReference' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, bSubtractiveAsset) == 0x0002B9, "Member 'AVoxelAssetActor::bSubtractiveAsset' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, MergeMode) == 0x0002BA, "Member 'AVoxelAssetActor::MergeMode' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, bSpawnNewVoxelWorld) == 0x0002BB, "Member 'AVoxelAssetActor::bSpawnNewVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, bSimulatePhysics) == 0x0002BC, "Member 'AVoxelAssetActor::bSimulatePhysics' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, PreviewLOD) == 0x0002C0, "Member 'AVoxelAssetActor::PreviewLOD' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, UpdateType) == 0x0002C4, "Member 'AVoxelAssetActor::UpdateType' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, bRoundAssetPosition) == 0x0002C8, "Member 'AVoxelAssetActor::bRoundAssetPosition' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, bRoundAssetRotation) == 0x0002C9, "Member 'AVoxelAssetActor::bRoundAssetRotation' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, MaxPreviewChunks) == 0x0002CC, "Member 'AVoxelAssetActor::MaxPreviewChunks' has a wrong offset!");
static_assert(offsetof(AVoxelAssetActor, Root) == 0x0002D0, "Member 'AVoxelAssetActor::Root' has a wrong offset!");

// Class Voxel.VoxelLandscapeImporter
// 0x0020 (0x0240 - 0x0220)
class AVoxelLandscapeImporter final : public AActor
{
public:
	class ALandscape*                             Landscape;                                         // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelHeightmapImporterMaterialConfig         MaterialConfig;                                    // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVoxelLandscapeImporterLayerInfo> LayerInfos;                                        // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLandscapeImporter">();
	}
	static class AVoxelLandscapeImporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelLandscapeImporter>();
	}
};
static_assert(alignof(AVoxelLandscapeImporter) == 0x000008, "Wrong alignment on AVoxelLandscapeImporter");
static_assert(sizeof(AVoxelLandscapeImporter) == 0x000240, "Wrong size on AVoxelLandscapeImporter");
static_assert(offsetof(AVoxelLandscapeImporter, Landscape) == 0x000220, "Member 'AVoxelLandscapeImporter::Landscape' has a wrong offset!");
static_assert(offsetof(AVoxelLandscapeImporter, MaterialConfig) == 0x000228, "Member 'AVoxelLandscapeImporter::MaterialConfig' has a wrong offset!");
static_assert(offsetof(AVoxelLandscapeImporter, LayerInfos) == 0x000230, "Member 'AVoxelLandscapeImporter::LayerInfos' has a wrong offset!");

// Class Voxel.VoxelAssetTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelAssetTools final : public UBlueprintFunctionLibrary
{
public:
	static void AddDisableEditsBox(struct FVoxelDisableEditsBoxItemReference* Reference, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void AddDisableEditsBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelDisableEditsBoxItemReference* Reference, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static class UVoxelDataAsset* CreateDataAssetFromWorldSection(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bCopyMaterials);
	static void ImportAsset(class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, bool bSubtractive, EVoxelAssetMergeMode MergeMode, bool bConvertToVoxelSpace);
	static void ImportAssetAsReference(struct FVoxelAssetItemReference* Reference, class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, int32 Priority, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void ImportAssetAsReferenceAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelAssetItemReference* Reference, class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, int32 Priority, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void ImportAssetAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, bool bSubtractive, EVoxelAssetMergeMode MergeMode, bool bConvertToVoxelSpace, bool bHideLatentWarnings);
	static void ImportDataAssetFast(class AVoxelWorld* World, class UVoxelDataAsset* Asset, const struct FVector& Position, EVoxelAssetMergeMode MergeMode, bool bConvertToVoxelSpace);
	static void ImportDataAssetFastAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, class UVoxelDataAsset* Asset, const struct FVector& Position, EVoxelAssetMergeMode MergeMode, bool bConvertToVoxelSpace, bool bHideLatentWarnings);
	static void ImportModifierAsset(class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, bool bModifyValues, bool bModifyMaterials, bool bLockEntireWorld, bool bConvertToVoxelSpace);
	static void ImportModifierAssetAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, class UVoxelTransformableGeneratorInstanceWrapper* Asset, const struct FTransform& Transform, const struct FVoxelIntBox& Bounds, bool bModifyValues, bool bModifyMaterials, bool bLockEntireWorld, bool bConvertToVoxelSpace, bool bHideLatentWarnings);
	static void InvertDataAsset(class UVoxelDataAsset* Asset, class UVoxelDataAsset** InvertedAsset);
	static void SetDataAssetMaterial(class UVoxelDataAsset* Asset, class UVoxelDataAsset** NewAsset, const struct FVoxelMaterial& Material);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelAssetTools">();
	}
	static class UVoxelAssetTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelAssetTools>();
	}
};
static_assert(alignof(UVoxelAssetTools) == 0x000008, "Wrong alignment on UVoxelAssetTools");
static_assert(sizeof(UVoxelAssetTools) == 0x000028, "Wrong size on UVoxelAssetTools");

// Class Voxel.VoxelMaterialCollectionBase
// 0x0000 (0x0028 - 0x0028)
class UVoxelMaterialCollectionBase : public UObject
{
public:
	class UMaterialInterface* GetIndexMaterial(uint8 Index_0) const;
	int32 GetMaterialIndex(class FName Name_0) const;
	TArray<struct FVoxelMaterialCollectionMaterialInfo> GetMaterials() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMaterialCollectionBase">();
	}
	static class UVoxelMaterialCollectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMaterialCollectionBase>();
	}
};
static_assert(alignof(UVoxelMaterialCollectionBase) == 0x000008, "Wrong alignment on UVoxelMaterialCollectionBase");
static_assert(sizeof(UVoxelMaterialCollectionBase) == 0x000028, "Wrong size on UVoxelMaterialCollectionBase");

// Class Voxel.VoxelBasicMaterialCollection
// 0x0010 (0x0038 - 0x0028)
class UVoxelBasicMaterialCollection final : public UVoxelMaterialCollectionBase
{
public:
	TArray<struct FVoxelBasicMaterialCollectionLayer> Layers;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBasicMaterialCollection">();
	}
	static class UVoxelBasicMaterialCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBasicMaterialCollection>();
	}
};
static_assert(alignof(UVoxelBasicMaterialCollection) == 0x000008, "Wrong alignment on UVoxelBasicMaterialCollection");
static_assert(sizeof(UVoxelBasicMaterialCollection) == 0x000038, "Wrong size on UVoxelBasicMaterialCollection");
static_assert(offsetof(UVoxelBasicMaterialCollection, Layers) == 0x000028, "Member 'UVoxelBasicMaterialCollection::Layers' has a wrong offset!");

// Class Voxel.VoxelBlueprintMaterialCollectionInterface
// 0x0008 (0x0030 - 0x0028)
class UVoxelBlueprintMaterialCollectionInterface final : public UObject
{
public:
	int32                                         MaxMaterialsToBlendAtOnce;                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCubicFaces;                                 // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInterface* GetMaterialForIndex(int32 Index_0, EVoxelCubicFace Face);
	class UMaterialInterface* GetMaterialForIndices(const TArray<uint8>& Indices);
	TArray<struct FVoxelMaterialCollectionMaterialInfo> GetMaterials();
	void InitializeCollection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBlueprintMaterialCollectionInterface">();
	}
	static class UVoxelBlueprintMaterialCollectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBlueprintMaterialCollectionInterface>();
	}
};
static_assert(alignof(UVoxelBlueprintMaterialCollectionInterface) == 0x000008, "Wrong alignment on UVoxelBlueprintMaterialCollectionInterface");
static_assert(sizeof(UVoxelBlueprintMaterialCollectionInterface) == 0x000030, "Wrong size on UVoxelBlueprintMaterialCollectionInterface");
static_assert(offsetof(UVoxelBlueprintMaterialCollectionInterface, MaxMaterialsToBlendAtOnce) == 0x000028, "Member 'UVoxelBlueprintMaterialCollectionInterface::MaxMaterialsToBlendAtOnce' has a wrong offset!");
static_assert(offsetof(UVoxelBlueprintMaterialCollectionInterface, bEnableCubicFaces) == 0x00002C, "Member 'UVoxelBlueprintMaterialCollectionInterface::bEnableCubicFaces' has a wrong offset!");

// Class Voxel.VoxelCachedMaterialCollection
// 0x0050 (0x0078 - 0x0028)
class UVoxelCachedMaterialCollection : public UVoxelMaterialCollectionBase
{
public:
	TMap<struct FVoxelMaterialIndices, class UMaterialInterface*> CachedMaterials;                                   // 0x0028(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelCachedMaterialCollection">();
	}
	static class UVoxelCachedMaterialCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelCachedMaterialCollection>();
	}
};
static_assert(alignof(UVoxelCachedMaterialCollection) == 0x000008, "Wrong alignment on UVoxelCachedMaterialCollection");
static_assert(sizeof(UVoxelCachedMaterialCollection) == 0x000078, "Wrong size on UVoxelCachedMaterialCollection");
static_assert(offsetof(UVoxelCachedMaterialCollection, CachedMaterials) == 0x000028, "Member 'UVoxelCachedMaterialCollection::CachedMaterials' has a wrong offset!");

// Class Voxel.VoxelBlueprintMaterialCollection
// 0x0008 (0x0080 - 0x0078)
class UVoxelBlueprintMaterialCollection final : public UVoxelCachedMaterialCollection
{
public:
	class UVoxelBlueprintMaterialCollectionInterface* Instance;                                          // 0x0078(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBlueprintMaterialCollection">();
	}
	static class UVoxelBlueprintMaterialCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBlueprintMaterialCollection>();
	}
};
static_assert(alignof(UVoxelBlueprintMaterialCollection) == 0x000008, "Wrong alignment on UVoxelBlueprintMaterialCollection");
static_assert(sizeof(UVoxelBlueprintMaterialCollection) == 0x000080, "Wrong size on UVoxelBlueprintMaterialCollection");
static_assert(offsetof(UVoxelBlueprintMaterialCollection, Instance) == 0x000078, "Member 'UVoxelBlueprintMaterialCollection::Instance' has a wrong offset!");

// Class Voxel.VoxelToolsBase
// 0x0000 (0x0028 - 0x0028)
class UVoxelToolsBase : public UBlueprintFunctionLibrary
{
public:
	static struct FVoxelIntBox GetModifiedVoxelMaterialsBounds(const TArray<struct FModifiedVoxelMaterial>& ModifiedVoxels);
	static struct FVoxelIntBox GetModifiedVoxelValuesBounds(const TArray<struct FModifiedVoxelValue>& ModifiedVoxels);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelToolsBase">();
	}
	static class UVoxelToolsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelToolsBase>();
	}
};
static_assert(alignof(UVoxelToolsBase) == 0x000008, "Wrong alignment on UVoxelToolsBase");
static_assert(sizeof(UVoxelToolsBase) == 0x000028, "Wrong size on UVoxelToolsBase");

// Class Voxel.VoxelBoxTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelBoxTools final : public UVoxelToolsBase
{
public:
	static void AddBox(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender);
	static void AddBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender, bool bHideLatentWarnings);
	static void RemoveBox(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender);
	static void RemoveBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender, bool bHideLatentWarnings);
	static void SetMaterialBox(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, const struct FVoxelPaintMaterial& PaintMaterial, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender);
	static void SetMaterialBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, const struct FVoxelPaintMaterial& PaintMaterial, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender, bool bHideLatentWarnings);
	static void SetValueBox(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, float Value, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender);
	static void SetValueBoxAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Bounds, float Value, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender, bool bHideLatentWarnings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBoxTools">();
	}
	static class UVoxelBoxTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBoxTools>();
	}
};
static_assert(alignof(UVoxelBoxTools) == 0x000008, "Wrong alignment on UVoxelBoxTools");
static_assert(sizeof(UVoxelBoxTools) == 0x000028, "Wrong size on UVoxelBoxTools");

// Class Voxel.VoxelCharacter
// 0x0000 (0x04C0 - 0x04C0)
class AVoxelCharacter final : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelCharacter">();
	}
	static class AVoxelCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelCharacter>();
	}
};
static_assert(alignof(AVoxelCharacter) == 0x000010, "Wrong alignment on AVoxelCharacter");
static_assert(sizeof(AVoxelCharacter) == 0x0004C0, "Wrong size on AVoxelCharacter");

// Class Voxel.VoxelSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelSubsystemProxy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSubsystemProxy">();
	}
	static class UVoxelSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelSubsystemProxy");
static_assert(sizeof(UVoxelSubsystemProxy) == 0x000028, "Wrong size on UVoxelSubsystemProxy");

// Class Voxel.VoxelStaticSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelStaticSubsystemProxy : public UVoxelSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelStaticSubsystemProxy">();
	}
	static class UVoxelStaticSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelStaticSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelStaticSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelStaticSubsystemProxy");
static_assert(sizeof(UVoxelStaticSubsystemProxy) == 0x000028, "Wrong size on UVoxelStaticSubsystemProxy");

// Class Voxel.VoxelChunksSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelChunksSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelChunksSubsystemProxy">();
	}
	static class UVoxelChunksSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelChunksSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelChunksSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelChunksSubsystemProxy");
static_assert(sizeof(UVoxelChunksSubsystemProxy) == 0x000028, "Wrong size on UVoxelChunksSubsystemProxy");

// Class Voxel.VoxelGenerator
// 0x0000 (0x0028 - 0x0028)
class UVoxelGenerator : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGenerator">();
	}
	static class UVoxelGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGenerator>();
	}
};
static_assert(alignof(UVoxelGenerator) == 0x000008, "Wrong alignment on UVoxelGenerator");
static_assert(sizeof(UVoxelGenerator) == 0x000028, "Wrong size on UVoxelGenerator");

// Class Voxel.VoxelChunkGenerator
// 0x0000 (0x0028 - 0x0028)
class UVoxelChunkGenerator final : public UVoxelGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelChunkGenerator">();
	}
	static class UVoxelChunkGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelChunkGenerator>();
	}
};
static_assert(alignof(UVoxelChunkGenerator) == 0x000008, "Wrong alignment on UVoxelChunkGenerator");
static_assert(sizeof(UVoxelChunkGenerator) == 0x000028, "Wrong size on UVoxelChunkGenerator");

// Class Voxel.VoxelCookingLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelCookingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVoxelCookedData CookVoxelData(const struct FVoxelCookingSettings& Settings);
	static struct FVoxelCookedData CookVoxelDataWithSave(const struct FVoxelCookingSettings& Settings, const struct FVoxelUncompressedWorldSave& Save);
	static void LoadCookedVoxelData(const struct FVoxelCookedData& CookedData, class AVoxelWorld* World);
	static struct FVoxelCookingSettings MakeVoxelCookingSettingsFromVoxelWorld(class AVoxelWorld* World);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelCookingLibrary">();
	}
	static class UVoxelCookingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelCookingLibrary>();
	}
};
static_assert(alignof(UVoxelCookingLibrary) == 0x000008, "Wrong alignment on UVoxelCookingLibrary");
static_assert(sizeof(UVoxelCookingLibrary) == 0x000028, "Wrong size on UVoxelCookingLibrary");

// Class Voxel.VoxelCubicLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelCubicLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FIntVector GetCubicVoxelPositionFromHit(class AVoxelWorld* World, const struct FVector& HitPosition, const struct FVector& HitNormal, bool bSelectVoxelOutside);
	static bool GetCubicVoxelValue(class AVoxelWorld* World, const struct FIntVector& Position);
	static void SetCubicVoxelValue(class AVoxelWorld* World, const struct FIntVector& Position, bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelCubicLibrary">();
	}
	static class UVoxelCubicLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelCubicLibrary>();
	}
};
static_assert(alignof(UVoxelCubicLibrary) == 0x000008, "Wrong alignment on UVoxelCubicLibrary");
static_assert(sizeof(UVoxelCubicLibrary) == 0x000028, "Wrong size on UVoxelCubicLibrary");

// Class Voxel.VoxelTransformableGenerator
// 0x0000 (0x0028 - 0x0028)
class UVoxelTransformableGenerator : public UVoxelGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelTransformableGenerator">();
	}
	static class UVoxelTransformableGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelTransformableGenerator>();
	}
};
static_assert(alignof(UVoxelTransformableGenerator) == 0x000008, "Wrong alignment on UVoxelTransformableGenerator");
static_assert(sizeof(UVoxelTransformableGenerator) == 0x000028, "Wrong size on UVoxelTransformableGenerator");

// Class Voxel.VoxelTransformableGeneratorWithBounds
// 0x0000 (0x0028 - 0x0028)
class UVoxelTransformableGeneratorWithBounds : public UVoxelTransformableGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelTransformableGeneratorWithBounds">();
	}
	static class UVoxelTransformableGeneratorWithBounds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelTransformableGeneratorWithBounds>();
	}
};
static_assert(alignof(UVoxelTransformableGeneratorWithBounds) == 0x000008, "Wrong alignment on UVoxelTransformableGeneratorWithBounds");
static_assert(sizeof(UVoxelTransformableGeneratorWithBounds) == 0x000028, "Wrong size on UVoxelTransformableGeneratorWithBounds");

// Class Voxel.VoxelDataAsset
// 0x0078 (0x00A0 - 0x0028)
class UVoxelDataAsset final : public UVoxelTransformableGeneratorWithBounds
{
public:
	bool                                          bSubtractiveAsset;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             PositionOffset;                                    // 0x002C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Size;                                              // 0x003C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UncompressedSizeInMB;                              // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompressedSizeInMB;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelDataAssetImportSource                   Source;                                            // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Paths;                                             // 0x0058(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FVoxelDataAssetImportSettings_MagicaVox ImportSettings_MagicaVox;                          // 0x0068(0x0008)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VoxelCustomVersion;                                // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        ValueConfigFlag;                                   // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        MaterialConfigFlag;                                // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C[0x14];                                      // 0x008C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVoxelIntBox GetBounds() const;
	struct FIntVector GetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDataAsset">();
	}
	static class UVoxelDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelDataAsset>();
	}
};
static_assert(alignof(UVoxelDataAsset) == 0x000008, "Wrong alignment on UVoxelDataAsset");
static_assert(sizeof(UVoxelDataAsset) == 0x0000A0, "Wrong size on UVoxelDataAsset");
static_assert(offsetof(UVoxelDataAsset, bSubtractiveAsset) == 0x000028, "Member 'UVoxelDataAsset::bSubtractiveAsset' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, PositionOffset) == 0x00002C, "Member 'UVoxelDataAsset::PositionOffset' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, Tolerance) == 0x000038, "Member 'UVoxelDataAsset::Tolerance' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, Size) == 0x00003C, "Member 'UVoxelDataAsset::Size' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, UncompressedSizeInMB) == 0x000048, "Member 'UVoxelDataAsset::UncompressedSizeInMB' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, CompressedSizeInMB) == 0x00004C, "Member 'UVoxelDataAsset::CompressedSizeInMB' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, Source) == 0x000050, "Member 'UVoxelDataAsset::Source' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, Paths) == 0x000058, "Member 'UVoxelDataAsset::Paths' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, ImportSettings_MagicaVox) == 0x000068, "Member 'UVoxelDataAsset::ImportSettings_MagicaVox' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, VoxelCustomVersion) == 0x000080, "Member 'UVoxelDataAsset::VoxelCustomVersion' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, ValueConfigFlag) == 0x000084, "Member 'UVoxelDataAsset::ValueConfigFlag' has a wrong offset!");
static_assert(offsetof(UVoxelDataAsset, MaterialConfigFlag) == 0x000088, "Member 'UVoxelDataAsset::MaterialConfigFlag' has a wrong offset!");

// Class Voxel.VoxelDataItemActor
// 0x0028 (0x0248 - 0x0220)
class AVoxelDataItemActor final : public AActor
{
public:
	bool                                          bAutomaticUpdates;                                 // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RefreshDelay;                                      // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x20];                                     // 0x0228(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_AddItemToWorld(class AVoxelWorld* World);
	void ScheduleRefresh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDataItemActor">();
	}
	static class AVoxelDataItemActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelDataItemActor>();
	}
};
static_assert(alignof(AVoxelDataItemActor) == 0x000008, "Wrong alignment on AVoxelDataItemActor");
static_assert(sizeof(AVoxelDataItemActor) == 0x000248, "Wrong size on AVoxelDataItemActor");
static_assert(offsetof(AVoxelDataItemActor, bAutomaticUpdates) == 0x000220, "Member 'AVoxelDataItemActor::bAutomaticUpdates' has a wrong offset!");
static_assert(offsetof(AVoxelDataItemActor, RefreshDelay) == 0x000224, "Member 'AVoxelDataItemActor::RefreshDelay' has a wrong offset!");

// Class Voxel.VoxelDataSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelDataSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDataSubsystemProxy">();
	}
	static class UVoxelDataSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelDataSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelDataSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelDataSubsystemProxy");
static_assert(sizeof(UVoxelDataSubsystemProxy) == 0x000028, "Wrong size on UVoxelDataSubsystemProxy");

// Class Voxel.VoxelDataTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelDataTools final : public UBlueprintFunctionLibrary
{
public:
	static void CacheMaterials(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bMultiThreaded);
	static void CacheMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void CacheValues(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bMultiThreaded);
	static void CacheValuesAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void CheckForSingleMaterials(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void CheckForSingleMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void CheckForSingleValues(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void CheckForSingleValuesAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void CheckIfSameAsGenerator(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void CheckIfSameAsGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void ClearCachedMaterials(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void ClearCachedMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void ClearCachedValues(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void ClearCachedValuesAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void ClearUnusedMaterials(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void ClearUnusedMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void CompressIntoHeightmap(class AVoxelWorld* World, class UVoxelHeightmapAsset* HeightmapAsset, bool bHeightmapAssetMatchesWorld);
	static void FindClosestNonEmptyVoxel(struct FVoxelFindClosestNonEmptyVoxelResult* Result, class AVoxelWorld* World, const struct FVector& Position, bool bReadMaterial, bool bConvertToVoxelSpace);
	static void FindClosestNonEmptyVoxelAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelFindClosestNonEmptyVoxelResult* Result, class AVoxelWorld* World, const struct FVector& Position, bool bReadMaterial, bool bConvertToVoxelSpace, bool bHideLatentWarnings);
	static void GetCompressedSave(class AVoxelWorld* World, struct FVoxelCompressedWorldSave* OutSave);
	static void GetCompressedSaveAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, struct FVoxelCompressedWorldSave* OutSave, bool bHideLatentWarnings);
	static struct FVoxelDataMemoryUsageInMB GetDataMemoryUsageInMB(class AVoxelWorld* World);
	static void GetInterpolatedValue(float* Value, class AVoxelWorld* World, const struct FVector& Position);
	static void GetMaterial(struct FVoxelMaterial* Material, class AVoxelWorld* World, const struct FIntVector& Position);
	static void GetMaterialAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelMaterial* Material, class AVoxelWorld* World, const struct FIntVector& Position, bool bHideLatentWarnings);
	static void GetSave(class AVoxelWorld* World, struct FVoxelUncompressedWorldSave* OutSave);
	static void GetSaveAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, struct FVoxelUncompressedWorldSave* OutSave, bool bHideLatentWarnings);
	static void GetValue(float* Value, class AVoxelWorld* World, const struct FIntVector& Position);
	static void GetValueAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float* Value, class AVoxelWorld* World, const struct FIntVector& Position, bool bHideLatentWarnings);
	static void GetVoxelsValueAndMaterial(TArray<struct FVoxelValueMaterial>* Voxels, class AVoxelWorld* World, const TArray<struct FIntVector>& Positions);
	static void GetVoxelsValueAndMaterialAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FVoxelValueMaterial>* Voxels, class AVoxelWorld* World, const TArray<struct FIntVector>& Positions, bool bHideLatentWarnings);
	static bool LoadFromCompressedSave(const class AVoxelWorld* World, const struct FVoxelCompressedWorldSave& Save);
	static bool LoadFromSave(const class AVoxelWorld* World, const struct FVoxelUncompressedWorldSave& Save);
	static void RoundToGenerator(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bPreserveNormals);
	static void RoundToGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bPreserveNormals, bool bHideLatentWarnings);
	static void RoundVoxels(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void RoundVoxelsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bHideLatentWarnings);
	static void SetBoxAsDirty(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bDirtyValues, bool bDirtyMaterials);
	static void SetBoxAsDirtyAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bDirtyValues, bool bDirtyMaterials, bool bHideLatentWarnings);
	static void SetMaterial(class AVoxelWorld* World, const struct FIntVector& Position, const struct FVoxelMaterial& Material, int32 Mask);
	static void SetMaterialAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FIntVector& Position, const struct FVoxelMaterial& Material, bool bHideLatentWarnings);
	static void SetValue(class AVoxelWorld* World, const struct FIntVector& Position, float Value, bool bUpdateRender);
	static void SetValueAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AVoxelWorld* World, const struct FIntVector& Position, float Value, bool bHideLatentWarnings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDataTools">();
	}
	static class UVoxelDataTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelDataTools>();
	}
};
static_assert(alignof(UVoxelDataTools) == 0x000008, "Wrong alignment on UVoxelDataTools");
static_assert(sizeof(UVoxelDataTools) == 0x000028, "Wrong size on UVoxelDataTools");

// Class Voxel.VoxelDebugSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelDebugSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDebugSubsystemProxy">();
	}
	static class UVoxelDebugSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelDebugSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelDebugSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelDebugSubsystemProxy");
static_assert(sizeof(UVoxelDebugSubsystemProxy) == 0x000028, "Wrong size on UVoxelDebugSubsystemProxy");

// Class Voxel.VoxelDebugUtilities
// 0x0000 (0x0028 - 0x0028)
class UVoxelDebugUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void DebugVoxelsInsideBounds(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, const struct FLinearColor& Color, float LifeTime, float Thickness, bool bDebugDensities, const struct FLinearColor& TextColor);
	static void DrawDataOctree(class AVoxelWorld* World, EVoxelDataType DataType, float LifeTime, bool bShowSingle, bool bShowCached, const struct FColor& SingleColor, const struct FColor& SingleDirtyColor, const struct FColor& CachedColor, const struct FColor& DirtyColor);
	static void DrawDebugIntBox(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, const struct FTransform& Transform, float LifeTime, float Thickness, const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDebugUtilities">();
	}
	static class UVoxelDebugUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelDebugUtilities>();
	}
};
static_assert(alignof(UVoxelDebugUtilities) == 0x000008, "Wrong alignment on UVoxelDebugUtilities");
static_assert(sizeof(UVoxelDebugUtilities) == 0x000028, "Wrong size on UVoxelDebugUtilities");

// Class Voxel.VoxelDynamicSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelDynamicSubsystemProxy : public UVoxelSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDynamicSubsystemProxy">();
	}
	static class UVoxelDynamicSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelDynamicSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelDynamicSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelDynamicSubsystemProxy");
static_assert(sizeof(UVoxelDynamicSubsystemProxy) == 0x000028, "Wrong size on UVoxelDynamicSubsystemProxy");

// Class Voxel.VoxelLODSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelLODSubsystemProxy : public UVoxelDynamicSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLODSubsystemProxy">();
	}
	static class UVoxelLODSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelLODSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelLODSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelLODSubsystemProxy");
static_assert(sizeof(UVoxelLODSubsystemProxy) == 0x000028, "Wrong size on UVoxelLODSubsystemProxy");

// Class Voxel.VoxelDefaultLODSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelDefaultLODSubsystemProxy final : public UVoxelLODSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDefaultLODSubsystemProxy">();
	}
	static class UVoxelDefaultLODSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelDefaultLODSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelDefaultLODSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelDefaultLODSubsystemProxy");
static_assert(sizeof(UVoxelDefaultLODSubsystemProxy) == 0x000028, "Wrong size on UVoxelDefaultLODSubsystemProxy");

// Class Voxel.VoxelRendererSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelRendererSubsystemProxy : public UVoxelDynamicSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelRendererSubsystemProxy">();
	}
	static class UVoxelRendererSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelRendererSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelRendererSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelRendererSubsystemProxy");
static_assert(sizeof(UVoxelRendererSubsystemProxy) == 0x000028, "Wrong size on UVoxelRendererSubsystemProxy");

// Class Voxel.VoxelDefaultRendererSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelDefaultRendererSubsystemProxy final : public UVoxelRendererSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDefaultRendererSubsystemProxy">();
	}
	static class UVoxelDefaultRendererSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelDefaultRendererSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelDefaultRendererSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelDefaultRendererSubsystemProxy");
static_assert(sizeof(UVoxelDefaultRendererSubsystemProxy) == 0x000028, "Wrong size on UVoxelDefaultRendererSubsystemProxy");

// Class Voxel.VoxelDisableEditsBox
// 0x0008 (0x0238 - 0x0230)
class AVoxelDisableEditsBox final : public AVoxelPlaceableItemActor
{
public:
	class UBoxComponent*                          Box;                                               // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelDisableEditsBox">();
	}
	static class AVoxelDisableEditsBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelDisableEditsBox>();
	}
};
static_assert(alignof(AVoxelDisableEditsBox) == 0x000008, "Wrong alignment on AVoxelDisableEditsBox");
static_assert(sizeof(AVoxelDisableEditsBox) == 0x000238, "Wrong size on AVoxelDisableEditsBox");
static_assert(offsetof(AVoxelDisableEditsBox, Box) == 0x000230, "Member 'AVoxelDisableEditsBox::Box' has a wrong offset!");

// Class Voxel.VoxelEmptyGenerator
// 0x0000 (0x0028 - 0x0028)
class UVoxelEmptyGenerator final : public UVoxelTransformableGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelEmptyGenerator">();
	}
	static class UVoxelEmptyGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelEmptyGenerator>();
	}
};
static_assert(alignof(UVoxelEmptyGenerator) == 0x000008, "Wrong alignment on UVoxelEmptyGenerator");
static_assert(sizeof(UVoxelEmptyGenerator) == 0x000028, "Wrong size on UVoxelEmptyGenerator");

// Class Voxel.VoxelErosion
// 0x0100 (0x0128 - 0x0028)
class UVoxelErosion final : public UObject
{
public:
	int32                                         Size;                                              // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Gravity;                                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SedimentCapacity;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SedimentDissolving;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SedimentDeposition;                                // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RainStrength;                                      // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Evaporation;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelFloatTexture                     RainMapInit;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVoxelFloatTexture                     HeightmapInit;                                     // 0x0068(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0xA8];                                      // 0x0080(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVoxelFloatTexture GetSedimentTexture();
	struct FVoxelFloatTexture GetTerrainHeightTexture();
	struct FVoxelFloatTexture GetWaterHeightTexture();
	void Initialize();
	void Step(int32 Count);

	bool IsInitialized() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelErosion">();
	}
	static class UVoxelErosion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelErosion>();
	}
};
static_assert(alignof(UVoxelErosion) == 0x000008, "Wrong alignment on UVoxelErosion");
static_assert(sizeof(UVoxelErosion) == 0x000128, "Wrong size on UVoxelErosion");
static_assert(offsetof(UVoxelErosion, Size) == 0x000028, "Member 'UVoxelErosion::Size' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, DeltaTime) == 0x00002C, "Member 'UVoxelErosion::DeltaTime' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, Scale) == 0x000030, "Member 'UVoxelErosion::Scale' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, Gravity) == 0x000034, "Member 'UVoxelErosion::Gravity' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, SedimentCapacity) == 0x000038, "Member 'UVoxelErosion::SedimentCapacity' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, SedimentDissolving) == 0x00003C, "Member 'UVoxelErosion::SedimentDissolving' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, SedimentDeposition) == 0x000040, "Member 'UVoxelErosion::SedimentDeposition' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, RainStrength) == 0x000044, "Member 'UVoxelErosion::RainStrength' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, Evaporation) == 0x000048, "Member 'UVoxelErosion::Evaporation' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, RainMapInit) == 0x000050, "Member 'UVoxelErosion::RainMapInit' has a wrong offset!");
static_assert(offsetof(UVoxelErosion, HeightmapInit) == 0x000068, "Member 'UVoxelErosion::HeightmapInit' has a wrong offset!");

// Class Voxel.VoxelEventSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelEventSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelEventSubsystemProxy">();
	}
	static class UVoxelEventSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelEventSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelEventSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelEventSubsystemProxy");
static_assert(sizeof(UVoxelEventSubsystemProxy) == 0x000028, "Wrong size on UVoxelEventSubsystemProxy");

// Class Voxel.VoxelFixedResolutionLODSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelFixedResolutionLODSubsystemProxy final : public UVoxelLODSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelFixedResolutionLODSubsystemProxy">();
	}
	static class UVoxelFixedResolutionLODSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelFixedResolutionLODSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelFixedResolutionLODSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelFixedResolutionLODSubsystemProxy");
static_assert(sizeof(UVoxelFixedResolutionLODSubsystemProxy) == 0x000028, "Wrong size on UVoxelFixedResolutionLODSubsystemProxy");

// Class Voxel.VoxelFlatGenerator
// 0x0020 (0x0048 - 0x0028)
class UVoxelFlatGenerator final : public UVoxelGenerator
{
public:
	struct FLinearColor                           Color;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVoxelFlatGeneratorDataItemConfig> DataItemConfigs;                                   // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelFlatGenerator">();
	}
	static class UVoxelFlatGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelFlatGenerator>();
	}
};
static_assert(alignof(UVoxelFlatGenerator) == 0x000008, "Wrong alignment on UVoxelFlatGenerator");
static_assert(sizeof(UVoxelFlatGenerator) == 0x000048, "Wrong size on UVoxelFlatGenerator");
static_assert(offsetof(UVoxelFlatGenerator, Color) == 0x000028, "Member 'UVoxelFlatGenerator::Color' has a wrong offset!");
static_assert(offsetof(UVoxelFlatGenerator, DataItemConfigs) == 0x000038, "Member 'UVoxelFlatGenerator::DataItemConfigs' has a wrong offset!");

// Class Voxel.VoxelTool
// 0x0158 (0x0180 - 0x0028)
class UVoxelTool : public UObject
{
public:
	class FName                                   ToolName;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Tooltip;                                           // 0x0030(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShowInDropdown;                                   // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPaintMaterial;                                // 0x0049(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelToolSharedConfig*                 SharedConfig;                                      // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabled;                                          // 0x0058(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelToolTickData                     FrozenTickData;                                    // 0x0060(0x0120)(Transient, NativeAccessSpecifierPrivate)

public:
	static bool Deproject(const struct FVoxelToolTickData& TickData, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection);
	static float GetAxis(const struct FVoxelToolTickData& TickData, class FName Axis);
	static struct FVector GetRayDirection(const struct FVoxelToolTickData& TickData);
	static struct FVector GetRayOrigin(const struct FVoxelToolTickData& TickData);
	static bool IsAlternativeMode(const struct FVoxelToolTickData& TickData);
	static bool IsKeyDown(const struct FVoxelToolTickData& TickData, class FName Key);
	static TMap<class FName, float> MakeToolAxes(float BrushSizeDelta, float FalloffDelta, float StrengthDelta);
	static TMap<class FName, bool> MakeToolKeys(bool bAlternativeMode);
	static class UVoxelTool* MakeVoxelTool(TSubclassOf<class UVoxelTool> ToolClass);
	static struct FVoxelToolTickData MakeVoxelToolTickData(class APlayerController* PlayerController, bool bEdit, const TMap<class FName, bool>& Keys, const TMap<class FName, float>& Axes, const struct FVector2D& MousePosition, const struct FVector& CameraDirection, ECollisionChannel CollisionChannel);

	void Apply(class AVoxelWorld* World, const struct FVector& Position, const struct FVector& Normal, const TMap<class FName, bool>& Keys, const TMap<class FName, float>& Axes);
	void DisableTool();
	void EnableTool();
	void K2_AdvancedTick(class UObject* WorldContextObject, const struct FVoxelToolTickData& TickData, const TDelegate<void(const struct FVector& Position, const struct FVector& Normal)>& DoEditOverride);
	void K2_SimpleTick(class APlayerController* PlayerController, bool bEdit, const TMap<class FName, bool>& Keys, const TMap<class FName, float>& Axes, const TDelegate<void(const struct FVector& Position, const struct FVector& Normal)>& DoEditOverride, ECollisionChannel CollisionChannel);

	class FName GetToolName() const;
	class AVoxelWorld* GetVoxelWorld() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelTool">();
	}
	static class UVoxelTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelTool>();
	}
};
static_assert(alignof(UVoxelTool) == 0x000010, "Wrong alignment on UVoxelTool");
static_assert(sizeof(UVoxelTool) == 0x000180, "Wrong size on UVoxelTool");
static_assert(offsetof(UVoxelTool, ToolName) == 0x000028, "Member 'UVoxelTool::ToolName' has a wrong offset!");
static_assert(offsetof(UVoxelTool, Tooltip) == 0x000030, "Member 'UVoxelTool::Tooltip' has a wrong offset!");
static_assert(offsetof(UVoxelTool, bShowInDropdown) == 0x000048, "Member 'UVoxelTool::bShowInDropdown' has a wrong offset!");
static_assert(offsetof(UVoxelTool, bShowPaintMaterial) == 0x000049, "Member 'UVoxelTool::bShowPaintMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelTool, SharedConfig) == 0x000050, "Member 'UVoxelTool::SharedConfig' has a wrong offset!");
static_assert(offsetof(UVoxelTool, bEnabled) == 0x000058, "Member 'UVoxelTool::bEnabled' has a wrong offset!");
static_assert(offsetof(UVoxelTool, FrozenTickData) == 0x000060, "Member 'UVoxelTool::FrozenTickData' has a wrong offset!");

// Class Voxel.VoxelToolBase
// 0x03D0 (0x0550 - 0x0180)
#pragma pack(push, 0x1)
class alignas(0x10) UVoxelToolBase : public UVoxelTool
{
public:
	class AVoxelWorld*                            VoxelWorld;                                        // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x3A8];                                    // 0x0188(0x03A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ToolOverlayMaterialInstance;                       // 0x0530(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               ToolMeshMaterialInstance;                          // 0x0538(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               PlaneMeshMaterialInstance;                         // 0x0540(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FVoxelIntBoxWithValidity K2_DoEdit();
	void K2_Tick();
	void K2_UpdateRender(class UMaterialInstanceDynamic* OverlayMaterialInstance, class UMaterialInstanceDynamic* MeshMaterialInstance);
	void SetToolOverlayBounds(const struct FBox& Bounds);
	void UpdateToolMesh(class UStaticMesh* Mesh, class UMaterialInterface* Material, const struct FTransform& Transform, class FName ID);

	bool CanEdit() const;
	struct FVoxelIntBox GetBoundsToCache(const struct FVoxelIntBox& Bounds) const;
	float GetDeltaTime() const;
	const struct FVoxelToolTickData GetLastFrameTickData() const;
	float GetMouseMovementSize() const;
	const struct FVoxelToolTickData GetTickData() const;
	struct FVector GetToolDirection() const;
	struct FVector GetToolNormal() const;
	struct FVector GetToolPosition() const;
	struct FVector GetToolPreviewPosition() const;
	float GetValueAfterAxisInput(class FName AxisName, float CurrentValue, float Min, float Max) const;
	void K2_GetToolConfig(const struct FVoxelToolBaseConfig& InConfig, struct FVoxelToolBaseConfig* OutConfig) const;
	bool LastFrameCanEdit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelToolBase">();
	}
	static class UVoxelToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelToolBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVoxelToolBase) == 0x000010, "Wrong alignment on UVoxelToolBase");
static_assert(sizeof(UVoxelToolBase) == 0x000550, "Wrong size on UVoxelToolBase");
static_assert(offsetof(UVoxelToolBase, VoxelWorld) == 0x000180, "Member 'UVoxelToolBase::VoxelWorld' has a wrong offset!");
static_assert(offsetof(UVoxelToolBase, ToolOverlayMaterialInstance) == 0x000530, "Member 'UVoxelToolBase::ToolOverlayMaterialInstance' has a wrong offset!");
static_assert(offsetof(UVoxelToolBase, ToolMeshMaterialInstance) == 0x000538, "Member 'UVoxelToolBase::ToolMeshMaterialInstance' has a wrong offset!");
static_assert(offsetof(UVoxelToolBase, PlaneMeshMaterialInstance) == 0x000540, "Member 'UVoxelToolBase::PlaneMeshMaterialInstance' has a wrong offset!");

// Class Voxel.VoxelFlattenTool
// 0x0040 (0x0590 - 0x0550)
class UVoxelFlattenTool final : public UVoxelToolBase
{
public:
	class UMaterialInterface*                     ToolMaterial;                                      // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFreezeOnClick;                                    // 0x0554(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAverage;                                       // 0x0555(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFixedRotation;                                 // 0x0556(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_557[0x1];                                      // 0x0557(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FixedRotation;                                     // 0x0558(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPropagateMaterials;                               // 0x0564(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFalloff;                                    // 0x0565(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelFalloff                                 FalloffType;                                       // 0x0566(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_567[0x1];                                      // 0x0567(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Falloff;                                           // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x24];                                     // 0x056C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelFlattenTool">();
	}
	static class UVoxelFlattenTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelFlattenTool>();
	}
};
static_assert(alignof(UVoxelFlattenTool) == 0x000010, "Wrong alignment on UVoxelFlattenTool");
static_assert(sizeof(UVoxelFlattenTool) == 0x000590, "Wrong size on UVoxelFlattenTool");
static_assert(offsetof(UVoxelFlattenTool, ToolMaterial) == 0x000548, "Member 'UVoxelFlattenTool::ToolMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, Strength) == 0x000550, "Member 'UVoxelFlattenTool::Strength' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, bFreezeOnClick) == 0x000554, "Member 'UVoxelFlattenTool::bFreezeOnClick' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, bUseAverage) == 0x000555, "Member 'UVoxelFlattenTool::bUseAverage' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, bUseFixedRotation) == 0x000556, "Member 'UVoxelFlattenTool::bUseFixedRotation' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, FixedRotation) == 0x000558, "Member 'UVoxelFlattenTool::FixedRotation' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, bPropagateMaterials) == 0x000564, "Member 'UVoxelFlattenTool::bPropagateMaterials' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, bEnableFalloff) == 0x000565, "Member 'UVoxelFlattenTool::bEnableFalloff' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, FalloffType) == 0x000566, "Member 'UVoxelFlattenTool::FalloffType' has a wrong offset!");
static_assert(offsetof(UVoxelFlattenTool, Falloff) == 0x000568, "Member 'UVoxelFlattenTool::Falloff' has a wrong offset!");

// Class Voxel.VoxelFoliageBiomeBase
// 0x0000 (0x0028 - 0x0028)
class UVoxelFoliageBiomeBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelFoliageBiomeBase">();
	}
	static class UVoxelFoliageBiomeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelFoliageBiomeBase>();
	}
};
static_assert(alignof(UVoxelFoliageBiomeBase) == 0x000008, "Wrong alignment on UVoxelFoliageBiomeBase");
static_assert(sizeof(UVoxelFoliageBiomeBase) == 0x000028, "Wrong size on UVoxelFoliageBiomeBase");

// Class Voxel.VoxelFoliageCollectionBase
// 0x0000 (0x0028 - 0x0028)
class UVoxelFoliageCollectionBase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelFoliageCollectionBase">();
	}
	static class UVoxelFoliageCollectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelFoliageCollectionBase>();
	}
};
static_assert(alignof(UVoxelFoliageCollectionBase) == 0x000008, "Wrong alignment on UVoxelFoliageCollectionBase");
static_assert(sizeof(UVoxelFoliageCollectionBase) == 0x000028, "Wrong size on UVoxelFoliageCollectionBase");

// Class Voxel.VoxelFoliageInterfaceSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelFoliageInterfaceSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelFoliageInterfaceSubsystemProxy">();
	}
	static class UVoxelFoliageInterfaceSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelFoliageInterfaceSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelFoliageInterfaceSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelFoliageInterfaceSubsystemProxy");
static_assert(sizeof(UVoxelFoliageInterfaceSubsystemProxy) == 0x000028, "Wrong size on UVoxelFoliageInterfaceSubsystemProxy");

// Class Voxel.VoxelGeneratorCacheSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelGeneratorCacheSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGeneratorCacheSubsystemProxy">();
	}
	static class UVoxelGeneratorCacheSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGeneratorCacheSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelGeneratorCacheSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelGeneratorCacheSubsystemProxy");
static_assert(sizeof(UVoxelGeneratorCacheSubsystemProxy) == 0x000028, "Wrong size on UVoxelGeneratorCacheSubsystemProxy");

// Class Voxel.VoxelGeneratorCache
// 0x0010 (0x0038 - 0x0028)
class UVoxelGeneratorCache final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UVoxelGeneratorInstanceWrapper* MakeGeneratorInstance(const struct FVoxelGeneratorPicker& Picker) const;
	class UVoxelTransformableGeneratorInstanceWrapper* MakeTransformableGeneratorInstance(const struct FVoxelTransformableGeneratorPicker& Picker) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGeneratorCache">();
	}
	static class UVoxelGeneratorCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGeneratorCache>();
	}
};
static_assert(alignof(UVoxelGeneratorCache) == 0x000008, "Wrong alignment on UVoxelGeneratorCache");
static_assert(sizeof(UVoxelGeneratorCache) == 0x000038, "Wrong size on UVoxelGeneratorCache");

// Class Voxel.VoxelGeneratorInstanceWrapper
// 0x0010 (0x0038 - 0x0028)
class UVoxelGeneratorInstanceWrapper final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGeneratorInstanceWrapper">();
	}
	static class UVoxelGeneratorInstanceWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGeneratorInstanceWrapper>();
	}
};
static_assert(alignof(UVoxelGeneratorInstanceWrapper) == 0x000008, "Wrong alignment on UVoxelGeneratorInstanceWrapper");
static_assert(sizeof(UVoxelGeneratorInstanceWrapper) == 0x000038, "Wrong size on UVoxelGeneratorInstanceWrapper");

// Class Voxel.VoxelTransformableGeneratorInstanceWrapper
// 0x0010 (0x0038 - 0x0028)
class UVoxelTransformableGeneratorInstanceWrapper final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelTransformableGeneratorInstanceWrapper">();
	}
	static class UVoxelTransformableGeneratorInstanceWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelTransformableGeneratorInstanceWrapper>();
	}
};
static_assert(alignof(UVoxelTransformableGeneratorInstanceWrapper) == 0x000008, "Wrong alignment on UVoxelTransformableGeneratorInstanceWrapper");
static_assert(sizeof(UVoxelTransformableGeneratorInstanceWrapper) == 0x000038, "Wrong size on UVoxelTransformableGeneratorInstanceWrapper");

// Class Voxel.VoxelGeneratorTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelGeneratorTools final : public UBlueprintFunctionLibrary
{
public:
	static void CreateColorTextureFromGenerator(struct FVoxelColorTexture* OutTexture, class UVoxelGeneratorInstanceWrapper* Generator, class FName OutputName, int32 SizeX, int32 SizeY, float Scale, int32 StartX, int32 StartY);
	static void CreateColorTextureFromGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelColorTexture* OutTexture, class UVoxelGeneratorInstanceWrapper* Generator, class FName OutputName, int32 SizeX, int32 SizeY, float Scale, int32 StartX, int32 StartY, bool bHideLatentWarnings);
	static void CreateFloatTextureFromGenerator(struct FVoxelFloatTexture* OutTexture, class UVoxelGeneratorInstanceWrapper* Generator, class FName OutputName, int32 SizeX, int32 SizeY, float Scale, int32 StartX, int32 StartY);
	static void CreateFloatTextureFromGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelFloatTexture* OutTexture, class UVoxelGeneratorInstanceWrapper* Generator, class FName OutputName, int32 SizeX, int32 SizeY, float Scale, int32 StartX, int32 StartY, bool bHideLatentWarnings);
	static bool IsValid_GeneratorPicker(const struct FVoxelGeneratorPicker& GeneratorPicker);
	static bool IsValid_TransformableGeneratorPicker(const struct FVoxelTransformableGeneratorPicker& GeneratorPicker);
	static class UVoxelGeneratorInstanceWrapper* MakeGeneratorInstance(const struct FVoxelGeneratorPicker& GeneratorPicker, const struct FVoxelGeneratorInit& GeneratorInit);
	static struct FVoxelGeneratorPicker MakeGeneratorPickerFromClass(TSubclassOf<class UVoxelGenerator> GeneratorClass);
	static struct FVoxelGeneratorPicker MakeGeneratorPickerFromObject(class UVoxelGenerator* Generator);
	static class UVoxelTransformableGeneratorInstanceWrapper* MakeTransformableGeneratorInstance(const struct FVoxelTransformableGeneratorPicker& GeneratorPicker, const struct FVoxelGeneratorInit& GeneratorInit);
	static struct FVoxelTransformableGeneratorPicker MakeTransformableGeneratorPickerFromClass(TSubclassOf<class UVoxelTransformableGenerator> GeneratorClass);
	static struct FVoxelTransformableGeneratorPicker MakeTransformableGeneratorPickerFromObject(class UVoxelTransformableGenerator* Generator);
	static bool SetGeneratorParameter(const struct FVoxelGeneratorPicker& Picker, class FName UniqueName, int32 Value);
	static bool SetTransformableGeneratorParameter(const struct FVoxelTransformableGeneratorPicker& Picker, class FName UniqueName, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelGeneratorTools">();
	}
	static class UVoxelGeneratorTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelGeneratorTools>();
	}
};
static_assert(alignof(UVoxelGeneratorTools) == 0x000008, "Wrong alignment on UVoxelGeneratorTools");
static_assert(sizeof(UVoxelGeneratorTools) == 0x000028, "Wrong size on UVoxelGeneratorTools");

// Class Voxel.VoxelHeightmapAsset
// 0x0038 (0x0060 - 0x0028)
class UVoxelHeightmapAsset : public UVoxelTransformableGeneratorWithBounds
{
public:
	float                                         Scale;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightScale;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInfiniteExtent;                                   // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalThickness;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Height;                                            // 0x0044(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VoxelCustomVersion;                                // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        MaterialConfigFlag;                                // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetHeight() const;
	int32 GetWidth() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelHeightmapAsset">();
	}
	static class UVoxelHeightmapAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelHeightmapAsset>();
	}
};
static_assert(alignof(UVoxelHeightmapAsset) == 0x000008, "Wrong alignment on UVoxelHeightmapAsset");
static_assert(sizeof(UVoxelHeightmapAsset) == 0x000060, "Wrong size on UVoxelHeightmapAsset");
static_assert(offsetof(UVoxelHeightmapAsset, Scale) == 0x000028, "Member 'UVoxelHeightmapAsset::Scale' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, HeightScale) == 0x00002C, "Member 'UVoxelHeightmapAsset::HeightScale' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, HeightOffset) == 0x000030, "Member 'UVoxelHeightmapAsset::HeightOffset' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, bInfiniteExtent) == 0x000034, "Member 'UVoxelHeightmapAsset::bInfiniteExtent' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, AdditionalThickness) == 0x000038, "Member 'UVoxelHeightmapAsset::AdditionalThickness' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, Precision) == 0x00003C, "Member 'UVoxelHeightmapAsset::Precision' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, Width) == 0x000040, "Member 'UVoxelHeightmapAsset::Width' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, Height) == 0x000044, "Member 'UVoxelHeightmapAsset::Height' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, VoxelCustomVersion) == 0x000048, "Member 'UVoxelHeightmapAsset::VoxelCustomVersion' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAsset, MaterialConfigFlag) == 0x00004C, "Member 'UVoxelHeightmapAsset::MaterialConfigFlag' has a wrong offset!");

// Class Voxel.VoxelHeightmapAssetFloat
// 0x0010 (0x0070 - 0x0060)
class UVoxelHeightmapAssetFloat final : public UVoxelHeightmapAsset
{
public:
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelHeightmapAssetFloat">();
	}
	static class UVoxelHeightmapAssetFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelHeightmapAssetFloat>();
	}
};
static_assert(alignof(UVoxelHeightmapAssetFloat) == 0x000008, "Wrong alignment on UVoxelHeightmapAssetFloat");
static_assert(sizeof(UVoxelHeightmapAssetFloat) == 0x000070, "Wrong size on UVoxelHeightmapAssetFloat");

// Class Voxel.VoxelHeightmapAssetUINT16
// 0x0048 (0x00A8 - 0x0060)
class UVoxelHeightmapAssetUINT16 final : public UVoxelHeightmapAsset
{
public:
	class FString                                 Heightmap;                                         // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelHeightmapImporterMaterialConfig         MaterialConfig;                                    // 0x0070(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         WeightMaps;                                        // 0x0078(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FVoxelHeightmapImporterWeightmapInfos> WeightmapsInfos;                                   // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelHeightmapAssetUINT16">();
	}
	static class UVoxelHeightmapAssetUINT16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelHeightmapAssetUINT16>();
	}
};
static_assert(alignof(UVoxelHeightmapAssetUINT16) == 0x000008, "Wrong alignment on UVoxelHeightmapAssetUINT16");
static_assert(sizeof(UVoxelHeightmapAssetUINT16) == 0x0000A8, "Wrong size on UVoxelHeightmapAssetUINT16");
static_assert(offsetof(UVoxelHeightmapAssetUINT16, Heightmap) == 0x000060, "Member 'UVoxelHeightmapAssetUINT16::Heightmap' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAssetUINT16, MaterialConfig) == 0x000070, "Member 'UVoxelHeightmapAssetUINT16::MaterialConfig' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAssetUINT16, WeightMaps) == 0x000078, "Member 'UVoxelHeightmapAssetUINT16::WeightMaps' has a wrong offset!");
static_assert(offsetof(UVoxelHeightmapAssetUINT16, WeightmapsInfos) == 0x000088, "Member 'UVoxelHeightmapAssetUINT16::WeightmapsInfos' has a wrong offset!");

// Class Voxel.VoxelInstancedMaterialCollectionTemplates
// 0x0038 (0x0060 - 0x0028)
class UVoxelInstancedMaterialCollectionTemplates final : public UObject
{
public:
	class UMaterialInterface*                     Template;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Template1x;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Template2x;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Template3x;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Template4x;                                        // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Template5x;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Template6x;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelInstancedMaterialCollectionTemplates">();
	}
	static class UVoxelInstancedMaterialCollectionTemplates* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelInstancedMaterialCollectionTemplates>();
	}
};
static_assert(alignof(UVoxelInstancedMaterialCollectionTemplates) == 0x000008, "Wrong alignment on UVoxelInstancedMaterialCollectionTemplates");
static_assert(sizeof(UVoxelInstancedMaterialCollectionTemplates) == 0x000060, "Wrong size on UVoxelInstancedMaterialCollectionTemplates");
static_assert(offsetof(UVoxelInstancedMaterialCollectionTemplates, Template) == 0x000028, "Member 'UVoxelInstancedMaterialCollectionTemplates::Template' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollectionTemplates, Template1x) == 0x000030, "Member 'UVoxelInstancedMaterialCollectionTemplates::Template1x' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollectionTemplates, Template2x) == 0x000038, "Member 'UVoxelInstancedMaterialCollectionTemplates::Template2x' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollectionTemplates, Template3x) == 0x000040, "Member 'UVoxelInstancedMaterialCollectionTemplates::Template3x' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollectionTemplates, Template4x) == 0x000048, "Member 'UVoxelInstancedMaterialCollectionTemplates::Template4x' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollectionTemplates, Template5x) == 0x000050, "Member 'UVoxelInstancedMaterialCollectionTemplates::Template5x' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollectionTemplates, Template6x) == 0x000058, "Member 'UVoxelInstancedMaterialCollectionTemplates::Template6x' has a wrong offset!");

// Class Voxel.VoxelInstancedMaterialCollection
// 0x0040 (0x00B8 - 0x0078)
class UVoxelInstancedMaterialCollection : public UVoxelCachedMaterialCollection
{
public:
	int32                                         MaxMaterialsToBlendAtOnce;                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Redirects;                                         // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ParametersPrefix;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelInstancedMaterialCollectionTemplates* Templates;                                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVoxelInstancedMaterialCollectionLayer> Layers;                                            // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelInstancedMaterialCollection">();
	}
	static class UVoxelInstancedMaterialCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelInstancedMaterialCollection>();
	}
};
static_assert(alignof(UVoxelInstancedMaterialCollection) == 0x000008, "Wrong alignment on UVoxelInstancedMaterialCollection");
static_assert(sizeof(UVoxelInstancedMaterialCollection) == 0x0000B8, "Wrong size on UVoxelInstancedMaterialCollection");
static_assert(offsetof(UVoxelInstancedMaterialCollection, MaxMaterialsToBlendAtOnce) == 0x000078, "Member 'UVoxelInstancedMaterialCollection::MaxMaterialsToBlendAtOnce' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollection, Redirects) == 0x000080, "Member 'UVoxelInstancedMaterialCollection::Redirects' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollection, ParametersPrefix) == 0x000090, "Member 'UVoxelInstancedMaterialCollection::ParametersPrefix' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollection, Templates) == 0x0000A0, "Member 'UVoxelInstancedMaterialCollection::Templates' has a wrong offset!");
static_assert(offsetof(UVoxelInstancedMaterialCollection, Layers) == 0x0000A8, "Member 'UVoxelInstancedMaterialCollection::Layers' has a wrong offset!");

// Class Voxel.VoxelInstancedMaterialCollectionInstance
// 0x0008 (0x00C0 - 0x00B8)
class UVoxelInstancedMaterialCollectionInstance final : public UVoxelInstancedMaterialCollection
{
public:
	class UVoxelInstancedMaterialCollection*      LayersSource;                                      // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelInstancedMaterialCollectionInstance">();
	}
	static class UVoxelInstancedMaterialCollectionInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelInstancedMaterialCollectionInstance>();
	}
};
static_assert(alignof(UVoxelInstancedMaterialCollectionInstance) == 0x000008, "Wrong alignment on UVoxelInstancedMaterialCollectionInstance");
static_assert(sizeof(UVoxelInstancedMaterialCollectionInstance) == 0x0000C0, "Wrong size on UVoxelInstancedMaterialCollectionInstance");
static_assert(offsetof(UVoxelInstancedMaterialCollectionInstance, LayersSource) == 0x0000B8, "Member 'UVoxelInstancedMaterialCollectionInstance::LayersSource' has a wrong offset!");

// Class Voxel.VoxelIntBoxLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelIntBoxLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVoxelIntBox AddBox(const struct FVoxelIntBox& Box, const struct FVoxelIntBox& BoxToAdd);
	static struct FVoxelIntBox AddPoint(const struct FVoxelIntBox& Box, const struct FIntVector& Point);
	static struct FVoxelIntBox ApplyTransform(const struct FVoxelIntBox& Box, const struct FTransform& Transform);
	static void BreakIntBox(const struct FVoxelIntBox& Box, struct FIntVector* Min, struct FIntVector* Max);
	static void BreakIntBoxWithValidity(const struct FVoxelIntBoxWithValidity& BoxWithValidity, struct FVoxelIntBox* Box, bool* bIsValid);
	static struct FVoxelIntBox Center(const struct FVoxelIntBox& Box);
	static bool Contains(const struct FVoxelIntBox& Box, const struct FVoxelIntBox& Other);
	static class FString Conv_IntBoxToString(const struct FVoxelIntBox& IntBox);
	static struct FVoxelIntBox Conv_IntVectorToVoxelIntBox(const struct FIntVector& Vector);
	static bool EqualEqual_IntBoxIntBox(const struct FVoxelIntBox& A, const struct FVoxelIntBox& B);
	static struct FVoxelIntBox Extend(const struct FVoxelIntBox& Box, int32 Extent);
	static struct FVoxelIntBox Extend_IntVector(const struct FVoxelIntBox& Box, const struct FIntVector& Extent);
	static struct FVector GetCenter(const struct FVoxelIntBox& Box);
	static TArray<struct FIntVector> GetCorners(const struct FVoxelIntBox& Box);
	static struct FIntVector GetSize(const struct FVoxelIntBox& Box);
	static struct FVoxelIntBox InfiniteBox();
	static bool Intersect(const struct FVoxelIntBox& Box, const struct FVoxelIntBox& Other);
	static bool IsIntVectorInsideBox(const struct FVoxelIntBox& Box, const struct FIntVector& Position);
	static bool IsValid(const struct FVoxelIntBox& Box);
	static bool IsVectorInsideBox(const struct FVoxelIntBox& Box, const struct FVector& Position);
	static struct FVoxelIntBox MakeBoxFromLocalPositionAndRadius(const struct FIntVector& Position, int32 Radius);
	static struct FVoxelIntBox MakeBoxFromPositionAndRadius(const struct FVector& Position, float Radius);
	static struct FVoxelIntBox MakeIntBox(const struct FIntVector& Min, const struct FIntVector& Max);
	static struct FVoxelIntBox MakeIntBoxFromPoints(const TArray<struct FVector>& Points);
	static struct FVoxelIntBoxWithValidity MakeIntBoxWithValidity(const struct FVoxelIntBox& Box, bool bIsValid);
	static bool NotEqual_IntBoxIntBox(const struct FVoxelIntBox& A, const struct FVoxelIntBox& B);
	static struct FVoxelIntBox Overlap(const struct FVoxelIntBox& A, const struct FVoxelIntBox& B);
	static struct FVoxelIntBox RemoveTranslation(const struct FVoxelIntBox& Box);
	static struct FVoxelIntBox Scale(const struct FVoxelIntBox& Box, int32 Scale_0);
	static struct FVoxelIntBox TranslateBox(const struct FVoxelIntBox& Box, const struct FIntVector& Position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelIntBoxLibrary">();
	}
	static class UVoxelIntBoxLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelIntBoxLibrary>();
	}
};
static_assert(alignof(UVoxelIntBoxLibrary) == 0x000008, "Wrong alignment on UVoxelIntBoxLibrary");
static_assert(sizeof(UVoxelIntBoxLibrary) == 0x000028, "Wrong size on UVoxelIntBoxLibrary");

// Class Voxel.VoxelInvokerWithPredictionComponent
// 0x0010 (0x0230 - 0x0220)
class UVoxelInvokerWithPredictionComponent final : public UVoxelSimpleInvokerComponent
{
public:
	bool                                          bEnablePrediction;                                 // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PredictionTime;                                    // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelInvokerWithPredictionComponent">();
	}
	static class UVoxelInvokerWithPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelInvokerWithPredictionComponent>();
	}
};
static_assert(alignof(UVoxelInvokerWithPredictionComponent) == 0x000010, "Wrong alignment on UVoxelInvokerWithPredictionComponent");
static_assert(sizeof(UVoxelInvokerWithPredictionComponent) == 0x000230, "Wrong size on UVoxelInvokerWithPredictionComponent");
static_assert(offsetof(UVoxelInvokerWithPredictionComponent, bEnablePrediction) == 0x000220, "Member 'UVoxelInvokerWithPredictionComponent::bEnablePrediction' has a wrong offset!");
static_assert(offsetof(UVoxelInvokerWithPredictionComponent, PredictionTime) == 0x000224, "Member 'UVoxelInvokerWithPredictionComponent::PredictionTime' has a wrong offset!");

// Class Voxel.VoxelVolumeInvokerComponent
// 0x0010 (0x0210 - 0x0200)
class UVoxelVolumeInvokerComponent final : public UVoxelInvokerComponentBase
{
public:
	bool                                          bUseForLOD;                                        // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODToSet;                                          // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForCollisions;                                 // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForNavmesh;                                    // 0x0209(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20A[0x6];                                      // 0x020A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelVolumeInvokerComponent">();
	}
	static class UVoxelVolumeInvokerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelVolumeInvokerComponent>();
	}
};
static_assert(alignof(UVoxelVolumeInvokerComponent) == 0x000010, "Wrong alignment on UVoxelVolumeInvokerComponent");
static_assert(sizeof(UVoxelVolumeInvokerComponent) == 0x000210, "Wrong size on UVoxelVolumeInvokerComponent");
static_assert(offsetof(UVoxelVolumeInvokerComponent, bUseForLOD) == 0x000200, "Member 'UVoxelVolumeInvokerComponent::bUseForLOD' has a wrong offset!");
static_assert(offsetof(UVoxelVolumeInvokerComponent, LODToSet) == 0x000204, "Member 'UVoxelVolumeInvokerComponent::LODToSet' has a wrong offset!");
static_assert(offsetof(UVoxelVolumeInvokerComponent, bUseForCollisions) == 0x000208, "Member 'UVoxelVolumeInvokerComponent::bUseForCollisions' has a wrong offset!");
static_assert(offsetof(UVoxelVolumeInvokerComponent, bUseForNavmesh) == 0x000209, "Member 'UVoxelVolumeInvokerComponent::bUseForNavmesh' has a wrong offset!");

// Class Voxel.VoxelLODVolume
// 0x0008 (0x0260 - 0x0258)
class AVoxelLODVolume final : public AVolume
{
public:
	class UVoxelVolumeInvokerComponent*           InvokerComponent;                                  // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLODVolume">();
	}
	static class AVoxelLODVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelLODVolume>();
	}
};
static_assert(alignof(AVoxelLODVolume) == 0x000008, "Wrong alignment on AVoxelLODVolume");
static_assert(sizeof(AVoxelLODVolume) == 0x000260, "Wrong size on AVoxelLODVolume");
static_assert(offsetof(AVoxelLODVolume, InvokerComponent) == 0x000258, "Member 'AVoxelLODVolume::InvokerComponent' has a wrong offset!");

// Class Voxel.VoxelLandscapeMaterialCollection
// 0x0110 (0x0138 - 0x0028)
class UVoxelLandscapeMaterialCollection final : public UVoxelMaterialCollectionBase
{
public:
	int32                                         MaxMaterialsToBlendAtOnce;                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       LayersToIgnore;                                    // 0x0038(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FVoxelLandscapeMaterialCollectionLayer> Layers;                                            // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FVoxelLandscapeMaterialCollectionPermutation, class UMaterialInstanceConstant*> MaterialCache;                                     // 0x0098(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<int32, struct FVoxelLandscapeMaterialCollectionLayer> IndicesToLayers;                                   // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLandscapeMaterialCollection">();
	}
	static class UVoxelLandscapeMaterialCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelLandscapeMaterialCollection>();
	}
};
static_assert(alignof(UVoxelLandscapeMaterialCollection) == 0x000008, "Wrong alignment on UVoxelLandscapeMaterialCollection");
static_assert(sizeof(UVoxelLandscapeMaterialCollection) == 0x000138, "Wrong size on UVoxelLandscapeMaterialCollection");
static_assert(offsetof(UVoxelLandscapeMaterialCollection, MaxMaterialsToBlendAtOnce) == 0x000028, "Member 'UVoxelLandscapeMaterialCollection::MaxMaterialsToBlendAtOnce' has a wrong offset!");
static_assert(offsetof(UVoxelLandscapeMaterialCollection, Material) == 0x000030, "Member 'UVoxelLandscapeMaterialCollection::Material' has a wrong offset!");
static_assert(offsetof(UVoxelLandscapeMaterialCollection, LayersToIgnore) == 0x000038, "Member 'UVoxelLandscapeMaterialCollection::LayersToIgnore' has a wrong offset!");
static_assert(offsetof(UVoxelLandscapeMaterialCollection, Layers) == 0x000088, "Member 'UVoxelLandscapeMaterialCollection::Layers' has a wrong offset!");
static_assert(offsetof(UVoxelLandscapeMaterialCollection, MaterialCache) == 0x000098, "Member 'UVoxelLandscapeMaterialCollection::MaterialCache' has a wrong offset!");
static_assert(offsetof(UVoxelLandscapeMaterialCollection, IndicesToLayers) == 0x0000E8, "Member 'UVoxelLandscapeMaterialCollection::IndicesToLayers' has a wrong offset!");

// Class Voxel.VoxelLevelTool
// 0x0020 (0x0570 - 0x0550)
class UVoxelLevelTool final : public UVoxelToolBase
{
public:
	class UMaterialInterface*                     ToolMaterial;                                      // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            CylinderMesh;                                      // 0x0550(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x0560(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stride;                                            // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLevelTool">();
	}
	static class UVoxelLevelTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelLevelTool>();
	}
};
static_assert(alignof(UVoxelLevelTool) == 0x000010, "Wrong alignment on UVoxelLevelTool");
static_assert(sizeof(UVoxelLevelTool) == 0x000570, "Wrong size on UVoxelLevelTool");
static_assert(offsetof(UVoxelLevelTool, ToolMaterial) == 0x000548, "Member 'UVoxelLevelTool::ToolMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelLevelTool, CylinderMesh) == 0x000550, "Member 'UVoxelLevelTool::CylinderMesh' has a wrong offset!");
static_assert(offsetof(UVoxelLevelTool, Falloff) == 0x000558, "Member 'UVoxelLevelTool::Falloff' has a wrong offset!");
static_assert(offsetof(UVoxelLevelTool, Height) == 0x00055C, "Member 'UVoxelLevelTool::Height' has a wrong offset!");
static_assert(offsetof(UVoxelLevelTool, Offset) == 0x000560, "Member 'UVoxelLevelTool::Offset' has a wrong offset!");
static_assert(offsetof(UVoxelLevelTool, Stride) == 0x000564, "Member 'UVoxelLevelTool::Stride' has a wrong offset!");

// Class Voxel.VoxelLevelTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelLevelTools final : public UVoxelToolsBase
{
public:
	static void Level(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Falloff, float Height, bool bAdditive, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void LevelAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Falloff, float Height, bool bAdditive, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLevelTools">();
	}
	static class UVoxelLevelTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelLevelTools>();
	}
};
static_assert(alignof(UVoxelLevelTools) == 0x000008, "Wrong alignment on UVoxelLevelTools");
static_assert(sizeof(UVoxelLevelTools) == 0x000028, "Wrong size on UVoxelLevelTools");

// Class Voxel.VoxelLineBatchComponent
// 0x0040 (0x0490 - 0x0450)
class UVoxelLineBatchComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_450[0x30];                                     // 0x0450(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultLifeTime;                                   // 0x0480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCalculateAccurateBounds;                          // 0x0484(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_485[0xB];                                      // 0x0485(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLineBatchComponent">();
	}
	static class UVoxelLineBatchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelLineBatchComponent>();
	}
};
static_assert(alignof(UVoxelLineBatchComponent) == 0x000010, "Wrong alignment on UVoxelLineBatchComponent");
static_assert(sizeof(UVoxelLineBatchComponent) == 0x000490, "Wrong size on UVoxelLineBatchComponent");
static_assert(offsetof(UVoxelLineBatchComponent, DefaultLifeTime) == 0x000480, "Member 'UVoxelLineBatchComponent::DefaultLifeTime' has a wrong offset!");
static_assert(offsetof(UVoxelLineBatchComponent, bCalculateAccurateBounds) == 0x000484, "Member 'UVoxelLineBatchComponent::bCalculateAccurateBounds' has a wrong offset!");

// Class Voxel.VoxelMagicaVoxScene
// 0x0020 (0x0048 - 0x0028)
class UVoxelMagicaVoxScene final : public UObject
{
public:
	TArray<struct FVoxelMagicaVoxSceneEntry>      Entries;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ImportPath;                                        // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMagicaVoxScene">();
	}
	static class UVoxelMagicaVoxScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMagicaVoxScene>();
	}
};
static_assert(alignof(UVoxelMagicaVoxScene) == 0x000008, "Wrong alignment on UVoxelMagicaVoxScene");
static_assert(sizeof(UVoxelMagicaVoxScene) == 0x000048, "Wrong size on UVoxelMagicaVoxScene");
static_assert(offsetof(UVoxelMagicaVoxScene, Entries) == 0x000028, "Member 'UVoxelMagicaVoxScene::Entries' has a wrong offset!");
static_assert(offsetof(UVoxelMagicaVoxScene, ImportPath) == 0x000038, "Member 'UVoxelMagicaVoxScene::ImportPath' has a wrong offset!");

// Class Voxel.VoxelMagicaVoxSceneActor
// 0x0060 (0x0280 - 0x0220)
class AVoxelMagicaVoxSceneActor final : public AActor
{
public:
	float                                         VoxelSize;                                         // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AVoxelAssetActor*, struct FTransform> ActorTransforms;                                   // 0x0228(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            VoxelWorld;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyVoxelSize();
	void SetScene(class UVoxelMagicaVoxScene* Scene);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMagicaVoxSceneActor">();
	}
	static class AVoxelMagicaVoxSceneActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelMagicaVoxSceneActor>();
	}
};
static_assert(alignof(AVoxelMagicaVoxSceneActor) == 0x000008, "Wrong alignment on AVoxelMagicaVoxSceneActor");
static_assert(sizeof(AVoxelMagicaVoxSceneActor) == 0x000280, "Wrong size on AVoxelMagicaVoxSceneActor");
static_assert(offsetof(AVoxelMagicaVoxSceneActor, VoxelSize) == 0x000220, "Member 'AVoxelMagicaVoxSceneActor::VoxelSize' has a wrong offset!");
static_assert(offsetof(AVoxelMagicaVoxSceneActor, ActorTransforms) == 0x000228, "Member 'AVoxelMagicaVoxSceneActor::ActorTransforms' has a wrong offset!");
static_assert(offsetof(AVoxelMagicaVoxSceneActor, VoxelWorld) == 0x000278, "Member 'AVoxelMagicaVoxSceneActor::VoxelWorld' has a wrong offset!");

// Class Voxel.MaterialExpressionVoxelLandscapeLayerBlend
// 0x0000 (0x0060 - 0x0060)
class UMaterialExpressionVoxelLandscapeLayerBlend final : public UMaterialExpressionLandscapeLayerBlend
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVoxelLandscapeLayerBlend">();
	}
	static class UMaterialExpressionVoxelLandscapeLayerBlend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVoxelLandscapeLayerBlend>();
	}
};
static_assert(alignof(UMaterialExpressionVoxelLandscapeLayerBlend) == 0x000008, "Wrong alignment on UMaterialExpressionVoxelLandscapeLayerBlend");
static_assert(sizeof(UMaterialExpressionVoxelLandscapeLayerBlend) == 0x000060, "Wrong size on UMaterialExpressionVoxelLandscapeLayerBlend");

// Class Voxel.MaterialExpressionVoxelLandscapeLayerSwitch
// 0x0000 (0x0088 - 0x0088)
class UMaterialExpressionVoxelLandscapeLayerSwitch final : public UMaterialExpressionLandscapeLayerSwitch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVoxelLandscapeLayerSwitch">();
	}
	static class UMaterialExpressionVoxelLandscapeLayerSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVoxelLandscapeLayerSwitch>();
	}
};
static_assert(alignof(UMaterialExpressionVoxelLandscapeLayerSwitch) == 0x000008, "Wrong alignment on UMaterialExpressionVoxelLandscapeLayerSwitch");
static_assert(sizeof(UMaterialExpressionVoxelLandscapeLayerSwitch) == 0x000088, "Wrong size on UMaterialExpressionVoxelLandscapeLayerSwitch");

// Class Voxel.MaterialExpressionVoxelLandscapeLayerWeight
// 0x0000 (0x0090 - 0x0090)
class UMaterialExpressionVoxelLandscapeLayerWeight final : public UMaterialExpressionLandscapeLayerWeight
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVoxelLandscapeLayerWeight">();
	}
	static class UMaterialExpressionVoxelLandscapeLayerWeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVoxelLandscapeLayerWeight>();
	}
};
static_assert(alignof(UMaterialExpressionVoxelLandscapeLayerWeight) == 0x000008, "Wrong alignment on UMaterialExpressionVoxelLandscapeLayerWeight");
static_assert(sizeof(UMaterialExpressionVoxelLandscapeLayerWeight) == 0x000090, "Wrong size on UMaterialExpressionVoxelLandscapeLayerWeight");

// Class Voxel.MaterialExpressionVoxelLandscapeLayerSample
// 0x0000 (0x0060 - 0x0060)
class UMaterialExpressionVoxelLandscapeLayerSample final : public UMaterialExpressionLandscapeLayerSample
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVoxelLandscapeLayerSample">();
	}
	static class UMaterialExpressionVoxelLandscapeLayerSample* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVoxelLandscapeLayerSample>();
	}
};
static_assert(alignof(UMaterialExpressionVoxelLandscapeLayerSample) == 0x000008, "Wrong alignment on UMaterialExpressionVoxelLandscapeLayerSample");
static_assert(sizeof(UMaterialExpressionVoxelLandscapeLayerSample) == 0x000060, "Wrong size on UMaterialExpressionVoxelLandscapeLayerSample");

// Class Voxel.MaterialExpressionVoxelLandscapeVisibilityMask
// 0x0000 (0x0050 - 0x0050)
class UMaterialExpressionVoxelLandscapeVisibilityMask final : public UMaterialExpressionLandscapeVisibilityMask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionVoxelLandscapeVisibilityMask">();
	}
	static class UMaterialExpressionVoxelLandscapeVisibilityMask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionVoxelLandscapeVisibilityMask>();
	}
};
static_assert(alignof(UMaterialExpressionVoxelLandscapeVisibilityMask) == 0x000008, "Wrong alignment on UMaterialExpressionVoxelLandscapeVisibilityMask");
static_assert(sizeof(UMaterialExpressionVoxelLandscapeVisibilityMask) == 0x000050, "Wrong size on UMaterialExpressionVoxelLandscapeVisibilityMask");

// Class Voxel.VoxelMathLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetHalton1D(const struct FVoxelHaltonStream& Stream);
	static struct FVector2D GetHalton2D(const struct FVoxelHaltonStream& Stream);
	static struct FVector GetHalton3D(const struct FVoxelHaltonStream& Stream);
	static struct FVector GetUnitVectorFromRandom(const struct FVector2D& Random);
	static struct FVoxelHaltonStream MakeHaltonStream(int32 InitialSeed);
	static void ResetHaltonStream(const struct FVoxelHaltonStream& Stream);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMathLibrary">();
	}
	static class UVoxelMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMathLibrary>();
	}
};
static_assert(alignof(UVoxelMathLibrary) == 0x000008, "Wrong alignment on UVoxelMathLibrary");
static_assert(sizeof(UVoxelMathLibrary) == 0x000028, "Wrong size on UVoxelMathLibrary");

// Class Voxel.VoxelMeshImporterInputData
// 0x0030 (0x0058 - 0x0028)
class UVoxelMeshImporterInputData final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMeshImporterInputData">();
	}
	static class UVoxelMeshImporterInputData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMeshImporterInputData>();
	}
};
static_assert(alignof(UVoxelMeshImporterInputData) == 0x000008, "Wrong alignment on UVoxelMeshImporterInputData");
static_assert(sizeof(UVoxelMeshImporterInputData) == 0x000058, "Wrong size on UVoxelMeshImporterInputData");

// Class Voxel.VoxelMeshImporterLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelMeshImporterLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertMeshToVoxels(class UObject* WorldContextObject, class UVoxelMeshImporterInputData* Mesh, const struct FTransform& Transform, bool bSubtractive, const struct FVoxelMeshImporterSettings& Settings, struct FVoxelMeshImporterRenderTargetCache& RenderTargetCache, class UVoxelDataAsset** Asset, int32* NumLeaks);
	static void ConvertMeshToVoxels_NoMaterials(class UObject* WorldContextObject, class UVoxelMeshImporterInputData* Mesh, const struct FTransform& Transform, bool bSubtractive, const struct FVoxelMeshImporterSettingsBase& Settings, class UVoxelDataAsset** Asset, int32* NumLeaks);
	static class UVoxelMeshImporterInputData* CreateMeshDataFromStaticMesh(class UStaticMesh* StaticMesh);
	static class UTextureRenderTarget2D* CreateTextureFromMaterial(class UObject* WorldContextObject, class UMaterialInterface* Material, int32 Width, int32 Height);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMeshImporterLibrary">();
	}
	static class UVoxelMeshImporterLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMeshImporterLibrary>();
	}
};
static_assert(alignof(UVoxelMeshImporterLibrary) == 0x000008, "Wrong alignment on UVoxelMeshImporterLibrary");
static_assert(sizeof(UVoxelMeshImporterLibrary) == 0x000028, "Wrong size on UVoxelMeshImporterLibrary");

// Class Voxel.VoxelMeshImporter
// 0x00E0 (0x0300 - 0x0220)
class AVoxelMeshImporter final : public AActor
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoxelMeshImporterSettings             Settings;                                          // 0x0228(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint32                                        SizeX;                                             // 0x0260(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SizeY;                                             // 0x0264(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SizeZ;                                             // 0x0268(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint64                                        NumberOfVoxels;                                    // 0x0270(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeInMB;                                          // 0x0278(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MaterialInstance;                                  // 0x0288(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBox                                   CachedBox;                                         // 0x0290(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            CachedStaticMesh;                                  // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        CachedVertices;                                    // 0x02B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CachedTransform;                                   // 0x02D0(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMeshImporter">();
	}
	static class AVoxelMeshImporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelMeshImporter>();
	}
};
static_assert(alignof(AVoxelMeshImporter) == 0x000010, "Wrong alignment on AVoxelMeshImporter");
static_assert(sizeof(AVoxelMeshImporter) == 0x000300, "Wrong size on AVoxelMeshImporter");
static_assert(offsetof(AVoxelMeshImporter, StaticMesh) == 0x000220, "Member 'AVoxelMeshImporter::StaticMesh' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, Settings) == 0x000228, "Member 'AVoxelMeshImporter::Settings' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, SizeX) == 0x000260, "Member 'AVoxelMeshImporter::SizeX' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, SizeY) == 0x000264, "Member 'AVoxelMeshImporter::SizeY' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, SizeZ) == 0x000268, "Member 'AVoxelMeshImporter::SizeZ' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, NumberOfVoxels) == 0x000270, "Member 'AVoxelMeshImporter::NumberOfVoxels' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, SizeInMB) == 0x000278, "Member 'AVoxelMeshImporter::SizeInMB' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, MeshComponent) == 0x000280, "Member 'AVoxelMeshImporter::MeshComponent' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, MaterialInstance) == 0x000288, "Member 'AVoxelMeshImporter::MaterialInstance' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, CachedBox) == 0x000290, "Member 'AVoxelMeshImporter::CachedBox' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, CachedStaticMesh) == 0x0002B0, "Member 'AVoxelMeshImporter::CachedStaticMesh' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, CachedVertices) == 0x0002B8, "Member 'AVoxelMeshImporter::CachedVertices' has a wrong offset!");
static_assert(offsetof(AVoxelMeshImporter, CachedTransform) == 0x0002D0, "Member 'AVoxelMeshImporter::CachedTransform' has a wrong offset!");

// Class Voxel.VoxelToolWithAlignment
// 0x0010 (0x0560 - 0x0550)
#pragma pack(push, 0x1)
class alignas(0x10) UVoxelToolWithAlignment : public UVoxelToolBase
{
public:
	EVoxelToolAlignment                           Alignment;                                         // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAirMode;                                          // 0x0549(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54A[0x2];                                      // 0x054A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToCamera;                                  // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowPlanePreview;                                 // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_551[0x7];                                      // 0x0551(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelToolWithAlignment">();
	}
	static class UVoxelToolWithAlignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelToolWithAlignment>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVoxelToolWithAlignment) == 0x000010, "Wrong alignment on UVoxelToolWithAlignment");
static_assert(sizeof(UVoxelToolWithAlignment) == 0x000560, "Wrong size on UVoxelToolWithAlignment");
static_assert(offsetof(UVoxelToolWithAlignment, Alignment) == 0x000548, "Member 'UVoxelToolWithAlignment::Alignment' has a wrong offset!");
static_assert(offsetof(UVoxelToolWithAlignment, bAirMode) == 0x000549, "Member 'UVoxelToolWithAlignment::bAirMode' has a wrong offset!");
static_assert(offsetof(UVoxelToolWithAlignment, DistanceToCamera) == 0x00054C, "Member 'UVoxelToolWithAlignment::DistanceToCamera' has a wrong offset!");
static_assert(offsetof(UVoxelToolWithAlignment, bShowPlanePreview) == 0x000550, "Member 'UVoxelToolWithAlignment::bShowPlanePreview' has a wrong offset!");

// Class Voxel.VoxelMeshTool
// 0x0120 (0x0680 - 0x0560)
class UVoxelMeshTool final : public UVoxelToolWithAlignment
{
public:
	class UMaterialInterface*                     ToolMaterial;                                      // 0x0558(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mesh;                                              // 0x0560(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stride;                                            // 0x0568(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSmoothImport;                                     // 0x056C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56D[0x3];                                      // 0x056D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Smoothness;                                        // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProgressiveStamp;                                 // 0x0574(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_575[0x3];                                      // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoxelMeshImporterSettingsBase         MeshImporterSettings;                              // 0x057C(0x0010)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bSculpt;                                           // 0x058C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaint;                                            // 0x058D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58E[0x2];                                      // 0x058E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PaintMask;                                         // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaintColors;                                      // 0x0594(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportColorsFromMesh;                             // 0x0595(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_596[0x2];                                      // 0x0596(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ColorsMaterial;                                    // 0x0598(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ColorToPaint;                                      // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaintUVs;                                         // 0x05A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImportUVsFromMesh;                                // 0x05A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A6[0x2];                                      // 0x05A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     UVsMaterial;                                       // 0x05A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV0ToPaint;                                        // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV1ToPaint;                                        // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaintIndex;                                       // 0x05C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IndexToPaint;                                      // 0x05C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C2[0x6];                                      // 0x05C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 UVsRenderTarget;                                   // 0x05C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 ColorsRenderTarget;                                // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenderTargetSize;                                  // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PositionOffset;                                    // 0x05DC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x05E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E9[0x3];                                      // 0x05E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x05EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignToNormal;                                    // 0x05F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignToMovement;                                  // 0x05F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FA[0x2];                                      // 0x05FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationOffset;                                    // 0x05FC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_608[0x18];                                     // 0x0608(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelMeshImporterRenderTargetCache    RenderTargetCache;                                 // 0x0620(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVoxelMeshImporterSettings             AssetData_ImporterSettings;                        // 0x0648(0x0038)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMeshTool">();
	}
	static class UVoxelMeshTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMeshTool>();
	}
};
static_assert(alignof(UVoxelMeshTool) == 0x000010, "Wrong alignment on UVoxelMeshTool");
static_assert(sizeof(UVoxelMeshTool) == 0x000680, "Wrong size on UVoxelMeshTool");
static_assert(offsetof(UVoxelMeshTool, ToolMaterial) == 0x000558, "Member 'UVoxelMeshTool::ToolMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, Mesh) == 0x000560, "Member 'UVoxelMeshTool::Mesh' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, Stride) == 0x000568, "Member 'UVoxelMeshTool::Stride' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bSmoothImport) == 0x00056C, "Member 'UVoxelMeshTool::bSmoothImport' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, Smoothness) == 0x000570, "Member 'UVoxelMeshTool::Smoothness' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bProgressiveStamp) == 0x000574, "Member 'UVoxelMeshTool::bProgressiveStamp' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, Speed) == 0x000578, "Member 'UVoxelMeshTool::Speed' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, MeshImporterSettings) == 0x00057C, "Member 'UVoxelMeshTool::MeshImporterSettings' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bSculpt) == 0x00058C, "Member 'UVoxelMeshTool::bSculpt' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bPaint) == 0x00058D, "Member 'UVoxelMeshTool::bPaint' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, PaintMask) == 0x000590, "Member 'UVoxelMeshTool::PaintMask' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bPaintColors) == 0x000594, "Member 'UVoxelMeshTool::bPaintColors' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bImportColorsFromMesh) == 0x000595, "Member 'UVoxelMeshTool::bImportColorsFromMesh' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, ColorsMaterial) == 0x000598, "Member 'UVoxelMeshTool::ColorsMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, ColorToPaint) == 0x0005A0, "Member 'UVoxelMeshTool::ColorToPaint' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bPaintUVs) == 0x0005A4, "Member 'UVoxelMeshTool::bPaintUVs' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bImportUVsFromMesh) == 0x0005A5, "Member 'UVoxelMeshTool::bImportUVsFromMesh' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, UVsMaterial) == 0x0005A8, "Member 'UVoxelMeshTool::UVsMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, UV0ToPaint) == 0x0005B0, "Member 'UVoxelMeshTool::UV0ToPaint' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, UV1ToPaint) == 0x0005B8, "Member 'UVoxelMeshTool::UV1ToPaint' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bPaintIndex) == 0x0005C0, "Member 'UVoxelMeshTool::bPaintIndex' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, IndexToPaint) == 0x0005C1, "Member 'UVoxelMeshTool::IndexToPaint' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, UVsRenderTarget) == 0x0005C8, "Member 'UVoxelMeshTool::UVsRenderTarget' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, ColorsRenderTarget) == 0x0005D0, "Member 'UVoxelMeshTool::ColorsRenderTarget' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, RenderTargetSize) == 0x0005D8, "Member 'UVoxelMeshTool::RenderTargetSize' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, PositionOffset) == 0x0005DC, "Member 'UVoxelMeshTool::PositionOffset' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bAbsoluteScale) == 0x0005E8, "Member 'UVoxelMeshTool::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, Scale) == 0x0005EC, "Member 'UVoxelMeshTool::Scale' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bAlignToNormal) == 0x0005F8, "Member 'UVoxelMeshTool::bAlignToNormal' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, bAlignToMovement) == 0x0005F9, "Member 'UVoxelMeshTool::bAlignToMovement' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, RotationOffset) == 0x0005FC, "Member 'UVoxelMeshTool::RotationOffset' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, RenderTargetCache) == 0x000620, "Member 'UVoxelMeshTool::RenderTargetCache' has a wrong offset!");
static_assert(offsetof(UVoxelMeshTool, AssetData_ImporterSettings) == 0x000648, "Member 'UVoxelMeshTool::AssetData_ImporterSettings' has a wrong offset!");

// Class Voxel.VoxelMultiplayerInterface
// 0x0000 (0x0028 - 0x0028)
class UVoxelMultiplayerInterface : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMultiplayerInterface">();
	}
	static class UVoxelMultiplayerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMultiplayerInterface>();
	}
};
static_assert(alignof(UVoxelMultiplayerInterface) == 0x000008, "Wrong alignment on UVoxelMultiplayerInterface");
static_assert(sizeof(UVoxelMultiplayerInterface) == 0x000028, "Wrong size on UVoxelMultiplayerInterface");

// Class Voxel.VoxelMultiplayerSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelMultiplayerSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMultiplayerSubsystemProxy">();
	}
	static class UVoxelMultiplayerSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMultiplayerSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelMultiplayerSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelMultiplayerSubsystemProxy");
static_assert(sizeof(UVoxelMultiplayerSubsystemProxy) == 0x000028, "Wrong size on UVoxelMultiplayerSubsystemProxy");

// Class Voxel.VoxelMultiplayerTcpInterface
// 0x0020 (0x0048 - 0x0028)
class UVoxelMultiplayerTcpInterface final : public UVoxelMultiplayerInterface
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ConnectToServer(class FString* OutError, const class FString& IP, int32 Port);
	bool StartServer(class FString* OutError, const class FString& IP, int32 Port);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelMultiplayerTcpInterface">();
	}
	static class UVoxelMultiplayerTcpInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelMultiplayerTcpInterface>();
	}
};
static_assert(alignof(UVoxelMultiplayerTcpInterface) == 0x000008, "Wrong alignment on UVoxelMultiplayerTcpInterface");
static_assert(sizeof(UVoxelMultiplayerTcpInterface) == 0x000048, "Wrong size on UVoxelMultiplayerTcpInterface");

// Class Voxel.VoxelNoClippingComponent
// 0x0080 (0x0280 - 0x0200)
class UVoxelNoClippingComponent : public USceneComponent
{
public:
	float                                         TickRate;                                          // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SearchRange;                                       // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDefaultBehavior;                            // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlanet;                                         // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PlanetCenter;                                      // 0x020C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              MoveTowardsSurface;                                // 0x0218(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              StopMovingTowardsSurface;                          // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTeleported;                                      // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsInsideSurface;                                  // 0x0248(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x37];                                     // 0x0249(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldUseVoxelWorld(class AVoxelWorld* VoxelWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelNoClippingComponent">();
	}
	static class UVoxelNoClippingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelNoClippingComponent>();
	}
};
static_assert(alignof(UVoxelNoClippingComponent) == 0x000010, "Wrong alignment on UVoxelNoClippingComponent");
static_assert(sizeof(UVoxelNoClippingComponent) == 0x000280, "Wrong size on UVoxelNoClippingComponent");
static_assert(offsetof(UVoxelNoClippingComponent, TickRate) == 0x0001F8, "Member 'UVoxelNoClippingComponent::TickRate' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, SearchRange) == 0x0001FC, "Member 'UVoxelNoClippingComponent::SearchRange' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, bEnableDefaultBehavior) == 0x000200, "Member 'UVoxelNoClippingComponent::bEnableDefaultBehavior' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, Speed) == 0x000204, "Member 'UVoxelNoClippingComponent::Speed' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, bIsPlanet) == 0x000208, "Member 'UVoxelNoClippingComponent::bIsPlanet' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, PlanetCenter) == 0x00020C, "Member 'UVoxelNoClippingComponent::PlanetCenter' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, MoveTowardsSurface) == 0x000218, "Member 'UVoxelNoClippingComponent::MoveTowardsSurface' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, StopMovingTowardsSurface) == 0x000228, "Member 'UVoxelNoClippingComponent::StopMovingTowardsSurface' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, OnTeleported) == 0x000238, "Member 'UVoxelNoClippingComponent::OnTeleported' has a wrong offset!");
static_assert(offsetof(UVoxelNoClippingComponent, bIsInsideSurface) == 0x000248, "Member 'UVoxelNoClippingComponent::bIsInsideSurface' has a wrong offset!");

// Class Voxel.VoxelPhysicsTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelPhysicsTools final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyVoxelPhysics(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<TScriptInterface<class IVoxelPhysicsPartSpawnerResult>>* Results, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, TScriptInterface<class IVoxelPhysicsPartSpawner> PartSpawner, int32 MinParts, bool bDebug, bool bHideLatentWarnings, EVoxelPartType PhysicsType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsTools">();
	}
	static class UVoxelPhysicsTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPhysicsTools>();
	}
};
static_assert(alignof(UVoxelPhysicsTools) == 0x000008, "Wrong alignment on UVoxelPhysicsTools");
static_assert(sizeof(UVoxelPhysicsTools) == 0x000028, "Wrong size on UVoxelPhysicsTools");

// Class Voxel.VoxelPhysicsPartSpawnerResult_VoxelWorlds
// 0x0010 (0x0038 - 0x0028)
class UVoxelPhysicsPartSpawnerResult_VoxelWorlds final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AVoxelWorld*                            VoxelWorld;                                        // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsPartSpawnerResult_VoxelWorlds">();
	}
	static class UVoxelPhysicsPartSpawnerResult_VoxelWorlds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPhysicsPartSpawnerResult_VoxelWorlds>();
	}
};
static_assert(alignof(UVoxelPhysicsPartSpawnerResult_VoxelWorlds) == 0x000008, "Wrong alignment on UVoxelPhysicsPartSpawnerResult_VoxelWorlds");
static_assert(sizeof(UVoxelPhysicsPartSpawnerResult_VoxelWorlds) == 0x000038, "Wrong size on UVoxelPhysicsPartSpawnerResult_VoxelWorlds");
static_assert(offsetof(UVoxelPhysicsPartSpawnerResult_VoxelWorlds, VoxelWorld) == 0x000030, "Member 'UVoxelPhysicsPartSpawnerResult_VoxelWorlds::VoxelWorld' has a wrong offset!");

// Class Voxel.VoxelPhysicsPartSpawner_VoxelWorlds
// 0x0020 (0x0048 - 0x0028)
class UVoxelPhysicsPartSpawner_VoxelWorlds final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class AVoxelWorld* VoxelWorld)> ConfigureVoxelWorld;                               // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AVoxelWorld>                VoxelWorldClass;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsPartSpawner_VoxelWorlds">();
	}
	static class UVoxelPhysicsPartSpawner_VoxelWorlds* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPhysicsPartSpawner_VoxelWorlds>();
	}
};
static_assert(alignof(UVoxelPhysicsPartSpawner_VoxelWorlds) == 0x000008, "Wrong alignment on UVoxelPhysicsPartSpawner_VoxelWorlds");
static_assert(sizeof(UVoxelPhysicsPartSpawner_VoxelWorlds) == 0x000048, "Wrong size on UVoxelPhysicsPartSpawner_VoxelWorlds");
static_assert(offsetof(UVoxelPhysicsPartSpawner_VoxelWorlds, ConfigureVoxelWorld) == 0x000030, "Member 'UVoxelPhysicsPartSpawner_VoxelWorlds::ConfigureVoxelWorld' has a wrong offset!");
static_assert(offsetof(UVoxelPhysicsPartSpawner_VoxelWorlds, VoxelWorldClass) == 0x000040, "Member 'UVoxelPhysicsPartSpawner_VoxelWorlds::VoxelWorldClass' has a wrong offset!");

// Class Voxel.VoxelPhysicsPartSpawnerResult_Cubes
// 0x0018 (0x0040 - 0x0028)
class UVoxelPhysicsPartSpawnerResult_Cubes final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AStaticMeshActor*>               Cubes;                                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsPartSpawnerResult_Cubes">();
	}
	static class UVoxelPhysicsPartSpawnerResult_Cubes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPhysicsPartSpawnerResult_Cubes>();
	}
};
static_assert(alignof(UVoxelPhysicsPartSpawnerResult_Cubes) == 0x000008, "Wrong alignment on UVoxelPhysicsPartSpawnerResult_Cubes");
static_assert(sizeof(UVoxelPhysicsPartSpawnerResult_Cubes) == 0x000040, "Wrong size on UVoxelPhysicsPartSpawnerResult_Cubes");
static_assert(offsetof(UVoxelPhysicsPartSpawnerResult_Cubes, Cubes) == 0x000030, "Member 'UVoxelPhysicsPartSpawnerResult_Cubes::Cubes' has a wrong offset!");

// Class Voxel.VoxelPhysicsPartSpawner_Cubes
// 0x0020 (0x0048 - 0x0028)
class UVoxelPhysicsPartSpawner_Cubes : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            CubeMesh;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnProbability;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsPartSpawner_Cubes">();
	}
	static class UVoxelPhysicsPartSpawner_Cubes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPhysicsPartSpawner_Cubes>();
	}
};
static_assert(alignof(UVoxelPhysicsPartSpawner_Cubes) == 0x000008, "Wrong alignment on UVoxelPhysicsPartSpawner_Cubes");
static_assert(sizeof(UVoxelPhysicsPartSpawner_Cubes) == 0x000048, "Wrong size on UVoxelPhysicsPartSpawner_Cubes");
static_assert(offsetof(UVoxelPhysicsPartSpawner_Cubes, Material) == 0x000030, "Member 'UVoxelPhysicsPartSpawner_Cubes::Material' has a wrong offset!");
static_assert(offsetof(UVoxelPhysicsPartSpawner_Cubes, CubeMesh) == 0x000038, "Member 'UVoxelPhysicsPartSpawner_Cubes::CubeMesh' has a wrong offset!");
static_assert(offsetof(UVoxelPhysicsPartSpawner_Cubes, SpawnProbability) == 0x000040, "Member 'UVoxelPhysicsPartSpawner_Cubes::SpawnProbability' has a wrong offset!");

// Class Voxel.VoxelPhysicsPartSpawnerResult_GetVoxels
// 0x0018 (0x0040 - 0x0028)
class UVoxelPhysicsPartSpawnerResult_GetVoxels final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVoxelPositionValueMaterial>    Voxels;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsPartSpawnerResult_GetVoxels">();
	}
	static class UVoxelPhysicsPartSpawnerResult_GetVoxels* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPhysicsPartSpawnerResult_GetVoxels>();
	}
};
static_assert(alignof(UVoxelPhysicsPartSpawnerResult_GetVoxels) == 0x000008, "Wrong alignment on UVoxelPhysicsPartSpawnerResult_GetVoxels");
static_assert(sizeof(UVoxelPhysicsPartSpawnerResult_GetVoxels) == 0x000040, "Wrong size on UVoxelPhysicsPartSpawnerResult_GetVoxels");
static_assert(offsetof(UVoxelPhysicsPartSpawnerResult_GetVoxels, Voxels) == 0x000030, "Member 'UVoxelPhysicsPartSpawnerResult_GetVoxels::Voxels' has a wrong offset!");

// Class Voxel.VoxelPhysicsPartSpawner_GetVoxels
// 0x0008 (0x0030 - 0x0028)
class UVoxelPhysicsPartSpawner_GetVoxels final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsPartSpawner_GetVoxels">();
	}
	static class UVoxelPhysicsPartSpawner_GetVoxels* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPhysicsPartSpawner_GetVoxels>();
	}
};
static_assert(alignof(UVoxelPhysicsPartSpawner_GetVoxels) == 0x000008, "Wrong alignment on UVoxelPhysicsPartSpawner_GetVoxels");
static_assert(sizeof(UVoxelPhysicsPartSpawner_GetVoxels) == 0x000030, "Wrong size on UVoxelPhysicsPartSpawner_GetVoxels");

// Class Voxel.VoxelPhysicsPartSpawnerResult
// 0x0000 (0x0028 - 0x0028)
class IVoxelPhysicsPartSpawnerResult final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsPartSpawnerResult">();
	}
	static class IVoxelPhysicsPartSpawnerResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVoxelPhysicsPartSpawnerResult>();
	}
};
static_assert(alignof(IVoxelPhysicsPartSpawnerResult) == 0x000008, "Wrong alignment on IVoxelPhysicsPartSpawnerResult");
static_assert(sizeof(IVoxelPhysicsPartSpawnerResult) == 0x000028, "Wrong size on IVoxelPhysicsPartSpawnerResult");

// Class Voxel.VoxelPhysicsPartSpawner
// 0x0000 (0x0028 - 0x0028)
class IVoxelPhysicsPartSpawner final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsPartSpawner">();
	}
	static class IVoxelPhysicsPartSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVoxelPhysicsPartSpawner>();
	}
};
static_assert(alignof(IVoxelPhysicsPartSpawner) == 0x000008, "Wrong alignment on IVoxelPhysicsPartSpawner");
static_assert(sizeof(IVoxelPhysicsPartSpawner) == 0x000028, "Wrong size on IVoxelPhysicsPartSpawner");

// Class Voxel.VoxelPhysicsRelevancyComponent
// 0x0038 (0x00E8 - 0x00B0)
class UVoxelPhysicsRelevancyComponent final : public UActorComponent
{
public:
	uint8                                         MaxVoxelChunksLODForPhysics;                       // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToWaitBeforeActivating;                        // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x2C];                                      // 0x00BC(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPhysicsRelevancyComponent">();
	}
	static class UVoxelPhysicsRelevancyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPhysicsRelevancyComponent>();
	}
};
static_assert(alignof(UVoxelPhysicsRelevancyComponent) == 0x000008, "Wrong alignment on UVoxelPhysicsRelevancyComponent");
static_assert(sizeof(UVoxelPhysicsRelevancyComponent) == 0x0000E8, "Wrong size on UVoxelPhysicsRelevancyComponent");
static_assert(offsetof(UVoxelPhysicsRelevancyComponent, MaxVoxelChunksLODForPhysics) == 0x0000B0, "Member 'UVoxelPhysicsRelevancyComponent::MaxVoxelChunksLODForPhysics' has a wrong offset!");
static_assert(offsetof(UVoxelPhysicsRelevancyComponent, TimeToWaitBeforeActivating) == 0x0000B4, "Member 'UVoxelPhysicsRelevancyComponent::TimeToWaitBeforeActivating' has a wrong offset!");
static_assert(offsetof(UVoxelPhysicsRelevancyComponent, TickInterval) == 0x0000B8, "Member 'UVoxelPhysicsRelevancyComponent::TickInterval' has a wrong offset!");

// Class Voxel.VoxelRuntimeActor
// 0x04A0 (0x06C0 - 0x0220)
class AVoxelRuntimeActor : public AActor
{
public:
	float                                         VoxelSize;                                         // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelGeneratorPicker                  Generator;                                         // 0x0228(0x0068)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelPlaceableItemManager*             PlaceableItemManager;                              // 0x0290(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateWorldAutomatically;                         // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCameraIfNoInvokersFound;                       // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableUndoRedo;                                   // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAbsoluteTransforms;                            // 0x029B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergeAssetActors;                                 // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergeDisableEditsBoxes;                           // 0x029D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableOnScreenMessages;                          // 0x029E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableDebugManager;                              // 0x029F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenderOctreeDepth;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        WorldSizeInVoxel;                                  // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomWorldBounds;                             // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x3];                                      // 0x02A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelIntBox                           CustomWorldBounds;                                 // 0x02AC(0x0018)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLOD;                                            // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLOD;                                            // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvokerDistanceThreshold;                          // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDelayBetweenLODUpdates;                         // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstantLOD;                                      // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelMaterialConfig                          MaterialConfig;                                    // 0x02D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaterialCollection;                            // 0x02D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D7[0x1];                                      // 0x02D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     VoxelMaterial;                                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelMaterialCollectionBase*           MaterialCollection;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVoxelLODMaterials>             LODMaterials;                                      // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVoxelLODMaterialCollections>   LODMaterialCollections;                            // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EVoxelUVConfig                                UVConfig;                                          // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x3];                                      // 0x0309(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UVScale;                                           // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelNormalConfig                            NormalConfig;                                      // 0x0310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelRGBHardness                             RGBHardness;                                       // 0x0311(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_312[0x6];                                      // 0x0312(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, float>                    MaterialsHardness;                                 // 0x0318(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHardColorTransitions;                             // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSplitSingleIndexTriangles;                        // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36A[0x6];                                      // 0x036A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 HolesMaterials;                                    // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	TMap<uint8, struct FVoxelMeshConfig>          MaterialsMeshConfigs;                              // 0x0380(0x0050)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bHalfPrecisionCoordinates;                         // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpolateColors;                                // 0x03D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterpolateUVs;                                   // 0x03D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSRGBColors;                                       // 0x03D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelRenderType                              RenderType;                                        // 0x03D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RenderSharpness;                                   // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateMaterialInstances;                          // 0x03DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDitherChunks;                                     // 0x03DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DE[0x2];                                      // 0x03DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChunksDitheringDuration;                           // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastFarShadow;                                    // 0x03E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E5[0x3];                                      // 0x03E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UVoxelProceduralMeshComponent> ProcMeshClass;                                     // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChunksCullingLOD;                                  // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRenderWorld;                                      // 0x03F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContributesToStaticLighting;                      // 0x03F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseStaticPath;                                    // 0x03F6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStaticWorld;                                      // 0x03F7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGreedyCubicMesher;                                // 0x03F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSingleIndexGreedy;                                // 0x03F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FA[0x2];                                      // 0x03FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TexturePoolTextureSize;                            // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptimizeIndices;                                  // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateDistanceFields;                           // 0x0401(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_402[0x2];                                      // 0x0402(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxDistanceFieldLOD;                               // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DistanceFieldBoundsExtension;                      // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DistanceFieldResolutionDivisor;                    // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFieldSelfShadowBias;                       // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTransitions;                                // 0x0414(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergeChunks;                                      // 0x0415(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_416[0x2];                                      // 0x0416(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChunksClustersSize;                                // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotMergeCollisionsAndNavmesh;                   // 0x041C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoundsExtension;                                   // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UVoxelFoliageCollectionBase*>    FoliageCollections;                                // 0x0428(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EVoxelFoliageWorldType                        FoliageWorldType;                                  // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFourWayBlend;                                   // 0x0439(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43A[0x2];                                      // 0x043A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HISMChunkSize;                                     // 0x043C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FoliageCollisionDistanceInVoxel;                   // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int64                                         MaxNumberOfFoliageInstances;                       // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollisions;                                 // 0x0450(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBodyInstance                          CollisionPresets;                                  // 0x0458(0x0158)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ECollisionTraceFlag                           CollisionTraceFlag;                                // 0x05B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECanBeCharacterBase                           CanCharacterStepUpOn;                              // 0x05B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNotifyRigidBodyCollision;                         // 0x05B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenerateOverlapEvents;                            // 0x05B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeVisibleChunksCollisions;                   // 0x05B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B5[0x3];                                      // 0x05B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VisibleChunksCollisionsMaxLOD;                     // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysMaterialOverride;                              // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCCD;                                           // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleCubicCollision;                             // 0x05C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5CA[0x2];                                      // 0x05CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SimpleCubicCollisionLODBias;                       // 0x05CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumConvexHullsPerAxis;                             // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCleanCollisionMeshes;                             // 0x05D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableNavmesh;                                    // 0x05D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bComputeVisibleChunksNavmesh;                      // 0x05D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D7[0x1];                                      // 0x05D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VisibleChunksNavmeshMaxLOD;                        // 0x05D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EVoxelTaskType, int32>                   PriorityCategories;                                // 0x05E0(0x0050)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	TMap<EVoxelTaskType, int32>                   PriorityOffsets;                                   // 0x0630(0x0050)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         MeshUpdatesBudget;                                 // 0x0680(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EventsTickRate;                                    // 0x0684(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataOctreeInitialSubdivisionDepth;                 // 0x0688(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMultiplayer;                                // 0x068C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68D[0x3];                                      // 0x068D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UVoxelMultiplayerInterface> MultiplayerInterface;                              // 0x0690(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplayerSyncRate;                               // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UVoxelRendererSubsystemProxy> RendererSubsystem;                                 // 0x06A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UVoxelLODSubsystemProxy>    LODSubsystem;                                      // 0x06A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UTexture>>        DebugTextures;                                     // 0x06B0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelRuntimeActor">();
	}
	static class AVoxelRuntimeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelRuntimeActor>();
	}
};
static_assert(alignof(AVoxelRuntimeActor) == 0x000008, "Wrong alignment on AVoxelRuntimeActor");
static_assert(sizeof(AVoxelRuntimeActor) == 0x0006C0, "Wrong size on AVoxelRuntimeActor");
static_assert(offsetof(AVoxelRuntimeActor, VoxelSize) == 0x000220, "Member 'AVoxelRuntimeActor::VoxelSize' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, Generator) == 0x000228, "Member 'AVoxelRuntimeActor::Generator' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, PlaceableItemManager) == 0x000290, "Member 'AVoxelRuntimeActor::PlaceableItemManager' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bCreateWorldAutomatically) == 0x000298, "Member 'AVoxelRuntimeActor::bCreateWorldAutomatically' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bUseCameraIfNoInvokersFound) == 0x000299, "Member 'AVoxelRuntimeActor::bUseCameraIfNoInvokersFound' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bEnableUndoRedo) == 0x00029A, "Member 'AVoxelRuntimeActor::bEnableUndoRedo' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bUseAbsoluteTransforms) == 0x00029B, "Member 'AVoxelRuntimeActor::bUseAbsoluteTransforms' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bMergeAssetActors) == 0x00029C, "Member 'AVoxelRuntimeActor::bMergeAssetActors' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bMergeDisableEditsBoxes) == 0x00029D, "Member 'AVoxelRuntimeActor::bMergeDisableEditsBoxes' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bDisableOnScreenMessages) == 0x00029E, "Member 'AVoxelRuntimeActor::bDisableOnScreenMessages' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bDisableDebugManager) == 0x00029F, "Member 'AVoxelRuntimeActor::bDisableDebugManager' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, RenderOctreeDepth) == 0x0002A0, "Member 'AVoxelRuntimeActor::RenderOctreeDepth' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, WorldSizeInVoxel) == 0x0002A4, "Member 'AVoxelRuntimeActor::WorldSizeInVoxel' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bUseCustomWorldBounds) == 0x0002A8, "Member 'AVoxelRuntimeActor::bUseCustomWorldBounds' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, CustomWorldBounds) == 0x0002AC, "Member 'AVoxelRuntimeActor::CustomWorldBounds' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MaxLOD) == 0x0002C4, "Member 'AVoxelRuntimeActor::MaxLOD' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MinLOD) == 0x0002C8, "Member 'AVoxelRuntimeActor::MinLOD' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, InvokerDistanceThreshold) == 0x0002CC, "Member 'AVoxelRuntimeActor::InvokerDistanceThreshold' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MinDelayBetweenLODUpdates) == 0x0002D0, "Member 'AVoxelRuntimeActor::MinDelayBetweenLODUpdates' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bConstantLOD) == 0x0002D4, "Member 'AVoxelRuntimeActor::bConstantLOD' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MaterialConfig) == 0x0002D5, "Member 'AVoxelRuntimeActor::MaterialConfig' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bUseMaterialCollection) == 0x0002D6, "Member 'AVoxelRuntimeActor::bUseMaterialCollection' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, VoxelMaterial) == 0x0002D8, "Member 'AVoxelRuntimeActor::VoxelMaterial' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MaterialCollection) == 0x0002E0, "Member 'AVoxelRuntimeActor::MaterialCollection' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, LODMaterials) == 0x0002E8, "Member 'AVoxelRuntimeActor::LODMaterials' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, LODMaterialCollections) == 0x0002F8, "Member 'AVoxelRuntimeActor::LODMaterialCollections' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, UVConfig) == 0x000308, "Member 'AVoxelRuntimeActor::UVConfig' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, UVScale) == 0x00030C, "Member 'AVoxelRuntimeActor::UVScale' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, NormalConfig) == 0x000310, "Member 'AVoxelRuntimeActor::NormalConfig' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, RGBHardness) == 0x000311, "Member 'AVoxelRuntimeActor::RGBHardness' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MaterialsHardness) == 0x000318, "Member 'AVoxelRuntimeActor::MaterialsHardness' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bHardColorTransitions) == 0x000368, "Member 'AVoxelRuntimeActor::bHardColorTransitions' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bSplitSingleIndexTriangles) == 0x000369, "Member 'AVoxelRuntimeActor::bSplitSingleIndexTriangles' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, HolesMaterials) == 0x000370, "Member 'AVoxelRuntimeActor::HolesMaterials' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MaterialsMeshConfigs) == 0x000380, "Member 'AVoxelRuntimeActor::MaterialsMeshConfigs' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bHalfPrecisionCoordinates) == 0x0003D0, "Member 'AVoxelRuntimeActor::bHalfPrecisionCoordinates' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bInterpolateColors) == 0x0003D1, "Member 'AVoxelRuntimeActor::bInterpolateColors' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bInterpolateUVs) == 0x0003D2, "Member 'AVoxelRuntimeActor::bInterpolateUVs' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bSRGBColors) == 0x0003D3, "Member 'AVoxelRuntimeActor::bSRGBColors' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, RenderType) == 0x0003D4, "Member 'AVoxelRuntimeActor::RenderType' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, RenderSharpness) == 0x0003D8, "Member 'AVoxelRuntimeActor::RenderSharpness' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bCreateMaterialInstances) == 0x0003DC, "Member 'AVoxelRuntimeActor::bCreateMaterialInstances' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bDitherChunks) == 0x0003DD, "Member 'AVoxelRuntimeActor::bDitherChunks' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, ChunksDitheringDuration) == 0x0003E0, "Member 'AVoxelRuntimeActor::ChunksDitheringDuration' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bCastFarShadow) == 0x0003E4, "Member 'AVoxelRuntimeActor::bCastFarShadow' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, ProcMeshClass) == 0x0003E8, "Member 'AVoxelRuntimeActor::ProcMeshClass' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, ChunksCullingLOD) == 0x0003F0, "Member 'AVoxelRuntimeActor::ChunksCullingLOD' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bRenderWorld) == 0x0003F4, "Member 'AVoxelRuntimeActor::bRenderWorld' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bContributesToStaticLighting) == 0x0003F5, "Member 'AVoxelRuntimeActor::bContributesToStaticLighting' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bUseStaticPath) == 0x0003F6, "Member 'AVoxelRuntimeActor::bUseStaticPath' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bStaticWorld) == 0x0003F7, "Member 'AVoxelRuntimeActor::bStaticWorld' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bGreedyCubicMesher) == 0x0003F8, "Member 'AVoxelRuntimeActor::bGreedyCubicMesher' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bSingleIndexGreedy) == 0x0003F9, "Member 'AVoxelRuntimeActor::bSingleIndexGreedy' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, TexturePoolTextureSize) == 0x0003FC, "Member 'AVoxelRuntimeActor::TexturePoolTextureSize' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bOptimizeIndices) == 0x000400, "Member 'AVoxelRuntimeActor::bOptimizeIndices' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bGenerateDistanceFields) == 0x000401, "Member 'AVoxelRuntimeActor::bGenerateDistanceFields' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MaxDistanceFieldLOD) == 0x000404, "Member 'AVoxelRuntimeActor::MaxDistanceFieldLOD' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, DistanceFieldBoundsExtension) == 0x000408, "Member 'AVoxelRuntimeActor::DistanceFieldBoundsExtension' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, DistanceFieldResolutionDivisor) == 0x00040C, "Member 'AVoxelRuntimeActor::DistanceFieldResolutionDivisor' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, DistanceFieldSelfShadowBias) == 0x000410, "Member 'AVoxelRuntimeActor::DistanceFieldSelfShadowBias' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bEnableTransitions) == 0x000414, "Member 'AVoxelRuntimeActor::bEnableTransitions' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bMergeChunks) == 0x000415, "Member 'AVoxelRuntimeActor::bMergeChunks' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, ChunksClustersSize) == 0x000418, "Member 'AVoxelRuntimeActor::ChunksClustersSize' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bDoNotMergeCollisionsAndNavmesh) == 0x00041C, "Member 'AVoxelRuntimeActor::bDoNotMergeCollisionsAndNavmesh' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, BoundsExtension) == 0x000420, "Member 'AVoxelRuntimeActor::BoundsExtension' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, FoliageCollections) == 0x000428, "Member 'AVoxelRuntimeActor::FoliageCollections' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, FoliageWorldType) == 0x000438, "Member 'AVoxelRuntimeActor::FoliageWorldType' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bIsFourWayBlend) == 0x000439, "Member 'AVoxelRuntimeActor::bIsFourWayBlend' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, HISMChunkSize) == 0x00043C, "Member 'AVoxelRuntimeActor::HISMChunkSize' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, FoliageCollisionDistanceInVoxel) == 0x000440, "Member 'AVoxelRuntimeActor::FoliageCollisionDistanceInVoxel' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MaxNumberOfFoliageInstances) == 0x000448, "Member 'AVoxelRuntimeActor::MaxNumberOfFoliageInstances' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bEnableCollisions) == 0x000450, "Member 'AVoxelRuntimeActor::bEnableCollisions' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, CollisionPresets) == 0x000458, "Member 'AVoxelRuntimeActor::CollisionPresets' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, CollisionTraceFlag) == 0x0005B0, "Member 'AVoxelRuntimeActor::CollisionTraceFlag' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, CanCharacterStepUpOn) == 0x0005B1, "Member 'AVoxelRuntimeActor::CanCharacterStepUpOn' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bNotifyRigidBodyCollision) == 0x0005B2, "Member 'AVoxelRuntimeActor::bNotifyRigidBodyCollision' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bGenerateOverlapEvents) == 0x0005B3, "Member 'AVoxelRuntimeActor::bGenerateOverlapEvents' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bComputeVisibleChunksCollisions) == 0x0005B4, "Member 'AVoxelRuntimeActor::bComputeVisibleChunksCollisions' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, VisibleChunksCollisionsMaxLOD) == 0x0005B8, "Member 'AVoxelRuntimeActor::VisibleChunksCollisionsMaxLOD' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, PhysMaterialOverride) == 0x0005C0, "Member 'AVoxelRuntimeActor::PhysMaterialOverride' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bUseCCD) == 0x0005C8, "Member 'AVoxelRuntimeActor::bUseCCD' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bSimpleCubicCollision) == 0x0005C9, "Member 'AVoxelRuntimeActor::bSimpleCubicCollision' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, SimpleCubicCollisionLODBias) == 0x0005CC, "Member 'AVoxelRuntimeActor::SimpleCubicCollisionLODBias' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, NumConvexHullsPerAxis) == 0x0005D0, "Member 'AVoxelRuntimeActor::NumConvexHullsPerAxis' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bCleanCollisionMeshes) == 0x0005D4, "Member 'AVoxelRuntimeActor::bCleanCollisionMeshes' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bEnableNavmesh) == 0x0005D5, "Member 'AVoxelRuntimeActor::bEnableNavmesh' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bComputeVisibleChunksNavmesh) == 0x0005D6, "Member 'AVoxelRuntimeActor::bComputeVisibleChunksNavmesh' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, VisibleChunksNavmeshMaxLOD) == 0x0005D8, "Member 'AVoxelRuntimeActor::VisibleChunksNavmeshMaxLOD' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, PriorityCategories) == 0x0005E0, "Member 'AVoxelRuntimeActor::PriorityCategories' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, PriorityOffsets) == 0x000630, "Member 'AVoxelRuntimeActor::PriorityOffsets' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MeshUpdatesBudget) == 0x000680, "Member 'AVoxelRuntimeActor::MeshUpdatesBudget' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, EventsTickRate) == 0x000684, "Member 'AVoxelRuntimeActor::EventsTickRate' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, DataOctreeInitialSubdivisionDepth) == 0x000688, "Member 'AVoxelRuntimeActor::DataOctreeInitialSubdivisionDepth' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, bEnableMultiplayer) == 0x00068C, "Member 'AVoxelRuntimeActor::bEnableMultiplayer' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MultiplayerInterface) == 0x000690, "Member 'AVoxelRuntimeActor::MultiplayerInterface' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, MultiplayerSyncRate) == 0x000698, "Member 'AVoxelRuntimeActor::MultiplayerSyncRate' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, RendererSubsystem) == 0x0006A0, "Member 'AVoxelRuntimeActor::RendererSubsystem' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, LODSubsystem) == 0x0006A8, "Member 'AVoxelRuntimeActor::LODSubsystem' has a wrong offset!");
static_assert(offsetof(AVoxelRuntimeActor, DebugTextures) == 0x0006B0, "Member 'AVoxelRuntimeActor::DebugTextures' has a wrong offset!");

// Class Voxel.VoxelWorld
// 0x01B8 (0x0878 - 0x06C0)
class AVoxelWorld : public AVoxelRuntimeActor
{
public:
	uint8                                         Pad_6C0[0x8];                                      // 0x06C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnGenerateWorld;                                   // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnWorldLoaded;                                     // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AVoxelWorld* VoxelWorldLoaded)> OnWorldLoadedWithPtr;                              // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnWorldDestroyed;                                  // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMaxFoliageInstancesReached;                      // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVoxelWorldRootComponent*               WorldRoot;                                         // 0x0718(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVoxelLineBatchComponent*               LineBatchComponent;                                // 0x0720(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_728[0x8];                                      // 0x0728(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelWorldSaveObject*                  SaveObject;                                        // 0x0730(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SaveFilePath;                                      // 0x0738(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallySaveToFile;                          // 0x0748(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppendDateToSavePath;                             // 0x0749(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecomputeNormalsBeforeBaking;                     // 0x074A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74B[0x5];                                      // 0x074B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BakedMeshTemplate;                                 // 0x0750(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UStaticMeshComponent>       BakedMeshComponentTemplate;                        // 0x0758(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFilePath                              BakedDataPath;                                     // 0x0760(0x0010)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bEnableFoliageInEditor;                            // 0x0770(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyRefreshMaterials;                    // 0x0771(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyRefreshFoliage;                      // 0x0772(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_773[0x1];                                      // 0x0773(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EditorOnly_NewScale;                               // 0x0774(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfThreads;                                   // 0x0780(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_784[0x4];                                      // 0x0784(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      Seeds;                                             // 0x0788(0x0050)(Edit, BlueprintVisible, AdvancedDisplay, NativeAccessSpecifierPublic)
	class UVoxelMultiplayerInterface*             MultiplayerInterfaceInstance;                      // 0x07D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoxelGeneratorCache*                   GeneratorCache;                                    // 0x07E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoxelPlaceableItemActorHelper*         PlaceableItemActorHelper;                          // 0x07E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsToggled;                                        // 0x07F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F1[0x87];                                     // 0x07F1(0x0087)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UVoxelMultiplayerInterface* CreateMultiplayerInterfaceInstance();
	void CreateWorld(const struct FVoxelWorldCreateInfo& Info);
	void DestroyWorld();
	void SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse NewResponse);
	void SetGeneratorClass(TSubclassOf<class UVoxelGenerator> NewGeneratorClass);
	void SetGeneratorObject(class UVoxelGenerator* NewGenerator);
	void SetRenderOctreeDepth(int32 NewDepth);
	void SetWorldSize(int32 NewWorldSizeInVoxels);

	void ApplyCollisionSettingsToRoot() const;
	class UVoxelGeneratorCache* GetGeneratorCache() const;
	struct FVoxelGeneratorInit GetGeneratorInit() const;
	class UVoxelMultiplayerInterface* GetMultiplayerInterfaceInstance() const;
	TArray<struct FIntVector> GetNeighboringPositions(const struct FVector& GlobalPosition) const;
	bool IsCreated() const;
	bool IsLoaded() const;
	struct FIntVector K2_GlobalToLocal(const struct FVector& Position, EVoxelWorldCoordinatesRounding Rounding) const;
	struct FVoxelIntBox K2_GlobalToLocalBounds(const struct FBox& Bounds) const;
	struct FVector K2_GlobalToLocalFloat(const struct FVector& Position) const;
	struct FVector K2_LocalToGlobal(const struct FIntVector& Position) const;
	struct FBox K2_LocalToGlobalBounds(const struct FVoxelIntBox& Bounds) const;
	struct FVector K2_LocalToGlobalFloat(const struct FVector& Position) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelWorld">();
	}
	static class AVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelWorld>();
	}
};
static_assert(alignof(AVoxelWorld) == 0x000008, "Wrong alignment on AVoxelWorld");
static_assert(sizeof(AVoxelWorld) == 0x000878, "Wrong size on AVoxelWorld");
static_assert(offsetof(AVoxelWorld, OnGenerateWorld) == 0x0006C8, "Member 'AVoxelWorld::OnGenerateWorld' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, OnWorldLoaded) == 0x0006D8, "Member 'AVoxelWorld::OnWorldLoaded' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, OnWorldLoadedWithPtr) == 0x0006E8, "Member 'AVoxelWorld::OnWorldLoadedWithPtr' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, OnWorldDestroyed) == 0x0006F8, "Member 'AVoxelWorld::OnWorldDestroyed' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, OnMaxFoliageInstancesReached) == 0x000708, "Member 'AVoxelWorld::OnMaxFoliageInstancesReached' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, WorldRoot) == 0x000718, "Member 'AVoxelWorld::WorldRoot' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, LineBatchComponent) == 0x000720, "Member 'AVoxelWorld::LineBatchComponent' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, SaveObject) == 0x000730, "Member 'AVoxelWorld::SaveObject' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, SaveFilePath) == 0x000738, "Member 'AVoxelWorld::SaveFilePath' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, bAutomaticallySaveToFile) == 0x000748, "Member 'AVoxelWorld::bAutomaticallySaveToFile' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, bAppendDateToSavePath) == 0x000749, "Member 'AVoxelWorld::bAppendDateToSavePath' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, bRecomputeNormalsBeforeBaking) == 0x00074A, "Member 'AVoxelWorld::bRecomputeNormalsBeforeBaking' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, BakedMeshTemplate) == 0x000750, "Member 'AVoxelWorld::BakedMeshTemplate' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, BakedMeshComponentTemplate) == 0x000758, "Member 'AVoxelWorld::BakedMeshComponentTemplate' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, BakedDataPath) == 0x000760, "Member 'AVoxelWorld::BakedDataPath' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, bEnableFoliageInEditor) == 0x000770, "Member 'AVoxelWorld::bEnableFoliageInEditor' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, bAutomaticallyRefreshMaterials) == 0x000771, "Member 'AVoxelWorld::bAutomaticallyRefreshMaterials' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, bAutomaticallyRefreshFoliage) == 0x000772, "Member 'AVoxelWorld::bAutomaticallyRefreshFoliage' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, EditorOnly_NewScale) == 0x000774, "Member 'AVoxelWorld::EditorOnly_NewScale' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, NumberOfThreads) == 0x000780, "Member 'AVoxelWorld::NumberOfThreads' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, Seeds) == 0x000788, "Member 'AVoxelWorld::Seeds' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, MultiplayerInterfaceInstance) == 0x0007D8, "Member 'AVoxelWorld::MultiplayerInterfaceInstance' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, GeneratorCache) == 0x0007E0, "Member 'AVoxelWorld::GeneratorCache' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, PlaceableItemActorHelper) == 0x0007E8, "Member 'AVoxelWorld::PlaceableItemActorHelper' has a wrong offset!");
static_assert(offsetof(AVoxelWorld, bIsToggled) == 0x0007F0, "Member 'AVoxelWorld::bIsToggled' has a wrong offset!");

// Class Voxel.VoxelPlaceableItemActorHelper
// 0x0050 (0x0078 - 0x0028)
class UVoxelPlaceableItemActorHelper final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPlaceableItemActorHelper">();
	}
	static class UVoxelPlaceableItemActorHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPlaceableItemActorHelper>();
	}
};
static_assert(alignof(UVoxelPlaceableItemActorHelper) == 0x000008, "Wrong alignment on UVoxelPlaceableItemActorHelper");
static_assert(sizeof(UVoxelPlaceableItemActorHelper) == 0x000078, "Wrong size on UVoxelPlaceableItemActorHelper");

// Class Voxel.VoxelPlaceableItemManager
// 0x0040 (0x0068 - 0x0028)
class UVoxelPlaceableItemManager final : public UObject
{
public:
	bool                                          bEnableDebug;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugBounds;                                      // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVoxelDataItemConstructionInfo> DataItemInfos;                                     // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UVoxelGeneratorCache*                   GeneratorCache;                                    // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDataItem(const struct FVoxelDataItemConstructionInfo& Info);
	void DrawDebugLine(const struct FVector& Start, const struct FVector& End, const struct FLinearColor& Color);
	void DrawDebugPoint(const struct FVector& Position, const struct FLinearColor& Color);
	void OnClear();
	void OnGenerate();

	class UVoxelGeneratorCache* GetGeneratorCache() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPlaceableItemManager">();
	}
	static class UVoxelPlaceableItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPlaceableItemManager>();
	}
};
static_assert(alignof(UVoxelPlaceableItemManager) == 0x000008, "Wrong alignment on UVoxelPlaceableItemManager");
static_assert(sizeof(UVoxelPlaceableItemManager) == 0x000068, "Wrong size on UVoxelPlaceableItemManager");
static_assert(offsetof(UVoxelPlaceableItemManager, bEnableDebug) == 0x000028, "Member 'UVoxelPlaceableItemManager::bEnableDebug' has a wrong offset!");
static_assert(offsetof(UVoxelPlaceableItemManager, bDebugBounds) == 0x000029, "Member 'UVoxelPlaceableItemManager::bDebugBounds' has a wrong offset!");
static_assert(offsetof(UVoxelPlaceableItemManager, DataItemInfos) == 0x000030, "Member 'UVoxelPlaceableItemManager::DataItemInfos' has a wrong offset!");
static_assert(offsetof(UVoxelPlaceableItemManager, GeneratorCache) == 0x000040, "Member 'UVoxelPlaceableItemManager::GeneratorCache' has a wrong offset!");

// Class Voxel.VoxelPlaceableItemsUtilities
// 0x0000 (0x0028 - 0x0028)
class UVoxelPlaceableItemsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void AddWorms(TDelegate<void(const struct FVector& Start, const struct FVector& End, float Radius)> AddWorm, const struct FVoxelPerlinWormsSettings& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPlaceableItemsUtilities">();
	}
	static class UVoxelPlaceableItemsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPlaceableItemsUtilities>();
	}
};
static_assert(alignof(UVoxelPlaceableItemsUtilities) == 0x000008, "Wrong alignment on UVoxelPlaceableItemsUtilities");
static_assert(sizeof(UVoxelPlaceableItemsUtilities) == 0x000028, "Wrong size on UVoxelPlaceableItemsUtilities");

// Class Voxel.VoxelPoolSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelPoolSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelPoolSubsystemProxy">();
	}
	static class UVoxelPoolSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelPoolSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelPoolSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelPoolSubsystemProxy");
static_assert(sizeof(UVoxelPoolSubsystemProxy) == 0x000028, "Wrong size on UVoxelPoolSubsystemProxy");

// Class Voxel.VoxelProceduralMeshComponent
// 0x01A0 (0x0630 - 0x0490)
class UVoxelProceduralMeshComponent : public UModelComponent
{
public:
	uint8                                         Pad_490[0xB8];                                     // 0x0490(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0548(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBodySetup*                             BodySetupBeingCooked;                              // 0x0550(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0558(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_560[0xD0];                                     // 0x0560(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool AreVoxelCollisionsFrozen(const class AVoxelWorld* VoxelWorld);
	static void SetVoxelCollisionsFrozen(const class AVoxelWorld* VoxelWorld, bool bFrozen);

	void InitChunk(uint8 ChunkLOD, const struct FVoxelIntBox& ChunkBounds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelProceduralMeshComponent">();
	}
	static class UVoxelProceduralMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelProceduralMeshComponent>();
	}
};
static_assert(alignof(UVoxelProceduralMeshComponent) == 0x000010, "Wrong alignment on UVoxelProceduralMeshComponent");
static_assert(sizeof(UVoxelProceduralMeshComponent) == 0x000630, "Wrong size on UVoxelProceduralMeshComponent");
static_assert(offsetof(UVoxelProceduralMeshComponent, BodySetup) == 0x000548, "Member 'UVoxelProceduralMeshComponent::BodySetup' has a wrong offset!");
static_assert(offsetof(UVoxelProceduralMeshComponent, BodySetupBeingCooked) == 0x000550, "Member 'UVoxelProceduralMeshComponent::BodySetupBeingCooked' has a wrong offset!");
static_assert(offsetof(UVoxelProceduralMeshComponent, StaticMeshComponent) == 0x000558, "Member 'UVoxelProceduralMeshComponent::StaticMeshComponent' has a wrong offset!");

// Class Voxel.VoxelProjectionTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelProjectionTools final : public UBlueprintFunctionLibrary
{
public:
	static struct FVoxelSurfaceEditsVoxels CreateSurfaceVoxelsFromHits(const TArray<struct FVoxelProjectionHit>& Hits);
	static struct FVoxelSurfaceEditsVoxels CreateSurfaceVoxelsFromHitsWithExactValues(class AVoxelWorld* World, const TArray<struct FVoxelProjectionHit>& Hits);
	static int32 FindProjectionVoxels(TArray<struct FVoxelProjectionHit>* Hits, class AVoxelWorld* World, const struct FVoxelLineTraceParameters& Parameters, const struct FVector& Position, const struct FVector& Direction, float Radius, EVoxelProjectionShape Shape, float NumRays, float MaxDistance);
	static int32 FindProjectionVoxelsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FVoxelProjectionHit>* Hits, class AVoxelWorld* World, const struct FVoxelLineTraceParameters& Parameters, const struct FVector& Position, const struct FVector& Direction, float Radius, EVoxelProjectionShape Shape, float NumRays, float MaxDistance, bool bHideLatentWarnings);
	static struct FVector GetHitsAverageNormal(const TArray<struct FVoxelProjectionHit>& Hits);
	static struct FVector GetHitsAveragePosition(const TArray<struct FVoxelProjectionHit>& Hits);
	static TArray<struct FIntVector> GetHitsPositions(const TArray<struct FVoxelProjectionHit>& Hits);
	static struct FVoxelLineTraceParameters MakeVoxelLineTraceParameters(const TArray<ECollisionChannel>& CollisionChannelsToIgnore, const TArray<class AActor*>& ActorsToIgnore, ECollisionChannel CollisionChannel, EDrawDebugTrace DrawDebugType, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelProjectionTools">();
	}
	static class UVoxelProjectionTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelProjectionTools>();
	}
};
static_assert(alignof(UVoxelProjectionTools) == 0x000008, "Wrong alignment on UVoxelProjectionTools");
static_assert(sizeof(UVoxelProjectionTools) == 0x000028, "Wrong size on UVoxelProjectionTools");

// Class Voxel.VoxelSphereToolBase
// 0x0010 (0x0570 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) UVoxelSphereToolBase : public UVoxelToolWithAlignment
{
public:
	class UMaterialInterface*                     ToolMaterial;                                      // 0x0558(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            SphereMesh;                                        // 0x0560(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSphereToolBase">();
	}
	static class UVoxelSphereToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSphereToolBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVoxelSphereToolBase) == 0x000010, "Wrong alignment on UVoxelSphereToolBase");
static_assert(sizeof(UVoxelSphereToolBase) == 0x000570, "Wrong size on UVoxelSphereToolBase");
static_assert(offsetof(UVoxelSphereToolBase, ToolMaterial) == 0x000558, "Member 'UVoxelSphereToolBase::ToolMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelSphereToolBase, SphereMesh) == 0x000560, "Member 'UVoxelSphereToolBase::SphereMesh' has a wrong offset!");

// Class Voxel.VoxelRevertTool
// 0x0010 (0x0580 - 0x0570)
class UVoxelRevertTool final : public UVoxelSphereToolBase
{
public:
	bool                                          bRevertValues;                                     // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRevertMaterials;                                  // 0x0569(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56A[0x2];                                      // 0x056A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HistoryPosition;                                   // 0x056C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentHistoryPosition;                            // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0xC];                                      // 0x0574(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelRevertTool">();
	}
	static class UVoxelRevertTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelRevertTool>();
	}
};
static_assert(alignof(UVoxelRevertTool) == 0x000010, "Wrong alignment on UVoxelRevertTool");
static_assert(sizeof(UVoxelRevertTool) == 0x000580, "Wrong size on UVoxelRevertTool");
static_assert(offsetof(UVoxelRevertTool, bRevertValues) == 0x000568, "Member 'UVoxelRevertTool::bRevertValues' has a wrong offset!");
static_assert(offsetof(UVoxelRevertTool, bRevertMaterials) == 0x000569, "Member 'UVoxelRevertTool::bRevertMaterials' has a wrong offset!");
static_assert(offsetof(UVoxelRevertTool, HistoryPosition) == 0x00056C, "Member 'UVoxelRevertTool::HistoryPosition' has a wrong offset!");
static_assert(offsetof(UVoxelRevertTool, CurrentHistoryPosition) == 0x000570, "Member 'UVoxelRevertTool::CurrentHistoryPosition' has a wrong offset!");

// Class Voxel.VoxelWorldSaveObject
// 0x0028 (0x0050 - 0x0028)
class UVoxelWorldSaveObject final : public UObject
{
public:
	struct FVoxelCompressedWorldSave              Save;                                              // 0x0028(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Depth;                                             // 0x0048(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelWorldSaveObject">();
	}
	static class UVoxelWorldSaveObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelWorldSaveObject>();
	}
};
static_assert(alignof(UVoxelWorldSaveObject) == 0x000008, "Wrong alignment on UVoxelWorldSaveObject");
static_assert(sizeof(UVoxelWorldSaveObject) == 0x000050, "Wrong size on UVoxelWorldSaveObject");
static_assert(offsetof(UVoxelWorldSaveObject, Save) == 0x000028, "Member 'UVoxelWorldSaveObject::Save' has a wrong offset!");
static_assert(offsetof(UVoxelWorldSaveObject, Depth) == 0x000048, "Member 'UVoxelWorldSaveObject::Depth' has a wrong offset!");

// Class Voxel.VoxelSaveUtilities
// 0x0000 (0x0028 - 0x0028)
class UVoxelSaveUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void CompressVoxelSave(const struct FVoxelUncompressedWorldSave& UncompressedSave, struct FVoxelCompressedWorldSave* OutCompressedSave);
	static bool DecompressVoxelSave(const struct FVoxelCompressedWorldSave& CompressedSave, struct FVoxelUncompressedWorldSave* OutUncompressedSave);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSaveUtilities">();
	}
	static class UVoxelSaveUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSaveUtilities>();
	}
};
static_assert(alignof(UVoxelSaveUtilities) == 0x000008, "Wrong alignment on UVoxelSaveUtilities");
static_assert(sizeof(UVoxelSaveUtilities) == 0x000028, "Wrong size on UVoxelSaveUtilities");

// Class Voxel.VoxelSettings
// 0x0010 (0x0048 - 0x0038)
class UVoxelSettings final : public UDeveloperSettings
{
public:
	int32                                         NumberOfThreads;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityDuration;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelThreadPriority                          ThreadPriority;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowNotifications;                                // 0x0041(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAutoPreview;                               // 0x0042(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRoundBeforeSaving;                                // 0x0043(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultCompressionLevel;                           // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSettings">();
	}
	static class UVoxelSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSettings>();
	}
};
static_assert(alignof(UVoxelSettings) == 0x000008, "Wrong alignment on UVoxelSettings");
static_assert(sizeof(UVoxelSettings) == 0x000048, "Wrong size on UVoxelSettings");
static_assert(offsetof(UVoxelSettings, NumberOfThreads) == 0x000038, "Member 'UVoxelSettings::NumberOfThreads' has a wrong offset!");
static_assert(offsetof(UVoxelSettings, PriorityDuration) == 0x00003C, "Member 'UVoxelSettings::PriorityDuration' has a wrong offset!");
static_assert(offsetof(UVoxelSettings, ThreadPriority) == 0x000040, "Member 'UVoxelSettings::ThreadPriority' has a wrong offset!");
static_assert(offsetof(UVoxelSettings, bShowNotifications) == 0x000041, "Member 'UVoxelSettings::bShowNotifications' has a wrong offset!");
static_assert(offsetof(UVoxelSettings, bDisableAutoPreview) == 0x000042, "Member 'UVoxelSettings::bDisableAutoPreview' has a wrong offset!");
static_assert(offsetof(UVoxelSettings, bRoundBeforeSaving) == 0x000043, "Member 'UVoxelSettings::bRoundBeforeSaving' has a wrong offset!");
static_assert(offsetof(UVoxelSettings, DefaultCompressionLevel) == 0x000044, "Member 'UVoxelSettings::DefaultCompressionLevel' has a wrong offset!");

// Class Voxel.VoxelSmoothTool
// 0x0020 (0x0570 - 0x0550)
class UVoxelSmoothTool final : public UVoxelToolBase
{
public:
	class UMaterialInterface*                     ToolMaterial;                                      // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSculpt;                                           // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaint;                                            // 0x0551(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_552[0x2];                                      // 0x0552(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PaintMask;                                         // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumIterations;                                     // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelFalloff                                 FalloffType;                                       // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_561[0x3];                                      // 0x0561(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Falloff;                                           // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSmoothTool">();
	}
	static class UVoxelSmoothTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSmoothTool>();
	}
};
static_assert(alignof(UVoxelSmoothTool) == 0x000010, "Wrong alignment on UVoxelSmoothTool");
static_assert(sizeof(UVoxelSmoothTool) == 0x000570, "Wrong size on UVoxelSmoothTool");
static_assert(offsetof(UVoxelSmoothTool, ToolMaterial) == 0x000548, "Member 'UVoxelSmoothTool::ToolMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelSmoothTool, bSculpt) == 0x000550, "Member 'UVoxelSmoothTool::bSculpt' has a wrong offset!");
static_assert(offsetof(UVoxelSmoothTool, bPaint) == 0x000551, "Member 'UVoxelSmoothTool::bPaint' has a wrong offset!");
static_assert(offsetof(UVoxelSmoothTool, PaintMask) == 0x000554, "Member 'UVoxelSmoothTool::PaintMask' has a wrong offset!");
static_assert(offsetof(UVoxelSmoothTool, Strength) == 0x000558, "Member 'UVoxelSmoothTool::Strength' has a wrong offset!");
static_assert(offsetof(UVoxelSmoothTool, NumIterations) == 0x00055C, "Member 'UVoxelSmoothTool::NumIterations' has a wrong offset!");
static_assert(offsetof(UVoxelSmoothTool, FalloffType) == 0x000560, "Member 'UVoxelSmoothTool::FalloffType' has a wrong offset!");
static_assert(offsetof(UVoxelSmoothTool, Falloff) == 0x000564, "Member 'UVoxelSmoothTool::Falloff' has a wrong offset!");

// Class Voxel.VoxelSphereTool
// 0x0020 (0x0590 - 0x0570)
class UVoxelSphereTool final : public UVoxelSphereToolBase
{
public:
	class UMaterialInterface*                     OverlayMaterial;                                   // 0x0568(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSculpt;                                           // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIndexInterval;                              // 0x0571(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_572[0x2];                                      // 0x0572(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelInt32Interval                    IndexInterval;                                     // 0x0574(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaint;                                            // 0x057C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57D[0x3];                                      // 0x057D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PaintStrength;                                     // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelFalloff                                 FalloffType;                                       // 0x0584(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_585[0x3];                                      // 0x0585(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Falloff;                                           // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSphereTool">();
	}
	static class UVoxelSphereTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSphereTool>();
	}
};
static_assert(alignof(UVoxelSphereTool) == 0x000010, "Wrong alignment on UVoxelSphereTool");
static_assert(sizeof(UVoxelSphereTool) == 0x000590, "Wrong size on UVoxelSphereTool");
static_assert(offsetof(UVoxelSphereTool, OverlayMaterial) == 0x000568, "Member 'UVoxelSphereTool::OverlayMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelSphereTool, bSculpt) == 0x000570, "Member 'UVoxelSphereTool::bSculpt' has a wrong offset!");
static_assert(offsetof(UVoxelSphereTool, bEnableIndexInterval) == 0x000571, "Member 'UVoxelSphereTool::bEnableIndexInterval' has a wrong offset!");
static_assert(offsetof(UVoxelSphereTool, IndexInterval) == 0x000574, "Member 'UVoxelSphereTool::IndexInterval' has a wrong offset!");
static_assert(offsetof(UVoxelSphereTool, bPaint) == 0x00057C, "Member 'UVoxelSphereTool::bPaint' has a wrong offset!");
static_assert(offsetof(UVoxelSphereTool, PaintStrength) == 0x000580, "Member 'UVoxelSphereTool::PaintStrength' has a wrong offset!");
static_assert(offsetof(UVoxelSphereTool, FalloffType) == 0x000584, "Member 'UVoxelSphereTool::FalloffType' has a wrong offset!");
static_assert(offsetof(UVoxelSphereTool, Falloff) == 0x000588, "Member 'UVoxelSphereTool::Falloff' has a wrong offset!");

// Class Voxel.VoxelSphereTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelSphereTools final : public UVoxelToolsBase
{
public:
	static void AddSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void AddSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void ApplyKernelSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float CenterMultiplier, float FirstDegreeNeighborMultiplier, float SecondDegreeNeighborMultiplier, float ThirdDegreeNeighborMultiplier, int32 NumIterations, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void ApplyKernelSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float CenterMultiplier, float FirstDegreeNeighborMultiplier, float SecondDegreeNeighborMultiplier, float ThirdDegreeNeighborMultiplier, int32 NumIterations, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void ApplyMaterialKernelSphere(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float CenterMultiplier, float FirstDegreeNeighborMultiplier, float SecondDegreeNeighborMultiplier, float ThirdDegreeNeighborMultiplier, int32 NumIterations, int32 Mask, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void ApplyMaterialKernelSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float CenterMultiplier, float FirstDegreeNeighborMultiplier, float SecondDegreeNeighborMultiplier, float ThirdDegreeNeighborMultiplier, int32 NumIterations, int32 Mask, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void RemoveCapsule(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FRotator& Rotation, float Radius, float HalfHeight, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void RemoveCapsuleAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FRotator& Rotation, float Radius, float HalfHeight, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void RemoveSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void RemoveSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void RemoveSphereWithDurability(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, const struct FVoxelInt32Interval& Interval, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void RemoveSphereWithDurabilityAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, const struct FVoxelInt32Interval& Interval, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void RevertSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, int32 HistoryPosition, bool bRevertValues, bool bRevertMaterials, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void RevertSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, int32 HistoryPosition, bool bRevertValues, bool bRevertMaterials, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void RevertSphereToGenerator(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bRevertValues, bool bRevertMaterials, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void RevertSphereToGeneratorAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, bool bRevertValues, bool bRevertMaterials, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void SetMaterialInCapsule(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FRotator& Rotation, float Radius, float HalfHeight, const struct FVoxelPaintMaterial& PaintMaterial, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void SetMaterialInCapsuleAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FRotator& Rotation, float Radius, float HalfHeight, const struct FVoxelPaintMaterial& PaintMaterial, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void SetMaterialSphere(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, const struct FVoxelPaintMaterial& PaintMaterial, float Strength, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void SetMaterialSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, const struct FVoxelPaintMaterial& PaintMaterial, float Strength, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void SetValueSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Value, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void SetValueSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Value, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void SmoothMaterialSphere(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Strength, int32 NumIterations, int32 Mask, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void SmoothMaterialSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Strength, int32 NumIterations, int32 Mask, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void SmoothSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Strength, int32 NumIterations, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void SmoothSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, float Radius, float Strength, int32 NumIterations, EVoxelFalloff FalloffType, float Falloff, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);
	static void TrimSphere(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FVector& Normal, float Radius, float Falloff, bool bAdditive, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender);
	static void TrimSphereAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVector& Position, const struct FVector& Normal, float Radius, float Falloff, bool bAdditive, bool bMultiThreaded, bool bRecordModifiedValues, bool bConvertToVoxelSpace, bool bUpdateRender, bool bHideLatentWarnings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSphereTools">();
	}
	static class UVoxelSphereTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSphereTools>();
	}
};
static_assert(alignof(UVoxelSphereTools) == 0x000008, "Wrong alignment on UVoxelSphereTools");
static_assert(sizeof(UVoxelSphereTools) == 0x000028, "Wrong size on UVoxelSphereTools");

// Class Voxel.VoxelStaticWorld
// 0x0018 (0x0238 - 0x0220)
class AVoxelStaticWorld final : public AActor
{
public:
	class UStaticMeshComponent*                   BaseMesh;                                          // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           Meshes;                                            // 0x0228(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelStaticWorld">();
	}
	static class AVoxelStaticWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelStaticWorld>();
	}
};
static_assert(alignof(AVoxelStaticWorld) == 0x000008, "Wrong alignment on AVoxelStaticWorld");
static_assert(sizeof(AVoxelStaticWorld) == 0x000238, "Wrong size on AVoxelStaticWorld");
static_assert(offsetof(AVoxelStaticWorld, BaseMesh) == 0x000220, "Member 'AVoxelStaticWorld::BaseMesh' has a wrong offset!");
static_assert(offsetof(AVoxelStaticWorld, Meshes) == 0x000228, "Member 'AVoxelStaticWorld::Meshes' has a wrong offset!");

// Class Voxel.VoxelSurfaceEditTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelSurfaceEditTools final : public UVoxelToolsBase
{
public:
	static void EditVoxelMaterials(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelPaintMaterial& PaintMaterial, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender);
	static void EditVoxelMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelPaintMaterial& PaintMaterial, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender, bool bHideLatentWarnings);
	static void EditVoxelValues(TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, float DistanceDivisor, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender);
	static void EditVoxelValuesAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelValue>* ModifiedValues, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, float DistanceDivisor, bool bMultiThreaded, bool bRecordModifiedValues, bool bUpdateRender, bool bHideLatentWarnings);
	static void PropagateVoxelMaterials(TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender);
	static void PropagateVoxelMaterialsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TArray<struct FModifiedVoxelMaterial>* ModifiedMaterials, struct FVoxelIntBox* EditedBounds, class AVoxelWorld* VoxelWorld, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, bool bMultiThreaded, bool bRecordModifiedMaterials, bool bUpdateRender, bool bHideLatentWarnings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSurfaceEditTools">();
	}
	static class UVoxelSurfaceEditTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSurfaceEditTools>();
	}
};
static_assert(alignof(UVoxelSurfaceEditTools) == 0x000008, "Wrong alignment on UVoxelSurfaceEditTools");
static_assert(sizeof(UVoxelSurfaceEditTools) == 0x000028, "Wrong size on UVoxelSurfaceEditTools");

// Class Voxel.VoxelSurfaceTool
// 0x0200 (0x0750 - 0x0550)
class UVoxelSurfaceTool final : public UVoxelToolBase
{
public:
	class UMaterialInterface*                     ToolMaterial;                                      // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSculpt;                                           // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_551[0x3];                                      // 0x0551(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SculptStrength;                                    // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateMaterials;                               // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaint;                                            // 0x0559(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55A[0x2];                                      // 0x055A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PaintStrength;                                     // 0x055C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          b2DBrush;                                          // 0x0560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMovementAffectsStrength;                          // 0x0561(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_562[0x2];                                      // 0x0562(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Stride;                                            // 0x0564(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlignToMovement;                                  // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_569[0x3];                                      // 0x0569(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FixedDirection;                                    // 0x056C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bModulateStrengthByDeltaTime;                      // 0x0578(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFalloff;                                    // 0x0579(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelFalloff                                 FalloffType;                                       // 0x057A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57B[0x1];                                      // 0x057B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Falloff;                                           // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMask;                                          // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_581[0x7];                                      // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelSurfaceToolMask                  Mask;                                              // 0x0588(0x00A8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_630[0x110];                                    // 0x0630(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             MaskGeneratorCache_RenderTexture;                  // 0x0740(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSurfaceTool">();
	}
	static class UVoxelSurfaceTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSurfaceTool>();
	}
};
static_assert(alignof(UVoxelSurfaceTool) == 0x000010, "Wrong alignment on UVoxelSurfaceTool");
static_assert(sizeof(UVoxelSurfaceTool) == 0x000750, "Wrong size on UVoxelSurfaceTool");
static_assert(offsetof(UVoxelSurfaceTool, ToolMaterial) == 0x000548, "Member 'UVoxelSurfaceTool::ToolMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, bSculpt) == 0x000550, "Member 'UVoxelSurfaceTool::bSculpt' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, SculptStrength) == 0x000554, "Member 'UVoxelSurfaceTool::SculptStrength' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, bPropagateMaterials) == 0x000558, "Member 'UVoxelSurfaceTool::bPropagateMaterials' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, bPaint) == 0x000559, "Member 'UVoxelSurfaceTool::bPaint' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, PaintStrength) == 0x00055C, "Member 'UVoxelSurfaceTool::PaintStrength' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, b2DBrush) == 0x000560, "Member 'UVoxelSurfaceTool::b2DBrush' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, bMovementAffectsStrength) == 0x000561, "Member 'UVoxelSurfaceTool::bMovementAffectsStrength' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, Stride) == 0x000564, "Member 'UVoxelSurfaceTool::Stride' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, bAlignToMovement) == 0x000568, "Member 'UVoxelSurfaceTool::bAlignToMovement' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, FixedDirection) == 0x00056C, "Member 'UVoxelSurfaceTool::FixedDirection' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, bModulateStrengthByDeltaTime) == 0x000578, "Member 'UVoxelSurfaceTool::bModulateStrengthByDeltaTime' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, bEnableFalloff) == 0x000579, "Member 'UVoxelSurfaceTool::bEnableFalloff' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, FalloffType) == 0x00057A, "Member 'UVoxelSurfaceTool::FalloffType' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, Falloff) == 0x00057C, "Member 'UVoxelSurfaceTool::Falloff' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, bUseMask) == 0x000580, "Member 'UVoxelSurfaceTool::bUseMask' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, Mask) == 0x000588, "Member 'UVoxelSurfaceTool::Mask' has a wrong offset!");
static_assert(offsetof(UVoxelSurfaceTool, MaskGeneratorCache_RenderTexture) == 0x000740, "Member 'UVoxelSurfaceTool::MaskGeneratorCache_RenderTexture' has a wrong offset!");

// Class Voxel.VoxelSurfaceTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelSurfaceTools final : public UBlueprintFunctionLibrary
{
public:
	static struct FVoxelSurfaceEditsStack AddToStack(const struct FVoxelSurfaceEditsStack& Stack, const struct FVoxelSurfaceEditsStackElement& Element);
	static struct FVoxelSurfaceEditsStackElement ApplyConstantStrength(float Strength);
	static struct FVoxelSurfaceEditsStackElement ApplyFalloff(class AVoxelWorld* World, EVoxelFalloff FalloffType, const struct FVector& Center, float Radius, float Falloff, bool bConvertToVoxelSpace);
	static struct FVoxelSurfaceEditsStackElement ApplyFlatten(class AVoxelWorld* World, const struct FVector& PlanePoint, const struct FVector& PlaneNormal, EVoxelSDFMergeMode MergeMode, bool bConvertToVoxelSpace);
	static struct FVoxelSurfaceEditsProcessedVoxels ApplyStack(const struct FVoxelSurfaceEditsVoxels& Voxels, const struct FVoxelSurfaceEditsStack& Stack);
	static void ApplyStackAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelSurfaceEditsProcessedVoxels* ProcessedVoxels, const struct FVoxelSurfaceEditsVoxels& Voxels, const struct FVoxelSurfaceEditsStack& Stack, bool bHideLatentWarnings);
	static struct FVoxelSurfaceEditsStackElement ApplyStrengthCurve(class AVoxelWorld* World, const struct FVector& Center, float Radius, class UCurveFloat* StrengthCurve, bool bConvertToVoxelSpace);
	static struct FVoxelSurfaceEditsStackElement ApplyStrengthMask(class AVoxelWorld* World, const struct FVoxelFloatTexture& Mask, const struct FVector& EditPosition, float ScaleX, float ScaleY, const struct FVector& PlaneNormal, const struct FVector& PlaneTangent, EVoxelSamplerMode SamplerMode, bool bConvertToVoxelSpace);
	static struct FVoxelSurfaceEditsStackElement ApplyTerrace(int32 TerraceHeightInVoxels, float Angle, int32 ImmutableVoxels);
	static void DebugSurfaceVoxels(class AVoxelWorld* World, const struct FVoxelSurfaceEditsProcessedVoxels& ProcessedVoxels, float LifeTime);
	static void FindSurfaceVoxels(struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bComputeNormals);
	static void FindSurfaceVoxels2D(struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bComputeNormals);
	static void FindSurfaceVoxels2DAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bComputeNormals, bool bHideLatentWarnings);
	static void FindSurfaceVoxelsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bComputeNormals, bool bHideLatentWarnings);
	static void FindSurfaceVoxelsFromDistanceField(struct FVoxelSurfaceEditsVoxels* Voxels, class AVoxelWorld* World, const struct FVoxelIntBox& Bounds, bool bMultiThreaded, EVoxelComputeDevice ComputeDevice);
	static struct FVoxelIntBox GetBounds(const struct FVoxelSurfaceEditsProcessedVoxels& Voxels);
	static void GetStrengthMaskScale(float* ScaleX, float* ScaleY, class AVoxelWorld* World, const struct FVoxelFloatTexture& Mask, float SizeX, float SizeY, bool bConvertToVoxelSpace);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelSurfaceTools">();
	}
	static class UVoxelSurfaceTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelSurfaceTools>();
	}
};
static_assert(alignof(UVoxelSurfaceTools) == 0x000008, "Wrong alignment on UVoxelSurfaceTools");
static_assert(sizeof(UVoxelSurfaceTools) == 0x000028, "Wrong size on UVoxelSurfaceTools");

// Class Voxel.VoxelTestLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelTestLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVoxelTestValues ReadValues(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds);
	static void TestValues(const struct FVoxelTestValues& ValuesA, const struct FVoxelTestValues& ValuesB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelTestLibrary">();
	}
	static class UVoxelTestLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelTestLibrary>();
	}
};
static_assert(alignof(UVoxelTestLibrary) == 0x000008, "Wrong alignment on UVoxelTestLibrary");
static_assert(sizeof(UVoxelTestLibrary) == 0x000028, "Wrong size on UVoxelTestLibrary");

// Class Voxel.VoxelTexturePoolSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelTexturePoolSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelTexturePoolSubsystemProxy">();
	}
	static class UVoxelTexturePoolSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelTexturePoolSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelTexturePoolSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelTexturePoolSubsystemProxy");
static_assert(sizeof(UVoxelTexturePoolSubsystemProxy) == 0x000028, "Wrong size on UVoxelTexturePoolSubsystemProxy");

// Class Voxel.VoxelTextureTools
// 0x0000 (0x0028 - 0x0028)
class UVoxelTextureTools final : public UBlueprintFunctionLibrary
{
public:
	static struct FVoxelFloatTexture Maximum(const struct FVoxelFloatTexture& Texture, float Radius);
	static struct FVoxelFloatTexture Minimum(const struct FVoxelFloatTexture& Texture, float Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelTextureTools">();
	}
	static class UVoxelTextureTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelTextureTools>();
	}
};
static_assert(alignof(UVoxelTextureTools) == 0x000008, "Wrong alignment on UVoxelTextureTools");
static_assert(sizeof(UVoxelTextureTools) == 0x000028, "Wrong size on UVoxelTextureTools");

// Class Voxel.VoxelToolSharedConfig
// 0x0108 (0x0130 - 0x0028)
class UVoxelToolSharedConfig final : public UObject
{
public:
	float                                         BrushSize;                                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelPaintMaterial                    PaintMaterial;                                     // 0x0030(0x0098)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ToolOpacity;                                       // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlignToMovementSmoothness;                         // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ControlSpeed;                                      // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVoxelWorld*>                    WorldsToEdit;                                      // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bCacheData;                                        // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiThreaded;                                    // 0x00E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelComputeDevice                           ComputeDevice;                                     // 0x00EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRegenerateFoliage;                                // 0x00EB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckForSingleValues;                             // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitForUpdates;                                   // 0x00ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x00EE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF[0x1];                                       // 0x00EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixedDeltaTime;                                    // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            PlaneMesh;                                         // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     PlaneMaterial;                                     // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AVoxelWorld* World, const struct FVoxelIntBox& Bounds)> OnBoundsUpdated;                                   // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelToolSharedConfig">();
	}
	static class UVoxelToolSharedConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelToolSharedConfig>();
	}
};
static_assert(alignof(UVoxelToolSharedConfig) == 0x000008, "Wrong alignment on UVoxelToolSharedConfig");
static_assert(sizeof(UVoxelToolSharedConfig) == 0x000130, "Wrong size on UVoxelToolSharedConfig");
static_assert(offsetof(UVoxelToolSharedConfig, BrushSize) == 0x000028, "Member 'UVoxelToolSharedConfig::BrushSize' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, PaintMaterial) == 0x000030, "Member 'UVoxelToolSharedConfig::PaintMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, ToolOpacity) == 0x0000C8, "Member 'UVoxelToolSharedConfig::ToolOpacity' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, AlignToMovementSmoothness) == 0x0000CC, "Member 'UVoxelToolSharedConfig::AlignToMovementSmoothness' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, ControlSpeed) == 0x0000D0, "Member 'UVoxelToolSharedConfig::ControlSpeed' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, WorldsToEdit) == 0x0000D8, "Member 'UVoxelToolSharedConfig::WorldsToEdit' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, bCacheData) == 0x0000E8, "Member 'UVoxelToolSharedConfig::bCacheData' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, bMultiThreaded) == 0x0000E9, "Member 'UVoxelToolSharedConfig::bMultiThreaded' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, ComputeDevice) == 0x0000EA, "Member 'UVoxelToolSharedConfig::ComputeDevice' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, bRegenerateFoliage) == 0x0000EB, "Member 'UVoxelToolSharedConfig::bRegenerateFoliage' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, bCheckForSingleValues) == 0x0000EC, "Member 'UVoxelToolSharedConfig::bCheckForSingleValues' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, bWaitForUpdates) == 0x0000ED, "Member 'UVoxelToolSharedConfig::bWaitForUpdates' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, bDebug) == 0x0000EE, "Member 'UVoxelToolSharedConfig::bDebug' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, FixedDeltaTime) == 0x0000F0, "Member 'UVoxelToolSharedConfig::FixedDeltaTime' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, PlaneMesh) == 0x0000F8, "Member 'UVoxelToolSharedConfig::PlaneMesh' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, PlaneMaterial) == 0x000100, "Member 'UVoxelToolSharedConfig::PlaneMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelToolSharedConfig, OnBoundsUpdated) == 0x000108, "Member 'UVoxelToolSharedConfig::OnBoundsUpdated' has a wrong offset!");

// Class Voxel.VoxelToolLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelToolLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void UpdateSphereOverlayMaterial(class UVoxelToolBase* Tool, class UMaterialInstanceDynamic* OverlayMaterialInstance, EVoxelFalloff FalloffType, float Falloff);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelToolLibrary">();
	}
	static class UVoxelToolLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelToolLibrary>();
	}
};
static_assert(alignof(UVoxelToolLibrary) == 0x000008, "Wrong alignment on UVoxelToolLibrary");
static_assert(sizeof(UVoxelToolLibrary) == 0x000028, "Wrong size on UVoxelToolLibrary");

// Class Voxel.VoxelToolManager
// 0x0020 (0x0048 - 0x0028)
class UVoxelToolManager final : public UObject
{
public:
	class UVoxelToolSharedConfig*                 SharedConfig;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoxelTool*                             ActiveTool;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UVoxelTool*>                     Tools;                                             // 0x0038(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void CreateDefaultTools(bool bLoadBlueprints);
	void SetActiveTool(class UVoxelTool* NewActiveTool);
	void SetActiveToolByClass(TSubclassOf<class UVoxelTool> NewActiveTool);
	void SetActiveToolByName(class FName NewActiveTool);

	class UVoxelTool* GetActiveTool() const;
	const TArray<class UVoxelTool*> GetTools() const;
	class UVoxelToolSharedConfig* K2_GetSharedConfig() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelToolManager">();
	}
	static class UVoxelToolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelToolManager>();
	}
};
static_assert(alignof(UVoxelToolManager) == 0x000008, "Wrong alignment on UVoxelToolManager");
static_assert(sizeof(UVoxelToolManager) == 0x000048, "Wrong size on UVoxelToolManager");
static_assert(offsetof(UVoxelToolManager, SharedConfig) == 0x000028, "Member 'UVoxelToolManager::SharedConfig' has a wrong offset!");
static_assert(offsetof(UVoxelToolManager, ActiveTool) == 0x000030, "Member 'UVoxelToolManager::ActiveTool' has a wrong offset!");
static_assert(offsetof(UVoxelToolManager, Tools) == 0x000038, "Member 'UVoxelToolManager::Tools' has a wrong offset!");

// Class Voxel.VoxelToolRenderingSubsystemProxy
// 0x0000 (0x0028 - 0x0028)
class UVoxelToolRenderingSubsystemProxy final : public UVoxelStaticSubsystemProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelToolRenderingSubsystemProxy">();
	}
	static class UVoxelToolRenderingSubsystemProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelToolRenderingSubsystemProxy>();
	}
};
static_assert(alignof(UVoxelToolRenderingSubsystemProxy) == 0x000008, "Wrong alignment on UVoxelToolRenderingSubsystemProxy");
static_assert(sizeof(UVoxelToolRenderingSubsystemProxy) == 0x000028, "Wrong size on UVoxelToolRenderingSubsystemProxy");

// Class Voxel.VoxelTrimTool
// 0x0020 (0x0570 - 0x0550)
class UVoxelTrimTool final : public UVoxelToolBase
{
public:
	class UMaterialInterface*                     ToolMaterial;                                      // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roughness;                                         // 0x0554(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_558[0x18];                                     // 0x0558(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelTrimTool">();
	}
	static class UVoxelTrimTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelTrimTool>();
	}
};
static_assert(alignof(UVoxelTrimTool) == 0x000010, "Wrong alignment on UVoxelTrimTool");
static_assert(sizeof(UVoxelTrimTool) == 0x000570, "Wrong size on UVoxelTrimTool");
static_assert(offsetof(UVoxelTrimTool, ToolMaterial) == 0x000548, "Member 'UVoxelTrimTool::ToolMaterial' has a wrong offset!");
static_assert(offsetof(UVoxelTrimTool, Falloff) == 0x000550, "Member 'UVoxelTrimTool::Falloff' has a wrong offset!");
static_assert(offsetof(UVoxelTrimTool, Roughness) == 0x000554, "Member 'UVoxelTrimTool::Roughness' has a wrong offset!");

// Class Voxel.VoxelWorldRootComponent
// 0x0070 (0x04C0 - 0x0450)
class UVoxelWorldRootComponent final : public UPrimitiveComponent
{
public:
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0458(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x60];                                     // 0x0460(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelWorldRootComponent">();
	}
	static class UVoxelWorldRootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelWorldRootComponent>();
	}
};
static_assert(alignof(UVoxelWorldRootComponent) == 0x000010, "Wrong alignment on UVoxelWorldRootComponent");
static_assert(sizeof(UVoxelWorldRootComponent) == 0x0004C0, "Wrong size on UVoxelWorldRootComponent");
static_assert(offsetof(UVoxelWorldRootComponent, BodySetup) == 0x000458, "Member 'UVoxelWorldRootComponent::BodySetup' has a wrong offset!");

}

