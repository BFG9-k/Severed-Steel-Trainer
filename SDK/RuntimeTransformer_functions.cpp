#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: RuntimeTransformer

#include "Basic.hpp"

#include "RuntimeTransformer_classes.hpp"
#include "RuntimeTransformer_parameters.hpp"


namespace SDK
{

// Function RuntimeTransformer.BaseGizmo.RegisterDomainComponent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETransformationDomain                   Domain                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseGizmo::RegisterDomainComponent(class USceneComponent* Component, ETransformationDomain Domain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGizmo", "RegisterDomainComponent");

	Params::BaseGizmo_RegisterDomainComponent Parms{};

	Parms.Component = Component;
	Parms.Domain = Domain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.BaseGizmo.SetTransformProgressState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETransformationDomain                   CurrentDomain                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseGizmo::SetTransformProgressState(bool bInProgress, ETransformationDomain CurrentDomain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGizmo", "SetTransformProgressState");

	Params::BaseGizmo_SetTransformProgressState Parms{};

	Parms.bInProgress = bInProgress;
	Parms.CurrentDomain = CurrentDomain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.BaseGizmo.GetTransformationDomain
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ComponentHit                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETransformationDomain                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETransformationDomain ABaseGizmo::GetTransformationDomain(class USceneComponent* ComponentHit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGizmo", "GetTransformationDomain");

	Params::BaseGizmo_GetTransformationDomain Parms{};

	Parms.ComponentHit = ComponentHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.BaseGizmo.GetTransformProgressState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseGizmo::GetTransformProgressState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseGizmo", "GetTransformProgressState");

	Params::BaseGizmo_GetTransformProgressState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.FocusableObject.Focus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATransformerPawn*                 Caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bComponentBased                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFocusableObject::Focus(class ATransformerPawn* Caller, class USceneComponent* Component, bool bComponentBased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FocusableObject", "Focus");

	Params::FocusableObject_Focus Parms{};

	Parms.Caller = Caller;
	Parms.Component = Component;
	Parms.bComponentBased = bComponentBased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.FocusableObject.OnNewTransformation
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATransformerPawn*                 Caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       NewTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bComponentBased                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFocusableObject::OnNewTransformation(class ATransformerPawn* Caller, class USceneComponent* Component, const struct FTransform& NewTransform, bool bComponentBased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FocusableObject", "OnNewTransformation");

	Params::FocusableObject_OnNewTransformation Parms{};

	Parms.Caller = Caller;
	Parms.Component = Component;
	Parms.NewTransform = std::move(NewTransform);
	Parms.bComponentBased = bComponentBased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.FocusableObject.Unfocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATransformerPawn*                 Caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bComponentBased                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFocusableObject::Unfocus(class ATransformerPawn* Caller, class USceneComponent* Component, bool bComponentBased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FocusableObject", "Unfocus");

	Params::FocusableObject_Unfocus Parms{};

	Parms.Caller = Caller;
	Parms.Component = Component;
	Parms.bComponentBased = bComponentBased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ApplyDeltaTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       DeltaTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATransformerPawn::ApplyDeltaTransform(const struct FTransform& DeltaTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ApplyDeltaTransform");

	Params::TransformerPawn_ApplyDeltaTransform Parms{};

	Parms.DeltaTransform = std::move(DeltaTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ClearDomain
// (Final, Native, Public, BlueprintCallable)

void ATransformerPawn::ClearDomain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ClearDomain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.CloneSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSelectNewClones                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::CloneSelected(bool bSelectNewClones, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "CloneSelected");

	Params::TransformerPawn_CloneSelected Parms{};

	Parms.bSelectNewClones = bSelectNewClones;
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.DeselectActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::DeselectActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "DeselectActor");

	Params::TransformerPawn_DeselectActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.DeselectAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDestroyDeselected                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class USceneComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class USceneComponent*> ATransformerPawn::DeselectAll(bool bDestroyDeselected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "DeselectAll");

	Params::TransformerPawn_DeselectAll Parms{};

	Parms.bDestroyDeselected = bDestroyDeselected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.DeselectComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::DeselectComponent(class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "DeselectComponent");

	Params::TransformerPawn_DeselectComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.HandleTracedObjects
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FHitResult>               HitResults                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransformerPawn::HandleTracedObjects(const TArray<struct FHitResult>& HitResults, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "HandleTracedObjects");

	Params::TransformerPawn_HandleTracedObjects Parms{};

	Parms.HitResults = std::move(HitResults);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.LogSelectedComponents
// (Final, Native, Public, BlueprintCallable)

void ATransformerPawn::LogSelectedComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "LogSelectedComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MouseTraceByChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoredActors                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransformerPawn::MouseTraceByChannel(float TraceDistance, ECollisionChannel TraceChannel, const TArray<class AActor*>& IgnoredActors, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MouseTraceByChannel");

	Params::TransformerPawn_MouseTraceByChannel Parms{};

	Parms.TraceDistance = TraceDistance;
	Parms.TraceChannel = TraceChannel;
	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.MouseTraceByObjectTypes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ECollisionChannel>               CollisionChannels                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoredActors                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransformerPawn::MouseTraceByObjectTypes(float TraceDistance, const TArray<ECollisionChannel>& CollisionChannels, const TArray<class AActor*>& IgnoredActors, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MouseTraceByObjectTypes");

	Params::TransformerPawn_MouseTraceByObjectTypes Parms{};

	Parms.TraceDistance = TraceDistance;
	Parms.CollisionChannels = std::move(CollisionChannels);
	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.MouseTraceByProfile
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoredActors                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransformerPawn::MouseTraceByProfile(float TraceDistance, const class FName& ProfileName, const TArray<class AActor*>& IgnoredActors, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MouseTraceByProfile");

	Params::TransformerPawn_MouseTraceByProfile Parms{};

	Parms.TraceDistance = TraceDistance;
	Parms.ProfileName = ProfileName;
	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.MulticastApplyTransform
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FTransform                       DeltaTransform                                         (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATransformerPawn::MulticastApplyTransform(const struct FTransform& DeltaTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastApplyTransform");

	Params::TransformerPawn_MulticastApplyTransform Parms{};

	Parms.DeltaTransform = std::move(DeltaTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MulticastClearDomain
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ATransformerPawn::MulticastClearDomain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastClearDomain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MulticastDeselectAll
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bDestroySelected                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::MulticastDeselectAll(bool bDestroySelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastDeselectAll");

	Params::TransformerPawn_MulticastDeselectAll Parms{};

	Parms.bDestroySelected = bDestroySelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MulticastSetComponentBased
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bIsComponentBased                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::MulticastSetComponentBased(bool bIsComponentBased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastSetComponentBased");

	Params::TransformerPawn_MulticastSetComponentBased Parms{};

	Parms.bIsComponentBased = bIsComponentBased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MulticastSetDomain
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ETransformationDomain                   Domain                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::MulticastSetDomain(ETransformationDomain Domain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastSetDomain");

	Params::TransformerPawn_MulticastSetDomain Parms{};

	Parms.Domain = Domain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MulticastSetRotateOnLocalAxis
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bRotateLocalAxis                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::MulticastSetRotateOnLocalAxis(bool bRotateLocalAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastSetRotateOnLocalAxis");

	Params::TransformerPawn_MulticastSetRotateOnLocalAxis Parms{};

	Parms.bRotateLocalAxis = bRotateLocalAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MulticastSetSelectedComponents
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// TArray<class USceneComponent*>          Components                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATransformerPawn::MulticastSetSelectedComponents(const TArray<class USceneComponent*>& Components)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastSetSelectedComponents");

	Params::TransformerPawn_MulticastSetSelectedComponents Parms{};

	Parms.Components = std::move(Components);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MulticastSetSpaceType
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ESpaceType                              Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::MulticastSetSpaceType(ESpaceType Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastSetSpaceType");

	Params::TransformerPawn_MulticastSetSpaceType Parms{};

	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.MulticastSetTransformationType
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ETransformationType                     Transformation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::MulticastSetTransformationType(ETransformationType Transformation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "MulticastSetTransformationType");

	Params::TransformerPawn_MulticastSetTransformationType Parms{};

	Parms.Transformation = Transformation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.OnComponentSelectionChange
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSelected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImplementsUFocusable                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::OnComponentSelectionChange(class USceneComponent* Component, bool bSelected, bool bImplementsUFocusable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "OnComponentSelectionChange");

	Params::TransformerPawn_OnComponentSelectionChange Parms{};

	Parms.Component = Component;
	Parms.bSelected = bSelected;
	Parms.bImplementsUFocusable = bImplementsUFocusable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.OnGizmoStateChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ETransformationType                     GizmoType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTransformInProgress                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETransformationDomain                   Domain                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::OnGizmoStateChanged(ETransformationType GizmoType, bool bTransformInProgress, ETransformationDomain Domain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "OnGizmoStateChanged");

	Params::TransformerPawn_OnGizmoStateChanged Parms{};

	Parms.GizmoType = GizmoType;
	Parms.bTransformInProgress = bTransformInProgress;
	Parms.Domain = Domain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ReplicatedMouseTraceByChannel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       CollisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ReplicatedMouseTraceByChannel(float TraceDistance, ECollisionChannel CollisionChannel, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ReplicatedMouseTraceByChannel");

	Params::TransformerPawn_ReplicatedMouseTraceByChannel Parms{};

	Parms.TraceDistance = TraceDistance;
	Parms.CollisionChannel = CollisionChannel;
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ReplicatedMouseTraceByObjectTypes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ECollisionChannel>               CollisionChannels                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ReplicatedMouseTraceByObjectTypes(float TraceDistance, const TArray<ECollisionChannel>& CollisionChannels, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ReplicatedMouseTraceByObjectTypes");

	Params::TransformerPawn_ReplicatedMouseTraceByObjectTypes Parms{};

	Parms.TraceDistance = TraceDistance;
	Parms.CollisionChannels = std::move(CollisionChannels);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ReplicatedMouseTraceByProfile
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   TraceDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ReplicatedMouseTraceByProfile(float TraceDistance, const class FName& ProfileName, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ReplicatedMouseTraceByProfile");

	Params::TransformerPawn_ReplicatedMouseTraceByProfile Parms{};

	Parms.TraceDistance = TraceDistance;
	Parms.ProfileName = ProfileName;
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ReplicateFinishTransform
// (Final, Native, Public, BlueprintCallable)

void ATransformerPawn::ReplicateFinishTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ReplicateFinishTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SelectActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SelectActor(class AActor* Actor, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SelectActor");

	Params::TransformerPawn_SelectActor Parms{};

	Parms.Actor = Actor;
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SelectComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SelectComponent(class USceneComponent* Component, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SelectComponent");

	Params::TransformerPawn_SelectComponent Parms{};

	Parms.Component = Component;
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SelectMultipleActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SelectMultipleActors(const TArray<class AActor*>& Actors, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SelectMultipleActors");

	Params::TransformerPawn_SelectMultipleActors Parms{};

	Parms.Actors = std::move(Actors);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SelectMultipleComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USceneComponent*>          Components                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SelectMultipleComponents(const TArray<class USceneComponent*>& Components, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SelectMultipleComponents");

	Params::TransformerPawn_SelectMultipleComponents Parms{};

	Parms.Components = std::move(Components);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerApplyTransform
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// struct FTransform                       DeltaTransform                                         (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerApplyTransform(const struct FTransform& DeltaTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerApplyTransform");

	Params::TransformerPawn_ServerApplyTransform Parms{};

	Parms.DeltaTransform = std::move(DeltaTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerClearDomain
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void ATransformerPawn::ServerClearDomain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerClearDomain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerCloneSelected
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bSelectNewClones                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerCloneSelected(bool bSelectNewClones, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerCloneSelected");

	Params::TransformerPawn_ServerCloneSelected Parms{};

	Parms.bSelectNewClones = bSelectNewClones;
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerDeselectAll
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bDestroySelected                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerDeselectAll(bool bDestroySelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerDeselectAll");

	Params::TransformerPawn_ServerDeselectAll Parms{};

	Parms.bDestroySelected = bDestroySelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerSetComponentBased
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bIsComponentBased                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerSetComponentBased(bool bIsComponentBased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerSetComponentBased");

	Params::TransformerPawn_ServerSetComponentBased Parms{};

	Parms.bIsComponentBased = bIsComponentBased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerSetDomain
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// ETransformationDomain                   Domain                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerSetDomain(ETransformationDomain Domain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerSetDomain");

	Params::TransformerPawn_ServerSetDomain Parms{};

	Parms.Domain = Domain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerSetRotateOnLocalAxis
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bRotateLocalAxis                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerSetRotateOnLocalAxis(bool bRotateLocalAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerSetRotateOnLocalAxis");

	Params::TransformerPawn_ServerSetRotateOnLocalAxis Parms{};

	Parms.bRotateLocalAxis = bRotateLocalAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerSetSpaceType
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// ESpaceType                              Space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerSetSpaceType(ESpaceType Space)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerSetSpaceType");

	Params::TransformerPawn_ServerSetSpaceType Parms{};

	Parms.Space = Space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerSetTransformationType
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// ETransformationType                     Transformation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerSetTransformationType(ETransformationType Transformation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerSetTransformationType");

	Params::TransformerPawn_ServerSetTransformationType Parms{};

	Parms.Transformation = Transformation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerSyncSelectedComponents
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void ATransformerPawn::ServerSyncSelectedComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerSyncSelectedComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerTraceByChannel
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// struct FVector                          StartLocation                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerTraceByChannel(const struct FVector& StartLocation, const struct FVector& EndLocation, ECollisionChannel TraceChannel, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerTraceByChannel");

	Params::TransformerPawn_ServerTraceByChannel Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.TraceChannel = TraceChannel;
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerTraceByObjectTypes
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// struct FVector                          StartLocation                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ECollisionChannel>               CollisionChannels                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerTraceByObjectTypes(const struct FVector& StartLocation, const struct FVector& EndLocation, const TArray<ECollisionChannel>& CollisionChannels, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerTraceByObjectTypes");

	Params::TransformerPawn_ServerTraceByObjectTypes Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.CollisionChannels = std::move(CollisionChannels);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ServerTraceByProfile
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// struct FVector                          StartLocation                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::ServerTraceByProfile(const struct FVector& StartLocation, const struct FVector& EndLocation, const class FName& ProfileName, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ServerTraceByProfile");

	Params::TransformerPawn_ServerTraceByProfile Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.ProfileName = ProfileName;
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SetComponentBased
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsComponentBased                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SetComponentBased(bool bIsComponentBased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SetComponentBased");

	Params::TransformerPawn_SetComponentBased Parms{};

	Parms.bIsComponentBased = bIsComponentBased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SetRotateOnLocalAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRotateLocalAxis                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SetRotateOnLocalAxis(bool bRotateLocalAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SetRotateOnLocalAxis");

	Params::TransformerPawn_SetRotateOnLocalAxis Parms{};

	Parms.bRotateLocalAxis = bRotateLocalAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SetSnappingEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETransformationType                     TransformationType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSnappingEnabled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SetSnappingEnabled(ETransformationType TransformationType, bool bSnappingEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SetSnappingEnabled");

	Params::TransformerPawn_SetSnappingEnabled Parms{};

	Parms.TransformationType = TransformationType;
	Parms.bSnappingEnabled = bSnappingEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SetSnappingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETransformationType                     TransformationType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SnappingValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SetSnappingValue(ETransformationType TransformationType, float SnappingValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SetSnappingValue");

	Params::TransformerPawn_SetSnappingValue Parms{};

	Parms.TransformationType = TransformationType;
	Parms.SnappingValue = SnappingValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SetSpaceType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESpaceType                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SetSpaceType(ESpaceType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SetSpaceType");

	Params::TransformerPawn_SetSpaceType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.SetTransformationType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETransformationType                     TransformationType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::SetTransformationType(ETransformationType TransformationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "SetTransformationType");

	Params::TransformerPawn_SetTransformationType Parms{};

	Parms.TransformationType = TransformationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function RuntimeTransformer.TransformerPawn.ShouldSelect
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           OwnerActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransformerPawn::ShouldSelect(class AActor* OwnerActor, class USceneComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "ShouldSelect");

	Params::TransformerPawn_ShouldSelect Parms{};

	Parms.OwnerActor = OwnerActor;
	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.TraceByChannel
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoredActors                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransformerPawn::TraceByChannel(const struct FVector& StartLocation, const struct FVector& EndLocation, ECollisionChannel TraceChannel, const TArray<class AActor*>& IgnoredActors, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "TraceByChannel");

	Params::TransformerPawn_TraceByChannel Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.TraceChannel = TraceChannel;
	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.TraceByObjectTypes
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ECollisionChannel>               CollisionChannels                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoredActors                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransformerPawn::TraceByObjectTypes(const struct FVector& StartLocation, const struct FVector& EndLocation, const TArray<ECollisionChannel>& CollisionChannels, const TArray<class AActor*>& IgnoredActors, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "TraceByObjectTypes");

	Params::TransformerPawn_TraceByObjectTypes Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.CollisionChannels = std::move(CollisionChannels);
	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.TraceByProfile
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          StartLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoredActors                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bAppendToList                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransformerPawn::TraceByProfile(const struct FVector& StartLocation, const struct FVector& EndLocation, const class FName& ProfileName, const TArray<class AActor*>& IgnoredActors, bool bAppendToList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "TraceByProfile");

	Params::TransformerPawn_TraceByProfile Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.ProfileName = ProfileName;
	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.bAppendToList = bAppendToList;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.UpdateTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          LookingVector                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RayOrigin                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RayDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ATransformerPawn::UpdateTransform(const struct FVector& LookingVector, const struct FVector& RayOrigin, const struct FVector& RayDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "UpdateTransform");

	Params::TransformerPawn_UpdateTransform Parms{};

	Parms.LookingVector = std::move(LookingVector);
	Parms.RayOrigin = std::move(RayOrigin);
	Parms.RayDirection = std::move(RayDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.GetCurrentDomain
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    TransformInProgress                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETransformationDomain                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETransformationDomain ATransformerPawn::GetCurrentDomain(bool* TransformInProgress) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "GetCurrentDomain");

	Params::TransformerPawn_GetCurrentDomain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TransformInProgress != nullptr)
		*TransformInProgress = Parms.TransformInProgress;

	return Parms.ReturnValue;
}


// Function RuntimeTransformer.TransformerPawn.GetSelectedComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class USceneComponent*>          outComponentList                                       (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class USceneComponent*                  outGizmoPlacedComponent                                (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransformerPawn::GetSelectedComponents(TArray<class USceneComponent*>* outComponentList, class USceneComponent** outGizmoPlacedComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransformerPawn", "GetSelectedComponents");

	Params::TransformerPawn_GetSelectedComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outComponentList != nullptr)
		*outComponentList = std::move(Parms.outComponentList);

	if (outGizmoPlacedComponent != nullptr)
		*outGizmoPlacedComponent = Parms.outGizmoPlacedComponent;
}

}

