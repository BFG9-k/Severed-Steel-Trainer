#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VoxelHelpers

#include "Basic.hpp"

#include "VoxelHelpers_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class VoxelHelpers.MaterialExpressionBlendMaterialAttributesBarycentric
// 0x0070 (0x00B0 - 0x0040)
class UMaterialExpressionBlendMaterialAttributesBarycentric final : public UMaterialExpression
{
public:
	struct FMaterialAttributesInput               A;                                                 // 0x0040(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FMaterialAttributesInput               B;                                                 // 0x0058(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FMaterialAttributesInput               C;                                                 // 0x0070(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       AlphaA;                                            // 0x0088(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	struct FExpressionInput                       AlphaB;                                            // 0x009C(0x0014)(NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBlendMaterialAttributesBarycentric">();
	}
	static class UMaterialExpressionBlendMaterialAttributesBarycentric* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBlendMaterialAttributesBarycentric>();
	}
};
static_assert(alignof(UMaterialExpressionBlendMaterialAttributesBarycentric) == 0x000008, "Wrong alignment on UMaterialExpressionBlendMaterialAttributesBarycentric");
static_assert(sizeof(UMaterialExpressionBlendMaterialAttributesBarycentric) == 0x0000B0, "Wrong size on UMaterialExpressionBlendMaterialAttributesBarycentric");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributesBarycentric, A) == 0x000040, "Member 'UMaterialExpressionBlendMaterialAttributesBarycentric::A' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributesBarycentric, B) == 0x000058, "Member 'UMaterialExpressionBlendMaterialAttributesBarycentric::B' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributesBarycentric, C) == 0x000070, "Member 'UMaterialExpressionBlendMaterialAttributesBarycentric::C' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributesBarycentric, AlphaA) == 0x000088, "Member 'UMaterialExpressionBlendMaterialAttributesBarycentric::AlphaA' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionBlendMaterialAttributesBarycentric, AlphaB) == 0x00009C, "Member 'UMaterialExpressionBlendMaterialAttributesBarycentric::AlphaB' has a wrong offset!");

// Class VoxelHelpers.MaterialExpressionPack
// 0x0028 (0x0068 - 0x0040)
class UMaterialExpressionPack final : public UMaterialExpression
{
public:
	TArray<struct FMaterialPackInput>             Inputs;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionPack">();
	}
	static class UMaterialExpressionPack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionPack>();
	}
};
static_assert(alignof(UMaterialExpressionPack) == 0x000008, "Wrong alignment on UMaterialExpressionPack");
static_assert(sizeof(UMaterialExpressionPack) == 0x000068, "Wrong size on UMaterialExpressionPack");
static_assert(offsetof(UMaterialExpressionPack, Inputs) == 0x000040, "Member 'UMaterialExpressionPack::Inputs' has a wrong offset!");

// Class VoxelHelpers.MaterialExpressionUnpack
// 0x0018 (0x0058 - 0x0040)
class UMaterialExpressionUnpack final : public UMaterialExpression
{
public:
	struct FExpressionInput                       Input;                                             // 0x0040(0x0014)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bRefresh;                                          // 0x0054(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionUnpack">();
	}
	static class UMaterialExpressionUnpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionUnpack>();
	}
};
static_assert(alignof(UMaterialExpressionUnpack) == 0x000008, "Wrong alignment on UMaterialExpressionUnpack");
static_assert(sizeof(UMaterialExpressionUnpack) == 0x000058, "Wrong size on UMaterialExpressionUnpack");
static_assert(offsetof(UMaterialExpressionUnpack, Input) == 0x000040, "Member 'UMaterialExpressionUnpack::Input' has a wrong offset!");
static_assert(offsetof(UMaterialExpressionUnpack, bRefresh) == 0x000054, "Member 'UMaterialExpressionUnpack::bRefresh' has a wrong offset!");

// Class VoxelHelpers.VoxelColorWheel
// 0x0030 (0x0138 - 0x0108)
class UVoxelColorWheel final : public UWidget
{
public:
	struct FLinearColor                           Color;                                             // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FLinearColor& NewColor)> OnColorChanged;                                    // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelColorWheel">();
	}
	static class UVoxelColorWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelColorWheel>();
	}
};
static_assert(alignof(UVoxelColorWheel) == 0x000008, "Wrong alignment on UVoxelColorWheel");
static_assert(sizeof(UVoxelColorWheel) == 0x000138, "Wrong size on UVoxelColorWheel");
static_assert(offsetof(UVoxelColorWheel, Color) == 0x000108, "Member 'UVoxelColorWheel::Color' has a wrong offset!");
static_assert(offsetof(UVoxelColorWheel, OnColorChanged) == 0x000118, "Member 'UVoxelColorWheel::OnColorChanged' has a wrong offset!");

// Class VoxelHelpers.VoxelHelpersLibrary
// 0x0000 (0x0028 - 0x0028)
class UVoxelHelpersLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CreateProcMeshPlane(class UProceduralMeshComponent* Mesh, int32 SizeX, int32 SizeY, float Step);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelHelpersLibrary">();
	}
	static class UVoxelHelpersLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelHelpersLibrary>();
	}
};
static_assert(alignof(UVoxelHelpersLibrary) == 0x000008, "Wrong alignment on UVoxelHelpersLibrary");
static_assert(sizeof(UVoxelHelpersLibrary) == 0x000028, "Wrong size on UVoxelHelpersLibrary");

}

