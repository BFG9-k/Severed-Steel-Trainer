#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ThankYouVeryCool

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Voxel_structs.hpp"


namespace SDK
{

// Enum ThankYouVeryCool.EEditMode
// NumValues: 0x000D
enum class EEditMode : uint8
{
	E_Select                                 = 0,
	E_VoxelBox                               = 1,
	E_VoxelFace                              = 2,
	E_VoxelSingle                            = 3,
	E_ColorPicker                            = 4,
	E_ColorFill                              = 5,
	E_RectangleSelect                        = 6,
	E_Circle                                 = 7,
	E_Ramp                                   = 8,
	E_Steam                                  = 9,
	E_Line                                   = 10,
	E_Stairs                                 = 11,
	E_MAX                                    = 12,
};

// Enum ThankYouVeryCool.EPlayerInteractionType
// NumValues: 0x0003
enum class EPlayerInteractionType : uint8
{
	E_CanBlockPlayer                         = 0,
	E_NoBlockingPlayer                       = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EActionType
// NumValues: 0x0044
enum class EActionType : uint8
{
	Hide                                     = 0,
	Spawn                                    = 1,
	Explode                                  = 2,
	Unlock                                   = 3,
	Stop                                     = 4,
	Start                                    = 5,
	Show                                     = 6,
	TurnRed                                  = 7,
	PlaySound                                = 8,
	FlatLight                                = 9,
	LoungeLight                              = 10,
	MakeInvuln                               = 11,
	RemoveInvuln                             = 12,
	DoWaveOf5                                = 13,
	DoWaveOf10                               = 14,
	DoWaveOf15                               = 15,
	DoWaveOf20                               = 16,
	DoWaveOf25                               = 17,
	DoWaveOf30                               = 18,
	DoWaveOf35                               = 19,
	DoWaveOf40                               = 20,
	DisableAI                                = 21,
	EnableAI                                 = 22,
	ShowHealth                               = 23,
	HideHealth                               = 24,
	UnlimitedCannon                          = 25,
	ScreenShakeShort                         = 26,
	ScreenShakeLong                          = 27,
	RumbleSound                              = 28,
	DropPitch                                = 29,
	RaisePitch                               = 30,
	KillLights                               = 31,
	StopMusic                                = 32,
	PlayMusic                                = 33,
	RestoreLights                            = 34,
	PlayPrison                               = 35,
	PlaySolarpunk                            = 36,
	PlayHotline                              = 37,
	PlayImpact                               = 38,
	PlayJunkie                               = 39,
	KillAllNPCs                              = 40,
	PlayKeepIt                               = 41,
	PlayRunningOutOfGas                      = 42,
	DisableCannon                            = 43,
	PulseCannon                              = 44,
	MetaCannon                               = 45,
	GravityCannon                            = 46,
	ImpactCannon                             = 47,
	OCCannon                                 = 48,
	CustomRed                                = 49,
	CustomWhite                              = 50,
	CustomIndigo                             = 51,
	CustomOrange                             = 52,
	CustomBrightRed                          = 53,
	Activate                                 = 54,
	Deactivate                               = 55,
	CustomWhite2                             = 56,
	CustomIndigo2                            = 57,
	CustomOrange2                            = 58,
	CustomBrightRed2                         = 59,
	CustomRed2                               = 60,
	PlayAbandonedChurch                      = 61,
	PlayThankYouVeryCool                     = 62,
	PlaySonata                               = 63,
	PlayGiants                               = 64,
	PlayCur                                  = 65,
	PlayBlowback                             = 66,
	EActionType_MAX                          = 67,
};

// Enum ThankYouVeryCool.EPropMoveStyle
// NumValues: 0x0005
enum class EPropMoveStyle : uint8
{
	RotateLoop                               = 0,
	SlideOnce                                = 1,
	SlideLoop                                = 2,
	SlideLoopTeleport                        = 3,
	EPropMoveStyle_MAX                       = 4,
};

// Enum ThankYouVeryCool.EVoxelPhysicsType
// NumValues: 0x0005
enum class EVoxelPhysicsType : uint8
{
	E_NoPhysics                              = 0,
	E_NoPhysicsUntilHit                      = 1,
	E_StartWithPhysics                       = 2,
	E_GravGunOnly                            = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EImpactType
// NumValues: 0x001D
enum class EImpactType : uint8
{
	E_LightRound                             = 0,
	E_MediumRound                            = 1,
	E_HeavyRound                             = 2,
	E_Melee                                  = 3,
	E_SniperLaser                            = 4,
	E_NarrowPulseBeam                        = 5,
	E_WidePulseBeam                          = 6,
	E_Thrown                                 = 7,
	E_Dive                                   = 8,
	E_Walking                                = 9,
	E_Kick                                   = 10,
	E_Ragdoll                                = 11,
	E_Minigun                                = 12,
	E_Door                                   = 13,
	E_Flame                                  = 14,
	E_KickSlide                              = 15,
	E_Overcharge                             = 16,
	E_Shockwave                              = 17,
	E_HeavyExplosive                         = 18,
	E_SuperKick                              = 19,
	E_CannnonShockwave                       = 20,
	E_LightExplosive                         = 21,
	E_Mech                                   = 22,
	E_NPCShockwave                           = 23,
	E_GravThrow                              = 24,
	E_ImpactDriver                           = 25,
	E_NarrowPulseProjectile                  = 26,
	E_Prop                                   = 27,
	E_MAX                                    = 28,
};

// Enum ThankYouVeryCool.ELeanState
// NumValues: 0x0004
enum class ELeanState : uint8
{
	E_None                                   = 0,
	E_Left                                   = 1,
	E_Right                                  = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EWeaponPosition
// NumValues: 0x0004
enum class EWeaponPosition : uint8
{
	E_Down                                   = 0,
	E_HipAim                                 = 1,
	E_ShoulderedAim                          = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ECoverState
// NumValues: 0x0008
enum class ECoverState : uint8
{
	E_None                                   = 0,
	E_Entering                               = 1,
	E_In                                     = 2,
	E_TransitionToPop                        = 3,
	E_Popped                                 = 4,
	E_LeavingPop                             = 5,
	E_Leaving                                = 6,
	E_MAX                                    = 7,
};

// Enum ThankYouVeryCool.EBoneGroup
// NumValues: 0x0008
enum class EBoneGroup : uint8
{
	E_Head                                   = 0,
	E_Torso                                  = 1,
	E_RightArm                               = 2,
	E_LeftArm                                = 3,
	E_LeftLeg                                = 4,
	E_RightLeg                               = 5,
	E_Unknown                                = 6,
	E_MAX                                    = 7,
};

// Enum ThankYouVeryCool.ETutorialType
// NumValues: 0x0005
enum class ETutorialType : uint8
{
	E_None                                   = 0,
	E_Steal                                  = 1,
	E_Disarm                                 = 2,
	E_Luck                                   = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.ENPCType
// NumValues: 0x000D
enum class ENPCType : uint8
{
	E_Standard                               = 0,
	E_Sniper                                 = 1,
	E_Heavy                                  = 2,
	E_Shield                                 = 3,
	E_Jumper                                 = 4,
	E_Jetpack                                = 5,
	E_Rocket                                 = 6,
	E_Minigun                                = 7,
	E_StandardElite                          = 8,
	E_Zombie                                 = 9,
	E_Specialist                             = 10,
	E_SuperHeavy                             = 11,
	E_MAX                                    = 12,
};

// Enum ThankYouVeryCool.ETYVCLeaderboardType
// NumValues: 0x0003
enum class ETYVCLeaderboardType : uint8
{
	Score                                    = 0,
	Time                                     = 1,
	ETYVCLeaderboardType_MAX                 = 2,
};

// Enum ThankYouVeryCool.ELeaderboardResult
// NumValues: 0x0006
enum class ELeaderboardResult : uint8
{
	Success                                  = 0,
	Failure                                  = 1,
	FailureNoNetworkConnection               = 2,
	FailureNotAuthorized                     = 3,
	FailureLoginFailed                       = 4,
	ELeaderboardResult_MAX                   = 5,
};

// Enum ThankYouVeryCool.EOSTMode
// NumValues: 0x0005
enum class EOSTMode : uint8
{
	SevSteel                                 = 0,
	SevSteelCustom                           = 1,
	OnlyMine                                 = 2,
	SevSteelCustomAndMine                    = 3,
	EOSTMode_MAX                             = 4,
};

// Enum ThankYouVeryCool.EAnalogControl
// NumValues: 0x0003
enum class EAnalogControl : uint8
{
	E_Left                                   = 0,
	E_Right                                  = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EHudColor
// NumValues: 0x0006
enum class EHudColor : uint8
{
	E_Orange                                 = 0,
	E_Blue                                   = 1,
	E_Green                                  = 2,
	E_White                                  = 3,
	E_Red                                    = 4,
	E_MAX                                    = 5,
};

// Enum ThankYouVeryCool.EAutoSlowMoSettings
// NumValues: 0x0004
enum class EAutoSlowMoSettings : uint8
{
	E_None                                   = 0,
	E_AllStunts                              = 1,
	E_WallJumpOnly                           = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EConsoleGraphicsMode
// NumValues: 0x0004
enum class EConsoleGraphicsMode : uint8
{
	E_HiRes                                  = 0,
	E_HiDetail                               = 1,
	E_HiFrames                               = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ETYVCAMDFXMode
// NumValues: 0x0006
enum class ETYVCAMDFXMode : uint8
{
	Off                                      = 0,
	Quality                                  = 1,
	Balanced                                 = 2,
	Performance                              = 3,
	UltraPerformance                         = 4,
	ETYVCAMDFXMode_MAX                       = 5,
};

// Enum ThankYouVeryCool.ETYVCDLSSMode
// NumValues: 0x0008
enum class ETYVCDLSSMode : uint8
{
	Off                                      = 0,
	Auto                                     = 1,
	UltraQuality                             = 2,
	Quality                                  = 3,
	Balanced                                 = 4,
	Performance                              = 5,
	UltraPerformance                         = 6,
	ETYVCDLSSMode_MAX                        = 7,
};

// Enum ThankYouVeryCool.EDestructionDetail
// NumValues: 0x0006
enum class EDestructionDetail : uint8
{
	E_Minimum                                = 0,
	E_VeryLow                                = 1,
	E_Low                                    = 2,
	E_Normal                                 = 3,
	E_High                                   = 4,
	E_MAX                                    = 5,
};

// Enum ThankYouVeryCool.ESlowMoVisualType
// NumValues: 0x0004
enum class ESlowMoVisualType : uint8
{
	E_Enabled                                = 0,
	E_Disabled                               = 1,
	E_AlwaysOn                               = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ERank
// NumValues: 0x000A
enum class ERank : uint8
{
	E_None                                   = 0,
	E_E                                      = 1,
	E_D                                      = 2,
	E_C                                      = 3,
	E_B                                      = 4,
	E_A                                      = 5,
	E_S                                      = 6,
	E_SS                                     = 7,
	E_SSS                                    = 8,
	E_MAX                                    = 9,
};

// Enum ThankYouVeryCool.EShineLevel
// NumValues: 0x0006
enum class EShineLevel : uint8
{
	ENone                                    = 0,
	EBronze                                  = 1,
	ESilver                                  = 2,
	EGold                                    = 3,
	ERoseGold                                = 4,
	EShineLevel_MAX                          = 5,
};

// Enum ThankYouVeryCool.EDifficulty
// NumValues: 0x0007
enum class EDifficulty : uint8
{
	E_Casual                                 = 0,
	E_Normal                                 = 1,
	E_Hard                                   = 2,
	E_VeryHard                               = 3,
	E_SharpenedSteel                         = 4,
	E_Impossible                             = 5,
	E_MAX                                    = 6,
};

// Enum ThankYouVeryCool.EGameState
// NumValues: 0x0007
enum class EGameState : uint8
{
	E_LoadingMainMenu                        = 0,
	E_InMainMenu                             = 1,
	E_LoadingDemo                            = 2,
	E_InDemo                                 = 3,
	E_LoadingDebugLevel                      = 4,
	E_ResettingLevel                         = 5,
	E_MAX                                    = 6,
};

// Enum ThankYouVeryCool.EGameModifier
// NumValues: 0x0043
enum class EGameModifier : uint8
{
	E_FloorIsLava                            = 0,
	E_KOsOnly                                = 1,
	E_SeeThroughWalls                        = 2,
	E_BigHeads                               = 3,
	E_MeleeGibsEnemies                       = 4,
	E_EnemiesGibOnDead                       = 5,
	E_Paintball                              = 6,
	E_StuntsCloak                            = 7,
	E_NoSlideFriction                        = 8,
	E_CubicMode                              = 9,
	E_ExplosiveRounds                        = 10,
	E_SuperShaded                            = 11,
	E_UnlimitedAmmo                          = 12,
	E_LimitedSlowMo                          = 13,
	E_LikeWater                              = 14,
	E_TripleThreat                           = 15,
	E_ArmCannonThruster                      = 16,
	E_NinjasOnly                             = 17,
	E_GodMode                                = 18,
	E_LowGrav                                = 19,
	E_NoLights                               = 20,
	E_OneInChamber                           = 21,
	E_SuperKick                              = 22,
	E_ThrownWeaponsExplode                   = 23,
	E_HeadshotsOnly                          = 24,
	E_MissedShotsDrainHealth                 = 25,
	E_AllWeaponsFullAuto                     = 26,
	E_BoostROF                               = 27,
	E_SuperDive                              = 28,
	E_StartingWeaponDoubleMag                = 29,
	E_TripleJump                             = 30,
	E_ExplodingDoor                          = 31,
	E_PerfectAcc                             = 32,
	E_ExplosiveShields                       = 33,
	E_SloMoEvenInStunt                       = 34,
	E_KillRefillMag                          = 35,
	E_DoubleCannon                           = 36,
	E_PassiveCannonRecharge                  = 37,
	E_FasterSteel                            = 38,
	E_SuperKickSlide                         = 39,
	E_SuperHeavies                           = 40,
	E_ExplosiveProps                         = 41,
	E_MeleeRefillsMag                        = 42,
	E_DiveBomber                             = 43,
	E_WallRunBoost                           = 44,
	E_OnlyMeleeRestoreHealth                 = 45,
	E_Cloakers                               = 46,
	E_Backfire                               = 47,
	E_FasterEnemies                          = 48,
	E_JetpackMeleeOnly                       = 49,
	E_FasterSloMo                            = 50,
	E_DrainSlomoInStunt                      = 51,
	E_SlomoDrainFaster                       = 52,
	E_EnemyRandomWep                         = 53,
	E_ChainExplosion                         = 54,
	E_HeadshotExplosion                      = 55,
	E_HoldOnTight                            = 56,
	E_Cowboy                                 = 57,
	E_Cyberpunk                              = 58,
	E_SuperJumpers                           = 59,
	E_NPCMAGS                                = 60,
	E_SuperShields                           = 61,
	E_SlowVelo                               = 62,
	E_SuperSnipers                           = 63,
	E_Halloween                              = 64,
	E_XMas                                   = 65,
	E_MAX                                    = 66,
};

// Enum ThankYouVeryCool.EMutCat
// NumValues: 0x0004
enum class EMutCat : uint8
{
	E_Both                                   = 0,
	E_FFOnly                                 = 1,
	E_CampaignOnly                           = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EUnlockType
// NumValues: 0x0004
enum class EUnlockType : uint8
{
	E_Weapon                                 = 0,
	E_Map                                    = 1,
	E_Mut                                    = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EGameType
// NumValues: 0x0005
enum class EGameType : uint8
{
	E_Hunt                                   = 0,
	E_LevelEdit                              = 1,
	E_Campaign                               = 2,
	E_Rogue                                  = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.ESituationContext
// NumValues: 0x0018
enum class ESituationContext : uint8
{
	E_Calm                                   = 0,
	E_LostPlayer                             = 1,
	E_UnknownNoise                           = 2,
	E_FoundBody                              = 3,
	E_UnderFire                              = 4,
	E_InCombat                               = 5,
	E_PlayerInSight                          = 6,
	E_CoverCompromised                       = 7,
	E_IsShieldUnit                           = 8,
	E_IsHeavy                                = 9,
	E_IsNormalTroop                          = 10,
	E_IsBackpackTroop                        = 11,
	E_IsMinigunTroop                         = 12,
	E_IsRocketTroop                          = 13,
	E_IsJetpackTroop                         = 14,
	E_IsSniper                               = 15,
	E_SquadSeesPlayer                        = 16,
	E_PositionModelValid                     = 17,
	E_PositionModelInvalid                   = 18,
	E_IsZombieTroop                          = 19,
	E_IsJumper                               = 20,
	E_IsBouncer                              = 21,
	E_IsSpecialist                           = 22,
	E_MAX                                    = 23,
};

// Enum ThankYouVeryCool.ECamShakeLevel
// NumValues: 0x0004
enum class ECamShakeLevel : uint8
{
	E_Maximum                                = 0,
	E_ThirdPersonRolls                       = 1,
	E_KeepFirstPersonButNoRolls              = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ECannonMode
// NumValues: 0x000C
enum class ECannonMode : uint8
{
	E_NarrowPulse                            = 0,
	E_WidePulse                              = 1,
	E_Magnet                                 = 2,
	E_Foam                                   = 3,
	E_WideFoam                               = 4,
	E_None                                   = 5,
	E_Punch                                  = 6,
	E_Count                                  = 7,
	E_Overcharge                             = 8,
	E_Default                                = 9,
	E_WidePulseMega                          = 10,
	E_MAX                                    = 11,
};

// Enum ThankYouVeryCool.ECharacter
// NumValues: 0x0004
enum class ECharacter : uint8
{
	E_Edith                                  = 0,
	E_Carl                                   = 1,
	E_Mystery                                = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EIKSocketOwner
// NumValues: 0x0003
enum class EIKSocketOwner : uint8
{
	E_Character                              = 0,
	E_Weapon                                 = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EIKTarget
// NumValues: 0x0003
enum class EIKTarget : uint8
{
	E_LeftHand                               = 0,
	E_RightHand                              = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.ECannonState
// NumValues: 0x0005
enum class ECannonState : uint8
{
	E_Idle                                   = 0,
	E_Charging                               = 1,
	E_Firing                                 = 2,
	E_CoolingDown                            = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EBackpackType
// NumValues: 0x0005
enum class EBackpackType : uint8
{
	E_Plain                                  = 0,
	E_Minigun                                = 1,
	E_Rocket                                 = 2,
	E_Jetpack                                = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EFormationShape
// NumValues: 0x0003
enum class EFormationShape : uint8
{
	E_File                                   = 0,
	E_Line                                   = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EFeedback
// NumValues: 0x0006
enum class EFeedback : uint8
{
	E_Headshot                               = 0,
	E_Knockout                               = 1,
	E_WallRun                                = 2,
	E_Flip                                   = 3,
	E_Thrown                                 = 4,
	E_MAX                                    = 5,
};

// Enum ThankYouVeryCool.EForWorld
// NumValues: 0x0004
enum class EForWorld : uint8
{
	E_Primary                                = 0,
	E_Outer                                  = 1,
	E_Cave                                   = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ETextType
// NumValues: 0x0002
enum class ETextType : uint8
{
	E_Intermission                           = 0,
	E_TutorialText                           = 1,
};

// Enum ThankYouVeryCool.EEditorStartType
// NumValues: 0x0005
enum class EEditorStartType : uint8
{
	E_FromVox                                = 0,
	E_Blank                                  = 1,
	E_Loading                                = 2,
	E_Arcade                                 = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EVoxelToolType
// NumValues: 0x0003
enum class EVoxelToolType : uint8
{
	E_Data                                   = 0,
	E_Sphere                                 = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EMaterialType
// NumValues: 0x000E
enum class EMaterialType : uint8
{
	Concrete                                 = 0,
	Wood                                     = 1,
	Plaster                                  = 2,
	Metal                                    = 3,
	Cloth                                    = 4,
	Plastic                                  = 5,
	Marble                                   = 6,
	Unbreakable                              = 7,
	Electronics                              = 8,
	Default                                  = 9,
	Cardboard                                = 10,
	Rubber                                   = 11,
	Goo                                      = 12,
	EMaterialType_MAX                        = 13,
};

// Enum ThankYouVeryCool.EDamageType
// NumValues: 0x0006
enum class EDamageType : uint8
{
	E_Sphere                                 = 0,
	E_Elipse                                 = 1,
	E_Shear                                  = 2,
	E_Point                                  = 3,
	E_Soft                                   = 4,
	E_MAX                                    = 5,
};

// Enum ThankYouVeryCool.EUploadType
// NumValues: 0x0004
enum class EUploadType : uint8
{
	E_Level                                  = 0,
	E_Campaign                               = 1,
	E_Prop                                   = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ESimState
// NumValues: 0x0004
enum class ESimState : uint8
{
	E_Editing                                = 0,
	E_Simulating                             = 1,
	E_Transitioning                          = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ESelectType
// NumValues: 0x0004
enum class ESelectType : uint8
{
	E_All                                    = 0,
	E_WorldOnly                              = 1,
	E_PropsAndLights                         = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EFaceDirection
// NumValues: 0x0007
enum class EFaceDirection : uint8
{
	E_Up                                     = 0,
	E_Down                                   = 1,
	E_Right                                  = 2,
	E_Left                                   = 3,
	E_Forward                                = 4,
	E_Back                                   = 5,
	E_MAX                                    = 6,
};

// Enum ThankYouVeryCool.EVoxelFindBias
// NumValues: 0x0004
enum class EVoxelFindBias : uint8
{
	E_None                                   = 0,
	E_In                                     = 1,
	E_Out                                    = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EEditType
// NumValues: 0x0004
enum class EEditType : uint8
{
	E_Attach                                 = 0,
	E_Erase                                  = 1,
	E_Paint                                  = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ESelectStage
// NumValues: 0x0004
enum class ESelectStage : uint8
{
	E_None                                   = 0,
	E_Selected                               = 1,
	E_Moving                                 = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ESelectionRotation
// NumValues: 0x0005
enum class ESelectionRotation : uint8
{
	E_0                                      = 0,
	E_90                                     = 1,
	E_180                                    = 2,
	E_270                                    = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.ETransactionType
// NumValues: 0x0005
enum class ETransactionType : uint8
{
	E_Voxel                                  = 0,
	E_SpawnActor                             = 1,
	E_DeleteActor                            = 2,
	E_AlterActor                             = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.ELiftState
// NumValues: 0x0005
enum class ELiftState : uint8
{
	E_AtBottom                               = 0,
	E_AtTop                                  = 1,
	E_GoingUp                                = 2,
	E_GoingDown                              = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EAkimboMode
// NumValues: 0x0004
enum class EAkimboMode : uint8
{
	None                                     = 0,
	Staggered                                = 1,
	Auto                                     = 2,
	EAkimboMode_MAX                          = 3,
};

// Enum ThankYouVeryCool.EGoalType
// NumValues: 0x0005
enum class EGoalType : uint8
{
	Destroy                                  = 0,
	StartOverlap                             = 1,
	EndOverlap                               = 2,
	KillThemAll                              = 3,
	EGoalType_MAX                            = 4,
};

// Enum ThankYouVeryCool.EVoxelEditMod
// NumValues: 0x0007
enum class EVoxelEditMod : uint8
{
	E_Attach                                 = 0,
	E_Erase                                  = 1,
	E_Paint                                  = 2,
	E_Bucket                                 = 3,
	E_Picker                                 = 4,
	E_GeoSelect                              = 5,
	E_MAX                                    = 6,
};

// Enum ThankYouVeryCool.EEditorMainNav
// NumValues: 0x0007
enum class EEditorMainNav : uint8
{
	E_World                                  = 0,
	W_Voxel                                  = 1,
	E_NPC                                    = 2,
	E_Props                                  = 3,
	E_Share                                  = 4,
	E_Obj                                    = 5,
	EEditorMainNav_MAX                       = 6,
};

// Enum ThankYouVeryCool.EFeat
// NumValues: 0x002D
enum class EFeat : uint8
{
	DiveKill                                 = 0,
	WallRunKill                              = 1,
	FlipKill                                 = 2,
	SlideKillWithKick                        = 3,
	SlideKill                                = 4,
	MeleeKill                                = 5,
	MultiDiveKill                            = 6,
	Headshot                                 = 7,
	FlipHeadshot                             = 8,
	RidingKill                               = 9,
	MultiWallRunKill                         = 10,
	MultiRideKill                            = 11,
	ShieldKicked                             = 12,
	DoorKill                                 = 13,
	UniqueWeaponKill                         = 14,
	EnvironmentalExplosiveKill               = 15,
	E_FlameKill                              = 16,
	E_MultiKillWithOneBullet                 = 17,
	E_DivingHeadshot                         = 18,
	E_WallRunningHeadshot                    = 19,
	E_Thrown                                 = 20,
	E_CannonKill                             = 21,
	E_None                                   = 22,
	E_GlassDive                              = 23,
	E_DropKickKill                           = 24,
	E_Vanilla                                = 25,
	E_Fall                                   = 26,
	E_Prop                                   = 27,
	E_WallBang                               = 28,
	E_StoleFromHolster                       = 29,
	E_QuickShot                              = 30,
	E_FlyingRagdoll                          = 31,
	E_MeleeDamage                            = 32,
	E_StandardKick                           = 33,
	E_HeavyDown                              = 34,
	E_KickJetpack                            = 35,
	E_NiceThrow                              = 36,
	E_KickRocket                             = 37,
	E_CatchPopUp                             = 38,
	E_SlideKillWithKickOnGround              = 39,
	E_Blowback                               = 40,
	E_SPlusMulti                             = 41,
	E_PeepHole                               = 42,
	E_TheTrey                                = 43,
	EFeat_MAX                                = 44,
};

// Enum ThankYouVeryCool.ECrossedStatus
// NumValues: 0x0004
enum class ECrossedStatus : uint8
{
	E_LeftCrossed                            = 0,
	E_RightCrossed                           = 1,
	E_NoCross                                = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EFoot
// NumValues: 0x0005
enum class EFoot : uint8
{
	E_Left                                   = 0,
	E_Right                                  = 1,
	E_Both                                   = 2,
	E_Neither                                = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EGyroSpace
// NumValues: 0x0003
enum class EGyroSpace : uint8
{
	E_Player                                 = 0,
	E_Local                                  = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EMontageControl
// NumValues: 0x0005
enum class EMontageControl : uint8
{
	E_Play                                   = 0,
	E_Stop                                   = 1,
	E_Pause                                  = 2,
	E_Resume                                 = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.ECameraMode
// NumValues: 0x0006
enum class ECameraMode : uint8
{
	E_YawAttachedToRootForwardVector         = 0,
	E_FreeRotate                             = 1,
	E_SnapToHeadSocket                       = 2,
	E_SnapToHeadSocketLimitedFreeRotation    = 3,
	E_YawAttachedToRootForwardVectorAndHead  = 4,
	E_MAX                                    = 5,
};

// Enum ThankYouVeryCool.ECardinalDirection
// NumValues: 0x0005
enum class ECardinalDirection : uint8
{
	E_North                                  = 0,
	E_East                                   = 1,
	E_West                                   = 2,
	E_South                                  = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EKickSlideStage
// NumValues: 0x0005
enum class EKickSlideStage : uint8
{
	E_None                                   = 0,
	E_Entering                               = 1,
	E_Sliding                                = 2,
	E_Standing                               = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EKickFoot
// NumValues: 0x0004
enum class EKickFoot : uint8
{
	E_None                                   = 0,
	E_Left                                   = 1,
	E_Right                                  = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.ECamToHeadAlignmentMode
// NumValues: 0x0003
enum class ECamToHeadAlignmentMode : uint8
{
	E_XYZ                                    = 0,
	E_XY                                     = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EBodyViz
// NumValues: 0x0004
enum class EBodyViz : uint8
{
	E_WholeBody                              = 0,
	E_OnlyArms                               = 1,
	E_ArmsAndLegs                            = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EPlayerAction
// NumValues: 0x0013
enum class EPlayerAction : uint8
{
	E_Dive                                   = 0,
	E_Crouch                                 = 1,
	E_Slide                                  = 2,
	E_Kick                                   = 3,
	E_Punch                                  = 4,
	E_Stand                                  = 5,
	E_GoProne                                = 6,
	E_Jump                                   = 7,
	E_PickUp                                 = 8,
	E_ThrowWeapon                            = 9,
	E_Shoot                                  = 10,
	E_FireCannon                             = 11,
	E_Flashlight                             = 12,
	E_SlowMo                                 = 13,
	E_JumpAlt                                = 14,
	E_Fall                                   = 15,
	E_Flip                                   = 16,
	E_Pause                                  = 17,
	E_MAX                                    = 18,
};

// Enum ThankYouVeryCool.ERogueState
// NumValues: 0x0005
enum class ERogueState : uint8
{
	E_Playing                                = 0,
	E_SelectingCard                          = 1,
	E_LoadingLevel                           = 2,
	E_PlayerDead                             = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.ESquadColor
// NumValues: 0x0007
enum class ESquadColor : uint8
{
	E_Red                                    = 0,
	E_Blue                                   = 1,
	E_Green                                  = 2,
	E_Yellow                                 = 3,
	E_Pink                                   = 4,
	E_Orange                                 = 5,
	E_MAX                                    = 6,
};

// Enum ThankYouVeryCool.ECheat
// NumValues: 0x0004
enum class ECheat : uint8
{
	E_None                                   = 0,
	E_UnlimitedAmmo                          = 1,
	E_Invincible                             = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EVoxelShape
// NumValues: 0x0010
enum class EVoxelShape : uint8
{
	E_HexPrism                               = 0,
	E_TriPrism                               = 1,
	E_Torus                                  = 2,
	E_Link                                   = 3,
	E_SolidAngle                             = 4,
	E_RoundedCylinder                        = 5,
	E_Pyramid                                = 6,
	E_CappedTorus                            = 7,
	E_Box                                    = 8,
	E_FastOcto                               = 9,
	E_FastCone                               = 10,
	E_CappedCone                             = 11,
	E_Cylinder                               = 12,
	E_Sphere                                 = 13,
	E_CappedCylinder                         = 14,
	E_MAX                                    = 15,
};

// Enum ThankYouVeryCool.ETutorialPickupType
// NumValues: 0x0003
enum class ETutorialPickupType : uint8
{
	E_Proximity                              = 0,
	E_External                               = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EPlatformRegion
// NumValues: 0x0005
enum class EPlatformRegion : uint8
{
	None                                     = 0,
	NorthAmerica                             = 1,
	Europe                                   = 2,
	Japan                                    = 3,
	EPlatformRegion_MAX                      = 4,
};

// Enum ThankYouVeryCool.EPlatformName
// NumValues: 0x000F
enum class EPlatformName : uint8
{
	None                                     = 0,
	PS4                                      = 1,
	PS5                                      = 2,
	Switch                                   = 3,
	WinGDK                                   = 4,
	XboxOneGDK                               = 5,
	XSX                                      = 6,
	Windows                                  = 7,
	Mac                                      = 8,
	Linux                                    = 9,
	Desktop                                  = 10,
	Console                                  = 11,
	Playstation                              = 12,
	Xbox                                     = 13,
	EPlatformName_MAX                        = 14,
};

// Enum ThankYouVeryCool.EGridOrientation
// NumValues: 0x0003
enum class EGridOrientation : uint8
{
	E_XY                                     = 0,
	E_XZ                                     = 1,
	E_MAX                                    = 2,
};

// Enum ThankYouVeryCool.EGridPattern
// NumValues: 0x0004
enum class EGridPattern : uint8
{
	E_Full                                   = 0,
	E_SingleCenter                           = 1,
	E_Cross                                  = 2,
	E_MAX                                    = 3,
};

// Enum ThankYouVeryCool.EVoxelWorld
// NumValues: 0x0005
enum class EVoxelWorld : uint8
{
	Primary                                  = 0,
	Secondary                                = 1,
	Tertiary                                 = 2,
	Quaternary                               = 3,
	EVoxelWorld_MAX                          = 4,
};

// Enum ThankYouVeryCool.EVoxelMaterial
// NumValues: 0x002B
enum class EVoxelMaterial : uint8
{
	Zero                                     = 0,
	WhitePlaster                             = 1,
	Gold                                     = 2,
	Metal                                    = 3,
	Marble                                   = 4,
	MarbleTile                               = 5,
	RedCarpet                                = 6,
	WoodFloor                                = 7,
	BlackTiledFloor                          = 8,
	DarkPlasterWall                          = 9,
	ServerInner                              = 10,
	ServerOuter                              = 11,
	NeonOrange                               = 12,
	Obsidian                                 = 13,
	RawWood                                  = 14,
	BeadBoard                                = 15,
	Bedding                                  = 16,
	BedCloth                                 = 17,
	BluePlaster                              = 18,
	ConcreteFloor                            = 19,
	ConcreteWall                             = 20,
	Cardboard                                = 21,
	PinkGlow                                 = 22,
	Art                                      = 23,
	RubberFloor                              = 24,
	RubberCable                              = 25,
	Vent                                     = 26,
	BlueConcrete                             = 27,
	RedConcrete                              = 28,
	FloorGrate                               = 29,
	SciFiTiledFloor                          = 30,
	SciFiCeiling                             = 31,
	SciFiWall                                = 32,
	SciFiRubberFloor                         = 33,
	SciFiMetalPlate                          = 34,
	SciFiMetalFloor                          = 35,
	Foam                                     = 36,
	GlassSkyscraper                          = 37,
	BathroomWhite                            = 38,
	Cubicle                                  = 39,
	Magma                                    = 40,
	Light                                    = 41,
	EVoxelMaterial_MAX                       = 42,
};

// Enum ThankYouVeryCool.EWeaponCategory
// NumValues: 0x0005
enum class EWeaponCategory : uint8
{
	E_Rifle                                  = 0,
	E_Pistol                                 = 1,
	E_Shotgun                                = 2,
	E_SMG                                    = 3,
	E_MAX                                    = 4,
};

// Enum ThankYouVeryCool.EFireModeType
// NumValues: 0x0006
enum class EFireModeType : uint8
{
	E_SemiAuto                               = 0,
	E_FallAuto                               = 1,
	E_Manual                                 = 2,
	E_2Burst                                 = 3,
	E_3Burst                                 = 4,
	E_MAX                                    = 5,
};

// Enum ThankYouVeryCool.ENPCGripType
// NumValues: 0x0005
enum class ENPCGripType : uint8
{
	E_Rifle                                  = 0,
	E_Pistol                                 = 1,
	E_Shotgun                                = 2,
	E_HandToHand                             = 3,
	E_MAX                                    = 4,
};

// ScriptStruct ThankYouVeryCool.Action
// 0x0010 (0x0010 - 0x0000)
struct FAction final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EActionType                                   Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBetween;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAction) == 0x000004, "Wrong alignment on FAction");
static_assert(sizeof(FAction) == 0x000010, "Wrong size on FAction");
static_assert(offsetof(FAction, ID) == 0x000000, "Member 'FAction::ID' has a wrong offset!");
static_assert(offsetof(FAction, Type) == 0x000008, "Member 'FAction::Type' has a wrong offset!");
static_assert(offsetof(FAction, DelayBetween) == 0x00000C, "Member 'FAction::DelayBetween' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.GameSettings
// 0x0090 (0x0090 - 0x0000)
struct FGameSettings final
{
public:
	float                                         CrosshairLength;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrosshairThickness;                                // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HairColor;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAltCrosshair;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideIndicators;                                   // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoSlowMoSettings                           AutoSloMoKeyboard;                                 // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDummyBool;                                        // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoSlowMoSettings                           AutoSloMoController;                               // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAimMouse;                                     // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoAimController;                                // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHudColor                                     UIColor;                                           // 0x001F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyPickUpWeapon;                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyKick;                                // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyThrow;                               // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleSlowMo;                                     // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideCrosshair;                                    // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideSloMo;                                        // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideAmmoCount;                                    // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideCannonCount;                                  // 0x0027(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideObjective;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideArcadeFeedback;                               // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLuck;                                         // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CurrentLevelName;                                  // 0x0030(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bManuallyEndArcadeVictory;                         // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSlomoOnGunCycle;                           // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponAlwaysReady;                                // 0x004A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopAtLedges;                                     // 0x004B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManuallyStand;                                    // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoReorientOnLand;                               // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowFlip;                                        // 0x004E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideDamageEffects;                                // 0x004F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpeedrunnersHUD;                                  // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUploadToLB;                                       // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkEmptyWeapons;                                 // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAirControlInDive;                            // 0x0053(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallRunAutoRun;                                   // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RunningSpeed;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldSpaceToClimb;                                 // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideKickPrompt;                                   // 0x005D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CrosshairIdx;                                      // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHudColor                                     CrosshairColor;                                    // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAmmoNumber;                                       // 0x0065(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCutscenes;                                    // 0x0066(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompressedHUD;                                    // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighVizObjectives;                                // 0x0079(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLivingRagdolls;                                   // 0x007A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B[0x1];                                       // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HitIndicator;                                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideObjectiveFlash;                               // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysCenterCannonShot;                           // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCheckpoints;                                    // 0x0082(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideIndi;                                         // 0x0083(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoKickAim;                                      // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysShowStyleMeter;                             // 0x0085(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowAkimbo;                                      // 0x0086(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualAkimbo;                                     // 0x0087(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAkimboAlwaysAuto;                                 // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimulSemi;                                        // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x6];                                       // 0x008A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameSettings) == 0x000008, "Wrong alignment on FGameSettings");
static_assert(sizeof(FGameSettings) == 0x000090, "Wrong size on FGameSettings");
static_assert(offsetof(FGameSettings, CrosshairLength) == 0x000000, "Member 'FGameSettings::CrosshairLength' has a wrong offset!");
static_assert(offsetof(FGameSettings, CrosshairThickness) == 0x000004, "Member 'FGameSettings::CrosshairThickness' has a wrong offset!");
static_assert(offsetof(FGameSettings, HairColor) == 0x000008, "Member 'FGameSettings::HairColor' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAltCrosshair) == 0x000018, "Member 'FGameSettings::bAltCrosshair' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideIndicators) == 0x000019, "Member 'FGameSettings::bHideIndicators' has a wrong offset!");
static_assert(offsetof(FGameSettings, AutoSloMoKeyboard) == 0x00001A, "Member 'FGameSettings::AutoSloMoKeyboard' has a wrong offset!");
static_assert(offsetof(FGameSettings, bDummyBool) == 0x00001B, "Member 'FGameSettings::bDummyBool' has a wrong offset!");
static_assert(offsetof(FGameSettings, AutoSloMoController) == 0x00001C, "Member 'FGameSettings::AutoSloMoController' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAutoAimMouse) == 0x00001D, "Member 'FGameSettings::bAutoAimMouse' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAutoAimController) == 0x00001E, "Member 'FGameSettings::bAutoAimController' has a wrong offset!");
static_assert(offsetof(FGameSettings, UIColor) == 0x00001F, "Member 'FGameSettings::UIColor' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAutomaticallyPickUpWeapon) == 0x000020, "Member 'FGameSettings::bAutomaticallyPickUpWeapon' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAutomaticallyKick) == 0x000021, "Member 'FGameSettings::bAutomaticallyKick' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAutomaticallyThrow) == 0x000022, "Member 'FGameSettings::bAutomaticallyThrow' has a wrong offset!");
static_assert(offsetof(FGameSettings, bToggleSlowMo) == 0x000023, "Member 'FGameSettings::bToggleSlowMo' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideCrosshair) == 0x000024, "Member 'FGameSettings::bHideCrosshair' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideSloMo) == 0x000025, "Member 'FGameSettings::bHideSloMo' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideAmmoCount) == 0x000026, "Member 'FGameSettings::bHideAmmoCount' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideCannonCount) == 0x000027, "Member 'FGameSettings::bHideCannonCount' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideObjective) == 0x000028, "Member 'FGameSettings::bHideObjective' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideArcadeFeedback) == 0x000029, "Member 'FGameSettings::bHideArcadeFeedback' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideLuck) == 0x00002A, "Member 'FGameSettings::bHideLuck' has a wrong offset!");
static_assert(offsetof(FGameSettings, CurrentLevelName) == 0x000030, "Member 'FGameSettings::CurrentLevelName' has a wrong offset!");
static_assert(offsetof(FGameSettings, bManuallyEndArcadeVictory) == 0x000048, "Member 'FGameSettings::bManuallyEndArcadeVictory' has a wrong offset!");
static_assert(offsetof(FGameSettings, bDisableSlomoOnGunCycle) == 0x000049, "Member 'FGameSettings::bDisableSlomoOnGunCycle' has a wrong offset!");
static_assert(offsetof(FGameSettings, bWeaponAlwaysReady) == 0x00004A, "Member 'FGameSettings::bWeaponAlwaysReady' has a wrong offset!");
static_assert(offsetof(FGameSettings, bStopAtLedges) == 0x00004B, "Member 'FGameSettings::bStopAtLedges' has a wrong offset!");
static_assert(offsetof(FGameSettings, bManuallyStand) == 0x00004C, "Member 'FGameSettings::bManuallyStand' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAutoReorientOnLand) == 0x00004D, "Member 'FGameSettings::bAutoReorientOnLand' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAllowFlip) == 0x00004E, "Member 'FGameSettings::bAllowFlip' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideDamageEffects) == 0x00004F, "Member 'FGameSettings::bHideDamageEffects' has a wrong offset!");
static_assert(offsetof(FGameSettings, bSpeedrunnersHUD) == 0x000050, "Member 'FGameSettings::bSpeedrunnersHUD' has a wrong offset!");
static_assert(offsetof(FGameSettings, bUploadToLB) == 0x000051, "Member 'FGameSettings::bUploadToLB' has a wrong offset!");
static_assert(offsetof(FGameSettings, bMarkEmptyWeapons) == 0x000052, "Member 'FGameSettings::bMarkEmptyWeapons' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAllowAirControlInDive) == 0x000053, "Member 'FGameSettings::bAllowAirControlInDive' has a wrong offset!");
static_assert(offsetof(FGameSettings, bWallRunAutoRun) == 0x000054, "Member 'FGameSettings::bWallRunAutoRun' has a wrong offset!");
static_assert(offsetof(FGameSettings, RunningSpeed) == 0x000058, "Member 'FGameSettings::RunningSpeed' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHoldSpaceToClimb) == 0x00005C, "Member 'FGameSettings::bHoldSpaceToClimb' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideKickPrompt) == 0x00005D, "Member 'FGameSettings::bHideKickPrompt' has a wrong offset!");
static_assert(offsetof(FGameSettings, CrosshairIdx) == 0x000060, "Member 'FGameSettings::CrosshairIdx' has a wrong offset!");
static_assert(offsetof(FGameSettings, CrosshairColor) == 0x000064, "Member 'FGameSettings::CrosshairColor' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAmmoNumber) == 0x000065, "Member 'FGameSettings::bAmmoNumber' has a wrong offset!");
static_assert(offsetof(FGameSettings, bSkipCutscenes) == 0x000066, "Member 'FGameSettings::bSkipCutscenes' has a wrong offset!");
static_assert(offsetof(FGameSettings, Language) == 0x000068, "Member 'FGameSettings::Language' has a wrong offset!");
static_assert(offsetof(FGameSettings, bCompressedHUD) == 0x000078, "Member 'FGameSettings::bCompressedHUD' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHighVizObjectives) == 0x000079, "Member 'FGameSettings::bHighVizObjectives' has a wrong offset!");
static_assert(offsetof(FGameSettings, bLivingRagdolls) == 0x00007A, "Member 'FGameSettings::bLivingRagdolls' has a wrong offset!");
static_assert(offsetof(FGameSettings, HitIndicator) == 0x00007C, "Member 'FGameSettings::HitIndicator' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideObjectiveFlash) == 0x000080, "Member 'FGameSettings::bHideObjectiveFlash' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAlwaysCenterCannonShot) == 0x000081, "Member 'FGameSettings::bAlwaysCenterCannonShot' has a wrong offset!");
static_assert(offsetof(FGameSettings, bNoCheckpoints) == 0x000082, "Member 'FGameSettings::bNoCheckpoints' has a wrong offset!");
static_assert(offsetof(FGameSettings, bHideIndi) == 0x000083, "Member 'FGameSettings::bHideIndi' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAutoKickAim) == 0x000084, "Member 'FGameSettings::bAutoKickAim' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAlwaysShowStyleMeter) == 0x000085, "Member 'FGameSettings::bAlwaysShowStyleMeter' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAllowAkimbo) == 0x000086, "Member 'FGameSettings::bAllowAkimbo' has a wrong offset!");
static_assert(offsetof(FGameSettings, bManualAkimbo) == 0x000087, "Member 'FGameSettings::bManualAkimbo' has a wrong offset!");
static_assert(offsetof(FGameSettings, bAkimboAlwaysAuto) == 0x000088, "Member 'FGameSettings::bAkimboAlwaysAuto' has a wrong offset!");
static_assert(offsetof(FGameSettings, bSimulSemi) == 0x000089, "Member 'FGameSettings::bSimulSemi' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.HitReactionKnockback
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x08) FHitReactionKnockback final
{
public:
	uint8                                         Pad_0[0xB0];                                       // 0x0000(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactionKnockback) == 0x000008, "Wrong alignment on FHitReactionKnockback");
static_assert(sizeof(FHitReactionKnockback) == 0x0000B0, "Wrong size on FHitReactionKnockback");

// ScriptStruct ThankYouVeryCool.TYVCAudioSettings
// 0x0038 (0x0038 - 0x0000)
struct FTYVCAudioSettings final
{
public:
	float                                         MasterVolume;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MusicVolume;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameVolume;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcadeVolume;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallRunChargeSound;                               // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NPCVolume;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerGunVolume;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOSTMode                                      OSTMode;                                           // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 OSTToSkip;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EOSTMode                                      OSTModeConsole;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTYVCAudioSettings) == 0x000008, "Wrong alignment on FTYVCAudioSettings");
static_assert(sizeof(FTYVCAudioSettings) == 0x000038, "Wrong size on FTYVCAudioSettings");
static_assert(offsetof(FTYVCAudioSettings, MasterVolume) == 0x000000, "Member 'FTYVCAudioSettings::MasterVolume' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, MusicVolume) == 0x000004, "Member 'FTYVCAudioSettings::MusicVolume' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, GameVolume) == 0x000008, "Member 'FTYVCAudioSettings::GameVolume' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, ArcadeVolume) == 0x00000C, "Member 'FTYVCAudioSettings::ArcadeVolume' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, bWallRunChargeSound) == 0x000010, "Member 'FTYVCAudioSettings::bWallRunChargeSound' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, NPCVolume) == 0x000014, "Member 'FTYVCAudioSettings::NPCVolume' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, PlayerGunVolume) == 0x000018, "Member 'FTYVCAudioSettings::PlayerGunVolume' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, OSTMode) == 0x00001C, "Member 'FTYVCAudioSettings::OSTMode' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, OSTToSkip) == 0x000020, "Member 'FTYVCAudioSettings::OSTToSkip' has a wrong offset!");
static_assert(offsetof(FTYVCAudioSettings, OSTModeConsole) == 0x000030, "Member 'FTYVCAudioSettings::OSTModeConsole' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ImpactReaction
// 0x0030 (0x0030 - 0x0000)
struct FImpactReaction final
{
public:
	EVoxelToolType                                ToolType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VoxelDepth;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoxelWidth;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialDamageWidth;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class Adebris>                    DebrisToSpawn;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleToSpawn;                                   // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ParticleScale;                                     // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImpactReaction) == 0x000008, "Wrong alignment on FImpactReaction");
static_assert(sizeof(FImpactReaction) == 0x000030, "Wrong size on FImpactReaction");
static_assert(offsetof(FImpactReaction, ToolType) == 0x000000, "Member 'FImpactReaction::ToolType' has a wrong offset!");
static_assert(offsetof(FImpactReaction, VoxelDepth) == 0x000004, "Member 'FImpactReaction::VoxelDepth' has a wrong offset!");
static_assert(offsetof(FImpactReaction, VoxelWidth) == 0x000008, "Member 'FImpactReaction::VoxelWidth' has a wrong offset!");
static_assert(offsetof(FImpactReaction, MaterialDamageWidth) == 0x00000C, "Member 'FImpactReaction::MaterialDamageWidth' has a wrong offset!");
static_assert(offsetof(FImpactReaction, DebrisToSpawn) == 0x000010, "Member 'FImpactReaction::DebrisToSpawn' has a wrong offset!");
static_assert(offsetof(FImpactReaction, ParticleToSpawn) == 0x000018, "Member 'FImpactReaction::ParticleToSpawn' has a wrong offset!");
static_assert(offsetof(FImpactReaction, ParticleScale) == 0x000020, "Member 'FImpactReaction::ParticleScale' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.MaterialConfig
// 0x0048 (0x0048 - 0x0000)
struct FMaterialConfig final
{
public:
	EMaterialType                                 Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Indices;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FImpactReaction                        ImpactReaction;                                    // 0x0018(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialConfig) == 0x000008, "Wrong alignment on FMaterialConfig");
static_assert(sizeof(FMaterialConfig) == 0x000048, "Wrong size on FMaterialConfig");
static_assert(offsetof(FMaterialConfig, Type) == 0x000000, "Member 'FMaterialConfig::Type' has a wrong offset!");
static_assert(offsetof(FMaterialConfig, Indices) == 0x000008, "Member 'FMaterialConfig::Indices' has a wrong offset!");
static_assert(offsetof(FMaterialConfig, ImpactReaction) == 0x000018, "Member 'FMaterialConfig::ImpactReaction' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.LeaderboardEvent
// 0x000C (0x000C - 0x0000)
struct FLeaderboardEvent final
{
public:
	bool                                          bSomethingNoteworthy;                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTotallyNew;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Before;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Now;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLeaderboardEvent) == 0x000004, "Wrong alignment on FLeaderboardEvent");
static_assert(sizeof(FLeaderboardEvent) == 0x00000C, "Wrong size on FLeaderboardEvent");
static_assert(offsetof(FLeaderboardEvent, bSomethingNoteworthy) == 0x000000, "Member 'FLeaderboardEvent::bSomethingNoteworthy' has a wrong offset!");
static_assert(offsetof(FLeaderboardEvent, bTotallyNew) == 0x000001, "Member 'FLeaderboardEvent::bTotallyNew' has a wrong offset!");
static_assert(offsetof(FLeaderboardEvent, Before) == 0x000004, "Member 'FLeaderboardEvent::Before' has a wrong offset!");
static_assert(offsetof(FLeaderboardEvent, Now) == 0x000008, "Member 'FLeaderboardEvent::Now' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.TYVCLBReadQueryParams
// 0x0018 (0x0018 - 0x0000)
struct FTYVCLBReadQueryParams final
{
public:
	class FString                                 BoardName;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETYVCLeaderboardType                          LeaderboardType;                                   // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriends;                                          // 0x0011(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTYVCLBReadQueryParams) == 0x000008, "Wrong alignment on FTYVCLBReadQueryParams");
static_assert(sizeof(FTYVCLBReadQueryParams) == 0x000018, "Wrong size on FTYVCLBReadQueryParams");
static_assert(offsetof(FTYVCLBReadQueryParams, BoardName) == 0x000000, "Member 'FTYVCLBReadQueryParams::BoardName' has a wrong offset!");
static_assert(offsetof(FTYVCLBReadQueryParams, LeaderboardType) == 0x000010, "Member 'FTYVCLBReadQueryParams::LeaderboardType' has a wrong offset!");
static_assert(offsetof(FTYVCLBReadQueryParams, bFriends) == 0x000011, "Member 'FTYVCLBReadQueryParams::bFriends' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ArcadeRecord
// 0x0020 (0x0020 - 0x0000)
struct FArcadeRecord final
{
public:
	TArray<float>                                 KillTimes;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 ScoreRecord;                                       // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcadeRecord) == 0x000008, "Wrong alignment on FArcadeRecord");
static_assert(sizeof(FArcadeRecord) == 0x000020, "Wrong size on FArcadeRecord");
static_assert(offsetof(FArcadeRecord, KillTimes) == 0x000000, "Member 'FArcadeRecord::KillTimes' has a wrong offset!");
static_assert(offsetof(FArcadeRecord, ScoreRecord) == 0x000010, "Member 'FArcadeRecord::ScoreRecord' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.TYVCSteamLeaderboardEntry
// 0x0058 (0x0058 - 0x0000)
struct FTYVCSteamLeaderboardEntry final
{
public:
	class FString                                 SteamID;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlobalRank;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Details;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FArcadeRecord                          Record;                                            // 0x0020(0x0020)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	bool                                          bIsSteam;                                          // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformOnlineID;                                  // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTYVCSteamLeaderboardEntry) == 0x000008, "Wrong alignment on FTYVCSteamLeaderboardEntry");
static_assert(sizeof(FTYVCSteamLeaderboardEntry) == 0x000058, "Wrong size on FTYVCSteamLeaderboardEntry");
static_assert(offsetof(FTYVCSteamLeaderboardEntry, SteamID) == 0x000000, "Member 'FTYVCSteamLeaderboardEntry::SteamID' has a wrong offset!");
static_assert(offsetof(FTYVCSteamLeaderboardEntry, GlobalRank) == 0x000010, "Member 'FTYVCSteamLeaderboardEntry::GlobalRank' has a wrong offset!");
static_assert(offsetof(FTYVCSteamLeaderboardEntry, Score) == 0x000014, "Member 'FTYVCSteamLeaderboardEntry::Score' has a wrong offset!");
static_assert(offsetof(FTYVCSteamLeaderboardEntry, Details) == 0x000018, "Member 'FTYVCSteamLeaderboardEntry::Details' has a wrong offset!");
static_assert(offsetof(FTYVCSteamLeaderboardEntry, Record) == 0x000020, "Member 'FTYVCSteamLeaderboardEntry::Record' has a wrong offset!");
static_assert(offsetof(FTYVCSteamLeaderboardEntry, bIsSteam) == 0x000040, "Member 'FTYVCSteamLeaderboardEntry::bIsSteam' has a wrong offset!");
static_assert(offsetof(FTYVCSteamLeaderboardEntry, PlatformOnlineID) == 0x000048, "Member 'FTYVCSteamLeaderboardEntry::PlatformOnlineID' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ControlSettings
// 0x000C (0x000C - 0x0000)
struct FControlSettings final
{
public:
	float                                         MouseSensitivity;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertMousePitch;                                 // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleSlowMo;                                     // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleKickSlide;                                  // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMouseSmooth;                                      // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimAssist;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControlSettings) == 0x000004, "Wrong alignment on FControlSettings");
static_assert(sizeof(FControlSettings) == 0x00000C, "Wrong size on FControlSettings");
static_assert(offsetof(FControlSettings, MouseSensitivity) == 0x000000, "Member 'FControlSettings::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(FControlSettings, bInvertMousePitch) == 0x000004, "Member 'FControlSettings::bInvertMousePitch' has a wrong offset!");
static_assert(offsetof(FControlSettings, bToggleSlowMo) == 0x000005, "Member 'FControlSettings::bToggleSlowMo' has a wrong offset!");
static_assert(offsetof(FControlSettings, bToggleKickSlide) == 0x000006, "Member 'FControlSettings::bToggleKickSlide' has a wrong offset!");
static_assert(offsetof(FControlSettings, bMouseSmooth) == 0x000007, "Member 'FControlSettings::bMouseSmooth' has a wrong offset!");
static_assert(offsetof(FControlSettings, bAimAssist) == 0x000008, "Member 'FControlSettings::bAimAssist' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.SteelJacket
// 0x0050 (0x0058 - 0x0008)
struct FSteelJacket final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsDefault;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           RColor;                                            // 0x0024(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           GColor;                                            // 0x0034(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BColor;                                            // 0x0044(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointsToUnlock;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSteelJacket) == 0x000008, "Wrong alignment on FSteelJacket");
static_assert(sizeof(FSteelJacket) == 0x000058, "Wrong size on FSteelJacket");
static_assert(offsetof(FSteelJacket, Name) == 0x000008, "Member 'FSteelJacket::Name' has a wrong offset!");
static_assert(offsetof(FSteelJacket, bIsDefault) == 0x000020, "Member 'FSteelJacket::bIsDefault' has a wrong offset!");
static_assert(offsetof(FSteelJacket, RColor) == 0x000024, "Member 'FSteelJacket::RColor' has a wrong offset!");
static_assert(offsetof(FSteelJacket, GColor) == 0x000034, "Member 'FSteelJacket::GColor' has a wrong offset!");
static_assert(offsetof(FSteelJacket, BColor) == 0x000044, "Member 'FSteelJacket::BColor' has a wrong offset!");
static_assert(offsetof(FSteelJacket, PointsToUnlock) == 0x000054, "Member 'FSteelJacket::PointsToUnlock' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ControlSettingsGamepad
// 0x001C (0x001C - 0x0000)
struct FControlSettingsGamepad final
{
public:
	float                                         LookSensitivity;                                   // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertPitch;                                      // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnalogControl                                LookMode;                                          // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnalogControl                                MoveMode;                                          // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bToggleSlowMo;                                     // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamepadAccel;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeadZone;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamepadEnabled;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGyroEnabled;                                      // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GyroSensitiviy;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFeedbackEnabled;                             // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGyroSlowMoOnly;                                   // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoGyroWhileStickAiming;                           // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAimAssist;                                        // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FControlSettingsGamepad) == 0x000004, "Wrong alignment on FControlSettingsGamepad");
static_assert(sizeof(FControlSettingsGamepad) == 0x00001C, "Wrong size on FControlSettingsGamepad");
static_assert(offsetof(FControlSettingsGamepad, LookSensitivity) == 0x000000, "Member 'FControlSettingsGamepad::LookSensitivity' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bInvertPitch) == 0x000004, "Member 'FControlSettingsGamepad::bInvertPitch' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, LookMode) == 0x000005, "Member 'FControlSettingsGamepad::LookMode' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, MoveMode) == 0x000006, "Member 'FControlSettingsGamepad::MoveMode' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bToggleSlowMo) == 0x000007, "Member 'FControlSettingsGamepad::bToggleSlowMo' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bGamepadAccel) == 0x000008, "Member 'FControlSettingsGamepad::bGamepadAccel' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, DeadZone) == 0x00000C, "Member 'FControlSettingsGamepad::DeadZone' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bGamepadEnabled) == 0x000010, "Member 'FControlSettingsGamepad::bGamepadEnabled' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bGyroEnabled) == 0x000011, "Member 'FControlSettingsGamepad::bGyroEnabled' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, GyroSensitiviy) == 0x000014, "Member 'FControlSettingsGamepad::GyroSensitiviy' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bForceFeedbackEnabled) == 0x000018, "Member 'FControlSettingsGamepad::bForceFeedbackEnabled' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bGyroSlowMoOnly) == 0x000019, "Member 'FControlSettingsGamepad::bGyroSlowMoOnly' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bNoGyroWhileStickAiming) == 0x00001A, "Member 'FControlSettingsGamepad::bNoGyroWhileStickAiming' has a wrong offset!");
static_assert(offsetof(FControlSettingsGamepad, bAimAssist) == 0x00001B, "Member 'FControlSettingsGamepad::bAimAssist' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.VisualSettings
// 0x0058 (0x0058 - 0x0000)
struct FVisualSettings final
{
public:
	class FString                                 Resolution;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WindowStyle;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShadows;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAO;                                               // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMotionBlur;                                       // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlowMoVisualType                             SlowMoVisualType;                                  // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDestructionDetail                            DestructionDetail;                                 // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulletCasings;                                    // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVsync;                                            // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCelShader;                                        // 0x0027(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLookingGlass;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVoxelPhysics;                                     // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETYVCDLSSMode                                 DLSSMode;                                          // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETYVCAMDFXMode                                AMDFXMode;                                         // 0x002B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRTXReflections;                                   // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReducedFlash;                                     // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOV;                                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFPS;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemyOutlines;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBloomEnabled;                                     // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWallRunGuideLines;                                // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSSR;                                              // 0x003B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHudColor                                     EnemyOutlineColor;                                 // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReducedViolence;                                  // 0x003D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStuntLines;                                       // 0x003E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScreenShake;                                      // 0x003F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidePlayerBody;                                   // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlimitedRagdolls;                                // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHDR;                                              // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCamRoll;                                          // 0x0043(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleLighting;                                   // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleFX;                                         // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConsoleGraphicsMode                          ConsoleGraphicsMode;                               // 0x0046(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Gamma;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FOVSwitchHandheld;                                 // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiThread;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVisualSettings) == 0x000008, "Wrong alignment on FVisualSettings");
static_assert(sizeof(FVisualSettings) == 0x000058, "Wrong size on FVisualSettings");
static_assert(offsetof(FVisualSettings, Resolution) == 0x000000, "Member 'FVisualSettings::Resolution' has a wrong offset!");
static_assert(offsetof(FVisualSettings, WindowStyle) == 0x000010, "Member 'FVisualSettings::WindowStyle' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bShadows) == 0x000020, "Member 'FVisualSettings::bShadows' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bAO) == 0x000021, "Member 'FVisualSettings::bAO' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bMotionBlur) == 0x000022, "Member 'FVisualSettings::bMotionBlur' has a wrong offset!");
static_assert(offsetof(FVisualSettings, SlowMoVisualType) == 0x000023, "Member 'FVisualSettings::SlowMoVisualType' has a wrong offset!");
static_assert(offsetof(FVisualSettings, DestructionDetail) == 0x000024, "Member 'FVisualSettings::DestructionDetail' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bBulletCasings) == 0x000025, "Member 'FVisualSettings::bBulletCasings' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bVsync) == 0x000026, "Member 'FVisualSettings::bVsync' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bCelShader) == 0x000027, "Member 'FVisualSettings::bCelShader' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bLookingGlass) == 0x000028, "Member 'FVisualSettings::bLookingGlass' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bVoxelPhysics) == 0x000029, "Member 'FVisualSettings::bVoxelPhysics' has a wrong offset!");
static_assert(offsetof(FVisualSettings, DLSSMode) == 0x00002A, "Member 'FVisualSettings::DLSSMode' has a wrong offset!");
static_assert(offsetof(FVisualSettings, AMDFXMode) == 0x00002B, "Member 'FVisualSettings::AMDFXMode' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bRTXReflections) == 0x00002C, "Member 'FVisualSettings::bRTXReflections' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bReducedFlash) == 0x00002D, "Member 'FVisualSettings::bReducedFlash' has a wrong offset!");
static_assert(offsetof(FVisualSettings, FOV) == 0x000030, "Member 'FVisualSettings::FOV' has a wrong offset!");
static_assert(offsetof(FVisualSettings, MaxFPS) == 0x000034, "Member 'FVisualSettings::MaxFPS' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bEnemyOutlines) == 0x000038, "Member 'FVisualSettings::bEnemyOutlines' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bBloomEnabled) == 0x000039, "Member 'FVisualSettings::bBloomEnabled' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bWallRunGuideLines) == 0x00003A, "Member 'FVisualSettings::bWallRunGuideLines' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bSSR) == 0x00003B, "Member 'FVisualSettings::bSSR' has a wrong offset!");
static_assert(offsetof(FVisualSettings, EnemyOutlineColor) == 0x00003C, "Member 'FVisualSettings::EnemyOutlineColor' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bReducedViolence) == 0x00003D, "Member 'FVisualSettings::bReducedViolence' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bStuntLines) == 0x00003E, "Member 'FVisualSettings::bStuntLines' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bScreenShake) == 0x00003F, "Member 'FVisualSettings::bScreenShake' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bHidePlayerBody) == 0x000040, "Member 'FVisualSettings::bHidePlayerBody' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bUnlimitedRagdolls) == 0x000041, "Member 'FVisualSettings::bUnlimitedRagdolls' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bHDR) == 0x000042, "Member 'FVisualSettings::bHDR' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bCamRoll) == 0x000043, "Member 'FVisualSettings::bCamRoll' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bSimpleLighting) == 0x000044, "Member 'FVisualSettings::bSimpleLighting' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bSimpleFX) == 0x000045, "Member 'FVisualSettings::bSimpleFX' has a wrong offset!");
static_assert(offsetof(FVisualSettings, ConsoleGraphicsMode) == 0x000046, "Member 'FVisualSettings::ConsoleGraphicsMode' has a wrong offset!");
static_assert(offsetof(FVisualSettings, Gamma) == 0x000048, "Member 'FVisualSettings::Gamma' has a wrong offset!");
static_assert(offsetof(FVisualSettings, FOVSwitchHandheld) == 0x00004C, "Member 'FVisualSettings::FOVSwitchHandheld' has a wrong offset!");
static_assert(offsetof(FVisualSettings, bMultiThread) == 0x000050, "Member 'FVisualSettings::bMultiThread' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ShinyData
// 0x0020 (0x0028 - 0x0008)
struct FShinyData final : public FTableRowBase
{
public:
	EShineLevel                                   ForShineLevel;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Cost;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShinyData) == 0x000008, "Wrong alignment on FShinyData");
static_assert(sizeof(FShinyData) == 0x000028, "Wrong size on FShinyData");
static_assert(offsetof(FShinyData, ForShineLevel) == 0x000008, "Member 'FShinyData::ForShineLevel' has a wrong offset!");
static_assert(offsetof(FShinyData, Cost) == 0x00000C, "Member 'FShinyData::Cost' has a wrong offset!");
static_assert(offsetof(FShinyData, DisplayName) == 0x000010, "Member 'FShinyData::DisplayName' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.TYVCNodeMemory
// 0x0020 (0x0020 - 0x0000)
struct FTYVCNodeMemory final
{
public:
	TArray<class AVoxelBuilder2*>                 ManagedBuilders;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ULevelStreaming*>                Levels;                                            // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTYVCNodeMemory) == 0x000008, "Wrong alignment on FTYVCNodeMemory");
static_assert(sizeof(FTYVCNodeMemory) == 0x000020, "Wrong size on FTYVCNodeMemory");
static_assert(offsetof(FTYVCNodeMemory, ManagedBuilders) == 0x000000, "Member 'FTYVCNodeMemory::ManagedBuilders' has a wrong offset!");
static_assert(offsetof(FTYVCNodeMemory, Levels) == 0x000010, "Member 'FTYVCNodeMemory::Levels' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.TYVCLBReadCachedResult
// 0x0080 (0x0080 - 0x0000)
struct FTYVCLBReadCachedResult final
{
public:
	struct FTYVCLBReadQueryParams                 ReadQueryParams;                                   // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FTYVCSteamLeaderboardEntry>     EntryList;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTYVCSteamLeaderboardEntry             User;                                              // 0x0028(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTYVCLBReadCachedResult) == 0x000008, "Wrong alignment on FTYVCLBReadCachedResult");
static_assert(sizeof(FTYVCLBReadCachedResult) == 0x000080, "Wrong size on FTYVCLBReadCachedResult");
static_assert(offsetof(FTYVCLBReadCachedResult, ReadQueryParams) == 0x000000, "Member 'FTYVCLBReadCachedResult::ReadQueryParams' has a wrong offset!");
static_assert(offsetof(FTYVCLBReadCachedResult, EntryList) == 0x000018, "Member 'FTYVCLBReadCachedResult::EntryList' has a wrong offset!");
static_assert(offsetof(FTYVCLBReadCachedResult, User) == 0x000028, "Member 'FTYVCLBReadCachedResult::User' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.MutatorData
// 0x0078 (0x0080 - 0x0008)
struct FMutatorData final : public FTableRowBase
{
public:
	EGameModifier                                 MutType;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayText;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         multi;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnlockKey;                                         // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         UnlockLevel;                                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMutCat                                       MutCat;                                            // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   UnlockCard;                                        // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMutatorData) == 0x000008, "Wrong alignment on FMutatorData");
static_assert(sizeof(FMutatorData) == 0x000080, "Wrong size on FMutatorData");
static_assert(offsetof(FMutatorData, MutType) == 0x000008, "Member 'FMutatorData::MutType' has a wrong offset!");
static_assert(offsetof(FMutatorData, DisplayText) == 0x000010, "Member 'FMutatorData::DisplayText' has a wrong offset!");
static_assert(offsetof(FMutatorData, multi) == 0x000028, "Member 'FMutatorData::multi' has a wrong offset!");
static_assert(offsetof(FMutatorData, UnlockKey) == 0x00002C, "Member 'FMutatorData::UnlockKey' has a wrong offset!");
static_assert(offsetof(FMutatorData, Description) == 0x000038, "Member 'FMutatorData::Description' has a wrong offset!");
static_assert(offsetof(FMutatorData, UnlockLevel) == 0x000050, "Member 'FMutatorData::UnlockLevel' has a wrong offset!");
static_assert(offsetof(FMutatorData, MutCat) == 0x000054, "Member 'FMutatorData::MutCat' has a wrong offset!");
static_assert(offsetof(FMutatorData, UnlockCard) == 0x000058, "Member 'FMutatorData::UnlockCard' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.DebugPoint
// 0x0014 (0x0014 - 0x0000)
struct FDebugPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenericOrUnitDebugData;                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugPoint) == 0x000004, "Wrong alignment on FDebugPoint");
static_assert(sizeof(FDebugPoint) == 0x000014, "Wrong size on FDebugPoint");
static_assert(offsetof(FDebugPoint, Location) == 0x000000, "Member 'FDebugPoint::Location' has a wrong offset!");
static_assert(offsetof(FDebugPoint, Color) == 0x00000C, "Member 'FDebugPoint::Color' has a wrong offset!");
static_assert(offsetof(FDebugPoint, bGenericOrUnitDebugData) == 0x000010, "Member 'FDebugPoint::bGenericOrUnitDebugData' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.UnlockData
// 0x0028 (0x0030 - 0x0008)
struct FUnlockData final : public FTableRowBase
{
public:
	class FName                                   Key;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayText;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnlockType                                   UnlockType;                                        // 0x002C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnlockData) == 0x000008, "Wrong alignment on FUnlockData");
static_assert(sizeof(FUnlockData) == 0x000030, "Wrong size on FUnlockData");
static_assert(offsetof(FUnlockData, Key) == 0x000008, "Member 'FUnlockData::Key' has a wrong offset!");
static_assert(offsetof(FUnlockData, DisplayText) == 0x000010, "Member 'FUnlockData::DisplayText' has a wrong offset!");
static_assert(offsetof(FUnlockData, Level) == 0x000028, "Member 'FUnlockData::Level' has a wrong offset!");
static_assert(offsetof(FUnlockData, UnlockType) == 0x00002C, "Member 'FUnlockData::UnlockType' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.CustomPropData
// 0x0090 (0x0090 - 0x0000)
struct FCustomPropData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  UniqueId;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoxelCompressedWorldSave              Data;                                              // 0x0020(0x0020)(SaveGame, NativeAccessSpecifierPublic)
	TArray<uint8>                                 DefaultActorData;                                  // 0x0040(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FVoxelIntBox                           Bounds;                                            // 0x0050(0x0018)(SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Category;                                          // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorkshopID;                                        // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFromWorkshop;                                   // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomPropData) == 0x000008, "Wrong alignment on FCustomPropData");
static_assert(sizeof(FCustomPropData) == 0x000090, "Wrong size on FCustomPropData");
static_assert(offsetof(FCustomPropData, Name) == 0x000000, "Member 'FCustomPropData::Name' has a wrong offset!");
static_assert(offsetof(FCustomPropData, UniqueId) == 0x000010, "Member 'FCustomPropData::UniqueId' has a wrong offset!");
static_assert(offsetof(FCustomPropData, Data) == 0x000020, "Member 'FCustomPropData::Data' has a wrong offset!");
static_assert(offsetof(FCustomPropData, DefaultActorData) == 0x000040, "Member 'FCustomPropData::DefaultActorData' has a wrong offset!");
static_assert(offsetof(FCustomPropData, Bounds) == 0x000050, "Member 'FCustomPropData::Bounds' has a wrong offset!");
static_assert(offsetof(FCustomPropData, Category) == 0x000068, "Member 'FCustomPropData::Category' has a wrong offset!");
static_assert(offsetof(FCustomPropData, WorkshopID) == 0x000078, "Member 'FCustomPropData::WorkshopID' has a wrong offset!");
static_assert(offsetof(FCustomPropData, bIsFromWorkshop) == 0x000088, "Member 'FCustomPropData::bIsFromWorkshop' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.RogueConfig
// 0x0009 (0x0009 - 0x0000)
struct FRogueConfig final
{
public:
	bool                                          bColdSteel;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMoltenSteel;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLikeWater;                                        // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPermaDeath;                                       // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomSelect;                                     // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExtendedv2;                                       // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoaded;                                           // 0x0006(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyRogueLvls;                                    // 0x0007(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartWithGravGun;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRogueConfig) == 0x000001, "Wrong alignment on FRogueConfig");
static_assert(sizeof(FRogueConfig) == 0x000009, "Wrong size on FRogueConfig");
static_assert(offsetof(FRogueConfig, bColdSteel) == 0x000000, "Member 'FRogueConfig::bColdSteel' has a wrong offset!");
static_assert(offsetof(FRogueConfig, bMoltenSteel) == 0x000001, "Member 'FRogueConfig::bMoltenSteel' has a wrong offset!");
static_assert(offsetof(FRogueConfig, bLikeWater) == 0x000002, "Member 'FRogueConfig::bLikeWater' has a wrong offset!");
static_assert(offsetof(FRogueConfig, bPermaDeath) == 0x000003, "Member 'FRogueConfig::bPermaDeath' has a wrong offset!");
static_assert(offsetof(FRogueConfig, bRandomSelect) == 0x000004, "Member 'FRogueConfig::bRandomSelect' has a wrong offset!");
static_assert(offsetof(FRogueConfig, bExtendedv2) == 0x000005, "Member 'FRogueConfig::bExtendedv2' has a wrong offset!");
static_assert(offsetof(FRogueConfig, bLoaded) == 0x000006, "Member 'FRogueConfig::bLoaded' has a wrong offset!");
static_assert(offsetof(FRogueConfig, bOnlyRogueLvls) == 0x000007, "Member 'FRogueConfig::bOnlyRogueLvls' has a wrong offset!");
static_assert(offsetof(FRogueConfig, bStartWithGravGun) == 0x000008, "Member 'FRogueConfig::bStartWithGravGun' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.PooledList
// 0x0010 (0x0010 - 0x0000)
struct FPooledList final
{
public:
	TArray<class APoolableActor*>                 List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPooledList) == 0x000008, "Wrong alignment on FPooledList");
static_assert(sizeof(FPooledList) == 0x000010, "Wrong size on FPooledList");
static_assert(offsetof(FPooledList, List) == 0x000000, "Member 'FPooledList::List' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.RespawnConfig
// 0x0028 (0x0028 - 0x0000)
struct FRespawnConfig final
{
public:
	int32                                         NumberToMaintain;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ANPC>>               ClassesToSpawn;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         SpawnFrequency;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnLimit;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipDistanceCheck;                                // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipHistoryCheck;                                 // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRespawnConfig) == 0x000008, "Wrong alignment on FRespawnConfig");
static_assert(sizeof(FRespawnConfig) == 0x000028, "Wrong size on FRespawnConfig");
static_assert(offsetof(FRespawnConfig, NumberToMaintain) == 0x000000, "Member 'FRespawnConfig::NumberToMaintain' has a wrong offset!");
static_assert(offsetof(FRespawnConfig, ClassesToSpawn) == 0x000008, "Member 'FRespawnConfig::ClassesToSpawn' has a wrong offset!");
static_assert(offsetof(FRespawnConfig, SpawnFrequency) == 0x000018, "Member 'FRespawnConfig::SpawnFrequency' has a wrong offset!");
static_assert(offsetof(FRespawnConfig, SpawnLimit) == 0x00001C, "Member 'FRespawnConfig::SpawnLimit' has a wrong offset!");
static_assert(offsetof(FRespawnConfig, bSkipDistanceCheck) == 0x000020, "Member 'FRespawnConfig::bSkipDistanceCheck' has a wrong offset!");
static_assert(offsetof(FRespawnConfig, bSkipHistoryCheck) == 0x000021, "Member 'FRespawnConfig::bSkipHistoryCheck' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ImpactConfig
// 0x0060 (0x0060 - 0x0000)
struct FImpactConfig final
{
public:
	TArray<struct FMaterialConfig>                MaterialConfigs;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x50];                                      // 0x0010(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FImpactConfig) == 0x000008, "Wrong alignment on FImpactConfig");
static_assert(sizeof(FImpactConfig) == 0x000060, "Wrong size on FImpactConfig");
static_assert(offsetof(FImpactConfig, MaterialConfigs) == 0x000000, "Member 'FImpactConfig::MaterialConfigs' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.TimeTrophies
// 0x0010 (0x0010 - 0x0000)
struct FTimeTrophies final
{
public:
	float                                         BronzeTime;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SilverTime;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoldTime;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlackTime;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimeTrophies) == 0x000004, "Wrong alignment on FTimeTrophies");
static_assert(sizeof(FTimeTrophies) == 0x000010, "Wrong size on FTimeTrophies");
static_assert(offsetof(FTimeTrophies, BronzeTime) == 0x000000, "Member 'FTimeTrophies::BronzeTime' has a wrong offset!");
static_assert(offsetof(FTimeTrophies, SilverTime) == 0x000004, "Member 'FTimeTrophies::SilverTime' has a wrong offset!");
static_assert(offsetof(FTimeTrophies, GoldTime) == 0x000008, "Member 'FTimeTrophies::GoldTime' has a wrong offset!");
static_assert(offsetof(FTimeTrophies, BlackTime) == 0x00000C, "Member 'FTimeTrophies::BlackTime' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.Word
// 0x0010 (0x0010 - 0x0000)
struct FWord final
{
public:
	TArray<class USoundBase*>                     Sounds;                                            // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWord) == 0x000008, "Wrong alignment on FWord");
static_assert(sizeof(FWord) == 0x000010, "Wrong size on FWord");
static_assert(offsetof(FWord, Sounds) == 0x000000, "Member 'FWord::Sounds' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.GeneralUnlock
// 0x0038 (0x0040 - 0x0008)
struct FGeneralUnlock final : public FTableRowBase
{
public:
	class FName                                   Key;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UnlockDescription;                                 // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   HowToUnlockDescription;                            // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralUnlock) == 0x000008, "Wrong alignment on FGeneralUnlock");
static_assert(sizeof(FGeneralUnlock) == 0x000040, "Wrong size on FGeneralUnlock");
static_assert(offsetof(FGeneralUnlock, Key) == 0x000008, "Member 'FGeneralUnlock::Key' has a wrong offset!");
static_assert(offsetof(FGeneralUnlock, UnlockDescription) == 0x000010, "Member 'FGeneralUnlock::UnlockDescription' has a wrong offset!");
static_assert(offsetof(FGeneralUnlock, HowToUnlockDescription) == 0x000028, "Member 'FGeneralUnlock::HowToUnlockDescription' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.CampaignLevelAccomps
// 0x0008 (0x0008 - 0x0000)
struct FCampaignLevelAccomps final
{
public:
	EDifficulty                                   HighestCompletion;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastestTime;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCampaignLevelAccomps) == 0x000004, "Wrong alignment on FCampaignLevelAccomps");
static_assert(sizeof(FCampaignLevelAccomps) == 0x000008, "Wrong size on FCampaignLevelAccomps");
static_assert(offsetof(FCampaignLevelAccomps, HighestCompletion) == 0x000000, "Member 'FCampaignLevelAccomps::HighestCompletion' has a wrong offset!");
static_assert(offsetof(FCampaignLevelAccomps, FastestTime) == 0x000004, "Member 'FCampaignLevelAccomps::FastestTime' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.NPCSave
// 0x0014 (0x0014 - 0x0000)
struct FNPCSave final
{
public:
	struct FGuid                                  UID;                                               // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlive;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNPCSave) == 0x000004, "Wrong alignment on FNPCSave");
static_assert(sizeof(FNPCSave) == 0x000014, "Wrong size on FNPCSave");
static_assert(offsetof(FNPCSave, UID) == 0x000000, "Member 'FNPCSave::UID' has a wrong offset!");
static_assert(offsetof(FNPCSave, bAlive) == 0x000010, "Member 'FNPCSave::bAlive' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.CoverPointOctreeElement
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FCoverPointOctreeElement final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCoverPointOctreeElement) == 0x000008, "Wrong alignment on FCoverPointOctreeElement");
static_assert(sizeof(FCoverPointOctreeElement) == 0x000030, "Wrong size on FCoverPointOctreeElement");

// ScriptStruct ThankYouVeryCool.DailyChallenge
// 0x0028 (0x0028 - 0x0000)
struct FDailyChallenge final
{
public:
	TSubclassOf<class UArcadeLevelAsset>          ArcadeLevelAsset;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                StartingWeapon;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGameModifier>                         Modifiers;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ECannonMode                                   CannonMode;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDailyChallenge) == 0x000008, "Wrong alignment on FDailyChallenge");
static_assert(sizeof(FDailyChallenge) == 0x000028, "Wrong size on FDailyChallenge");
static_assert(offsetof(FDailyChallenge, ArcadeLevelAsset) == 0x000000, "Member 'FDailyChallenge::ArcadeLevelAsset' has a wrong offset!");
static_assert(offsetof(FDailyChallenge, StartingWeapon) == 0x000008, "Member 'FDailyChallenge::StartingWeapon' has a wrong offset!");
static_assert(offsetof(FDailyChallenge, Modifiers) == 0x000010, "Member 'FDailyChallenge::Modifiers' has a wrong offset!");
static_assert(offsetof(FDailyChallenge, CannonMode) == 0x000020, "Member 'FDailyChallenge::CannonMode' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.DebugArrow
// 0x0020 (0x0020 - 0x0000)
struct FDebugArrow final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGenericOrUnitDebugData;                           // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugArrow) == 0x000004, "Wrong alignment on FDebugArrow");
static_assert(sizeof(FDebugArrow) == 0x000020, "Wrong size on FDebugArrow");
static_assert(offsetof(FDebugArrow, Start) == 0x000000, "Member 'FDebugArrow::Start' has a wrong offset!");
static_assert(offsetof(FDebugArrow, End) == 0x00000C, "Member 'FDebugArrow::End' has a wrong offset!");
static_assert(offsetof(FDebugArrow, Color) == 0x000018, "Member 'FDebugArrow::Color' has a wrong offset!");
static_assert(offsetof(FDebugArrow, bGenericOrUnitDebugData) == 0x00001C, "Member 'FDebugArrow::bGenericOrUnitDebugData' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ValMatList
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FValMatList final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FValMatList) == 0x000008, "Wrong alignment on FValMatList");
static_assert(sizeof(FValMatList) == 0x000010, "Wrong size on FValMatList");

// ScriptStruct ThankYouVeryCool.MaterialProperties
// 0x0030 (0x0030 - 0x0000)
struct FMaterialProperties final
{
public:
	float                                         JoulesToDestroy;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brittleness;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ImpactSound;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoZRot;                                            // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class Adebris>                    DebrisToSpawn;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageType                                   DamageType;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialType                                 MatType;                                           // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInvuln;                                         // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialProperties) == 0x000008, "Wrong alignment on FMaterialProperties");
static_assert(sizeof(FMaterialProperties) == 0x000030, "Wrong size on FMaterialProperties");
static_assert(offsetof(FMaterialProperties, JoulesToDestroy) == 0x000000, "Member 'FMaterialProperties::JoulesToDestroy' has a wrong offset!");
static_assert(offsetof(FMaterialProperties, Brittleness) == 0x000004, "Member 'FMaterialProperties::Brittleness' has a wrong offset!");
static_assert(offsetof(FMaterialProperties, Particle) == 0x000008, "Member 'FMaterialProperties::Particle' has a wrong offset!");
static_assert(offsetof(FMaterialProperties, ImpactSound) == 0x000010, "Member 'FMaterialProperties::ImpactSound' has a wrong offset!");
static_assert(offsetof(FMaterialProperties, DoZRot) == 0x000018, "Member 'FMaterialProperties::DoZRot' has a wrong offset!");
static_assert(offsetof(FMaterialProperties, DebrisToSpawn) == 0x000020, "Member 'FMaterialProperties::DebrisToSpawn' has a wrong offset!");
static_assert(offsetof(FMaterialProperties, DamageType) == 0x000028, "Member 'FMaterialProperties::DamageType' has a wrong offset!");
static_assert(offsetof(FMaterialProperties, MatType) == 0x000029, "Member 'FMaterialProperties::MatType' has a wrong offset!");
static_assert(offsetof(FMaterialProperties, bIsInvuln) == 0x00002A, "Member 'FMaterialProperties::bIsInvuln' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ImpactDamageData
// 0x000C (0x000C - 0x0000)
struct FImpactDamageData final
{
public:
	float                                         MaxRagdollAmount;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactStrength;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPushbackVelocity;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FImpactDamageData) == 0x000004, "Wrong alignment on FImpactDamageData");
static_assert(sizeof(FImpactDamageData) == 0x00000C, "Wrong size on FImpactDamageData");
static_assert(offsetof(FImpactDamageData, MaxRagdollAmount) == 0x000000, "Member 'FImpactDamageData::MaxRagdollAmount' has a wrong offset!");
static_assert(offsetof(FImpactDamageData, ImpactStrength) == 0x000004, "Member 'FImpactDamageData::ImpactStrength' has a wrong offset!");
static_assert(offsetof(FImpactDamageData, MaxPushbackVelocity) == 0x000008, "Member 'FImpactDamageData::MaxPushbackVelocity' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.GlooInfo
// 0x0020 (0x0020 - 0x0000)
struct FGlooInfo final
{
public:
	class AVoxelWorld*                            StuckWorld;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            StuckToWorld;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGlooInfo) == 0x000008, "Wrong alignment on FGlooInfo");
static_assert(sizeof(FGlooInfo) == 0x000020, "Wrong size on FGlooInfo");
static_assert(offsetof(FGlooInfo, StuckWorld) == 0x000000, "Member 'FGlooInfo::StuckWorld' has a wrong offset!");
static_assert(offsetof(FGlooInfo, StuckToWorld) == 0x000008, "Member 'FGlooInfo::StuckToWorld' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.BulletTraceViz
// 0x001C (0x001C - 0x0000)
struct FBulletTraceViz final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmStrength;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulletTraceViz) == 0x000004, "Wrong alignment on FBulletTraceViz");
static_assert(sizeof(FBulletTraceViz) == 0x00001C, "Wrong size on FBulletTraceViz");
static_assert(offsetof(FBulletTraceViz, Color) == 0x000000, "Member 'FBulletTraceViz::Color' has a wrong offset!");
static_assert(offsetof(FBulletTraceViz, Thickness) == 0x000010, "Member 'FBulletTraceViz::Thickness' has a wrong offset!");
static_assert(offsetof(FBulletTraceViz, Length) == 0x000014, "Member 'FBulletTraceViz::Length' has a wrong offset!");
static_assert(offsetof(FBulletTraceViz, EmStrength) == 0x000018, "Member 'FBulletTraceViz::EmStrength' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.GraphQueue
// 0x0028 (0x0028 - 0x0000)
struct FGraphQueue final
{
public:
	class AVoxelWorld*                            OnWorld;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x20];                                       // 0x0008(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGraphQueue) == 0x000008, "Wrong alignment on FGraphQueue");
static_assert(sizeof(FGraphQueue) == 0x000028, "Wrong size on FGraphQueue");
static_assert(offsetof(FGraphQueue, OnWorld) == 0x000000, "Member 'FGraphQueue::OnWorld' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.EditHistory
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x10) FEditHistory final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ActorTarget;                                       // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x60];                                      // 0x0060(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEditHistory) == 0x000010, "Wrong alignment on FEditHistory");
static_assert(sizeof(FEditHistory) == 0x0000C0, "Wrong size on FEditHistory");
static_assert(offsetof(FEditHistory, ActorTarget) == 0x000058, "Member 'FEditHistory::ActorTarget' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.CustomCampaignText
// 0x0010 (0x0010 - 0x0000)
struct FCustomCampaignText final
{
public:
	TArray<class FString>                         Strings;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomCampaignText) == 0x000008, "Wrong alignment on FCustomCampaignText");
static_assert(sizeof(FCustomCampaignText) == 0x000010, "Wrong size on FCustomCampaignText");
static_assert(offsetof(FCustomCampaignText, Strings) == 0x000000, "Member 'FCustomCampaignText::Strings' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.CustomCampaignStruct
// 0x0088 (0x0088 - 0x0000)
struct FCustomCampaignStruct final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorkshopID;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         LevelList;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FCustomCampaignText>            BetweenLevelText;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FCustomCampaignText                    EndScreenText;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	TArray<class UArcadeLevelAssetWorkshop*>      LevelAssets;                                       // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Author;                                            // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseScreenIndex;                                    // 0x0070(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WorkshopDescription;                               // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomCampaignStruct) == 0x000008, "Wrong alignment on FCustomCampaignStruct");
static_assert(sizeof(FCustomCampaignStruct) == 0x000088, "Wrong size on FCustomCampaignStruct");
static_assert(offsetof(FCustomCampaignStruct, DisplayName) == 0x000000, "Member 'FCustomCampaignStruct::DisplayName' has a wrong offset!");
static_assert(offsetof(FCustomCampaignStruct, WorkshopID) == 0x000010, "Member 'FCustomCampaignStruct::WorkshopID' has a wrong offset!");
static_assert(offsetof(FCustomCampaignStruct, LevelList) == 0x000020, "Member 'FCustomCampaignStruct::LevelList' has a wrong offset!");
static_assert(offsetof(FCustomCampaignStruct, BetweenLevelText) == 0x000030, "Member 'FCustomCampaignStruct::BetweenLevelText' has a wrong offset!");
static_assert(offsetof(FCustomCampaignStruct, EndScreenText) == 0x000040, "Member 'FCustomCampaignStruct::EndScreenText' has a wrong offset!");
static_assert(offsetof(FCustomCampaignStruct, LevelAssets) == 0x000050, "Member 'FCustomCampaignStruct::LevelAssets' has a wrong offset!");
static_assert(offsetof(FCustomCampaignStruct, Author) == 0x000060, "Member 'FCustomCampaignStruct::Author' has a wrong offset!");
static_assert(offsetof(FCustomCampaignStruct, UseScreenIndex) == 0x000070, "Member 'FCustomCampaignStruct::UseScreenIndex' has a wrong offset!");
static_assert(offsetof(FCustomCampaignStruct, WorkshopDescription) == 0x000078, "Member 'FCustomCampaignStruct::WorkshopDescription' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.PropCatUploadInfo
// 0x0030 (0x0030 - 0x0000)
struct FPropCatUploadInfo final
{
public:
	class FString                                 CatName;                                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorkshopID;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPropCatUploadInfo) == 0x000008, "Wrong alignment on FPropCatUploadInfo");
static_assert(sizeof(FPropCatUploadInfo) == 0x000030, "Wrong size on FPropCatUploadInfo");
static_assert(offsetof(FPropCatUploadInfo, CatName) == 0x000000, "Member 'FPropCatUploadInfo::CatName' has a wrong offset!");
static_assert(offsetof(FPropCatUploadInfo, WorkshopID) == 0x000010, "Member 'FPropCatUploadInfo::WorkshopID' has a wrong offset!");
static_assert(offsetof(FPropCatUploadInfo, Description) == 0x000020, "Member 'FPropCatUploadInfo::Description' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.EditorActorSave
// 0x0060 (0x0060 - 0x0000)
struct FEditorActorSave final
{
public:
	class FString                                 Class;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FGuid                                  Guid;                                              // 0x0040(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ActorData;                                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEditorActorSave) == 0x000010, "Wrong alignment on FEditorActorSave");
static_assert(sizeof(FEditorActorSave) == 0x000060, "Wrong size on FEditorActorSave");
static_assert(offsetof(FEditorActorSave, Class) == 0x000000, "Member 'FEditorActorSave::Class' has a wrong offset!");
static_assert(offsetof(FEditorActorSave, Transform) == 0x000010, "Member 'FEditorActorSave::Transform' has a wrong offset!");
static_assert(offsetof(FEditorActorSave, Guid) == 0x000040, "Member 'FEditorActorSave::Guid' has a wrong offset!");
static_assert(offsetof(FEditorActorSave, ActorData) == 0x000050, "Member 'FEditorActorSave::ActorData' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.CannonSkin
// 0x0050 (0x0058 - 0x0008)
struct FCannonSkin final : public FTableRowBase
{
public:
	class FText                                   Name;                                              // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         PointsToUnlock;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              SoftTexture;                                       // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseTriplanar;                                     // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEm;                                            // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwim;                                             // 0x0052(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCannonSkin) == 0x000008, "Wrong alignment on FCannonSkin");
static_assert(sizeof(FCannonSkin) == 0x000058, "Wrong size on FCannonSkin");
static_assert(offsetof(FCannonSkin, Name) == 0x000008, "Member 'FCannonSkin::Name' has a wrong offset!");
static_assert(offsetof(FCannonSkin, PointsToUnlock) == 0x000020, "Member 'FCannonSkin::PointsToUnlock' has a wrong offset!");
static_assert(offsetof(FCannonSkin, SoftTexture) == 0x000028, "Member 'FCannonSkin::SoftTexture' has a wrong offset!");
static_assert(offsetof(FCannonSkin, bUseTriplanar) == 0x000050, "Member 'FCannonSkin::bUseTriplanar' has a wrong offset!");
static_assert(offsetof(FCannonSkin, bUseEm) == 0x000051, "Member 'FCannonSkin::bUseEm' has a wrong offset!");
static_assert(offsetof(FCannonSkin, bSwim) == 0x000052, "Member 'FCannonSkin::bSwim' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.WeaponPool
// 0x0020 (0x0020 - 0x0000)
struct FWeaponPool final
{
public:
	TArray<TSubclassOf<class AWeaponBase>>        StartingWeaponPool;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AWeaponBase>>        StartingSideArmPool;                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponPool) == 0x000008, "Wrong alignment on FWeaponPool");
static_assert(sizeof(FWeaponPool) == 0x000020, "Wrong size on FWeaponPool");
static_assert(offsetof(FWeaponPool, StartingWeaponPool) == 0x000000, "Member 'FWeaponPool::StartingWeaponPool' has a wrong offset!");
static_assert(offsetof(FWeaponPool, StartingSideArmPool) == 0x000010, "Member 'FWeaponPool::StartingSideArmPool' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ActorList
// 0x0010 (0x0010 - 0x0000)
struct FActorList final
{
public:
	TArray<class AActor*>                         ActorList;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActorList) == 0x000008, "Wrong alignment on FActorList");
static_assert(sizeof(FActorList) == 0x000010, "Wrong size on FActorList");
static_assert(offsetof(FActorList, ActorList) == 0x000000, "Member 'FActorList::ActorList' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.Goal
// 0x000C (0x000C - 0x0000)
struct FGoal final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGoalType                                     Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGoal) == 0x000004, "Wrong alignment on FGoal");
static_assert(sizeof(FGoal) == 0x00000C, "Wrong size on FGoal");
static_assert(offsetof(FGoal, ID) == 0x000000, "Member 'FGoal::ID' has a wrong offset!");
static_assert(offsetof(FGoal, Type) == 0x000008, "Member 'FGoal::Type' has a wrong offset!");
static_assert(offsetof(FGoal, bCompleted) == 0x000009, "Member 'FGoal::bCompleted' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.Stage
// 0x0060 (0x0060 - 0x0000)
struct FStage final
{
public:
	float                                         IntroDelay;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   IntroText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FGoal>                          Goals;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAction>                        Actions;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          bIsCheckpoint;                                     // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CheckpointSpawnID;                                 // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStage) == 0x000008, "Wrong alignment on FStage");
static_assert(sizeof(FStage) == 0x000060, "Wrong size on FStage");
static_assert(offsetof(FStage, IntroDelay) == 0x000000, "Member 'FStage::IntroDelay' has a wrong offset!");
static_assert(offsetof(FStage, IntroText) == 0x000008, "Member 'FStage::IntroText' has a wrong offset!");
static_assert(offsetof(FStage, Goals) == 0x000020, "Member 'FStage::Goals' has a wrong offset!");
static_assert(offsetof(FStage, Actions) == 0x000040, "Member 'FStage::Actions' has a wrong offset!");
static_assert(offsetof(FStage, bIsCheckpoint) == 0x000050, "Member 'FStage::bIsCheckpoint' has a wrong offset!");
static_assert(offsetof(FStage, CheckpointSpawnID) == 0x000054, "Member 'FStage::CheckpointSpawnID' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ChapterMusicInfo
// 0x0008 (0x0008 - 0x0000)
struct FChapterMusicInfo final
{
public:
	int32                                         TrackIndex;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnCombatStart;                                // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChapterMusicInfo) == 0x000004, "Wrong alignment on FChapterMusicInfo");
static_assert(sizeof(FChapterMusicInfo) == 0x000008, "Wrong size on FChapterMusicInfo");
static_assert(offsetof(FChapterMusicInfo, TrackIndex) == 0x000000, "Member 'FChapterMusicInfo::TrackIndex' has a wrong offset!");
static_assert(offsetof(FChapterMusicInfo, bPlayOnCombatStart) == 0x000004, "Member 'FChapterMusicInfo::bPlayOnCombatStart' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.WorkshopChapterData
// 0x0020 (0x0020 - 0x0000)
struct FWorkshopChapterData final
{
public:
	TArray<struct FStage>                         Stages;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FChapterMusicInfo                      MusicInfo;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                SpawnWeapon;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorkshopChapterData) == 0x000008, "Wrong alignment on FWorkshopChapterData");
static_assert(sizeof(FWorkshopChapterData) == 0x000020, "Wrong size on FWorkshopChapterData");
static_assert(offsetof(FWorkshopChapterData, Stages) == 0x000000, "Member 'FWorkshopChapterData::Stages' has a wrong offset!");
static_assert(offsetof(FWorkshopChapterData, MusicInfo) == 0x000010, "Member 'FWorkshopChapterData::MusicInfo' has a wrong offset!");
static_assert(offsetof(FWorkshopChapterData, SpawnWeapon) == 0x000018, "Member 'FWorkshopChapterData::SpawnWeapon' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.Challenge
// 0x000C (0x000C - 0x0000)
struct FChallenge final
{
public:
	EFeat                                         Feat;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Amount;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficulty                                   CompletedAt;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallenge) == 0x000004, "Wrong alignment on FChallenge");
static_assert(sizeof(FChallenge) == 0x00000C, "Wrong size on FChallenge");
static_assert(offsetof(FChallenge, Feat) == 0x000000, "Member 'FChallenge::Feat' has a wrong offset!");
static_assert(offsetof(FChallenge, Amount) == 0x000004, "Member 'FChallenge::Amount' has a wrong offset!");
static_assert(offsetof(FChallenge, CompletedAt) == 0x000008, "Member 'FChallenge::CompletedAt' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ArcadeLevelSave
// 0x0030 (0x0030 - 0x0000)
struct FArcadeLevelSave final
{
public:
	struct FGuid                                  UniqueId;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChallenge>                     CompletedChallenges;                               // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         HighScore;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BestTime;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficulty                                   HighestDifficulty;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERank                                         HighestRank;                                       // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArcadeLevelSave) == 0x000008, "Wrong alignment on FArcadeLevelSave");
static_assert(sizeof(FArcadeLevelSave) == 0x000030, "Wrong size on FArcadeLevelSave");
static_assert(offsetof(FArcadeLevelSave, UniqueId) == 0x000000, "Member 'FArcadeLevelSave::UniqueId' has a wrong offset!");
static_assert(offsetof(FArcadeLevelSave, CompletedChallenges) == 0x000010, "Member 'FArcadeLevelSave::CompletedChallenges' has a wrong offset!");
static_assert(offsetof(FArcadeLevelSave, HighScore) == 0x000020, "Member 'FArcadeLevelSave::HighScore' has a wrong offset!");
static_assert(offsetof(FArcadeLevelSave, BestTime) == 0x000024, "Member 'FArcadeLevelSave::BestTime' has a wrong offset!");
static_assert(offsetof(FArcadeLevelSave, HighestDifficulty) == 0x000028, "Member 'FArcadeLevelSave::HighestDifficulty' has a wrong offset!");
static_assert(offsetof(FArcadeLevelSave, HighestRank) == 0x000029, "Member 'FArcadeLevelSave::HighestRank' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ChallengeDisplay
// 0x0014 (0x0014 - 0x0000)
struct FChallengeDisplay final
{
public:
	struct FChallenge                             Challenge;                                         // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CurrentProgress;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowProgessAsBinary;                              // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleted;                                        // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeDisplay) == 0x000004, "Wrong alignment on FChallengeDisplay");
static_assert(sizeof(FChallengeDisplay) == 0x000014, "Wrong size on FChallengeDisplay");
static_assert(offsetof(FChallengeDisplay, Challenge) == 0x000000, "Member 'FChallengeDisplay::Challenge' has a wrong offset!");
static_assert(offsetof(FChallengeDisplay, CurrentProgress) == 0x00000C, "Member 'FChallengeDisplay::CurrentProgress' has a wrong offset!");
static_assert(offsetof(FChallengeDisplay, bShowProgessAsBinary) == 0x000010, "Member 'FChallengeDisplay::bShowProgessAsBinary' has a wrong offset!");
static_assert(offsetof(FChallengeDisplay, bCompleted) == 0x000011, "Member 'FChallengeDisplay::bCompleted' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.GammeplayStats
// 0x0010 (0x0010 - 0x0000)
struct FGammeplayStats final
{
public:
	int32                                         Killed;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KOs;                                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotsFired;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShotsHit;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGammeplayStats) == 0x000004, "Wrong alignment on FGammeplayStats");
static_assert(sizeof(FGammeplayStats) == 0x000010, "Wrong size on FGammeplayStats");
static_assert(offsetof(FGammeplayStats, Killed) == 0x000000, "Member 'FGammeplayStats::Killed' has a wrong offset!");
static_assert(offsetof(FGammeplayStats, KOs) == 0x000004, "Member 'FGammeplayStats::KOs' has a wrong offset!");
static_assert(offsetof(FGammeplayStats, ShotsFired) == 0x000008, "Member 'FGammeplayStats::ShotsFired' has a wrong offset!");
static_assert(offsetof(FGammeplayStats, ShotsHit) == 0x00000C, "Member 'FGammeplayStats::ShotsHit' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.RogueLevelScore
// 0x0018 (0x0018 - 0x0000)
struct FRogueLevelScore final
{
public:
	int32                                         KillsGrunts;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillsJumpers;                                      // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillsHeavies;                                      // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillsShields;                                      // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillsGunners;                                      // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Explosives;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRogueLevelScore) == 0x000004, "Wrong alignment on FRogueLevelScore");
static_assert(sizeof(FRogueLevelScore) == 0x000018, "Wrong size on FRogueLevelScore");
static_assert(offsetof(FRogueLevelScore, KillsGrunts) == 0x000000, "Member 'FRogueLevelScore::KillsGrunts' has a wrong offset!");
static_assert(offsetof(FRogueLevelScore, KillsJumpers) == 0x000004, "Member 'FRogueLevelScore::KillsJumpers' has a wrong offset!");
static_assert(offsetof(FRogueLevelScore, KillsHeavies) == 0x000008, "Member 'FRogueLevelScore::KillsHeavies' has a wrong offset!");
static_assert(offsetof(FRogueLevelScore, KillsShields) == 0x00000C, "Member 'FRogueLevelScore::KillsShields' has a wrong offset!");
static_assert(offsetof(FRogueLevelScore, KillsGunners) == 0x000010, "Member 'FRogueLevelScore::KillsGunners' has a wrong offset!");
static_assert(offsetof(FRogueLevelScore, Explosives) == 0x000014, "Member 'FRogueLevelScore::Explosives' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.RogueLevel
// 0x0010 (0x0010 - 0x0000)
struct FRogueLevel final
{
public:
	TSubclassOf<class UCampaignDataAsset>         CampaignDataAsset;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UArcadeLevelAsset>          ArcadeLevelAsset;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRogueLevel) == 0x000008, "Wrong alignment on FRogueLevel");
static_assert(sizeof(FRogueLevel) == 0x000010, "Wrong size on FRogueLevel");
static_assert(offsetof(FRogueLevel, CampaignDataAsset) == 0x000000, "Member 'FRogueLevel::CampaignDataAsset' has a wrong offset!");
static_assert(offsetof(FRogueLevel, ArcadeLevelAsset) == 0x000008, "Member 'FRogueLevel::ArcadeLevelAsset' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.RogueProgressSave
// 0x0078 (0x0078 - 0x0000)
struct FRogueProgressSave final
{
public:
	TArray<TSoftObjectPtr<class UTexture>>        LevelHistory;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FRogueLevel                            NextLevel;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNextIsArcade;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0021(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           Hand;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         LevelStreak;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SpawnWeapon;                                       // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRogueConfig                           StashedRogueConfig;                                // 0x0068(0x0009)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RunTotal;                                          // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRogueProgressSave) == 0x000008, "Wrong alignment on FRogueProgressSave");
static_assert(sizeof(FRogueProgressSave) == 0x000078, "Wrong size on FRogueProgressSave");
static_assert(offsetof(FRogueProgressSave, LevelHistory) == 0x000000, "Member 'FRogueProgressSave::LevelHistory' has a wrong offset!");
static_assert(offsetof(FRogueProgressSave, NextLevel) == 0x000010, "Member 'FRogueProgressSave::NextLevel' has a wrong offset!");
static_assert(offsetof(FRogueProgressSave, bNextIsArcade) == 0x000020, "Member 'FRogueProgressSave::bNextIsArcade' has a wrong offset!");
static_assert(offsetof(FRogueProgressSave, bIsValid) == 0x000021, "Member 'FRogueProgressSave::bIsValid' has a wrong offset!");
static_assert(offsetof(FRogueProgressSave, Hand) == 0x000028, "Member 'FRogueProgressSave::Hand' has a wrong offset!");
static_assert(offsetof(FRogueProgressSave, LevelStreak) == 0x000038, "Member 'FRogueProgressSave::LevelStreak' has a wrong offset!");
static_assert(offsetof(FRogueProgressSave, SpawnWeapon) == 0x000040, "Member 'FRogueProgressSave::SpawnWeapon' has a wrong offset!");
static_assert(offsetof(FRogueProgressSave, StashedRogueConfig) == 0x000068, "Member 'FRogueProgressSave::StashedRogueConfig' has a wrong offset!");
static_assert(offsetof(FRogueProgressSave, RunTotal) == 0x000074, "Member 'FRogueProgressSave::RunTotal' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.Sentence
// 0x0010 (0x0010 - 0x0000)
struct FSentence final
{
public:
	TArray<class FName>                           Words;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSentence) == 0x000008, "Wrong alignment on FSentence");
static_assert(sizeof(FSentence) == 0x000010, "Wrong size on FSentence");
static_assert(offsetof(FSentence, Words) == 0x000000, "Member 'FSentence::Words' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.NoiseData
// 0x0014 (0x0014 - 0x0000)
struct FNoiseData final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HeardLocation;                                     // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x4];                                       // 0x0010(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNoiseData) == 0x000004, "Wrong alignment on FNoiseData");
static_assert(sizeof(FNoiseData) == 0x000014, "Wrong size on FNoiseData");
static_assert(offsetof(FNoiseData, HeardLocation) == 0x000004, "Member 'FNoiseData::HeardLocation' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.SquadOrderInfo
// 0x0028 (0x0030 - 0x0008)
struct FSquadOrderInfo final : public FTableRowBase
{
public:
	class UBehaviorTree*                          BT;                                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESituationContext                             ForSituation;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinNeeded;                                         // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAllowed;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESituationContext>                     DisqualifyingSitReps;                              // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSquadOrderInfo) == 0x000008, "Wrong alignment on FSquadOrderInfo");
static_assert(sizeof(FSquadOrderInfo) == 0x000030, "Wrong size on FSquadOrderInfo");
static_assert(offsetof(FSquadOrderInfo, BT) == 0x000008, "Member 'FSquadOrderInfo::BT' has a wrong offset!");
static_assert(offsetof(FSquadOrderInfo, ForSituation) == 0x000010, "Member 'FSquadOrderInfo::ForSituation' has a wrong offset!");
static_assert(offsetof(FSquadOrderInfo, MinNeeded) == 0x000014, "Member 'FSquadOrderInfo::MinNeeded' has a wrong offset!");
static_assert(offsetof(FSquadOrderInfo, MaxAllowed) == 0x000018, "Member 'FSquadOrderInfo::MaxAllowed' has a wrong offset!");
static_assert(offsetof(FSquadOrderInfo, DisqualifyingSitReps) == 0x000020, "Member 'FSquadOrderInfo::DisqualifyingSitReps' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.LevelSaveV2
// 0x0008 (0x0008 - 0x0000)
struct FLevelSaveV2 final
{
public:
	bool                                          bBeatClone;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeatTime;                                         // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficulty                                   HighestDifficultyCleared;                          // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BestTime;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelSaveV2) == 0x000004, "Wrong alignment on FLevelSaveV2");
static_assert(sizeof(FLevelSaveV2) == 0x000008, "Wrong size on FLevelSaveV2");
static_assert(offsetof(FLevelSaveV2, bBeatClone) == 0x000000, "Member 'FLevelSaveV2::bBeatClone' has a wrong offset!");
static_assert(offsetof(FLevelSaveV2, bBeatTime) == 0x000001, "Member 'FLevelSaveV2::bBeatTime' has a wrong offset!");
static_assert(offsetof(FLevelSaveV2, HighestDifficultyCleared) == 0x000002, "Member 'FLevelSaveV2::HighestDifficultyCleared' has a wrong offset!");
static_assert(offsetof(FLevelSaveV2, BestTime) == 0x000004, "Member 'FLevelSaveV2::BestTime' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ArcadeSettings
// 0x0048 (0x0048 - 0x0000)
struct FArcadeSettings final
{
public:
	EDifficulty                                   Difficulty;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AWeaponBase>                Weapon;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGameModifier>                         Modifiers;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UArcadeLevelAsset>          Level;                                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LevelDisplayName;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bSelectedArmCannon;                                // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectedUnarmed;                                  // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECannonMode                                   CannonMode;                                        // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNGP;                                              // 0x0043(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArcadeSettings) == 0x000008, "Wrong alignment on FArcadeSettings");
static_assert(sizeof(FArcadeSettings) == 0x000048, "Wrong size on FArcadeSettings");
static_assert(offsetof(FArcadeSettings, Difficulty) == 0x000000, "Member 'FArcadeSettings::Difficulty' has a wrong offset!");
static_assert(offsetof(FArcadeSettings, Weapon) == 0x000008, "Member 'FArcadeSettings::Weapon' has a wrong offset!");
static_assert(offsetof(FArcadeSettings, Modifiers) == 0x000010, "Member 'FArcadeSettings::Modifiers' has a wrong offset!");
static_assert(offsetof(FArcadeSettings, Level) == 0x000020, "Member 'FArcadeSettings::Level' has a wrong offset!");
static_assert(offsetof(FArcadeSettings, LevelDisplayName) == 0x000028, "Member 'FArcadeSettings::LevelDisplayName' has a wrong offset!");
static_assert(offsetof(FArcadeSettings, bSelectedArmCannon) == 0x000040, "Member 'FArcadeSettings::bSelectedArmCannon' has a wrong offset!");
static_assert(offsetof(FArcadeSettings, bSelectedUnarmed) == 0x000041, "Member 'FArcadeSettings::bSelectedUnarmed' has a wrong offset!");
static_assert(offsetof(FArcadeSettings, CannonMode) == 0x000042, "Member 'FArcadeSettings::CannonMode' has a wrong offset!");
static_assert(offsetof(FArcadeSettings, bNGP) == 0x000043, "Member 'FArcadeSettings::bNGP' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.SubShape
// 0x0060 (0x0060 - 0x0000)
struct FSubShape final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntVector                             Location;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelShape                                   Shape;                                             // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MatIdx;                                            // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoot;                                           // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 RGBValue;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAngle;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRadius;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRadius;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosAngle;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Smoothness;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubtractive;                                      // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeHollow;                                       // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShellThickness;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxSize;                                           // 0x0050(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubShape) == 0x000004, "Wrong alignment on FSubShape");
static_assert(sizeof(FSubShape) == 0x000060, "Wrong size on FSubShape");
static_assert(offsetof(FSubShape, Rotation) == 0x000000, "Member 'FSubShape::Rotation' has a wrong offset!");
static_assert(offsetof(FSubShape, Location) == 0x00000C, "Member 'FSubShape::Location' has a wrong offset!");
static_assert(offsetof(FSubShape, Shape) == 0x000018, "Member 'FSubShape::Shape' has a wrong offset!");
static_assert(offsetof(FSubShape, Radius) == 0x00001C, "Member 'FSubShape::Radius' has a wrong offset!");
static_assert(offsetof(FSubShape, Thickness) == 0x000020, "Member 'FSubShape::Thickness' has a wrong offset!");
static_assert(offsetof(FSubShape, MatIdx) == 0x000024, "Member 'FSubShape::MatIdx' has a wrong offset!");
static_assert(offsetof(FSubShape, bIsRoot) == 0x000025, "Member 'FSubShape::bIsRoot' has a wrong offset!");
static_assert(offsetof(FSubShape, RGBValue) == 0x000028, "Member 'FSubShape::RGBValue' has a wrong offset!");
static_assert(offsetof(FSubShape, Length) == 0x00002C, "Member 'FSubShape::Length' has a wrong offset!");
static_assert(offsetof(FSubShape, SinAngle) == 0x000030, "Member 'FSubShape::SinAngle' has a wrong offset!");
static_assert(offsetof(FSubShape, Height) == 0x000034, "Member 'FSubShape::Height' has a wrong offset!");
static_assert(offsetof(FSubShape, StartRadius) == 0x000038, "Member 'FSubShape::StartRadius' has a wrong offset!");
static_assert(offsetof(FSubShape, EndRadius) == 0x00003C, "Member 'FSubShape::EndRadius' has a wrong offset!");
static_assert(offsetof(FSubShape, CosAngle) == 0x000040, "Member 'FSubShape::CosAngle' has a wrong offset!");
static_assert(offsetof(FSubShape, Smoothness) == 0x000044, "Member 'FSubShape::Smoothness' has a wrong offset!");
static_assert(offsetof(FSubShape, bSubtractive) == 0x000048, "Member 'FSubShape::bSubtractive' has a wrong offset!");
static_assert(offsetof(FSubShape, bMakeHollow) == 0x000049, "Member 'FSubShape::bMakeHollow' has a wrong offset!");
static_assert(offsetof(FSubShape, ShellThickness) == 0x00004C, "Member 'FSubShape::ShellThickness' has a wrong offset!");
static_assert(offsetof(FSubShape, BoxSize) == 0x000050, "Member 'FSubShape::BoxSize' has a wrong offset!");
static_assert(offsetof(FSubShape, bDebug) == 0x00005C, "Member 'FSubShape::bDebug' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.Shape
// 0x0078 (0x0078 - 0x0000)
struct FShape final
{
public:
	struct FRotator                               Rotation;                                          // 0x0000(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FIntVector                             Location;                                          // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MatIdx;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoot;                                           // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasHinge;                                         // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x1];                                       // 0x0023(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 RGBValue;                                          // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAngle;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRadius;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRadius;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosAngle;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Smoothness;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubtractive;                                      // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeHollow;                                       // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShellThickness;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxSize;                                           // 0x004C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelShape                                   Shape;                                             // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSubShape>                      ExclusiveSubs;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShape) == 0x000008, "Wrong alignment on FShape");
static_assert(sizeof(FShape) == 0x000078, "Wrong size on FShape");
static_assert(offsetof(FShape, Rotation) == 0x000000, "Member 'FShape::Rotation' has a wrong offset!");
static_assert(offsetof(FShape, Location) == 0x00000C, "Member 'FShape::Location' has a wrong offset!");
static_assert(offsetof(FShape, Radius) == 0x000018, "Member 'FShape::Radius' has a wrong offset!");
static_assert(offsetof(FShape, Thickness) == 0x00001C, "Member 'FShape::Thickness' has a wrong offset!");
static_assert(offsetof(FShape, MatIdx) == 0x000020, "Member 'FShape::MatIdx' has a wrong offset!");
static_assert(offsetof(FShape, bIsRoot) == 0x000021, "Member 'FShape::bIsRoot' has a wrong offset!");
static_assert(offsetof(FShape, bHasHinge) == 0x000022, "Member 'FShape::bHasHinge' has a wrong offset!");
static_assert(offsetof(FShape, RGBValue) == 0x000024, "Member 'FShape::RGBValue' has a wrong offset!");
static_assert(offsetof(FShape, Length) == 0x000028, "Member 'FShape::Length' has a wrong offset!");
static_assert(offsetof(FShape, SinAngle) == 0x00002C, "Member 'FShape::SinAngle' has a wrong offset!");
static_assert(offsetof(FShape, Height) == 0x000030, "Member 'FShape::Height' has a wrong offset!");
static_assert(offsetof(FShape, StartRadius) == 0x000034, "Member 'FShape::StartRadius' has a wrong offset!");
static_assert(offsetof(FShape, EndRadius) == 0x000038, "Member 'FShape::EndRadius' has a wrong offset!");
static_assert(offsetof(FShape, CosAngle) == 0x00003C, "Member 'FShape::CosAngle' has a wrong offset!");
static_assert(offsetof(FShape, Smoothness) == 0x000040, "Member 'FShape::Smoothness' has a wrong offset!");
static_assert(offsetof(FShape, bSubtractive) == 0x000044, "Member 'FShape::bSubtractive' has a wrong offset!");
static_assert(offsetof(FShape, bMakeHollow) == 0x000045, "Member 'FShape::bMakeHollow' has a wrong offset!");
static_assert(offsetof(FShape, ShellThickness) == 0x000048, "Member 'FShape::ShellThickness' has a wrong offset!");
static_assert(offsetof(FShape, BoxSize) == 0x00004C, "Member 'FShape::BoxSize' has a wrong offset!");
static_assert(offsetof(FShape, Shape) == 0x000058, "Member 'FShape::Shape' has a wrong offset!");
static_assert(offsetof(FShape, bDebug) == 0x000059, "Member 'FShape::bDebug' has a wrong offset!");
static_assert(offsetof(FShape, ExclusiveSubs) == 0x000060, "Member 'FShape::ExclusiveSubs' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.ShapeList
// 0x0010 (0x0010 - 0x0000)
struct FShapeList final
{
public:
	TArray<struct FShape>                         List;                                              // 0x0000(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShapeList) == 0x000008, "Wrong alignment on FShapeList");
static_assert(sizeof(FShapeList) == 0x000010, "Wrong size on FShapeList");
static_assert(offsetof(FShapeList, List) == 0x000000, "Member 'FShapeList::List' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.MaterialThickness
// 0x0010 (0x0010 - 0x0000)
struct FMaterialThickness final
{
public:
	class UVoxelDataAsset*                        Material;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Thickness;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialThickness) == 0x000008, "Wrong alignment on FMaterialThickness");
static_assert(sizeof(FMaterialThickness) == 0x000010, "Wrong size on FMaterialThickness");
static_assert(offsetof(FMaterialThickness, Material) == 0x000000, "Member 'FMaterialThickness::Material' has a wrong offset!");
static_assert(offsetof(FMaterialThickness, Thickness) == 0x000008, "Member 'FMaterialThickness::Thickness' has a wrong offset!");

// ScriptStruct ThankYouVeryCool.GridIterator
// 0x0070 (0x0070 - 0x0000)
struct FGridIterator final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class AVoxelBuilder2*                         VoxelBuilder;                                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGridIterator) == 0x000008, "Wrong alignment on FGridIterator");
static_assert(sizeof(FGridIterator) == 0x000070, "Wrong size on FGridIterator");
static_assert(offsetof(FGridIterator, VoxelBuilder) == 0x000050, "Member 'FGridIterator::VoxelBuilder' has a wrong offset!");

}

