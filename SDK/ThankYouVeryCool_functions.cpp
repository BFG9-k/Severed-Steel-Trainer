#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ThankYouVeryCool

#include "Basic.hpp"

#include "ThankYouVeryCool_classes.hpp"
#include "ThankYouVeryCool_parameters.hpp"


namespace SDK
{

// Function ThankYouVeryCool.StatsManager.CheckCompletion
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FChallenge>               SaveList                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FChallenge                       ToCheck                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EDifficulty                             OutDifficulty                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStatsManager::CheckCompletion(const TArray<struct FChallenge>& SaveList, const struct FChallenge& ToCheck, EDifficulty* OutDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StatsManager", "CheckCompletion");

	Params::StatsManager_CheckCompletion Parms{};

	Parms.SaveList = std::move(SaveList);
	Parms.ToCheck = std::move(ToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDifficulty != nullptr)
		*OutDifficulty = Parms.OutDifficulty;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.StatsManager.CheckFresh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFeat                                   InFeat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AStatsManager::CheckFresh(EFeat InFeat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "CheckFresh");

	Params::StatsManager_CheckFresh Parms{};

	Parms.InFeat = InFeat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.StatsManager.DoChallengeComplete
// (Event, Public, BlueprintEvent)

void AStatsManager::DoChallengeComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "DoChallengeComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.StatsManager.FeatToChallengeText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFeat                                   InFeat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AStatsManager::FeatToChallengeText(EFeat InFeat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "FeatToChallengeText");

	Params::StatsManager_FeatToChallengeText Parms{};

	Parms.InFeat = InFeat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.StatsManager.FeatToChallengeTextSingular
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFeat                                   InFeat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AStatsManager::FeatToChallengeTextSingular(EFeat InFeat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "FeatToChallengeTextSingular");

	Params::StatsManager_FeatToChallengeTextSingular Parms{};

	Parms.InFeat = InFeat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.StatsManager.GetColorForRank
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InRank                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor AStatsManager::GetColorForRank(int32 InRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "GetColorForRank");

	Params::StatsManager_GetColorForRank Parms{};

	Parms.InRank = InRank;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.StatsManager.GetCurrentDailyCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AStatsManager::GetCurrentDailyCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "GetCurrentDailyCount");

	Params::StatsManager_GetCurrentDailyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.StatsManager.GetTextForRank
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   InRank                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AStatsManager::GetTextForRank(int32 InRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "GetTextForRank");

	Params::StatsManager_GetTextForRank Parms{};

	Parms.InRank = InRank;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.StatsManager.GiveCheevo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ToGive                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStatsManager::GiveCheevo(const class FString& ToGive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "GiveCheevo");

	Params::StatsManager_GiveCheevo Parms{};

	Parms.ToGive = std::move(ToGive);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.StatsManager.GiveCheevoOthers
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ToGive                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStatsManager::GiveCheevoOthers(class FName ToGive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "GiveCheevoOthers");

	Params::StatsManager_GiveCheevoOthers Parms{};

	Parms.ToGive = ToGive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.StatsManager.GiveCheevos
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ToGive                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AStatsManager::GiveCheevos(const TArray<class FString>& ToGive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "GiveCheevos");

	Params::StatsManager_GiveCheevos Parms{};

	Parms.ToGive = std::move(ToGive);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.StatsManager.GiveCheevosOthers
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ToGive                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AStatsManager::GiveCheevosOthers(const TArray<class FName>& ToGive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "GiveCheevosOthers");

	Params::StatsManager_GiveCheevosOthers Parms{};

	Parms.ToGive = std::move(ToGive);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.StatsManager.LoginToOSS
// (Event, Public, BlueprintEvent)

void AStatsManager::LoginToOSS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "LoginToOSS");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.StatsManager.OnGDKSessionManagerStatsRetrieved
// (Final, Native, Private)
// Parameters:
// int32                                   Headshots                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Kills                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStatsManager::OnGDKSessionManagerStatsRetrieved(int32 Headshots, int32 Kills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "OnGDKSessionManagerStatsRetrieved");

	Params::StatsManager_OnGDKSessionManagerStatsRetrieved Parms{};

	Parms.Headshots = Headshots;
	Parms.Kills = Kills;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.StatsManager.OnLevelReady
// (Final, Native, Public)

void AStatsManager::OnLevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "OnLevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.StatsManager.UpdateCheevos
// (Event, Public, BlueprintEvent)

void AStatsManager::UpdateCheevos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "UpdateCheevos");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.StatsManager.UpdateOfflineAchievements
// (Final, Native, Public, BlueprintCallable)

void AStatsManager::UpdateOfflineAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsManager", "UpdateOfflineAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CoverGeneratorComponent.GenerateCoverPoints
// (Final, Native, Public, BlueprintCallable)

void UCoverGeneratorComponent::GenerateCoverPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverGeneratorComponent", "GenerateCoverPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CoverGeneratorComponent.OnNavmeshGenerationFinished
// (Final, Native, Public)
// Parameters:
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverGeneratorComponent::OnNavmeshGenerationFinished(class ANavigationData* NavData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverGeneratorComponent", "OnNavmeshGenerationFinished");

	Params::CoverGeneratorComponent_OnNavmeshGenerationFinished Parms{};

	Parms.NavData = NavData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.SquadBT.GetBB
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBlackboardComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlackboardComponent* USquadBT::GetBB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadBT", "GetBB");

	Params::SquadBT_GetBB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.SquadBT.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USquadBT::Stop(const class FString& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadBT", "Stop");

	Params::SquadBT_Stop Parms{};

	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.AdamCrosshair.DoHitFlare
// (Event, Public, BlueprintEvent)

void UAdamCrosshair::DoHitFlare()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AdamCrosshair", "DoHitFlare");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.CloverWidget.SetDisplayedLuck
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Luck                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCloverWidget::SetDisplayedLuck(int32 Luck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloverWidget", "SetDisplayedLuck");

	Params::CloverWidget_SetDisplayedLuck Parms{};

	Parms.Luck = Luck;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.CloverWidget.SetupAsImpossible
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsImpossible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCloverWidget::SetupAsImpossible(bool bIsImpossible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CloverWidget", "SetupAsImpossible");

	Params::CloverWidget_SetupAsImpossible Parms{};

	Parms.bIsImpossible = bIsImpossible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.AmmoCountWidget.SetAkimboAmmo
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InAmmo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoCountWidget::SetAkimboAmmo(int32 InAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoCountWidget", "SetAkimboAmmo");

	Params::AmmoCountWidget_SetAkimboAmmo Parms{};

	Parms.InAmmo = InAmmo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.AmmoCountWidget.SetAmmo
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   InAmmo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoCountWidget::SetAmmo(int32 InAmmo, int32 MaxAmmo, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoCountWidget", "SetAmmo");

	Params::AmmoCountWidget_SetAmmo Parms{};

	Parms.InAmmo = InAmmo;
	Parms.MaxAmmo = MaxAmmo;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.AmmoCountWidget.SetAmmoViz
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInViz                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoCountWidget::SetAmmoViz(bool bInViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoCountWidget", "SetAmmoViz");

	Params::AmmoCountWidget_SetAmmoViz Parms{};

	Parms.bInViz = bInViz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.AmmoCountWidget.SetDesireShowAkimbo
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bDesire                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAmmoCountWidget::SetDesireShowAkimbo(bool bDesire)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoCountWidget", "SetDesireShowAkimbo");

	Params::AmmoCountWidget_SetDesireShowAkimbo Parms{};

	Parms.bDesire = bDesire;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.AmmoIndicatorComponent.ToggleBlink
// (Final, Native, Public)

void UAmmoIndicatorComponent::ToggleBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoIndicatorComponent", "ToggleBlink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TutorialGuide.SetInstructions
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bForController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGuide::SetInstructions(bool bForController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGuide", "SetInstructions");

	Params::TutorialGuide_SetInstructions Parms{};

	Parms.bForController = bForController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ConsoleIconsDataAsset.GetGamepadButtonIcon
// (Final, Native, Public)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UConsoleIconsDataAsset::GetGamepadButtonIcon(const class UObject* WorldContextObject, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleIconsDataAsset", "GetGamepadButtonIcon");

	Params::ConsoleIconsDataAsset_GetGamepadButtonIcon Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCGDKSessionManager.RequestStats
// (Final, Native, Public, BlueprintCallable)

void UTYVCGDKSessionManager::RequestStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCGDKSessionManager", "RequestStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCGDKSessionManager.SendArcadeLevelCompleteEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           LevelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCGDKSessionManager::SendArcadeLevelCompleteEvent(const class FString& LevelName, int32 Score, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCGDKSessionManager", "SendArcadeLevelCompleteEvent");

	Params::TYVCGDKSessionManager_SendArcadeLevelCompleteEvent Parms{};

	Parms.LevelName = std::move(LevelName);
	Parms.Score = Score;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCGDKSessionManager.SendFirefightLevelEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCGDKSessionManager::SendFirefightLevelEvent(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCGDKSessionManager", "SendFirefightLevelEvent");

	Params::TYVCGDKSessionManager_SendFirefightLevelEvent Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCGDKSessionManager.SendHeadshotEvent
// (Final, Native, Public, BlueprintCallable)

void UTYVCGDKSessionManager::SendHeadshotEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCGDKSessionManager", "SendHeadshotEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCGDKSessionManager.SendKillEvent
// (Final, Native, Public, BlueprintCallable)

void UTYVCGDKSessionManager::SendKillEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCGDKSessionManager", "SendKillEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CoverSystem.GetCoverSystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCoverSystem*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCoverSystem* UCoverSystem::GetCoverSystem(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CoverSystem", "GetCoverSystem");

	Params::CoverSystem_GetCoverSystem Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CoverSystem.HoldCover
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ElementLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoverSystem::HoldCover(const struct FVector& ElementLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSystem", "HoldCover");

	Params::CoverSystem_HoldCover Parms{};

	Parms.ElementLocation = std::move(ElementLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CoverSystem.OnBeginPlay
// (Final, Native, Private)

void UCoverSystem::OnBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSystem", "OnBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CoverSystem.OnNavMeshTilesUpdated
// (Final, Native, Public, HasOutParams)
// Parameters:
// TSet<uint32>                            UpdatedTiles                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCoverSystem::OnNavMeshTilesUpdated(const TSet<uint32>& UpdatedTiles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSystem", "OnNavMeshTilesUpdated");

	Params::CoverSystem_OnNavMeshTilesUpdated Parms{};

	Parms.UpdatedTiles = std::move(UpdatedTiles);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CoverSystem.ReleaseCover
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ElementLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoverSystem::ReleaseCover(const struct FVector& ElementLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSystem", "ReleaseCover");

	Params::CoverSystem_ReleaseCover Parms{};

	Parms.ElementLocation = std::move(ElementLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CoverSystem.RemoveAll
// (Final, Native, Public, BlueprintCallable)

void UCoverSystem::RemoveAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSystem", "RemoveAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CoverSystem.RemoveCoverPointsOfObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           CoverObject                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverSystem::RemoveCoverPointsOfObject(const class AActor* CoverObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSystem", "RemoveCoverPointsOfObject");

	Params::CoverSystem_RemoveCoverPointsOfObject Parms{};

	Parms.CoverObject = CoverObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CoverSystem.RemoveStaleCoverPoints
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Extent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoverSystem::RemoveStaleCoverPoints(const struct FVector& Origin, const struct FVector& Extent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoverSystem", "RemoveStaleCoverPoints");

	Params::CoverSystem_RemoveStaleCoverPoints Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Extent = std::move(Extent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCHUD.HideStartPrompt
// (Event, Public, BlueprintEvent)

void UTYVCHUD::HideStartPrompt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "HideStartPrompt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TYVCHUD.HideVictoryScreen
// (Event, Public, BlueprintEvent)

void UTYVCHUD::HideVictoryScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "HideVictoryScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TYVCHUD.IntroduceChapter
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           ChapterTitle                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnComplete                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UTYVCHUD::IntroduceChapter(const class FString& ChapterTitle, const TDelegate<void()>& OnComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "IntroduceChapter");

	Params::TYVCHUD_IntroduceChapter Parms{};

	Parms.ChapterTitle = std::move(ChapterTitle);
	Parms.OnComplete = OnComplete;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCHUD.NotifyLevelLoaded
// (Event, Public, BlueprintEvent)

void UTYVCHUD::NotifyLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "NotifyLevelLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TYVCHUD.NotifyLoadNarrativeDone
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UTYVCHUD::NotifyLoadNarrativeDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "NotifyLoadNarrativeDone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TYVCHUD.SetLoadBarViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsViz                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCHUD::SetLoadBarViz(bool bIsViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "SetLoadBarViz");

	Params::TYVCHUD_SetLoadBarViz Parms{};

	Parms.bIsViz = bIsViz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCHUD.SetupForHunt
// (Event, Public, BlueprintEvent)

void UTYVCHUD::SetupForHunt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "SetupForHunt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TYVCHUD.SetupForTime
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Time                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewTrophy                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewBestTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDifficulty                             TropyToShow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCHUD::SetupForTime(const class FString& Time, bool bNewTrophy, bool bNewBestTime, EDifficulty TropyToShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "SetupForTime");

	Params::TYVCHUD_SetupForTime Parms{};

	Parms.Time = std::move(Time);
	Parms.bNewTrophy = bNewTrophy;
	Parms.bNewBestTime = bNewBestTime;
	Parms.TropyToShow = TropyToShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCHUD.Show3Remaining
// (Event, Public, BlueprintEvent)

void UTYVCHUD::Show3Remaining()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "Show3Remaining");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TYVCHUD.ShowFinishedScreenforChapter
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Title                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowNext                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCHUD::ShowFinishedScreenforChapter(const class FString& Title, bool bShowNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "ShowFinishedScreenforChapter");

	Params::TYVCHUD_ShowFinishedScreenforChapter Parms{};

	Parms.Title = std::move(Title);
	Parms.bShowNext = bShowNext;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCHUD.ShowVictoryScreen
// (Event, Public, BlueprintEvent)

void UTYVCHUD::ShowVictoryScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "ShowVictoryScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TYVCHUD.UpdateTaskDisplay
// (Final, Native, Protected)
// Parameters:
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCHUD::UpdateTaskDisplay(float Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCHUD", "UpdateTaskDisplay");

	Params::TYVCHUD_UpdateTaskDisplay Parms{};

	Parms.Percentage = Percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCActor.CustomReset
// (Native, Event, Public, BlueprintEvent)

void ATYVCActor::CustomReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCActor", "CustomReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCActor.OnImpact
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Joules                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EImpactType                             ImpactType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATYVCActor::OnImpact(const struct FHitResult& HitResult, float Joules, EImpactType ImpactType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCActor", "OnImpact");

	Params::TYVCActor_OnImpact Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.Joules = Joules;
	Parms.ImpactType = ImpactType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCLight.CheckDistance
// (Final, Native, Protected)

void ATYVCLight::CheckDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCLight", "CheckDistance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCLight.CreateProbeLight
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATYVCProbeLight*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATYVCProbeLight* ATYVCLight::CreateProbeLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCLight", "CreateProbeLight");

	Params::TYVCLight_CreateProbeLight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCLight.UpdateFlicker
// (Final, Native, Public)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATYVCLight::UpdateFlicker(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCLight", "UpdateFlicker");

	Params::TYVCLight_UpdateFlicker Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCLight.UpdateProbeLights
// (Final, Native, Public, BlueprintCallable)

void ATYVCLight::UpdateProbeLights()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCLight", "UpdateProbeLights");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RechargeStation.GetRandomColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ARechargeStation::GetRandomColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RechargeStation", "GetRandomColor");

	Params::RechargeStation_GetRandomColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RechargeStation.OnEditorModeChange
// (Event, Public, BlueprintEvent)
// Parameters:
// EEditMode                               NewEditMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARechargeStation::OnEditorModeChange(EEditMode NewEditMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RechargeStation", "OnEditorModeChange");

	Params::RechargeStation_OnEditorModeChange Parms{};

	Parms.NewEditMode = NewEditMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.RechargeStation.OnLevelReady
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ARechargeStation::OnLevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RechargeStation", "OnLevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ANPCSpawner.LevelReady
// (Final, Native, Public)

void AANPCSpawner::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ANPCSpawner", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArcadeLevelAsset.GetLevelSave
// (Native, Public)
// Parameters:
// class ULevelEditorSave*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelEditorSave* UArcadeLevelAsset::GetLevelSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArcadeLevelAsset", "GetLevelSave");

	Params::ArcadeLevelAsset_GetLevelSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ArcadeLevelAsset.GetPreviewImage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UArcadeLevelAsset::GetPreviewImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArcadeLevelAsset", "GetPreviewImage");

	Params::ArcadeLevelAsset_GetPreviewImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ArcadeLevelAsset.GetShouldFetchImgFromDisc
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UArcadeLevelAsset::GetShouldFetchImgFromDisc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArcadeLevelAsset", "GetShouldFetchImgFromDisc");

	Params::ArcadeLevelAsset_GetShouldFetchImgFromDisc Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ArmCannon.DoCinematicOvercharge
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FTransform>               ChargePoints                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bForWorkshopSwap                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::DoCinematicOvercharge(const TArray<struct FTransform>& ChargePoints, bool bForWorkshopSwap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "DoCinematicOvercharge");

	Params::ArmCannon_DoCinematicOvercharge Parms{};

	Parms.ChargePoints = std::move(ChargePoints);
	Parms.bForWorkshopSwap = bForWorkshopSwap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ArmCannon.DoHeldObjectLogic
// (Final, Native, Public)

void AArmCannon::DoHeldObjectLogic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "DoHeldObjectLogic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.DoHeldObjectLogicDeferred
// (Final, Native, Public)

void AArmCannon::DoHeldObjectLogicDeferred()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "DoHeldObjectLogicDeferred");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.DoPunchCharge
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          WorldDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::DoPunchCharge(const struct FVector& WorldDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "DoPunchCharge");

	Params::ArmCannon_DoPunchCharge Parms{};

	Parms.WorldDir = std::move(WorldDir);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ArmCannon.FinishCharge
// (Final, Native, Protected)

void AArmCannon::FinishCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "FinishCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.FireWidePulseProjectile
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTransform                       StartingTransform                                      (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Chargetime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MagmaUV                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMega                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALuosProjectile*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALuosProjectile* AArmCannon::FireWidePulseProjectile(const struct FTransform& StartingTransform, float Chargetime, float MagmaUV, bool bMega)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "FireWidePulseProjectile");

	Params::ArmCannon_FireWidePulseProjectile Parms{};

	Parms.StartingTransform = std::move(StartingTransform);
	Parms.Chargetime = Chargetime;
	Parms.MagmaUV = MagmaUV;
	Parms.bMega = bMega;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ArmCannon.LoadSkin
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InJacket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::LoadSkin(class FName InJacket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "LoadSkin");

	Params::ArmCannon_LoadSkin Parms{};

	Parms.InJacket = InJacket;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ArmCannon.NotifyCinematicCharge
// (Event, Public, BlueprintEvent)

void AArmCannon::NotifyCinematicCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "NotifyCinematicCharge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.ArmCannon.NotifyMagPullComplete
// (Final, Native, Protected, BlueprintCallable)

void AArmCannon::NotifyMagPullComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "NotifyMagPullComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.OCChargeDone
// (Final, Native, Protected)

void AArmCannon::OCChargeDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "OCChargeDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.OCDoneFiring
// (Final, Native, Protected)

void AArmCannon::OCDoneFiring()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "OCDoneFiring");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.OnFoamHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AArmCannon::OnFoamHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "OnFoamHit");

	Params::ArmCannon_OnFoamHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.OnLevelReady
// (Final, Native, Public)

void AArmCannon::OnLevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "OnLevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.OnThrownHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AArmCannon::OnThrownHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "OnThrownHit");

	Params::ArmCannon_OnThrownHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.OnWidePulseHit
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           OnActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Chargetime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MagmaUV                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::OnWidePulseHit(const struct FTransform& Transform, class AActor* OnActor, const struct FVector& HitVelocity, const struct FHitResult& HitResult, float Chargetime, float MagmaUV, class UActorComponent* HitComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "OnWidePulseHit");

	Params::ArmCannon_OnWidePulseHit Parms{};

	Parms.Transform = std::move(Transform);
	Parms.OnActor = OnActor;
	Parms.HitVelocity = std::move(HitVelocity);
	Parms.HitResult = std::move(HitResult);
	Parms.Chargetime = Chargetime;
	Parms.MagmaUV = MagmaUV;
	Parms.HitComp = HitComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.QueryRadialForMode
// (Event, Public, BlueprintEvent)
// Parameters:
// ECannonMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECannonMode AArmCannon::QueryRadialForMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "QueryRadialForMode");

	Params::ArmCannon_QueryRadialForMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ArmCannon.RechargeFromBackpack
// (Final, Native, Public)
// Parameters:
// class UBackpack*                        BackpackComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::RechargeFromBackpack(class UBackpack* BackpackComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "RechargeFromBackpack");

	Params::ArmCannon_RechargeFromBackpack Parms{};

	Parms.BackpackComp = BackpackComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.RechargeFromStation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Station                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::RechargeFromStation(class AActor* Station)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "RechargeFromStation");

	Params::ArmCannon_RechargeFromStation Parms{};

	Parms.Station = Station;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.SetArmCannonRaise
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bShouldRaise                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::SetArmCannonRaise(bool bShouldRaise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "SetArmCannonRaise");

	Params::ArmCannon_SetArmCannonRaise Parms{};

	Parms.bShouldRaise = bShouldRaise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.SetBeamEndPoint
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InEnd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::SetBeamEndPoint(const struct FVector& InEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "SetBeamEndPoint");

	Params::ArmCannon_SetBeamEndPoint Parms{};

	Parms.InEnd = std::move(InEnd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.SetIdleSeqTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimSequence*                    IdleSeq                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::SetIdleSeqTo(class UAnimSequence* IdleSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "SetIdleSeqTo");

	Params::ArmCannon_SetIdleSeqTo Parms{};

	Parms.IdleSeq = IdleSeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.SetModeTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECannonMode                             InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::SetModeTo(ECannonMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "SetModeTo");

	Params::ArmCannon_SetModeTo Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.SetVisualsForMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECannonMode                             ForMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::SetVisualsForMode(ECannonMode ForMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "SetVisualsForMode");

	Params::ArmCannon_SetVisualsForMode Parms{};

	Parms.ForMode = ForMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.ShowChargePercent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::ShowChargePercent(float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "ShowChargePercent");

	Params::ArmCannon_ShowChargePercent Parms{};

	Parms.InPercent = InPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.ShowOvercharge
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::ShowOvercharge(bool bShow, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "ShowOvercharge");

	Params::ArmCannon_ShowOvercharge Parms{};

	Parms.bShow = bShow;
	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ArmCannon.StartPullObject
// (Event, Protected, BlueprintEvent)

void AArmCannon::StartPullObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "StartPullObject");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.ArmCannon.StartWPAim
// (Event, Protected, BlueprintEvent)

void AArmCannon::StartWPAim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "StartWPAim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.ArmCannon.StopPullObject
// (Event, Protected, BlueprintEvent)

void AArmCannon::StopPullObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "StopPullObject");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.ArmCannon.StopWPAim
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AArmCannon::StopWPAim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "StopWPAim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.ArmCannon.TickCharge
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AArmCannon::TickCharge(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "TickCharge");

	Params::ArmCannon_TickCharge Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannon.TryDoPassiveRecharge
// (Final, Native, Public)

void AArmCannon::TryDoPassiveRecharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannon", "TryDoPassiveRecharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ArmCannonModeWidget.GetSelectedMode
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECannonMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECannonMode UArmCannonModeWidget::GetSelectedMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannonModeWidget", "GetSelectedMode");

	Params::ArmCannonModeWidget_GetSelectedMode Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ArmCannonModeWidget.SetupModes
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<ECannonMode>                     Modes                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UArmCannonModeWidget::SetupModes(const TArray<ECannonMode>& Modes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmCannonModeWidget", "SetupModes");

	Params::ArmCannonModeWidget_SetupModes Parms{};

	Parms.Modes = std::move(Modes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Backpack.DoRocketBurst
// (Final, Native, Public)

void UBackpack::DoRocketBurst()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Backpack", "DoRocketBurst");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Backpack.FinishMuzzleFlash
// (Final, Native, Private)

void UBackpack::FinishMuzzleFlash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Backpack", "FinishMuzzleFlash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Backpack.RocketsLoaded
// (Final, Native, Public)

void UBackpack::RocketsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Backpack", "RocketsLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Backpack.ShootMinigun
// (Final, Native, Public)

void UBackpack::ShootMinigun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Backpack", "ShootMinigun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Backpack.ShootRocket
// (Final, Native, Public)

void UBackpack::ShootRocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Backpack", "ShootRocket");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Backpack.TickMuzzleFlash
// (Final, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBackpack::TickMuzzleFlash(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Backpack", "TickMuzzleFlash");

	Params::Backpack_TickMuzzleFlash Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.AddBoxToGenerator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          BoxDims                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHollow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShellSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelMaterial                          Mat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           RGB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsRoot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSub                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::AddBoxToGenerator(const struct FVector& BoxDims, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot, bool bIsSub)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "AddBoxToGenerator");

	Params::VoxelBuilder2_AddBoxToGenerator Parms{};

	Parms.BoxDims = std::move(BoxDims);
	Parms.bHollow = bHollow;
	Parms.ShellSize = ShellSize;
	Parms.Mat = Mat;
	Parms.RGB = std::move(RGB);
	Parms.bIsRoot = bIsRoot;
	Parms.bIsSub = bIsSub;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.AddHexPrismGenerator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHollow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShellSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelMaterial                          Mat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           RGB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsRoot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::AddHexPrismGenerator(float Radius, float Thickness, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "AddHexPrismGenerator");

	Params::VoxelBuilder2_AddHexPrismGenerator Parms{};

	Parms.Radius = Radius;
	Parms.Thickness = Thickness;
	Parms.bHollow = bHollow;
	Parms.ShellSize = ShellSize;
	Parms.Mat = Mat;
	Parms.RGB = std::move(RGB);
	Parms.bIsRoot = bIsRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.AddOctohedronToGenerator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHollow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShellSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelMaterial                          Mat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           RGB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsRoot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::AddOctohedronToGenerator(float Radius, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "AddOctohedronToGenerator");

	Params::VoxelBuilder2_AddOctohedronToGenerator Parms{};

	Parms.Radius = Radius;
	Parms.bHollow = bHollow;
	Parms.ShellSize = ShellSize;
	Parms.Mat = Mat;
	Parms.RGB = std::move(RGB);
	Parms.bIsRoot = bIsRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.AddRoundedCylinderGenerator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Smoothness                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHollow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShellSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelMaterial                          Mat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           RGB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsRoot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::AddRoundedCylinderGenerator(float Radius, float Smoothness, float Height, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "AddRoundedCylinderGenerator");

	Params::VoxelBuilder2_AddRoundedCylinderGenerator Parms{};

	Parms.Radius = Radius;
	Parms.Smoothness = Smoothness;
	Parms.Height = Height;
	Parms.bHollow = bHollow;
	Parms.ShellSize = ShellSize;
	Parms.Mat = Mat;
	Parms.RGB = std::move(RGB);
	Parms.bIsRoot = bIsRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.AddTorusGenerator
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHollow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShellSize                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVoxelMaterial                          Mat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           RGB                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsRoot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::AddTorusGenerator(float Radius, float Thickness, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "AddTorusGenerator");

	Params::VoxelBuilder2_AddTorusGenerator Parms{};

	Parms.Radius = Radius;
	Parms.Thickness = Thickness;
	Parms.bHollow = bHollow;
	Parms.ShellSize = ShellSize;
	Parms.Mat = Mat;
	Parms.RGB = std::move(RGB);
	Parms.bIsRoot = bIsRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.BlueprintBuildImp
// (Event, Public, BlueprintEvent)

void AVoxelBuilder2::BlueprintBuildImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "BlueprintBuildImp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.VoxelBuilder2.Build
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bStampToOuterWorlds                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceSubtractive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSubtractFromAll                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::Build(bool bStampToOuterWorlds, bool bForceSubtractive, bool bSubtractFromAll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "Build");

	Params::VoxelBuilder2_Build Parms{};

	Parms.bStampToOuterWorlds = bStampToOuterWorlds;
	Parms.bForceSubtractive = bForceSubtractive;
	Parms.bSubtractFromAll = bSubtractFromAll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.Build_Imp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bStampToOuterWorlds                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceSubtractive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVoxelBuilder2::Build_Imp(bool bStampToOuterWorlds, bool bForceSubtractive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "Build_Imp");

	Params::VoxelBuilder2_Build_Imp Parms{};

	Parms.bStampToOuterWorlds = bStampToOuterWorlds;
	Parms.bForceSubtractive = bForceSubtractive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.VoxelBuilder2.DeleteManagedAssets
// (Final, Native, Public, BlueprintCallable)

void AVoxelBuilder2::DeleteManagedAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "DeleteManagedAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.GetOuterWorldsAffected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AVoxelWorld*>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AVoxelWorld*> AVoxelBuilder2::GetOuterWorldsAffected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "GetOuterWorldsAffected");

	Params::VoxelBuilder2_GetOuterWorldsAffected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.VoxelBuilder2.GetTurtleWorldTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AVoxelBuilder2::GetTurtleWorldTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "GetTurtleWorldTransform");

	Params::VoxelBuilder2_GetTurtleWorldTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.VoxelBuilder2.MoveTurtle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Units                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMinusOne                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::MoveTurtle(int32 Units, bool bMinusOne)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "MoveTurtle");

	Params::VoxelBuilder2_MoveTurtle Parms{};

	Parms.Units = Units;
	Parms.bMinusOne = bMinusOne;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.RebuildAllCalled
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AVoxelBuilder2::RebuildAllCalled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "RebuildAllCalled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.VoxelBuilder2.ReturnTurtleToRoot
// (Final, Native, Public, BlueprintCallable)

void AVoxelBuilder2::ReturnTurtleToRoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "ReturnTurtleToRoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.RotateTurtle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         RotateDelta                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AVoxelBuilder2::RotateTurtle(const struct FRotator& RotateDelta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "RotateTurtle");

	Params::VoxelBuilder2_RotateTurtle Parms{};

	Parms.RotateDelta = std::move(RotateDelta);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.SetTurtleWorldTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       ToSet                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AVoxelBuilder2::SetTurtleWorldTransform(const struct FTransform& ToSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "SetTurtleWorldTransform");

	Params::VoxelBuilder2_SetTurtleWorldTransform Parms{};

	Parms.ToSet = std::move(ToSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.SlideTurtleRight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Units                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMinusOne                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::SlideTurtleRight(int32 Units, bool bMinusOne)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "SlideTurtleRight");

	Params::VoxelBuilder2_SlideTurtleRight Parms{};

	Parms.Units = Units;
	Parms.bMinusOne = bMinusOne;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.SlideTurtleUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Units                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMinusOne                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::SlideTurtleUp(int32 Units, bool bMinusOne)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "SlideTurtleUp");

	Params::VoxelBuilder2_SlideTurtleUp Parms{};

	Parms.Units = Units;
	Parms.bMinusOne = bMinusOne;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.SpawnActorAtTurtle
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ToSpawn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnedActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::SpawnActorAtTurtle(TSubclassOf<class AActor> ToSpawn, class AActor** SpawnedActor, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "SpawnActorAtTurtle");

	Params::VoxelBuilder2_SpawnActorAtTurtle Parms{};

	Parms.ToSpawn = ToSpawn;
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = Parms.SpawnedActor;
}


// Function ThankYouVeryCool.VoxelBuilder2.SpawnActorsInGrid
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   XDistance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   YDistance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   XCount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   YCount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       OffsetSpawnLocation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RotationFromTurtleStart                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SpawnFirstAtCurrentLocation                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrimFromMiddleX                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrimFromMiddleY                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToTrimFromEdgeX                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToTrimFromEdgeY                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::SpawnActorsInGrid(int32 XDistance, int32 YDistance, int32 XCount, int32 YCount, TSubclassOf<class AActor> ActorClass, const struct FIntVector& OffsetSpawnLocation, const struct FRotator& RotationFromTurtleStart, TArray<class AActor*>* OutActors, const struct FVector& Scale, bool SpawnFirstAtCurrentLocation, int32 TrimFromMiddleX, int32 TrimFromMiddleY, int32 ToTrimFromEdgeX, int32 ToTrimFromEdgeY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "SpawnActorsInGrid");

	Params::VoxelBuilder2_SpawnActorsInGrid Parms{};

	Parms.XDistance = XDistance;
	Parms.YDistance = YDistance;
	Parms.XCount = XCount;
	Parms.YCount = YCount;
	Parms.ActorClass = ActorClass;
	Parms.OffsetSpawnLocation = std::move(OffsetSpawnLocation);
	Parms.RotationFromTurtleStart = std::move(RotationFromTurtleStart);
	Parms.Scale = std::move(Scale);
	Parms.SpawnFirstAtCurrentLocation = SpawnFirstAtCurrentLocation;
	Parms.TrimFromMiddleX = TrimFromMiddleX;
	Parms.TrimFromMiddleY = TrimFromMiddleY;
	Parms.ToTrimFromEdgeX = ToTrimFromEdgeX;
	Parms.ToTrimFromEdgeY = ToTrimFromEdgeY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function ThankYouVeryCool.VoxelBuilder2.SpawnActorsInLine
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   LineDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActorCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       OffsetSpawnLocation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         RotationFromLine                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnTurtleWhenFinished                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SpawnFirstAtCurrentLocation                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrimFromMiddle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrimFromEdge                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::SpawnActorsInLine(int32 LineDistance, int32 ActorCount, TSubclassOf<class AActor> ActorClass, const struct FIntVector& OffsetSpawnLocation, const struct FRotator& RotationFromLine, TArray<class AActor*>* OutActors, const struct FVector& Scale, bool ReturnTurtleWhenFinished, bool SpawnFirstAtCurrentLocation, int32 TrimFromMiddle, int32 TrimFromEdge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "SpawnActorsInLine");

	Params::VoxelBuilder2_SpawnActorsInLine Parms{};

	Parms.LineDistance = LineDistance;
	Parms.ActorCount = ActorCount;
	Parms.ActorClass = ActorClass;
	Parms.OffsetSpawnLocation = std::move(OffsetSpawnLocation);
	Parms.RotationFromLine = std::move(RotationFromLine);
	Parms.Scale = std::move(Scale);
	Parms.ReturnTurtleWhenFinished = ReturnTurtleWhenFinished;
	Parms.SpawnFirstAtCurrentLocation = SpawnFirstAtCurrentLocation;
	Parms.TrimFromMiddle = TrimFromMiddle;
	Parms.TrimFromEdge = TrimFromEdge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function ThankYouVeryCool.VoxelBuilder2.StampActors
// (Final, Native, Public)

void AVoxelBuilder2::StampActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "StampActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.StampAssets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Priority_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bToOuterWorld                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVoxelBuilder2::StampAssets(int32 Priority_0, bool bToOuterWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "StampAssets");

	Params::VoxelBuilder2_StampAssets Parms{};

	Parms.Priority_0 = Priority_0;
	Parms.bToOuterWorld = bToOuterWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.VoxelBuilder2.TestSpawn
// (Final, Native, Public, BlueprintCallable)

void AVoxelBuilder2::TestSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "TestSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelBuilder2.TurnTurtleYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Degrees                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoxelBuilder2::TurnTurtleYaw(int32 Degrees)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelBuilder2", "TurnTurtleYaw");

	Params::VoxelBuilder2_TurnTurtleYaw Parms{};

	Parms.Degrees = Degrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.BloodSplatter.OnHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABloodSplatter::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodSplatter", "OnHit");

	Params::BloodSplatter_OnHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComponent = OtherComponent;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.SquadTask_Base.GetBB
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBehaviorTreeComponent*           BTComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlackboardComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlackboardComponent* USquadTask_Base::GetBB(class UBehaviorTreeComponent* BTComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadTask_Base", "GetBB");

	Params::SquadTask_Base_GetBB Parms{};

	Parms.BTComp = BTComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.SquadTask_Base.GetSquadBT
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBehaviorTreeComponent*           BTComp                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USquadBT*                         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USquadBT* USquadTask_Base::GetSquadBT(class UBehaviorTreeComponent* BTComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SquadTask_Base", "GetSquadBT");

	Params::SquadTask_Base_GetSquadBT Parms{};

	Parms.BTComp = BTComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.BTS_OperateWeapon.BurstShot
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   BurstLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CoolDownTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTS_OperateWeapon::BurstShot(float BurstLength, float CoolDownTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTS_OperateWeapon", "BurstShot");

	Params::BTS_OperateWeapon_BurstShot Parms{};

	Parms.BurstLength = BurstLength;
	Parms.CoolDownTime = CoolDownTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.BTS_OperateWeapon.MagDump
// (Event, Protected, BlueprintEvent)

void UBTS_OperateWeapon::MagDump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTS_OperateWeapon", "MagDump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.BTS_OperateWeapon.ReloadComplete
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTS_OperateWeapon::ReloadComplete(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTS_OperateWeapon", "ReloadComplete");

	Params::BTS_OperateWeapon_ReloadComplete Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.BTS_OperateWeapon.SingleShot
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   CoolDownTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTS_OperateWeapon::SingleShot(float CoolDownTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTS_OperateWeapon", "SingleShot");

	Params::BTS_OperateWeapon_SingleShot Parms{};

	Parms.CoolDownTime = CoolDownTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.BTTask_DrawSidearm.DrawComplete
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBTTask_DrawSidearm::DrawComplete(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_DrawSidearm", "DrawComplete");

	Params::BTTask_DrawSidearm_DrawComplete Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.BuildingBoundsTrigger.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABuildingBoundsTrigger::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuildingBoundsTrigger", "OnOverlapBegin");

	Params::BuildingBoundsTrigger_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.BuildingBoundsTrigger.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABuildingBoundsTrigger::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuildingBoundsTrigger", "OnOverlapEnd");

	Params::BuildingBoundsTrigger_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.BulletTrace.TickFade
// (Final, Native, Private)

void ABulletTrace::TickFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BulletTrace", "TickFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignIDInterface.GetID
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ICampaignIDInterface::GetID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignIDInterface", "GetID");

	Params::CampaignIDInterface_GetID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CampaignIDInterface.SetHighlighted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsHighlighted                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICampaignIDInterface::SetHighlighted(bool bIsHighlighted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignIDInterface", "SetHighlighted");

	Params::CampaignIDInterface_SetHighlighted Parms{};

	Parms.bIsHighlighted = bIsHighlighted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.CampaignManager.AttachArmCannon
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::AttachArmCannon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "AttachArmCannon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.CleanupEdenMap
// (Event, Protected, BlueprintEvent)

void ACampaignManager::CleanupEdenMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "CleanupEdenMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.CampaignManager.DoCompassReveal
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::DoCompassReveal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "DoCompassReveal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.DoEdenMapThing
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             To                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DestinationText                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACampaignManager::DoEdenMapThing(class FName From, class FName To, const class FText& DestinationText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "DoEdenMapThing");

	Params::CampaignManager_DoEdenMapThing Parms{};

	Parms.From = From;
	Parms.To = To;
	Parms.DestinationText = std::move(DestinationText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.CampaignManager.EndCampaignLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             NextChapter                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::EndCampaignLevel(TSoftClassPtr<class UClass> NextChapter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "EndCampaignLevel");

	Params::CampaignManager_EndCampaignLevel Parms{};

	Parms.NextChapter = NextChapter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.FadeAndStopGameplay
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::FadeAndStopGameplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "FadeAndStopGameplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.FinishNewLevelSave
// (Final, Native, Public)

void ACampaignManager::FinishNewLevelSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "FinishNewLevelSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.GetCurrentChapter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AChapter*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AChapter* ACampaignManager::GetCurrentChapter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "GetCurrentChapter");

	Params::CampaignManager_GetCurrentChapter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CampaignManager.GetNewPlayer
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       AtTransform                                            (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeaponBase>          WithWeapon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MagCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerCharacter*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerCharacter* ACampaignManager::GetNewPlayer(const struct FTransform& AtTransform, TSubclassOf<class AWeaponBase> WithWeapon, int32 MagCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "GetNewPlayer");

	Params::CampaignManager_GetNewPlayer Parms{};

	Parms.AtTransform = std::move(AtTransform);
	Parms.WithWeapon = WithWeapon;
	Parms.MagCount = MagCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CampaignManager.NodeLoadDuringGameplayDone
// (Final, Native, Public)
// Parameters:
// struct FTYVCNodeMemory                  InNodeMemory                                           (Parm, NativeAccessSpecifierPublic)

void ACampaignManager::NodeLoadDuringGameplayDone(const struct FTYVCNodeMemory& InNodeMemory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "NodeLoadDuringGameplayDone");

	Params::CampaignManager_NodeLoadDuringGameplayDone Parms{};

	Parms.InNodeMemory = std::move(InNodeMemory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.NodeUnloaded
// (Final, Native, Public)
// Parameters:
// TArray<class FName>                     NodeName                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACampaignManager::NodeUnloaded(const TArray<class FName>& NodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "NodeUnloaded");

	Params::CampaignManager_NodeUnloaded Parms{};

	Parms.NodeName = std::move(NodeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.NotifyActorDestroyed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActorId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::NotifyActorDestroyed(class FName ActorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "NotifyActorDestroyed");

	Params::CampaignManager_NotifyActorDestroyed Parms{};

	Parms.ActorId = ActorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.NotifyActorTookDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActorId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::NotifyActorTookDamage(class FName ActorId, float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "NotifyActorTookDamage");

	Params::CampaignManager_NotifyActorTookDamage Parms{};

	Parms.ActorId = ActorId;
	Parms.Damage = Damage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.NotifyCinematicChargeEnd
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::NotifyCinematicChargeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "NotifyCinematicChargeEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.NotifyCustomEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::NotifyCustomEvent(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "NotifyCustomEvent");

	Params::CampaignManager_NotifyCustomEvent Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.NotifyFadeOutOver
// (Final, Native, Public)

void ACampaignManager::NotifyFadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "NotifyFadeOutOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.PickupCallPressed
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::PickupCallPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "PickupCallPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.PlayCutscene
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UFileMediaSource*                 InSource                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::PlayCutscene(class UFileMediaSource* InSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "PlayCutscene");

	Params::CampaignManager_PlayCutscene Parms{};

	Parms.InSource = InSource;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.CampaignManager.PlayerRequestedNextChapter
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::PlayerRequestedNextChapter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "PlayerRequestedNextChapter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.PossessPlayer
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::PossessPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "PossessPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.RequestFadeIn
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::RequestFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "RequestFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.RequestFadeOut
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::RequestFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "RequestFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.RequestKillPlayer
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::RequestKillPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "RequestKillPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.RequestLevelLoad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::RequestLevelLoad(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "RequestLevelLoad");

	Params::CampaignManager_RequestLevelLoad Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.RequestLevelStart
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::RequestLevelStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "RequestLevelStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.RequestReturnToMainMenu
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::RequestReturnToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "RequestReturnToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.SaveCampaign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             OnChapter                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDifficulty                             ForDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCampaignDataAsset*               LoadedNextAsset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::SaveCampaign(TSoftClassPtr<class UClass> OnChapter, EDifficulty ForDifficulty, class UCampaignDataAsset* LoadedNextAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "SaveCampaign");

	Params::CampaignManager_SaveCampaign Parms{};

	Parms.OnChapter = OnChapter;
	Parms.ForDifficulty = ForDifficulty;
	Parms.LoadedNextAsset = LoadedNextAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.SetCustomEmmisiveColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::SetCustomEmmisiveColor(int32 Channel, const struct FColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "SetCustomEmmisiveColor");

	Params::CampaignManager_SetCustomEmmisiveColor Parms{};

	Parms.Channel = Channel;
	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.SetPlayFDVid
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bShouldPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::SetPlayFDVid(bool bShouldPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "SetPlayFDVid");

	Params::CampaignManager_SetPlayFDVid Parms{};

	Parms.bShouldPlay = bShouldPlay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.CampaignManager.SpawnNPCDuringChapter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class ANPC>                 ClassToSpawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class ACampaignMarker*                  MyMarker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnUnleased                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::SpawnNPCDuringChapter(TSubclassOf<class ANPC> ClassToSpawn, const struct FTransform& SpawnTransform, class ACampaignMarker* MyMarker, bool bSpawnUnleased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "SpawnNPCDuringChapter");

	Params::CampaignManager_SpawnNPCDuringChapter Parms{};

	Parms.ClassToSpawn = ClassToSpawn;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.MyMarker = MyMarker;
	Parms.bSpawnUnleased = bSpawnUnleased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.StartChapterObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCampaignDataAsset>   InData                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDifficulty                             Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSkip                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::StartChapterObject(TSubclassOf<class UCampaignDataAsset> InData, EDifficulty Difficulty, bool bIsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "StartChapterObject");

	Params::CampaignManager_StartChapterObject Parms{};

	Parms.InData = InData;
	Parms.Difficulty = Difficulty;
	Parms.bIsSkip = bIsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.StartChapterObjectWorkshop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UArcadeLevelAssetWorkshop*        InAsset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDifficulty                             Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSkip                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::StartChapterObjectWorkshop(class UArcadeLevelAssetWorkshop* InAsset, EDifficulty Difficulty, bool bIsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "StartChapterObjectWorkshop");

	Params::CampaignManager_StartChapterObjectWorkshop Parms{};

	Parms.InAsset = InAsset;
	Parms.Difficulty = Difficulty;
	Parms.bIsSkip = bIsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.StartCustomCampaign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomCampaign*                  InAsset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDifficulty                             Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSkip                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::StartCustomCampaign(class UCustomCampaign* InAsset, EDifficulty Difficulty, bool bIsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "StartCustomCampaign");

	Params::CampaignManager_StartCustomCampaign Parms{};

	Parms.InAsset = InAsset;
	Parms.Difficulty = Difficulty;
	Parms.bIsSkip = bIsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.UnloadFadeOutOver
// (Final, Native, Public, BlueprintCallable)

void ACampaignManager::UnloadFadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "UnloadFadeOutOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignManager.UnloadOver
// (Final, Native, Public)
// Parameters:
// class FName                             UnloadedName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignManager::UnloadOver(class FName UnloadedName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignManager", "UnloadOver");

	Params::CampaignManager_UnloadOver Parms{};

	Parms.UnloadedName = UnloadedName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignMarker.DoManualSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceSpecial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipFX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignMarker::DoManualSpawn(bool bForceSpecial, bool bSkipFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignMarker", "DoManualSpawn");

	Params::CampaignMarker_DoManualSpawn Parms{};

	Parms.bForceSpecial = bForceSpecial;
	Parms.bSkipFX = bSkipFX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignMarker.EditorModeChanged_Implementation
// (Final, Native, Public)
// Parameters:
// EEditMode                               NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignMarker::EditorModeChanged_Implementation(EEditMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignMarker", "EditorModeChanged_Implementation");

	Params::CampaignMarker_EditorModeChanged_Implementation Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignMarker.GetRandomSpecialType
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class ANPC>                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ANPC> ACampaignMarker::GetRandomSpecialType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignMarker", "GetRandomSpecialType");

	Params::CampaignMarker_GetRandomSpecialType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.EditorModeChanged_Implementation
// (Final, Native, Public)
// Parameters:
// EEditMode                               NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignTriggerVolume::EditorModeChanged_Implementation(EEditMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "EditorModeChanged_Implementation");

	Params::CampaignTriggerVolume_EditorModeChanged_Implementation Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.ForceLevelReady
// (Final, Native, Public, BlueprintCallable)

void ACampaignTriggerVolume::ForceLevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "ForceLevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.GetNPCsWithin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ANPC*>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ANPC*> ACampaignTriggerVolume::GetNPCsWithin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "GetNPCsWithin");

	Params::CampaignTriggerVolume_GetNPCsWithin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.LevelReady
// (Final, Native, Public)

void ACampaignTriggerVolume::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.LevelReset
// (Final, Native, Public)

void ACampaignTriggerVolume::LevelReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "LevelReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignTriggerVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "OnOverlapBegin");

	Params::CampaignTriggerVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignTriggerVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "OnOverlapEnd");

	Params::CampaignTriggerVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.SetDims
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InDims                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignTriggerVolume::SetDims(const struct FVector& InDims)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "SetDims");

	Params::CampaignTriggerVolume_SetDims Parms{};

	Parms.InDims = std::move(InDims);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.SetHighlightedHUD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHighlighted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignTriggerVolume::SetHighlightedHUD(bool bHighlighted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "SetHighlightedHUD");

	Params::CampaignTriggerVolume_SetHighlightedHUD Parms{};

	Parms.bHighlighted = bHighlighted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.SetInteractable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInteractable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignTriggerVolume::SetInteractable(bool bInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "SetInteractable");

	Params::CampaignTriggerVolume_SetInteractable Parms{};

	Parms.bInteractable = bInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.CampaignTriggerVolume.SetNavBlocking
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bNavBlocking                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACampaignTriggerVolume::SetNavBlocking(bool bNavBlocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CampaignTriggerVolume", "SetNavBlocking");

	Params::CampaignTriggerVolume_SetNavBlocking Parms{};

	Parms.bNavBlocking = bNavBlocking;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.CardData.GetTYVCGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AThankYouVeryCoolGameMode*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AThankYouVeryCoolGameMode* UCardData::GetTYVCGameMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CardData", "GetTYVCGameMode");

	Params::CardData_GetTYVCGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.CardData.OnFirstAdded
// (Event, Public, BlueprintEvent)

void UCardData::OnFirstAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CardData", "OnFirstAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.CardData.OnGameplayStart
// (Event, Public, BlueprintEvent)

void UCardData::OnGameplayStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CardData", "OnGameplayStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.CardData.OnLevelEnd
// (Event, Public, BlueprintEvent)

void UCardData::OnLevelEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CardData", "OnLevelEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.CallBWOverDel
// (Final, Native, Public, BlueprintCallable)

void AChameleon::CallBWOverDel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "CallBWOverDel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.CallOnBlinkClosed
// (Final, Native, Public, BlueprintCallable)

void AChameleon::CallOnBlinkClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "CallOnBlinkClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.CancelBWFade
// (Event, Public, BlueprintEvent)

void AChameleon::CancelBWFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "CancelBWFade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.DoBlink
// (Event, Public, BlueprintEvent)

void AChameleon::DoBlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "DoBlink");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.DoHeadshot
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          HeadshotLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChameleon::DoHeadshot(const struct FVector& HeadshotLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "DoHeadshot");

	Params::Chameleon_DoHeadshot Parms{};

	Parms.HeadshotLocation = std::move(HeadshotLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chameleon.DoHitEffect
// (Event, Public, BlueprintEvent)

void AChameleon::DoHitEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "DoHitEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.FadeOutToArcade
// (Event, Public, BlueprintEvent)

void AChameleon::FadeOutToArcade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "FadeOutToArcade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.FadeToBW
// (Event, Public, BlueprintEvent)

void AChameleon::FadeToBW()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "FadeToBW");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.ForceFadeOutOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChameleon::ForceFadeOutOpacity(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "ForceFadeOutOpacity");

	Params::Chameleon_ForceFadeOutOpacity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.ForceStopHitEffect
// (Event, Public, BlueprintEvent)

void AChameleon::ForceStopHitEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "ForceStopHitEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.GetPPVol
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APostProcessVolume*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APostProcessVolume* AChameleon::GetPPVol()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "GetPPVol");

	Params::Chameleon_GetPPVol Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Chameleon.GetPPVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APostProcessVolume*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APostProcessVolume* AChameleon::GetPPVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "GetPPVolume");

	Params::Chameleon_GetPPVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Chameleon.HideBloodOnScreen
// (Final, Native, Public)

void AChameleon::HideBloodOnScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "HideBloodOnScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.LerpFadeIn
// (Event, Public, BlueprintEvent)

void AChameleon::LerpFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "LerpFadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.LerpFadeInFromLoad
// (Event, Public, BlueprintEvent)

void AChameleon::LerpFadeInFromLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "LerpFadeInFromLoad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.LerpFadeInToChallenges
// (Event, Public, BlueprintEvent)

void AChameleon::LerpFadeInToChallenges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "LerpFadeInToChallenges");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.LerpFadeInToReset
// (Event, Public, BlueprintEvent)

void AChameleon::LerpFadeInToReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "LerpFadeInToReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.LerpFadeOut
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   SpeedModifier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChameleon::LerpFadeOut(float SpeedModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "LerpFadeOut");

	Params::Chameleon_LerpFadeOut Parms{};

	Parms.SpeedModifier = SpeedModifier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chameleon.LerpFadeOutToChallenges
// (Event, Public, BlueprintEvent)

void AChameleon::LerpFadeOutToChallenges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "LerpFadeOutToChallenges");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.LerpFadeOutToLoad
// (Event, Public, BlueprintEvent)

void AChameleon::LerpFadeOutToLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "LerpFadeOutToLoad");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.LerpFadeOutToReset
// (Event, Public, BlueprintEvent)

void AChameleon::LerpFadeOutToReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "LerpFadeOutToReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chameleon.SetBlinkHalfOpen
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOpen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChameleon::SetBlinkHalfOpen(bool bOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "SetBlinkHalfOpen");

	Params::Chameleon_SetBlinkHalfOpen Parms{};

	Parms.bOpen = bOpen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chameleon.SetEffectSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SpeedFactor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChameleon::SetEffectSpeed(float SpeedFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "SetEffectSpeed");

	Params::Chameleon_SetEffectSpeed Parms{};

	Parms.SpeedFactor = SpeedFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.ShowBloodOnScreen
// (Final, Native, Public)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChameleon::ShowBloodOnScreen(float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "ShowBloodOnScreen");

	Params::Chameleon_ShowBloodOnScreen Parms{};

	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.StuntFadeInEnd
// (Final, Native, Protected)

void AChameleon::StuntFadeInEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "StuntFadeInEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.StuntFadeInUpdate
// (Final, Native, Protected)

void AChameleon::StuntFadeInUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "StuntFadeInUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.StuntFadeOutEnd
// (Final, Native, Protected)

void AChameleon::StuntFadeOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "StuntFadeOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chameleon.StuntFadeOutUpdate
// (Final, Native, Protected)

void AChameleon::StuntFadeOutUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chameleon", "StuntFadeOutUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ChangeNotifyingRecastNavMesh.OnNavmeshGenerationFinishedHandler
// (Final, Native, Public)
// Parameters:
// class ANavigationData*                  NavData                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChangeNotifyingRecastNavMesh::OnNavmeshGenerationFinishedHandler(class ANavigationData* NavData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChangeNotifyingRecastNavMesh", "OnNavmeshGenerationFinishedHandler");

	Params::ChangeNotifyingRecastNavMesh_OnNavmeshGenerationFinishedHandler Parms{};

	Parms.NavData = NavData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ChangeNotifyingRecastNavMesh.ProcessQueuedTiles
// (Final, Native, Public)

void AChangeNotifyingRecastNavMesh::ProcessQueuedTiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChangeNotifyingRecastNavMesh", "ProcessQueuedTiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TypewriterTextBlock.PlayFromStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       FinishedDel                                            (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class USoundBase*                       SoundToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTypewriterTextBlock::PlayFromStart(TDelegate<void()> FinishedDel, class USoundBase* SoundToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TypewriterTextBlock", "PlayFromStart");

	Params::TypewriterTextBlock_PlayFromStart Parms{};

	Parms.FinishedDel = FinishedDel;
	Parms.SoundToPlay = SoundToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TypewriterTextBlock.SetSpeedToFast
// (Final, Native, Public, BlueprintCallable)

void UTypewriterTextBlock::SetSpeedToFast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TypewriterTextBlock", "SetSpeedToFast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TypewriterTextBlock.SetSpeedToNormal
// (Final, Native, Public, BlueprintCallable)

void UTypewriterTextBlock::SetSpeedToNormal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TypewriterTextBlock", "SetSpeedToNormal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TypewriterTextBlock.SetTextToType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTypewriterTextBlock::SetTextToType(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TypewriterTextBlock", "SetTextToType");

	Params::TypewriterTextBlock_SetTextToType Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TypewriterTextBlock.Tick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTypewriterTextBlock::Tick(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TypewriterTextBlock", "Tick");

	Params::TypewriterTextBlock_Tick Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chapter.CancelMyDelays
// (Final, Native, Public, BlueprintCallable)

void AChapter::CancelMyDelays()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "CancelMyDelays");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chapter.EndChapter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             NextChapter                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::EndChapter(TSoftClassPtr<class UClass> NextChapter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "EndChapter");

	Params::Chapter_EndChapter Parms{};

	Parms.NextChapter = NextChapter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chapter.GetActorFromID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               GetAsClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* AChapter::GetActorFromID(class FName InID, TSubclassOf<class AActor> GetAsClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "GetActorFromID");

	Params::Chapter_GetActorFromID Parms{};

	Parms.InID = InID;
	Parms.GetAsClass = GetAsClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Chapter.GetActorsFromID
// (Final, Native, Public)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> AChapter::GetActorsFromID(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "GetActorsFromID");

	Params::Chapter_GetActorsFromID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Chapter.GetLevelsToLoad
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> AChapter::GetLevelsToLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "GetLevelsToLoad");

	Params::Chapter_GetLevelsToLoad Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Chapter.GetLightsFromID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AEditorLight*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AEditorLight*> AChapter::GetLightsFromID(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "GetLightsFromID");

	Params::Chapter_GetLightsFromID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Chapter.GetPlayerSpawnTransform
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AChapter::GetPlayerSpawnTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "GetPlayerSpawnTransform");

	Params::Chapter_GetPlayerSpawnTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Chapter.GetTransformOfID
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AChapter::GetTransformOfID(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "GetTransformOfID");

	Params::Chapter_GetTransformOfID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Chapter.NotifyActivatedSlowMo
// (Event, Public, BlueprintEvent)

void AChapter::NotifyActivatedSlowMo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyActivatedSlowMo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyActorDestroyed
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::NotifyActorDestroyed(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyActorDestroyed");

	Params::Chapter_NotifyActorDestroyed Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chapter.NotifyActorTookDamage
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::NotifyActorTookDamage(class FName ID, float Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyActorTookDamage");

	Params::Chapter_NotifyActorTookDamage Parms{};

	Parms.ID = ID;
	Parms.Damage = Damage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chapter.NotifyCinematicChargeEnded
// (Event, Public, BlueprintEvent)

void AChapter::NotifyCinematicChargeEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyCinematicChargeEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyCombatStarted
// (Event, Public, BlueprintEvent)

void AChapter::NotifyCombatStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyCombatStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyCustomEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::NotifyCustomEvent(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyCustomEvent");

	Params::Chapter_NotifyCustomEvent Parms{};

	Parms.EventName = EventName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chapter.NotifyDidWallRun
// (Event, Public, BlueprintEvent)

void AChapter::NotifyDidWallRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyDidWallRun");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyDidWallRunJump
// (Event, Public, BlueprintEvent)

void AChapter::NotifyDidWallRunJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyDidWallRunJump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyFadeInOver
// (Event, Public, BlueprintEvent)

void AChapter::NotifyFadeInOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyFadeInOver");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyFadeOutOver
// (Event, Public, BlueprintEvent)

void AChapter::NotifyFadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyFadeOutOver");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyKickslideStart
// (Event, Public, BlueprintEvent)

void AChapter::NotifyKickslideStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyKickslideStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyLevelLoaded
// (Event, Public, BlueprintEvent)

void AChapter::NotifyLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyLevelLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyLoadComplete
// (Event, Public, BlueprintEvent)

void AChapter::NotifyLoadComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyLoadComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyLoadNarrativeOver
// (Final, Native, Public, BlueprintCallable)

void AChapter::NotifyLoadNarrativeOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyLoadNarrativeOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chapter.NotifyLoadStart
// (Event, Public, BlueprintEvent)

void AChapter::NotifyLoadStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyLoadStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyLongLoadStarted
// (Event, Public, BlueprintEvent)

void AChapter::NotifyLongLoadStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyLongLoadStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyNPCDied
// (Event, Public, BlueprintEvent)
// Parameters:
// class ANPC*                             DeadNPC                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::NotifyNPCDied(class ANPC* DeadNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyNPCDied");

	Params::Chapter_NotifyNPCDied Parms{};

	Parms.DeadNPC = DeadNPC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chapter.NotifyOverlapStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OhterActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TriggerVolume                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::NotifyOverlapStart(class FName ID, class AActor* OhterActor, class AActor* TriggerVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyOverlapStart");

	Params::Chapter_NotifyOverlapStart Parms{};

	Parms.ID = ID;
	Parms.OhterActor = OhterActor;
	Parms.TriggerVolume = TriggerVolume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chapter.NotifyOverlapStop
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::NotifyOverlapStop(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyOverlapStop");

	Params::Chapter_NotifyOverlapStop Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chapter.NotifyPlayerDive
// (Event, Public, BlueprintEvent)

void AChapter::NotifyPlayerDive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyPlayerDive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyPlayerDoubleJump
// (Event, Public, BlueprintEvent)

void AChapter::NotifyPlayerDoubleJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyPlayerDoubleJump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyPlayerEndedKickslide
// (Event, Public, BlueprintEvent)

void AChapter::NotifyPlayerEndedKickslide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyPlayerEndedKickslide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyPlayerMoveStatus
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsMoving                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::NotifyPlayerMoveStatus(bool bIsMoving)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyPlayerMoveStatus");

	Params::Chapter_NotifyPlayerMoveStatus Parms{};

	Parms.bIsMoving = bIsMoving;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chapter.NotifyReset
// (Event, Public, BlueprintEvent)

void AChapter::NotifyReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifySteelDied
// (Event, Public, BlueprintEvent)

void AChapter::NotifySteelDied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifySteelDied");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.NotifyVoxelDamage
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::NotifyVoxelDamage(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "NotifyVoxelDamage");

	Params::Chapter_NotifyVoxelDamage Parms{};

	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Chapter.OnAllNPCsDead
// (Event, Public, BlueprintEvent)

void AChapter::OnAllNPCsDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "OnAllNPCsDead");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.OnCannonEmpty
// (Event, Public, BlueprintEvent)

void AChapter::OnCannonEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "OnCannonEmpty");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.OnCannonRecharge
// (Event, Public, BlueprintEvent)

void AChapter::OnCannonRecharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "OnCannonRecharge");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.OnCannonRechargeFromStation
// (Event, Public, BlueprintEvent)

void AChapter::OnCannonRechargeFromStation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "OnCannonRechargeFromStation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.OnEvePickedUpWeapon
// (Event, Public, BlueprintEvent)

void AChapter::OnEvePickedUpWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "OnEvePickedUpWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.OnSkipTo
// (Event, Public, BlueprintEvent)

void AChapter::OnSkipTo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "OnSkipTo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.OnSpawnsOver
// (Event, Public, BlueprintEvent)

void AChapter::OnSpawnsOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "OnSpawnsOver");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.OnWeaponEmpty
// (Event, Public, BlueprintEvent)

void AChapter::OnWeaponEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "OnWeaponEmpty");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.RequestObjectiveReminder
// (Event, Public, BlueprintEvent)

void AChapter::RequestObjectiveReminder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "RequestObjectiveReminder");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.SetObjectiveText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoNotify                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChapter::SetObjectiveText(const class FString& Text, bool bDoNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "SetObjectiveText");

	Params::Chapter_SetObjectiveText Parms{};

	Parms.Text = std::move(Text);
	Parms.bDoNotify = bDoNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Chapter.SetupLoaded
// (Event, Public, BlueprintEvent)

void AChapter::SetupLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "SetupLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.SetupNew
// (Event, Public, BlueprintEvent)

void AChapter::SetupNew()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "SetupNew");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.StartLoadedSave
// (Event, Public, BlueprintEvent)

void AChapter::StartLoadedSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "StartLoadedSave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Chapter.StartNew
// (Event, Public, BlueprintEvent)

void AChapter::StartNew()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chapter", "StartNew");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.DailyManager.GetTimespanAsString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        In                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADailyManager::GetTimespanAsString(const struct FTimespan& In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DailyManager", "GetTimespanAsString");

	Params::DailyManager_GetTimespanAsString Parms{};

	Parms.In = std::move(In);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.TimespanTicksNegative
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        In                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADailyManager::TimespanTicksNegative(const struct FTimespan& In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DailyManager", "TimespanTicksNegative");

	Params::DailyManager_TimespanTicksNegative Parms{};

	Parms.In = std::move(In);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.GetChallengeFromDateTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        DateTimeIn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDailyChallenge                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDailyChallenge ADailyManager::GetChallengeFromDateTime(const struct FDateTime& DateTimeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "GetChallengeFromDateTime");

	Params::DailyManager_GetChallengeFromDateTime Parms{};

	Parms.DateTimeIn = std::move(DateTimeIn);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.GetConsoleLeaderboardNameFromChallenge
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Challenge                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADailyManager::GetConsoleLeaderboardNameFromChallenge(const class FString& Challenge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "GetConsoleLeaderboardNameFromChallenge");

	Params::DailyManager_GetConsoleLeaderboardNameFromChallenge Parms{};

	Parms.Challenge = std::move(Challenge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.GetConsoleNetworkDateTimeUTC
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime ADailyManager::GetConsoleNetworkDateTimeUTC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "GetConsoleNetworkDateTimeUTC");

	Params::DailyManager_GetConsoleNetworkDateTimeUTC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.GetMyDateTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime ADailyManager::GetMyDateTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "GetMyDateTime");

	Params::DailyManager_GetMyDateTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.GetMyString
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Out                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADailyManager::GetMyString(class FString* Out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "GetMyString");

	Params::DailyManager_GetMyString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Out != nullptr)
		*Out = std::move(Parms.Out);
}


// Function ThankYouVeryCool.DailyManager.GetSecondsToMidnight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADailyManager::GetSecondsToMidnight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "GetSecondsToMidnight");

	Params::DailyManager_GetSecondsToMidnight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.GetSpanToMidnight
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan ADailyManager::GetSpanToMidnight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "GetSpanToMidnight");

	Params::DailyManager_GetSpanToMidnight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.GetYesterday
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        InDateTime                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutString                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        OutDateTime                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADailyManager::GetYesterday(const struct FDateTime& InDateTime, class FString* OutString, struct FDateTime* OutDateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "GetYesterday");

	Params::DailyManager_GetYesterday Parms{};

	Parms.InDateTime = std::move(InDateTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutString != nullptr)
		*OutString = std::move(Parms.OutString);

	if (OutDateTime != nullptr)
		*OutDateTime = std::move(Parms.OutDateTime);
}


// Function ThankYouVeryCool.DailyManager.HasStringBeenSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADailyManager::HasStringBeenSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "HasStringBeenSet");

	Params::DailyManager_HasStringBeenSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.DailyManager.InvalidateString
// (Final, Native, Public, BlueprintCallable)

void ADailyManager::InvalidateString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "InvalidateString");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.DailyManager.PlayChallenge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDailyChallenge                  ToPlay                                                 (Parm, NativeAccessSpecifierPublic)
// EDifficulty                             InDiff                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADailyManager::PlayChallenge(const struct FDailyChallenge& ToPlay, EDifficulty InDiff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "PlayChallenge");

	Params::DailyManager_PlayChallenge Parms{};

	Parms.ToPlay = std::move(ToPlay);
	Parms.InDiff = InDiff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.DailyManager.SetTodayAsDateTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        InDt                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADailyManager::SetTodayAsDateTime(const struct FDateTime& InDt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyManager", "SetTodayAsDateTime");

	Params::DailyManager_SetTodayAsDateTime Parms{};

	Parms.InDt = std::move(InDt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.debris.OnStop
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              SleepingComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void Adebris::OnStop(class UPrimitiveComponent* SleepingComponent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("debris", "OnStop");

	Params::debris_OnStop Parms{};

	Parms.SleepingComponent = SleepingComponent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCAnimInstance_Post.SetALSMovementModeC
// (Event, Public, BlueprintEvent)
// Parameters:
// EMovementMode                           MovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCAnimInstance_Post::SetALSMovementModeC(EMovementMode MovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCAnimInstance_Post", "SetALSMovementModeC");

	Params::TYVCAnimInstance_Post_SetALSMovementModeC Parms{};

	Parms.MovementMode = MovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCAnimInstance_Post.SetIKEnabledC
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCAnimInstance_Post::SetIKEnabledC(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCAnimInstance_Post", "SetIKEnabledC");

	Params::TYVCAnimInstance_Post_SetIKEnabledC Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.DroppedCasing.UpdateEject
// (Final, Native, Public)

void ADroppedCasing::UpdateEject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedCasing", "UpdateEject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorInterface.DoActions
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EActionType                             ToDo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSimulated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEditorInterface::DoActions(EActionType ToDo, bool bSimulated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "DoActions");

	Params::EditorInterface_DoActions Parms{};

	Parms.ToDo = ToDo;
	Parms.bSimulated = bSimulated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorInterface.EditorModeChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EEditMode                               NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEditorInterface::EditorModeChanged(EEditMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "EditorModeChanged");

	Params::EditorInterface_EditorModeChanged Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorInterface.GetActions
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<EActionType>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EActionType> IEditorInterface::GetActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "GetActions");

	Params::EditorInterface_GetActions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.EditorInterface.GetGoals
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<EGoalType>                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EGoalType> IEditorInterface::GetGoals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "GetGoals");

	Params::EditorInterface_GetGoals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.EditorInterface.GetShouldSave
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IEditorInterface::GetShouldSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "GetShouldSave");

	Params::EditorInterface_GetShouldSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.EditorInterface.NotifyMoved
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IEditorInterface::NotifyMoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "NotifyMoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorInterface.NotifyPlayingReverse
// (Event, Public, BlueprintEvent)

void IEditorInterface::NotifyPlayingReverse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "NotifyPlayingReverse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.EditorInterface.PostDataLoaded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IEditorInterface::PostDataLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "PostDataLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorInterface.SetInEditor
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInEditor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEditorInterface::SetInEditor(bool bInEditor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "SetInEditor");

	Params::EditorInterface_SetInEditor Parms{};

	Parms.bInEditor = bInEditor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorInterface.SetSelected
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsSelected                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEditorInterface::SetSelected(bool bIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorInterface", "SetSelected");

	Params::EditorInterface_SetSelected Parms{};

	Parms.bIsSelected = bIsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorLight.DoShortFlicker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ForTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEditorLight::DoShortFlicker(float ForTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorLight", "DoShortFlicker");

	Params::EditorLight_DoShortFlicker Parms{};

	Parms.ForTime = ForTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorLight.EditorModeChanged_Implementation
// (Final, Native, Public)
// Parameters:
// EEditMode                               NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEditorLight::EditorModeChanged_Implementation(EEditMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorLight", "EditorModeChanged_Implementation");

	Params::EditorLight_EditorModeChanged_Implementation Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorLight.LevelReady
// (Final, Native, Public)

void AEditorLight::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorLight", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorLight.PostSettingsChanged
// (Final, Native, Public)

void AEditorLight::PostSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorLight", "PostSettingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorLight.RandomizeLightColor
// (Final, Native, Public, BlueprintCallable)

void AEditorLight::RandomizeLightColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorLight", "RandomizeLightColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorLight.SetFlicker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFlicker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEditorLight::SetFlicker(bool bFlicker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorLight", "SetFlicker");

	Params::EditorLight_SetFlicker Parms{};

	Parms.bFlicker = bFlicker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.EditorLight.Setup
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Temp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSaveTransaction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInShowWhenSimple                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEditorLight::Setup(float Intensity, float Temp, float Radius, const struct FColor& Color, bool bSaveTransaction, bool bInShowWhenSimple)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EditorLight", "Setup");

	Params::EditorLight_Setup Parms{};

	Parms.Intensity = Intensity;
	Parms.Temp = Temp;
	Parms.Radius = Radius;
	Parms.Color = std::move(Color);
	Parms.bSaveTransaction = bSaveTransaction;
	Parms.bInShowWhenSimple = bInShowWhenSimple;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.FeedbackActor.DoFade
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Stack                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFeedbackActor::DoFade(int32 Stack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FeedbackActor", "DoFade");

	Params::FeedbackActor_DoFade Parms{};

	Parms.Stack = Stack;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.FeedbackActor.FadeOver
// (Final, Native, Public, BlueprintCallable)

void AFeedbackActor::FadeOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FeedbackActor", "FadeOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.FeedbackActor.OnLevelUnload
// (Final, Native, Private)

void AFeedbackActor::OnLevelUnload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FeedbackActor", "OnLevelUnload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.FeedbackActor.SetupText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AFeedbackActor::SetupText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FeedbackActor", "SetupText");

	Params::FeedbackActor_SetupText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.FeedbackActor.SetupTexture
// (Event, Public, BlueprintEvent)
// Parameters:
// EFeedback                               ForType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFeedbackActor::SetupTexture(EFeedback ForType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FeedbackActor", "SetupTexture");

	Params::FeedbackActor_SetupTexture Parms{};

	Parms.ForType = ForType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.FeedbackActor.SetupValue
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFeedbackActor::SetupValue(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FeedbackActor", "SetupValue");

	Params::FeedbackActor_SetupValue Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.FireNumberOfShots.FireShots
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ANPC*                             InShooter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InShotCount                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFireNumberOfShots*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFireNumberOfShots* UFireNumberOfShots::FireShots(class ANPC* InShooter, const int32 InShotCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FireNumberOfShots", "FireShots");

	Params::FireNumberOfShots_FireShots Parms{};

	Parms.InShooter = InShooter;
	Parms.InShotCount = InShotCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.FireNumberOfShots.Chambered
// (Final, Native, Private)

void UFireNumberOfShots::Chambered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireNumberOfShots", "Chambered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.FireNumberOfShots.ExecuteAfterShootingComplete
// (Final, Native, Private)

void UFireNumberOfShots::ExecuteAfterShootingComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireNumberOfShots", "ExecuteAfterShootingComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCPS5ActivityManager.CheckEndCampaign
// (Final, Native, Public, BlueprintCallable)

void UTYVCPS5ActivityManager::CheckEndCampaign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPS5ActivityManager", "CheckEndCampaign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCPS5ActivityManager.EndCampaign
// (Final, Native, Public, BlueprintCallable)

void UTYVCPS5ActivityManager::EndCampaign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPS5ActivityManager", "EndCampaign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCPS5ActivityManager.IsCampaignActivityLaunchRequested
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCPS5ActivityManager::IsCampaignActivityLaunchRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPS5ActivityManager", "IsCampaignActivityLaunchRequested");

	Params::TYVCPS5ActivityManager_IsCampaignActivityLaunchRequested Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCPS5ActivityManager.ResetCampaignActivityLaunchRequest
// (Final, Native, Public, BlueprintCallable)

void UTYVCPS5ActivityManager::ResetCampaignActivityLaunchRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPS5ActivityManager", "ResetCampaignActivityLaunchRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCPS5ActivityManager.ResumeCampaign
// (Final, Native, Public, BlueprintCallable)

void UTYVCPS5ActivityManager::ResumeCampaign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPS5ActivityManager", "ResumeCampaign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCPS5ActivityManager.SimulateLaunchPS5CampaignActivity
// (Final, Native, Public, BlueprintCallable)

void UTYVCPS5ActivityManager::SimulateLaunchPS5CampaignActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPS5ActivityManager", "SimulateLaunchPS5CampaignActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCPS5ActivityManager.StartCampaign
// (Final, Native, Public, BlueprintCallable)

void UTYVCPS5ActivityManager::StartCampaign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPS5ActivityManager", "StartCampaign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.FoamVoxelWorld.DoDestruction
// (Native, Event, Public, BlueprintEvent)

void AFoamVoxelWorld::DoDestruction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FoamVoxelWorld", "DoDestruction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.FoamVoxelWorld.DoLurch
// (Native, Event, Public, BlueprintEvent)

void AFoamVoxelWorld::DoLurch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FoamVoxelWorld", "DoLurch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.FoamVoxelWorld.DoMaterialize
// (Event, Public, BlueprintEvent)

void AFoamVoxelWorld::DoMaterialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FoamVoxelWorld", "DoMaterialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.FootstepComponent.UpdateOnLand
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFootstepComponent::UpdateOnLand(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepComponent", "UpdateOnLand");

	Params::FootstepComponent_UpdateOnLand Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameMenuWidget.ClosePauseScreen
// (Event, Public, BlueprintEvent)

void UGameMenuWidget::ClosePauseScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "ClosePauseScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.DoEndGameCredits
// (Event, Public, BlueprintEvent)

void UGameMenuWidget::DoEndGameCredits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "DoEndGameCredits");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.DoPreGame
// (Event, Public, BlueprintEvent)

void UGameMenuWidget::DoPreGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "DoPreGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.FadeIn
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UGameMenuWidget::FadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "FadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.FadeOut
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UGameMenuWidget::FadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "FadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.GetDefaultFocus
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UGameMenuWidget::GetDefaultFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "GetDefaultFocus");

	Params::GameMenuWidget_GetDefaultFocus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameMenuWidget.GetPauseDefaultFocus
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UGameMenuWidget::GetPauseDefaultFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "GetPauseDefaultFocus");

	Params::GameMenuWidget_GetPauseDefaultFocus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameMenuWidget.PlayVideos
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UGameMenuWidget::PlayVideos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "PlayVideos");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.ShowArcadeScreen
// (Event, Public, BlueprintEvent)

void UGameMenuWidget::ShowArcadeScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "ShowArcadeScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.ShowCampaignLevelSelectScreen
// (Event, Public, BlueprintEvent)

void UGameMenuWidget::ShowCampaignLevelSelectScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "ShowCampaignLevelSelectScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.ShowChallengeScreen
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UGameMenuWidget::ShowChallengeScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "ShowChallengeScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.ShowPauseScreen
// (Event, Public, BlueprintEvent)

void UGameMenuWidget::ShowPauseScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "ShowPauseScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.ShowRogueScreen
// (Event, Public, BlueprintEvent)

void UGameMenuWidget::ShowRogueScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "ShowRogueScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameMenuWidget.ShowThisVictoryWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidget*                      InWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuWidget::ShowThisVictoryWidget(class UUserWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "ShowThisVictoryWidget");

	Params::GameMenuWidget_ShowThisVictoryWidget Parms{};

	Parms.InWidget = InWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameMenuWidget.StartArcade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDifficulty                             Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               GameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnWithArmCannon                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCustomLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArcadeLevelAsset*                InAsset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBizarre                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuWidget::StartArcade(EDifficulty Difficulty, EGameType GameType, bool bSpawnWithArmCannon, bool bCustomLevel, class UArcadeLevelAsset* InAsset, bool bBizarre)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "StartArcade");

	Params::GameMenuWidget_StartArcade Parms{};

	Parms.Difficulty = Difficulty;
	Parms.GameType = GameType;
	Parms.bSpawnWithArmCannon = bSpawnWithArmCannon;
	Parms.bCustomLevel = bCustomLevel;
	Parms.InAsset = InAsset;
	Parms.bBizarre = bBizarre;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameMenuWidget.StartLevelEditorLoad
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UArcadeLevelAssetWorkshop*        LevelAsset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuWidget::StartLevelEditorLoad(class UArcadeLevelAssetWorkshop* LevelAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "StartLevelEditorLoad");

	Params::GameMenuWidget_StartLevelEditorLoad Parms{};

	Parms.LevelAsset = LevelAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameMenuWidget.StartLevelEditorNew
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FString                           LevelPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuWidget::StartLevelEditorNew(const class FString& LevelPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "StartLevelEditorNew");

	Params::GameMenuWidget_StartLevelEditorNew Parms{};

	Parms.LevelPath = std::move(LevelPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameMenuWidget.StartLevelEditorVox
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FString                           LevelPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameMenuWidget::StartLevelEditorVox(const class FString& LevelPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "StartLevelEditorVox");

	Params::GameMenuWidget_StartLevelEditorVox Parms{};

	Parms.LevelPath = std::move(LevelPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameMenuWidget.StopVideos
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UGameMenuWidget::StopVideos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameMenuWidget", "StopVideos");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TYVCConsoleLeaderboardManager.OnSonyPrivilegeCheckComplete
// (Final, Native, Private)

void UTYVCConsoleLeaderboardManager::OnSonyPrivilegeCheckComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCConsoleLeaderboardManager", "OnSonyPrivilegeCheckComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayGask_EndArcade.TaskEndArcade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayGask_EndArcade*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayGask_EndArcade* UGameplayGask_EndArcade::TaskEndArcade(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class AThankYouVeryCoolGameMode* InGameMode, EGameType InGameType, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayGask_EndArcade", "TaskEndArcade");

	Params::GameplayGask_EndArcade_TaskEndArcade Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InGameMode = InGameMode;
	Parms.InGameType = InGameType;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayGask_EndArcade.FadeOutOver
// (Final, Native, Public)

void UGameplayGask_EndArcade::FadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayGask_EndArcade", "FadeOutOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayGask_EndArcade.NodeUnloaded
// (Final, Native, Public)
// Parameters:
// TArray<class FName>                     Levelnames                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UGameplayGask_EndArcade::NodeUnloaded(const TArray<class FName>& Levelnames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayGask_EndArcade", "NodeUnloaded");

	Params::GameplayGask_EndArcade_NodeUnloaded Parms{};

	Parms.Levelnames = std::move(Levelnames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayHUD.DoExploitDetected
// (Event, Public, BlueprintEvent)

void UGameplayHUD::DoExploitDetected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "DoExploitDetected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameplayHUD.DoFresh
// (Event, Public, BlueprintEvent)
// Parameters:
// EFeat                                   ForFeat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::DoFresh(EFeat ForFeat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "DoFresh");

	Params::GameplayHUD_DoFresh Parms{};

	Parms.ForFeat = ForFeat;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.DoStale
// (Event, Public, BlueprintEvent)
// Parameters:
// EFeat                                   ForFeat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::DoStale(EFeat ForFeat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "DoStale");

	Params::GameplayHUD_DoStale Parms{};

	Parms.ForFeat = ForFeat;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.FocusOnWeapon
// (Event, Public, BlueprintEvent)
// Parameters:
// class AWeaponBase*                      ToFocus                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::FocusOnWeapon(class AWeaponBase* ToFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "FocusOnWeapon");

	Params::GameplayHUD_FocusOnWeapon Parms{};

	Parms.ToFocus = ToFocus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.NotifyCannonMode
// (Event, Public, BlueprintEvent)
// Parameters:
// ECannonMode                             NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::NotifyCannonMode(ECannonMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "NotifyCannonMode");

	Params::GameplayHUD_NotifyCannonMode Parms{};

	Parms.NewMode = NewMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.RefreshCards
// (Event, Public, BlueprintEvent)

void UGameplayHUD::RefreshCards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "RefreshCards");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameplayHUD.SetAmmoViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetAmmoViz(bool bViz, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetAmmoViz");

	Params::GameplayHUD_SetAmmoViz Parms{};

	Parms.bViz = bViz;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCannonChargeViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsViz                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCannonChargeViz(bool bIsViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCannonChargeViz");

	Params::GameplayHUD_SetCannonChargeViz Parms{};

	Parms.bIsViz = bIsViz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCannonPercentage
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCannonPercentage(float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCannonPercentage");

	Params::GameplayHUD_SetCannonPercentage Parms{};

	Parms.InPercent = InPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCannonShots
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Total                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCannonShots(int32 Left, int32 Total)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCannonShots");

	Params::GameplayHUD_SetCannonShots Parms{};

	Parms.Left = Left;
	Parms.Total = Total;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCannonShotsViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsViz                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCannonShotsViz(bool bIsViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCannonShotsViz");

	Params::GameplayHUD_SetCannonShotsViz Parms{};

	Parms.bIsViz = bIsViz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCardsViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCardsViz(bool bViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCardsViz");

	Params::GameplayHUD_SetCardsViz Parms{};

	Parms.bViz = bViz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCompassViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCompassViz(bool bViz, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCompassViz");

	Params::GameplayHUD_SetCompassViz Parms{};

	Parms.bViz = bViz;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCompressedHUD
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bCompressed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCompressedHUD(bool bCompressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCompressedHUD");

	Params::GameplayHUD_SetCompressedHUD Parms{};

	Parms.bCompressed = bCompressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCrosshairTexture
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTexture2D*                       ToSet                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCrosshairTexture(class UTexture2D* ToSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCrosshairTexture");

	Params::GameplayHUD_SetCrosshairTexture Parms{};

	Parms.ToSet = ToSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetCrosshairViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetCrosshairViz(bool bViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetCrosshairViz");

	Params::GameplayHUD_SetCrosshairViz Parms{};

	Parms.bViz = bViz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetEnemiesRemaining
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Remaining                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Total                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetEnemiesRemaining(int32 Remaining, int32 Total)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetEnemiesRemaining");

	Params::GameplayHUD_SetEnemiesRemaining Parms{};

	Parms.Remaining = Remaining;
	Parms.Total = Total;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetKickPromptViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Viz                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetKickPromptViz(bool Viz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetKickPromptViz");

	Params::GameplayHUD_SetKickPromptViz Parms{};

	Parms.Viz = Viz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetLuckViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetLuckViz(bool bViz, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetLuckViz");

	Params::GameplayHUD_SetLuckViz Parms{};

	Parms.bViz = bViz;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetMultiplier
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsUp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldAnimate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetMultiplier(int32 multiplier, bool bIsUp, bool bShouldAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetMultiplier");

	Params::GameplayHUD_SetMultiplier Parms{};

	Parms.multiplier = multiplier;
	Parms.bIsUp = bIsUp;
	Parms.bShouldAnimate = bShouldAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetMultiplierOnlyCorner
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetMultiplierOnlyCorner(int32 multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetMultiplierOnlyCorner");

	Params::GameplayHUD_SetMultiplierOnlyCorner Parms{};

	Parms.multiplier = multiplier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetNoWeaponFocus
// (Event, Public, BlueprintEvent)

void UGameplayHUD::SetNoWeaponFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetNoWeaponFocus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.GameplayHUD.SetObjectiveProgress
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetObjectiveProgress(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetObjectiveProgress");

	Params::GameplayHUD_SetObjectiveProgress Parms{};

	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetObjectiveText
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           InText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoNotify                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetObjectiveText(const class FString& InText, bool bDoNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetObjectiveText");

	Params::GameplayHUD_SetObjectiveText Parms{};

	Parms.InText = std::move(InText);
	Parms.bDoNotify = bDoNotify;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetObjectiveViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetObjectiveViz(bool bViz, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetObjectiveViz");

	Params::GameplayHUD_SetObjectiveViz Parms{};

	Parms.bViz = bViz;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetScore
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetScore(int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetScore");

	Params::GameplayHUD_SetScore Parms{};

	Parms.Score = Score;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetSloMoViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnimate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetSloMoViz(bool bViz, bool bAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetSloMoViz");

	Params::GameplayHUD_SetSloMoViz Parms{};

	Parms.bViz = bViz;
	Parms.bAnimate = bAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetSpeedrunnersViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsViz                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetSpeedrunnersViz(bool bIsViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetSpeedrunnersViz");

	Params::GameplayHUD_SetSpeedrunnersViz Parms{};

	Parms.bIsViz = bIsViz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.SetupForMode
// (Event, Public, BlueprintEvent)
// Parameters:
// EGameType                               ForMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::SetupForMode(EGameType ForMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "SetupForMode");

	Params::GameplayHUD_SetupForMode Parms{};

	Parms.ForMode = ForMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.ShowArcadeOver
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bArcadeOver                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::ShowArcadeOver(bool bArcadeOver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "ShowArcadeOver");

	Params::GameplayHUD_ShowArcadeOver Parms{};

	Parms.bArcadeOver = bArcadeOver;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.ShowRemainingNotification
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Remaining                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayHUD::ShowRemainingNotification(int32 Remaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "ShowRemainingNotification");

	Params::GameplayHUD_ShowRemainingNotification Parms{};

	Parms.Remaining = Remaining;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayHUD.UpdateChallengeCount
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FChallengeDisplay>        ToDisplay                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UGameplayHUD::UpdateChallengeCount(const TArray<struct FChallengeDisplay>& ToDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayHUD", "UpdateChallengeCount");

	Params::GameplayHUD_UpdateChallengeCount Parms{};

	Parms.ToDisplay = std::move(ToDisplay);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.TaskLoadChapter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_LoadChapter*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_LoadChapter* UGameplayTask_LoadChapter::TaskLoadChapter(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_LoadChapter", "TaskLoadChapter");

	Params::GameplayTask_LoadChapter_TaskLoadChapter Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.TaskLoadChapterQuick
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_LoadChapter*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_LoadChapter* UGameplayTask_LoadChapter::TaskLoadChapterQuick(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_LoadChapter", "TaskLoadChapterQuick");

	Params::GameplayTask_LoadChapter_TaskLoadChapterQuick Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.TaskStartChapter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class AChapter*                         InChapter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDifficulty                             Difficulty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCampaignDataAsset*               DataAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_LoadChapter*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_LoadChapter* UGameplayTask_LoadChapter::TaskStartChapter(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class AChapter* InChapter, EDifficulty Difficulty, class UCampaignDataAsset* DataAsset, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_LoadChapter", "TaskStartChapter");

	Params::GameplayTask_LoadChapter_TaskStartChapter Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InChapter = InChapter;
	Parms.Difficulty = Difficulty;
	Parms.DataAsset = DataAsset;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.CheckVoxelWorldResetProgress
// (Final, Native, Public)

void UGameplayTask_LoadChapter::CheckVoxelWorldResetProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "CheckVoxelWorldResetProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.DoLoad
// (Final, Native, Public)

void UGameplayTask_LoadChapter::DoLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "DoLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.FadeOutOver
// (Final, Native, Public)

void UGameplayTask_LoadChapter::FadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "FadeOutOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.NodeReset
// (Final, Native, Public)
// Parameters:
// struct FTYVCNodeMemory                  InNodeMemory                                           (Parm, NativeAccessSpecifierPublic)

void UGameplayTask_LoadChapter::NodeReset(const struct FTYVCNodeMemory& InNodeMemory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "NodeReset");

	Params::GameplayTask_LoadChapter_NodeReset Parms{};

	Parms.InNodeMemory = std::move(InNodeMemory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.PlayerRequestLevelStart
// (Final, Native, Public)

void UGameplayTask_LoadChapter::PlayerRequestLevelStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "PlayerRequestLevelStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.PostNodeLoaded
// (Final, Native, Public)
// Parameters:
// struct FTYVCNodeMemory                  NodeMemory                                             (Parm, NativeAccessSpecifierPublic)

void UGameplayTask_LoadChapter::PostNodeLoaded(const struct FTYVCNodeMemory& NodeMemory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "PostNodeLoaded");

	Params::GameplayTask_LoadChapter_PostNodeLoaded Parms{};

	Parms.NodeMemory = std::move(NodeMemory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.PostNonQuickLoad
// (Final, Native, Public)

void UGameplayTask_LoadChapter::PostNonQuickLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "PostNonQuickLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.PostReset
// (Final, Native, Public)

void UGameplayTask_LoadChapter::PostReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "PostReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.PostWorldsReady
// (Final, Native, Public)

void UGameplayTask_LoadChapter::PostWorldsReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "PostWorldsReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.PQR
// (Final, Native, Public)

void UGameplayTask_LoadChapter::PQR()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "PQR");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadChapter.VoxelDataLoaded
// (Final, Native, Public)
// Parameters:
// struct FVoxelUncompressedWorldSave      Save                                                   (Parm, NativeAccessSpecifierPublic)

void UGameplayTask_LoadChapter::VoxelDataLoaded(const struct FVoxelUncompressedWorldSave& Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadChapter", "VoxelDataLoaded");

	Params::GameplayTask_LoadChapter_VoxelDataLoaded Parms{};

	Parms.Save = std::move(Save);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.TaskLoadNode_ForArcade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class FName>                     NodeName                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)>OnCompleteDel                                          (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_LoadNode*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_LoadNode* UGameplayTask_LoadNode::TaskLoadNode_ForArcade(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeName, class AThankYouVeryCoolGameMode* InGameMode, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_LoadNode", "TaskLoadNode_ForArcade");

	Params::GameplayTask_LoadNode_TaskLoadNode_ForArcade Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.NodeName = std::move(NodeName);
	Parms.InGameMode = InGameMode;
	Parms.OnCompleteDel = OnCompleteDel;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.TaskLoadNode_ForCampaign
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class FName>                     NodeName                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AChapter*                         InChapter                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)>OnCompleteDel                                          (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_LoadNode*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_LoadNode* UGameplayTask_LoadNode::TaskLoadNode_ForCampaign(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeName, class AChapter* InChapter, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_LoadNode", "TaskLoadNode_ForCampaign");

	Params::GameplayTask_LoadNode_TaskLoadNode_ForCampaign Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.NodeName = std::move(NodeName);
	Parms.InChapter = InChapter;
	Parms.OnCompleteDel = OnCompleteDel;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.TaskLoadNode_ForEditorLoad
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class FName>                     NodeName                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)>OnCompleteDel                                          (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void()>                       PreVDel                                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_LoadNode*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_LoadNode* UGameplayTask_LoadNode::TaskLoadNode_ForEditorLoad(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeName, class AThankYouVeryCoolGameMode* InGameMode, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, TDelegate<void()> PreVDel, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_LoadNode", "TaskLoadNode_ForEditorLoad");

	Params::GameplayTask_LoadNode_TaskLoadNode_ForEditorLoad Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.NodeName = std::move(NodeName);
	Parms.InGameMode = InGameMode;
	Parms.OnCompleteDel = OnCompleteDel;
	Parms.PreVDel = PreVDel;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.TaskLoadNode_ForEditorVox
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class FName>                     NodeName                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)>OnCompleteDel                                          (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class UVoxelDataAsset*                  InDataAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       PreVDel                                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_LoadNode*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_LoadNode* UGameplayTask_LoadNode::TaskLoadNode_ForEditorVox(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeName, class AThankYouVeryCoolGameMode* InGameMode, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, class UVoxelDataAsset* InDataAsset, TDelegate<void()> PreVDel, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_LoadNode", "TaskLoadNode_ForEditorVox");

	Params::GameplayTask_LoadNode_TaskLoadNode_ForEditorVox Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.NodeName = std::move(NodeName);
	Parms.InGameMode = InGameMode;
	Parms.OnCompleteDel = OnCompleteDel;
	Parms.InDataAsset = InDataAsset;
	Parms.PreVDel = PreVDel;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.LevelLoaded
// (Final, Native, Public)

void UGameplayTask_LoadNode::LevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadNode", "LevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.NotifyVoxelWorldLoaded
// (Final, Native, Public)
// Parameters:
// class AVoxelWorld*                      LoadedWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayTask_LoadNode::NotifyVoxelWorldLoaded(class AVoxelWorld* LoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadNode", "NotifyVoxelWorldLoaded");

	Params::GameplayTask_LoadNode_NotifyVoxelWorldLoaded Parms{};

	Parms.LoadedWorld = LoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.PostActorsSpawned
// (Final, Native, Public)

void UGameplayTask_LoadNode::PostActorsSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadNode", "PostActorsSpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.TickCacheWorld
// (Final, Native, Public)

void UGameplayTask_LoadNode::TickCacheWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadNode", "TickCacheWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.TickLoadingStandalones
// (Final, Native, Public)
// Parameters:
// class AVoxelWorld*                      LoadedWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayTask_LoadNode::TickLoadingStandalones(class AVoxelWorld* LoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadNode", "TickLoadingStandalones");

	Params::GameplayTask_LoadNode_TickLoadingStandalones Parms{};

	Parms.LoadedWorld = LoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_LoadNode.UpdateTasksCount
// (Final, Native, Public)

void UGameplayTask_LoadNode::UpdateTasksCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_LoadNode", "UpdateTasksCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ResetArcade.TaskResetArcade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_ResetArcade*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_ResetArcade* UGameplayTask_ResetArcade::TaskResetArcade(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class AThankYouVeryCoolGameMode* InGameMode, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_ResetArcade", "TaskResetArcade");

	Params::GameplayTask_ResetArcade_TaskResetArcade Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InGameMode = InGameMode;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_ResetArcade.TaskResetEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnComplete                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_ResetArcade*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_ResetArcade* UGameplayTask_ResetArcade::TaskResetEditor(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class AThankYouVeryCoolGameMode* InGameMode, TDelegate<void()> OnComplete, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_ResetArcade", "TaskResetEditor");

	Params::GameplayTask_ResetArcade_TaskResetEditor Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InGameMode = InGameMode;
	Parms.OnComplete = OnComplete;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_ResetArcade.CountdownOver
// (Final, Native, Public)

void UGameplayTask_ResetArcade::CountdownOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ResetArcade", "CountdownOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ResetArcade.FadeOutOver
// (Final, Native, Public)

void UGameplayTask_ResetArcade::FadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ResetArcade", "FadeOutOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ResetArcade.PQR
// (Final, Native, Public)

void UGameplayTask_ResetArcade::PQR()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ResetArcade", "PQR");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ResetArcade.ResetComplete
// (Final, Native, Public)
// Parameters:
// struct FTYVCNodeMemory                  NodeMemory                                             (Parm, NativeAccessSpecifierPublic)

void UGameplayTask_ResetArcade::ResetComplete(const struct FTYVCNodeMemory& NodeMemory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ResetArcade", "ResetComplete");

	Params::GameplayTask_ResetArcade_ResetComplete Parms{};

	Parms.NodeMemory = std::move(NodeMemory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ResetNodeToGen.TaskReloadVox
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class FName                             NodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVoxelIntBox>             InPrimaryBoxes                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)>OnCompleteDel                                          (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_ResetNodeToGen*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_ResetNodeToGen* UGameplayTask_ResetNodeToGen::TaskReloadVox(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class FName NodeName, class AThankYouVeryCoolGameMode* InGameMode, const TArray<struct FVoxelIntBox>& InPrimaryBoxes, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_ResetNodeToGen", "TaskReloadVox");

	Params::GameplayTask_ResetNodeToGen_TaskReloadVox Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.NodeName = NodeName;
	Parms.InGameMode = InGameMode;
	Parms.InPrimaryBoxes = std::move(InPrimaryBoxes);
	Parms.OnCompleteDel = OnCompleteDel;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_ResetNodeToGen.TaskResetNode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class FName                             NodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVoxelIntBox>             InPrimaryBoxes                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)>OnCompleteDel                                          (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_ResetNodeToGen*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_ResetNodeToGen* UGameplayTask_ResetNodeToGen::TaskResetNode(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class FName NodeName, class AThankYouVeryCoolGameMode* InGameMode, const TArray<struct FVoxelIntBox>& InPrimaryBoxes, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_ResetNodeToGen", "TaskResetNode");

	Params::GameplayTask_ResetNodeToGen_TaskResetNode Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.NodeName = NodeName;
	Parms.InGameMode = InGameMode;
	Parms.InPrimaryBoxes = std::move(InPrimaryBoxes);
	Parms.OnCompleteDel = OnCompleteDel;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_ResetNodeToGen.CheckLevelResetProgress
// (Final, Native, Public)

void UGameplayTask_ResetNodeToGen::CheckLevelResetProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ResetNodeToGen", "CheckLevelResetProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ResetNodeToGen.NotifyVoxelWorldLoaded
// (Final, Native, Public)

void UGameplayTask_ResetNodeToGen::NotifyVoxelWorldLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ResetNodeToGen", "NotifyVoxelWorldLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ResetNodeToGen.TickLoadingStandalones
// (Final, Native, Public)

void UGameplayTask_ResetNodeToGen::TickLoadingStandalones()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ResetNodeToGen", "TickLoadingStandalones");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ResetNodeToGen.WorldLoaded
// (Final, Native, Public)

void UGameplayTask_ResetNodeToGen::WorldLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ResetNodeToGen", "WorldLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_SaveChapter.TaskSaveChapter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class FName                             InNode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_SaveChapter*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_SaveChapter* UGameplayTask_SaveChapter::TaskSaveChapter(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class FName InNode, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_SaveChapter", "TaskSaveChapter");

	Params::GameplayTask_SaveChapter_TaskSaveChapter Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InNode = InNode;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_SaveChapter.AsyncSaveDone
// (Final, Native, Public)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Slot                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayTask_SaveChapter::AsyncSaveDone(const class FString& Name_0, const int32 Slot, bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_SaveChapter", "AsyncSaveDone");

	Params::GameplayTask_SaveChapter_AsyncSaveDone Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Slot = Slot;
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_SaveChapter.GetCompleteSave
// (Final, Native, Public)
// Parameters:
// struct FVoxelUncompressedWorldSave      Save                                                   (Parm, NativeAccessSpecifierPublic)

void UGameplayTask_SaveChapter::GetCompleteSave(const struct FVoxelUncompressedWorldSave& Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_SaveChapter", "GetCompleteSave");

	Params::GameplayTask_SaveChapter_GetCompleteSave Parms{};

	Parms.Save = std::move(Save);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ShowText.TaskIntermissionText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)
// ECharacter                              InForCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_ShowText*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_ShowText* UGameplayTask_ShowText::TaskIntermissionText(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FText& InText, ECharacter InForCharacter, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_ShowText", "TaskIntermissionText");

	Params::GameplayTask_ShowText_TaskIntermissionText Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InText = std::move(InText);
	Parms.InForCharacter = InForCharacter;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_ShowText.TaskTutorialText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_ShowText*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_ShowText* UGameplayTask_ShowText::TaskTutorialText(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FText& InText, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_ShowText", "TaskTutorialText");

	Params::GameplayTask_ShowText_TaskTutorialText Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InText = std::move(InText);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_ShowText.KillMe
// (Final, Native, Public, BlueprintCallable)

void UGameplayTask_ShowText::KillMe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ShowText", "KillMe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ShowText.MarkComplete
// (Final, Native, Public, BlueprintCallable)

void UGameplayTask_ShowText::MarkComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ShowText", "MarkComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ShowText.MsgComplete
// (Final, Native, Public, BlueprintCallable)

void UGameplayTask_ShowText::MsgComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ShowText", "MsgComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_ShowText.PauseStatusChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bPauseStatus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayTask_ShowText::PauseStatusChanged(bool bPauseStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_ShowText", "PauseStatusChanged");

	Params::GameplayTask_ShowText_PauseStatusChanged Parms{};

	Parms.bPauseStatus = bPauseStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_StartArcade.TaskStartArcade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// EDifficulty                             InDifficulty                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AThankYouVeryCoolGameMode*        InGameMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameType                               InGameType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCustomLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArcadeLevelAsset*                InArcadeAsset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_StartArcade*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_StartArcade* UGameplayTask_StartArcade::TaskStartArcade(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, EDifficulty InDifficulty, class AThankYouVeryCoolGameMode* InGameMode, EGameType InGameType, bool bCustomLevel, class UArcadeLevelAsset* InArcadeAsset, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_StartArcade", "TaskStartArcade");

	Params::GameplayTask_StartArcade_TaskStartArcade Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InDifficulty = InDifficulty;
	Parms.InGameMode = InGameMode;
	Parms.InGameType = InGameType;
	Parms.bCustomLevel = bCustomLevel;
	Parms.InArcadeAsset = InArcadeAsset;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_StartArcade.CountdownOver
// (Final, Native, Public)

void UGameplayTask_StartArcade::CountdownOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_StartArcade", "CountdownOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_StartArcade.FadeOutOver
// (Final, Native, Public)

void UGameplayTask_StartArcade::FadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_StartArcade", "FadeOutOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_StartArcade.PostNodeLoaded
// (Final, Native, Public)
// Parameters:
// struct FTYVCNodeMemory                  NodeMemory                                             (Parm, NativeAccessSpecifierPublic)

void UGameplayTask_StartArcade::PostNodeLoaded(const struct FTYVCNodeMemory& NodeMemory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_StartArcade", "PostNodeLoaded");

	Params::GameplayTask_StartArcade_PostNodeLoaded Parms{};

	Parms.NodeMemory = std::move(NodeMemory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_StartEditor.TaskReloadVox
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class FString                           InVoxPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelEditorManager*              InLevelEditorManager                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_StartEditor*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_StartEditor* UGameplayTask_StartEditor::TaskReloadVox(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FString& InVoxPath, class ALevelEditorManager* InLevelEditorManager, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_StartEditor", "TaskReloadVox");

	Params::GameplayTask_StartEditor_TaskReloadVox Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InVoxPath = std::move(InVoxPath);
	Parms.InLevelEditorManager = InLevelEditorManager;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_StartEditor.TaskStartEditorLoad
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class UArcadeLevelAsset*                InLevelAsset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelEditorManager*              InLevelEditorManager                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForArcade                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelEditorSave*                 SaveOverride                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_StartEditor*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_StartEditor* UGameplayTask_StartEditor::TaskStartEditorLoad(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class UArcadeLevelAsset* InLevelAsset, class ALevelEditorManager* InLevelEditorManager, bool bForArcade, const uint8 Priority, class ULevelEditorSave* SaveOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_StartEditor", "TaskStartEditorLoad");

	Params::GameplayTask_StartEditor_TaskStartEditorLoad Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InLevelAsset = InLevelAsset;
	Parms.InLevelEditorManager = InLevelEditorManager;
	Parms.bForArcade = bForArcade;
	Parms.Priority = Priority;
	Parms.SaveOverride = SaveOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_StartEditor.TaskStartEditorNew
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class FString                           NewName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelEditorManager*              InLevelEditorManager                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_StartEditor*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_StartEditor* UGameplayTask_StartEditor::TaskStartEditorNew(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FString& NewName, class ALevelEditorManager* InLevelEditorManager, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_StartEditor", "TaskStartEditorNew");

	Params::GameplayTask_StartEditor_TaskStartEditorNew Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.NewName = std::move(NewName);
	Parms.InLevelEditorManager = InLevelEditorManager;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_StartEditor.TaskStartEditorVox
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// class FString                           InVoxPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelEditorManager*              InLevelEditorManager                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_StartEditor*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_StartEditor* UGameplayTask_StartEditor::TaskStartEditorVox(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FString& InVoxPath, class ALevelEditorManager* InLevelEditorManager, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_StartEditor", "TaskStartEditorVox");

	Params::GameplayTask_StartEditor_TaskStartEditorVox Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.InVoxPath = std::move(InVoxPath);
	Parms.InLevelEditorManager = InLevelEditorManager;
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_StartEditor.FadeOutOver
// (Final, Native, Public)

void UGameplayTask_StartEditor::FadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_StartEditor", "FadeOutOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_StartEditor.PostNodeLoad
// (Final, Native, Public)
// Parameters:
// struct FTYVCNodeMemory                  NodeMemory                                             (Parm, NativeAccessSpecifierPublic)

void UGameplayTask_StartEditor::PostNodeLoad(const struct FTYVCNodeMemory& NodeMemory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_StartEditor", "PostNodeLoad");

	Params::GameplayTask_StartEditor_PostNodeLoad Parms{};

	Parms.NodeMemory = std::move(NodeMemory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_StartEditor.PostSpawnSaved
// (Final, Native, Public)

void UGameplayTask_StartEditor::PostSpawnSaved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_StartEditor", "PostSpawnSaved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_StartEditor.PreV
// (Final, Native, Public)

void UGameplayTask_StartEditor::PreV()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_StartEditor", "PreV");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_UnloadNode.TaskUnloadNode_ForCampaign
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<class FName>                     NodeNames                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(const TArray<class FName>& UnloadedName)>OnCompleteDel                                          (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// struct FTYVCNodeMemory                  InNodeMemory                                           (Parm, NativeAccessSpecifierPublic)
// uint8                                   Priority                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayTask_UnloadNode*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTask_UnloadNode* UGameplayTask_UnloadNode::TaskUnloadNode_ForCampaign(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeNames, TDelegate<void(const TArray<class FName>& UnloadedName)> OnCompleteDel, const struct FTYVCNodeMemory& InNodeMemory, const uint8 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayTask_UnloadNode", "TaskUnloadNode_ForCampaign");

	Params::GameplayTask_UnloadNode_TaskUnloadNode_ForCampaign Parms{};

	Parms.TaskOwner = TaskOwner;
	Parms.NodeNames = std::move(NodeNames);
	Parms.OnCompleteDel = OnCompleteDel;
	Parms.InNodeMemory = std::move(InNodeMemory);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.GameplayTask_UnloadNode.LevelUnloaded
// (Final, Native, Public)

void UGameplayTask_UnloadNode::LevelUnloaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_UnloadNode", "LevelUnloaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_UnloadNode.TickDeleteCache
// (Final, Native, Public)

void UGameplayTask_UnloadNode::TickDeleteCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_UnloadNode", "TickDeleteCache");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GameplayTask_UnloadNode.TickUnloadVoxelWorld
// (Final, Native, Public)

void UGameplayTask_UnloadNode::TickUnloadVoxelWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayTask_UnloadNode", "TickUnloadVoxelWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GlassVoxelWorld.DoHole
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HoleRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DirVec                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoDebris                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGlassVoxelWorld::DoHole(const struct FVector& Location, float HoleRadius, const struct FVector& DirVec, bool bDoDebris)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlassVoxelWorld", "DoHole");

	Params::GlassVoxelWorld_DoHole Parms{};

	Parms.Location = std::move(Location);
	Parms.HoleRadius = HoleRadius;
	Parms.DirVec = std::move(DirVec);
	Parms.bDoDebris = bDoDebris;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.GlassVoxelWorld.EditorModeChanged_Implementation
// (Final, Native, Public)
// Parameters:
// EEditMode                               NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGlassVoxelWorld::EditorModeChanged_Implementation(EEditMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlassVoxelWorld", "EditorModeChanged_Implementation");

	Params::GlassVoxelWorld_EditorModeChanged_Implementation Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GlassVoxelWorld.LevelReady
// (Final, Native, Public)

void AGlassVoxelWorld::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlassVoxelWorld", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GlassVoxelWorld.MakeDebris
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          DirVec                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FModifiedVoxelValue>      ModdelVals                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AGlassVoxelWorld::MakeDebris(const struct FVector& DirVec, const TArray<struct FModifiedVoxelValue>& ModdelVals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlassVoxelWorld", "MakeDebris");

	Params::GlassVoxelWorld_MakeDebris Parms{};

	Parms.DirVec = std::move(DirVec);
	Parms.ModdelVals = std::move(ModdelVals);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.GlassVoxelWorld.SetDims
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGlassVoxelWorld::SetDims(int32 InLength, int32 InHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlassVoxelWorld", "SetDims");

	Params::GlassVoxelWorld_SetDims Parms{};

	Parms.InLength = InLength;
	Parms.InHeight = InHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.M203_Round.AddIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ToIgnore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AM203_Round::AddIgnoredActor(class AActor* ToIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("M203_Round", "AddIgnoredActor");

	Params::M203_Round_AddIgnoredActor Parms{};

	Parms.ToIgnore = ToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.M203_Round.Launch
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       StartTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bInFiredByPlayer                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Launcher                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AM203_Round::Launch(const struct FTransform& StartTransform, bool bInFiredByPlayer, class AActor* Launcher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("M203_Round", "Launch");

	Params::M203_Round_Launch Parms{};

	Parms.StartTransform = std::move(StartTransform);
	Parms.bInFiredByPlayer = bInFiredByPlayer;
	Parms.Launcher = Launcher;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.M203_Round.MakeDormantBP
// (Event, Public, BlueprintEvent)

void AM203_Round::MakeDormantBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("M203_Round", "MakeDormantBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.M203_Round.NadeOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AM203_Round::NadeOverlap(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("M203_Round", "NadeOverlap");

	Params::M203_Round_NadeOverlap Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.M203_Round.OnStop
// (Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AM203_Round::OnStop(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("M203_Round", "OnStop");

	Params::M203_Round_OnStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TextDisplayWidget.MarkAsComplete
// (Event, Public, BlueprintEvent)

void UTextDisplayWidget::MarkAsComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextDisplayWidget", "MarkAsComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TextDisplayWidget.SetupForCharacter
// (Event, Public, BlueprintEvent)
// Parameters:
// ECharacter                              InForCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTextDisplayWidget::SetupForCharacter(ECharacter InForCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TextDisplayWidget", "SetupForCharacter");

	Params::TextDisplayWidget_SetupForCharacter Parms{};

	Parms.InForCharacter = InForCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCPlayerController.GetGamertag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATYVCPlayerController::GetGamertag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPlayerController", "GetGamertag");

	Params::TYVCPlayerController_GetGamertag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCPlayerController.GetGamertagSuffix
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATYVCPlayerController::GetGamertagSuffix()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPlayerController", "GetGamertagSuffix");

	Params::TYVCPlayerController_GetGamertagSuffix Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCPlayerController.GetTYVCHUD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTYVCHUD*                         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTYVCHUD* ATYVCPlayerController::GetTYVCHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPlayerController", "GetTYVCHUD");

	Params::TYVCPlayerController_GetTYVCHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCPlayerController.IsControllerConnected
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATYVCPlayerController::IsControllerConnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPlayerController", "IsControllerConnected");

	Params::TYVCPlayerController_IsControllerConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCPlayerController.IsSwitchHandheldController
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATYVCPlayerController::IsSwitchHandheldController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPlayerController", "IsSwitchHandheldController");

	Params::TYVCPlayerController_IsSwitchHandheldController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCPlayerController.IsSwitchProController
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATYVCPlayerController::IsSwitchProController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPlayerController", "IsSwitchProController");

	Params::TYVCPlayerController_IsSwitchProController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCPlayerController.RequestEveHUD
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UGameplayHUD*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayHUD* ATYVCPlayerController::RequestEveHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCPlayerController", "RequestEveHUD");

	Params::TYVCPlayerController_RequestEveHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ImpactManager.AsyncExplosion
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::AsyncExplosion(const struct FVector& WorldPosition, float Radius, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "AsyncExplosion");

	Params::ImpactManager_AsyncExplosion Parms{};

	Parms.WorldPosition = std::move(WorldPosition);
	Parms.Radius = Radius;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ImpactManager.CalculateVoxelPhysics
// (Event, Public, BlueprintEvent)
// Parameters:
// class AVoxelWorld*                      VoxelWorld                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Box                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinWorlds                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanShatter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::CalculateVoxelPhysics(class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Box, int32 MinWorlds, bool bCanShatter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "CalculateVoxelPhysics");

	Params::ImpactManager_CalculateVoxelPhysics Parms{};

	Parms.VoxelWorld = VoxelWorld;
	Parms.Box = std::move(Box);
	Parms.MinWorlds = MinWorlds;
	Parms.bCanShatter = bCanShatter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ImpactManager.CheckVoxelPhysicsNearPlayerForWorld
// (Final, Native, Public)

void AImpactManager::CheckVoxelPhysicsNearPlayerForWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "CheckVoxelPhysicsNearPlayerForWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.ConfigureFoamWorld
// (Final, Native, Public)
// Parameters:
// class AVoxelWorld*                      InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::ConfigureFoamWorld(class AVoxelWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "ConfigureFoamWorld");

	Params::ImpactManager_ConfigureFoamWorld Parms{};

	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.ConfigureGlassChunk
// (Final, Native, Public)
// Parameters:
// class AVoxelWorld*                      InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::ConfigureGlassChunk(class AVoxelWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "ConfigureGlassChunk");

	Params::ImpactManager_ConfigureGlassChunk Parms{};

	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.ConfigurePhysicsWorld
// (Final, Native, Public)
// Parameters:
// class AVoxelWorld*                      InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::ConfigurePhysicsWorld(class AVoxelWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "ConfigurePhysicsWorld");

	Params::ImpactManager_ConfigurePhysicsWorld Parms{};

	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.ConfigureShatterWorld
// (Final, Native, Public)
// Parameters:
// class AVoxelWorld*                      InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::ConfigureShatterWorld(class AVoxelWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "ConfigureShatterWorld");

	Params::ImpactManager_ConfigureShatterWorld Parms{};

	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.ConfigureShearChunk
// (Final, Native, Public)
// Parameters:
// class AVoxelWorld*                      InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::ConfigureShearChunk(class AVoxelWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "ConfigureShearChunk");

	Params::ImpactManager_ConfigureShearChunk Parms{};

	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.CreateExplosion
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ShockwaveRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EditRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerMade                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Async                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  ParticleOverride                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       SoundOverride                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoGib                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      OverrideWorld                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropCaused                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKickedBack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGravThrown                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSwitchCull                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::CreateExplosion(const struct FVector& Location, const struct FRotator& Rotation, float ShockwaveRadius, float EditRadius, bool bPlayerMade, bool Async, class UParticleSystem* ParticleOverride, class USoundBase* SoundOverride, bool bNoGib, class AVoxelWorld* OverrideWorld, bool bPropCaused, bool bKickedBack, bool bGravThrown, bool bSwitchCull)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "CreateExplosion");

	Params::ImpactManager_CreateExplosion Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.ShockwaveRadius = ShockwaveRadius;
	Parms.EditRadius = EditRadius;
	Parms.bPlayerMade = bPlayerMade;
	Parms.Async = Async;
	Parms.ParticleOverride = ParticleOverride;
	Parms.SoundOverride = SoundOverride;
	Parms.bNoGib = bNoGib;
	Parms.OverrideWorld = OverrideWorld;
	Parms.bPropCaused = bPropCaused;
	Parms.bKickedBack = bKickedBack;
	Parms.bGravThrown = bGravThrown;
	Parms.bSwitchCull = bSwitchCull;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.DoBulletTrace
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          TraceStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceStop                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::DoBulletTrace(const struct FVector& TraceStart, const struct FVector& TraceStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "DoBulletTrace");

	Params::ImpactManager_DoBulletTrace Parms{};

	Parms.TraceStart = std::move(TraceStart);
	Parms.TraceStop = std::move(TraceStop);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ImpactManager.DoExplosionGraph
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AVoxelWorld*                      OnWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPlayerMade                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EditRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::DoExplosionGraph(class AVoxelWorld* OnWorld, const struct FVector& WorldLocation, const struct FRotator& Rotation, bool bPlayerMade, float EditRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "DoExplosionGraph");

	Params::ImpactManager_DoExplosionGraph Parms{};

	Parms.OnWorld = OnWorld;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.Rotation = std::move(Rotation);
	Parms.bPlayerMade = bPlayerMade;
	Parms.EditRadius = EditRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ImpactManager.DummyCallback
// (Final, Native, Public)

void AImpactManager::DummyCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "DummyCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.GetCurrentTimeDilation
// (Final, Native, Public)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AImpactManager::GetCurrentTimeDilation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "GetCurrentTimeDilation");

	Params::ImpactManager_GetCurrentTimeDilation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ImpactManager.NotifyGraphFinished
// (Final, Native, Public, BlueprintCallable)

void AImpactManager::NotifyGraphFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "NotifyGraphFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.NotifyGraphFinishedWithResults
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FModifiedVoxelValue>      Info                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Bounds                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::NotifyGraphFinishedWithResults(const TArray<struct FModifiedVoxelValue>& Info, const struct FVoxelIntBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "NotifyGraphFinishedWithResults");

	Params::ImpactManager_NotifyGraphFinishedWithResults Parms{};

	Parms.Info = std::move(Info);
	Parms.Bounds = std::move(Bounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.NotifyVoxelPhysicsTaskDone
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<TScriptInterface<class IVoxelPhysicsPartSpawnerResult>>Results                                                (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void AImpactManager::NotifyVoxelPhysicsTaskDone(TArray<TScriptInterface<class IVoxelPhysicsPartSpawnerResult>>* Results)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "NotifyVoxelPhysicsTaskDone");

	Params::ImpactManager_NotifyVoxelPhysicsTaskDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Results != nullptr)
		*Results = std::move(Parms.Results);
}


// Function ThankYouVeryCool.ImpactManager.OnVoxelChunkHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AImpactManager::OnVoxelChunkHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "OnVoxelChunkHit");

	Params::ImpactManager_OnVoxelChunkHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.PhysicsCheckDone
// (Final, Native, Public)

void AImpactManager::PhysicsCheckDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "PhysicsCheckDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.ReceiveChunkUpdate
// (Final, Native, Public)
// Parameters:
// struct FVoxelIntBox                     InBox                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::ReceiveChunkUpdate(const struct FVoxelIntBox& InBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "ReceiveChunkUpdate");

	Params::ImpactManager_ReceiveChunkUpdate Parms{};

	Parms.InBox = std::move(InBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.ResolveImpact
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EImpactType                             Impact                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FiredByPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Shooter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceOrigin                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PenetrationModifier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAlreadyKilledNPC                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AImpactManager::ResolveImpact(const struct FHitResult& HitResult, EImpactType Impact, bool FiredByPlayer, class AActor* Shooter, struct FVector* TraceOrigin, float PenetrationModifier, bool bAlreadyKilledNPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "ResolveImpact");

	Params::ImpactManager_ResolveImpact Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.Impact = Impact;
	Parms.FiredByPlayer = FiredByPlayer;
	Parms.Shooter = Shooter;
	Parms.PenetrationModifier = PenetrationModifier;
	Parms.bAlreadyKilledNPC = bAlreadyKilledNPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TraceOrigin != nullptr)
		*TraceOrigin = std::move(Parms.TraceOrigin);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ImpactManager.SetSendChapterEdits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSend                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::SetSendChapterEdits(bool bSend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "SetSendChapterEdits");

	Params::ImpactManager_SetSendChapterEdits Parms{};

	Parms.bSend = bSend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.ShatterWorldLoaded
// (Final, Native, Public)
// Parameters:
// class AVoxelWorld*                      LoadedWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::ShatterWorldLoaded(class AVoxelWorld* LoadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "ShatterWorldLoaded");

	Params::ImpactManager_ShatterWorldLoaded Parms{};

	Parms.LoadedWorld = LoadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ImpactManager.WorldToggleSlowMo
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AImpactManager::WorldToggleSlowMo(bool Value, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpactManager", "WorldToggleSlowMo");

	Params::ImpactManager_WorldToggleSlowMo Parms{};

	Parms.Value = Value;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.InteractableInterface.GetHighlightComponent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* IInteractableInterface::GetHighlightComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "GetHighlightComponent");

	Params::InteractableInterface_GetHighlightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.InteractableInterface.GetInteractionText
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IInteractableInterface::GetInteractionText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "GetInteractionText");

	Params::InteractableInterface_GetInteractionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.InteractableInterface.IsInteractable
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractableInterface::IsInteractable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "IsInteractable");

	Params::InteractableInterface_IsInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.InteractableInterface.OnHit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EImpactType                             ImpactType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Dmg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractableInterface::OnHit(EImpactType ImpactType, const struct FHitResult& HitResult, float Dmg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "OnHit");

	Params::InteractableInterface_OnHit Parms{};

	Parms.ImpactType = ImpactType;
	Parms.HitResult = std::move(HitResult);
	Parms.Dmg = Dmg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.InteractableInterface.OnLookAt
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          LookAtLoc                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractableInterface::OnLookAt(const struct FVector& LookAtLoc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "OnLookAt");

	Params::InteractableInterface_OnLookAt Parms{};

	Parms.LookAtLoc = std::move(LookAtLoc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.InteractableInterface.OnStopLookAt
// (Native, Event, Public, BlueprintEvent)

void IInteractableInterface::OnStopLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "OnStopLookAt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.InteractableInterface.RequestInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Interactor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractableInterface::RequestInteraction(class AActor* Interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "RequestInteraction");

	Params::InteractableInterface_RequestInteraction Parms{};

	Parms.Interactor = Interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.InteractableInterface.ShouldHighlight
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractableInterface::ShouldHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableInterface", "ShouldHighlight");

	Params::InteractableInterface_ShouldHighlight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponPickupWidget.SetupForBackpackRecharge
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  OnComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponPickupWidget::SetupForBackpackRecharge(class USceneComponent* OnComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPickupWidget", "SetupForBackpackRecharge");

	Params::WeaponPickupWidget_SetupForBackpackRecharge Parms{};

	Parms.OnComponent = OnComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.WeaponPickupWidget.SetupForInteract
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  OnComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InteractText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWeaponPickupWidget::SetupForInteract(class USceneComponent* OnComponent, const class FText& InteractText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPickupWidget", "SetupForInteract");

	Params::WeaponPickupWidget_SetupForInteract Parms{};

	Parms.OnComponent = OnComponent;
	Parms.InteractText = std::move(InteractText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.WeaponPickupWidget.SetupForThrow
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AWeaponBase*                      InWeapon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponPickupWidget::SetupForThrow(class AWeaponBase* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPickupWidget", "SetupForThrow");

	Params::WeaponPickupWidget_SetupForThrow Parms{};

	Parms.InWeapon = InWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.WeaponPickupWidget.SetupForWeapon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AWeaponBase*                      InWeapon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponPickupWidget::SetupForWeapon(class AWeaponBase* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPickupWidget", "SetupForWeapon");

	Params::WeaponPickupWidget_SetupForWeapon Parms{};

	Parms.InWeapon = InWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LevelEditorManager.GetFoundProps
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   OutFound                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALevelEditorManager::GetFoundProps(TArray<class FString>* OutFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LevelEditorManager", "GetFoundProps");

	Params::LevelEditorManager_GetFoundProps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFound != nullptr)
		*OutFound = std::move(Parms.OutFound);
}


// Function ThankYouVeryCool.LevelEditorManager.GetFoundVox
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   OutFound                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALevelEditorManager::GetFoundVox(TArray<class FString>* OutFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LevelEditorManager", "GetFoundVox");

	Params::LevelEditorManager_GetFoundVox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFound != nullptr)
		*OutFound = std::move(Parms.OutFound);
}


// Function ThankYouVeryCool.LevelEditorManager.MakeColorFromFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor ALevelEditorManager::MakeColorFromFloat(float R, float G, float B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LevelEditorManager", "MakeColorFromFloat");

	Params::LevelEditorManager_MakeColorFromFloat Parms{};

	Parms.R = R;
	Parms.G = G;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.AddPropToLibrary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCustomPropData                  InProp                                                 (Parm, NativeAccessSpecifierPublic)

void ALevelEditorManager::AddPropToLibrary(const struct FCustomPropData& InProp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "AddPropToLibrary");

	Params::LevelEditorManager_AddPropToLibrary Parms{};

	Parms.InProp = std::move(InProp);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.AfterNodeReset
// (Final, Native, Public)

void ALevelEditorManager::AfterNodeReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "AfterNodeReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ApplyAndClearMask
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::ApplyAndClearMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ApplyAndClearMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ConvertLegacyLevels
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::ConvertLegacyLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ConvertLegacyLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.DeleteSelected
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::DeleteSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "DeleteSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.DeleteSelection
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::DeleteSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "DeleteSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.DoSpecialAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EActionType                             OfType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSimulated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::DoSpecialAction(EActionType OfType, bool bSimulated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "DoSpecialAction");

	Params::LevelEditorManager_DoSpecialAction Parms{};

	Parms.OfType = OfType;
	Parms.bSimulated = bSimulated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.EnsureDirLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBe                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::EnsureDirLight(bool bShouldBe, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "EnsureDirLight");

	Params::LevelEditorManager_EnsureDirLight Parms{};

	Parms.bShouldBe = bShouldBe;
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.EnsureSkyActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBe                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowAmbient                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::EnsureSkyActor(bool bShouldBe, bool bAllowAmbient)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "EnsureSkyActor");

	Params::LevelEditorManager_EnsureSkyActor Parms{};

	Parms.bShouldBe = bShouldBe;
	Parms.bAllowAmbient = bAllowAmbient;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.GetActionsFromID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EActionType>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EActionType> ALevelEditorManager::GetActionsFromID(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetActionsFromID");

	Params::LevelEditorManager_GetActionsFromID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetAlphabeticIDs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ALevelEditorManager::GetAlphabeticIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetAlphabeticIDs");

	Params::LevelEditorManager_GetAlphabeticIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetAlphabeticPropCategories
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ALevelEditorManager::GetAlphabeticPropCategories()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetAlphabeticPropCategories");

	Params::LevelEditorManager_GetAlphabeticPropCategories Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetAlphabeticPropKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FGuid>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGuid> ALevelEditorManager::GetAlphabeticPropKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetAlphabeticPropKeys");

	Params::LevelEditorManager_GetAlphabeticPropKeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetAlphabeticPropKeysForCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CategoryIn                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGuid>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGuid> ALevelEditorManager::GetAlphabeticPropKeysForCategory(const class FString& CategoryIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetAlphabeticPropKeysForCategory");

	Params::LevelEditorManager_GetAlphabeticPropKeysForCategory Parms{};

	Parms.CategoryIn = std::move(CategoryIn);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetCatSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ForCat                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCustomPropCatSave*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomPropCatSave* ALevelEditorManager::GetCatSave(const class FString& ForCat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetCatSave");

	Params::LevelEditorManager_GetCatSave Parms{};

	Parms.ForCat = std::move(ForCat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetCurrentCampaignDirLocal
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bFull                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALevelEditorManager::GetCurrentCampaignDirLocal(bool bFull)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetCurrentCampaignDirLocal");

	Params::LevelEditorManager_GetCurrentCampaignDirLocal Parms{};

	Parms.bFull = bFull;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetCurrentLevelDir
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bFull                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALevelEditorManager::GetCurrentLevelDir(bool bFull)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetCurrentLevelDir");

	Params::LevelEditorManager_GetCurrentLevelDir Parms{};

	Parms.bFull = bFull;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetCurrentLevelWorkshopInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           OutID                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelEditorManager::GetCurrentLevelWorkshopInfo(class FString* OutID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetCurrentLevelWorkshopInfo");

	Params::LevelEditorManager_GetCurrentLevelWorkshopInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutID != nullptr)
		*OutID = std::move(Parms.OutID);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetFoundCampaigns
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForConsoles                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UCustomCampaign*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCustomCampaign*> ALevelEditorManager::GetFoundCampaigns(bool bForConsoles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetFoundCampaigns");

	Params::LevelEditorManager_GetFoundCampaigns Parms{};

	Parms.bForConsoles = bForConsoles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetFoundEditorLevels
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForConsoles                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UArcadeLevelAssetWorkshop*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UArcadeLevelAssetWorkshop*> ALevelEditorManager::GetFoundEditorLevels(bool bForConsoles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetFoundEditorLevels");

	Params::LevelEditorManager_GetFoundEditorLevels Parms{};

	Parms.bForConsoles = bForConsoles;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetGoalsFromID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EGoalType>                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EGoalType> ALevelEditorManager::GetGoalsFromID(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetGoalsFromID");

	Params::LevelEditorManager_GetGoalsFromID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetIDsWithActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ALevelEditorManager::GetIDsWithActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetIDsWithActions");

	Params::LevelEditorManager_GetIDsWithActions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetIDsWithGoals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ALevelEditorManager::GetIDsWithGoals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetIDsWithGoals");

	Params::LevelEditorManager_GetIDsWithGoals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetLevelFromCampaign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomCampaign*                  Campaign                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InLevelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGetSource                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArcadeLevelAssetWorkshop*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArcadeLevelAssetWorkshop* ALevelEditorManager::GetLevelFromCampaign(class UCustomCampaign* Campaign, const class FString& InLevelName, bool bGetSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetLevelFromCampaign");

	Params::LevelEditorManager_GetLevelFromCampaign Parms{};

	Parms.Campaign = Campaign;
	Parms.InLevelName = std::move(InLevelName);
	Parms.bGetSource = bGetSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetLocalLevelAssets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UArcadeLevelAssetWorkshop*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UArcadeLevelAssetWorkshop*> ALevelEditorManager::GetLocalLevelAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetLocalLevelAssets");

	Params::LevelEditorManager_GetLocalLevelAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetPropCat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ALevelEditorManager::GetPropCat(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetPropCat");

	Params::LevelEditorManager_GetPropCat Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetScreenshotFromCampaign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomCampaign*                  Campaign                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InLevelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ALevelEditorManager::GetScreenshotFromCampaign(class UCustomCampaign* Campaign, const class FString& InLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetScreenshotFromCampaign");

	Params::LevelEditorManager_GetScreenshotFromCampaign Parms{};

	Parms.Campaign = Campaign;
	Parms.InLevelName = std::move(InLevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetSpawnTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bYawOnly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ALevelEditorManager::GetSpawnTransform(bool bYawOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetSpawnTransform");

	Params::LevelEditorManager_GetSpawnTransform Parms{};

	Parms.bYawOnly = bYawOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetWorkshopCampaignAssets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UCustomCampaign*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCustomCampaign*> ALevelEditorManager::GetWorkshopCampaignAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetWorkshopCampaignAssets");

	Params::LevelEditorManager_GetWorkshopCampaignAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.GetWorkshopLevelAssets
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UArcadeLevelAssetWorkshop*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UArcadeLevelAssetWorkshop*> ALevelEditorManager::GetWorkshopLevelAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "GetWorkshopLevelAssets");

	Params::LevelEditorManager_GetWorkshopLevelAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.IsLevelNameValid
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           ToCheck                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             OutMsg                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelEditorManager::IsLevelNameValid(const class FString& ToCheck, class FText* OutMsg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "IsLevelNameValid");

	Params::LevelEditorManager_IsLevelNameValid Parms{};

	Parms.ToCheck = std::move(ToCheck);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMsg != nullptr)
		*OutMsg = std::move(Parms.OutMsg);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.LoadFromEditorAndApply
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::LoadFromEditorAndApply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "LoadFromEditorAndApply");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.MakeCatSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ForCat                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPropCatUploadInfo               InInfo                                                 (Parm, NativeAccessSpecifierPublic)
// class UCustomPropCatSave*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomPropCatSave* ALevelEditorManager::MakeCatSave(const class FString& ForCat, const struct FPropCatUploadInfo& InInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "MakeCatSave");

	Params::LevelEditorManager_MakeCatSave Parms{};

	Parms.ForCat = std::move(ForCat);
	Parms.InInfo = std::move(InInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.NotifyPostLoad
// (Native, Event, Public, BlueprintEvent)

void ALevelEditorManager::NotifyPostLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "NotifyPostLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.OpenWorkshopFor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::OpenWorkshopFor(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "OpenWorkshopFor");

	Params::LevelEditorManager_OpenWorkshopFor Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ReadyVoxProps
// (Final, Native, Public)

void ALevelEditorManager::ReadyVoxProps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ReadyVoxProps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.Redo
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::Redo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "Redo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.RefreshPreviewProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APropVoxelWorld*                  ToRefresh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::RefreshPreviewProp(class APropVoxelWorld* ToRefresh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "RefreshPreviewProp");

	Params::LevelEditorManager_RefreshPreviewProp Parms{};

	Parms.ToRefresh = ToRefresh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ReloadVox
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::ReloadVox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ReloadVox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.RemovePropFromLibrary
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                            ForGUID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::RemovePropFromLibrary(const struct FGuid& ForGUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "RemovePropFromLibrary");

	Params::LevelEditorManager_RemovePropFromLibrary Parms{};

	Parms.ForGUID = std::move(ForGUID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.RequestMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldCut                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::RequestMove(bool bShouldCut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "RequestMove");

	Params::LevelEditorManager_RequestMove Parms{};

	Parms.bShouldCut = bShouldCut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.RotateSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Counter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::RotateSelection(bool Counter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "RotateSelection");

	Params::LevelEditorManager_RotateSelection Parms{};

	Parms.Counter = Counter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SaveCustomCampaign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCustomCampaignStruct            InCampaign                                             (Parm, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelEditorManager::SaveCustomCampaign(const struct FCustomCampaignStruct& InCampaign, const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SaveCustomCampaign");

	Params::LevelEditorManager_SaveCustomCampaign Parms{};

	Parms.InCampaign = std::move(InCampaign);
	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.SaveEditor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCacheOnly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelEditorManager::SaveEditor(bool bCacheOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SaveEditor");

	Params::LevelEditorManager_SaveEditor Parms{};

	Parms.bCacheOnly = bCacheOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.SetAmbientLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InStrength                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SimpleMod                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDirLight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetAmbientLight(float InStrength, float SimpleMod, float InDirLight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetAmbientLight");

	Params::LevelEditorManager_SetAmbientLight Parms{};

	Parms.InStrength = InStrength;
	Parms.SimpleMod = SimpleMod;
	Parms.InDirLight = InDirLight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetBorder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVoxelIntBox                     Dims                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReloadWorld                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasSky                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetBorder(int32 Index_0, const struct FVoxelIntBox& Dims, bool bReloadWorld, bool bHasSky)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetBorder");

	Params::LevelEditorManager_SetBorder Parms{};

	Parms.Index_0 = Index_0;
	Parms.Dims = std::move(Dims);
	Parms.bReloadWorld = bReloadWorld;
	Parms.bHasSky = bHasSky;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetBorderViz
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetBorderViz(bool bViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetBorderViz");

	Params::LevelEditorManager_SetBorderViz Parms{};

	Parms.bViz = bViz;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetCurrentLevelWorkshopInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetCurrentLevelWorkshopInfo(const class FString& InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetCurrentLevelWorkshopInfo");

	Params::LevelEditorManager_SetCurrentLevelWorkshopInfo Parms{};

	Parms.InID = std::move(InID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetDescription
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InDescription                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelEditorManager::SetDescription(const class FText& InDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetDescription");

	Params::LevelEditorManager_SetDescription Parms{};

	Parms.InDescription = std::move(InDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.SetDisplayName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             DisplayName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelEditorManager::SetDisplayName(const class FText& DisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetDisplayName");

	Params::LevelEditorManager_SetDisplayName Parms{};

	Parms.DisplayName = std::move(DisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.SetEditMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEditMode                               InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetEditMode(EEditMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetEditMode");

	Params::LevelEditorManager_SetEditMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetEditType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEditType                               InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetEditType(EEditType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetEditType");

	Params::LevelEditorManager_SetEditType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetFogEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetFogEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetFogEnabled");

	Params::LevelEditorManager_SetFogEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetLUT
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LUTIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LUTStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetLUT(int32 LUTIndex, float LUTStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetLUT");

	Params::LevelEditorManager_SetLUT Parms{};

	Parms.LUTIndex = LUTIndex;
	Parms.LUTStrength = LUTStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetMaskActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bStatus                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetMaskActive(bool bStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetMaskActive");

	Params::LevelEditorManager_SetMaskActive Parms{};

	Parms.bStatus = bStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetMaterialIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetMaterialIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetMaterialIndex");

	Params::LevelEditorManager_SetMaterialIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetNoFriction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNo                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetNoFriction(bool bNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetNoFriction");

	Params::LevelEditorManager_SetNoFriction Parms{};

	Parms.bNo = bNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetShouldSnap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldSnap                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetShouldSnap(bool bShouldSnap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetShouldSnap");

	Params::LevelEditorManager_SetShouldSnap Parms{};

	Parms.bShouldSnap = bShouldSnap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetSkylightTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TextureIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetSkylightTexture(int32 TextureIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetSkylightTexture");

	Params::LevelEditorManager_SetSkylightTexture Parms{};

	Parms.TextureIndex = TextureIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetSkyTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetSkyTime(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetSkyTime");

	Params::LevelEditorManager_SetSkyTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetSpawnPoint
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SetSpawnPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetSpawnPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetupWorldBoundsDisplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVoxelIntBox                     InBounds                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SetupWorldBoundsDisplay(const struct FVoxelIntBox& InBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetupWorldBoundsDisplay");

	Params::LevelEditorManager_SetupWorldBoundsDisplay Parms{};

	Parms.InBounds = std::move(InBounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SetWorkshopAuthor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Author                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelEditorManager::SetWorkshopAuthor(const class FText& Author)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetWorkshopAuthor");

	Params::LevelEditorManager_SetWorkshopAuthor Parms{};

	Parms.Author = std::move(Author);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.SetWorkshopName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             DisplayName                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALevelEditorManager::SetWorkshopName(const class FText& DisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SetWorkshopName");

	Params::LevelEditorManager_SetWorkshopName Parms{};

	Parms.DisplayName = std::move(DisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.SimulationLeft
// (Final, Native, Public)

void ALevelEditorManager::SimulationLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SimulationLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnAsEditor
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SpawnAsEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnAsEditor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnAsEve
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SpawnAsEve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnAsEve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnCampaignMarker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACampaignMarker>      MarkerClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnCampaignMarker(TSubclassOf<class ACampaignMarker> MarkerClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnCampaignMarker");

	Params::LevelEditorManager_SpawnCampaignMarker Parms{};

	Parms.MarkerClass = MarkerClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnChargeStation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARechargeStation>     InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnChargeStation(TSubclassOf<class ARechargeStation> InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnChargeStation");

	Params::LevelEditorManager_SpawnChargeStation Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnCustomPropFromData
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCustomPropData                  InData                                                 (Parm, NativeAccessSpecifierPublic)
// struct FTransform                       AtTransform                                            (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class APropVoxelWorld*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APropVoxelWorld* ALevelEditorManager::SpawnCustomPropFromData(const struct FCustomPropData& InData, const struct FTransform& AtTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnCustomPropFromData");

	Params::LevelEditorManager_SpawnCustomPropFromData Parms{};

	Parms.InData = std::move(InData);
	Parms.AtTransform = std::move(AtTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnDoor
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SpawnDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnGenericProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class APropVoxelWorld>      ClassToSpawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnGenericProp(TSubclassOf<class APropVoxelWorld> ClassToSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnGenericProp");

	Params::LevelEditorManager_SpawnGenericProp Parms{};

	Parms.ClassToSpawn = ClassToSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnGlass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AGlassVoxelWorld>     GlassClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnGlass(TSubclassOf<class AGlassVoxelWorld> GlassClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnGlass");

	Params::LevelEditorManager_SpawnGlass Parms{};

	Parms.GlassClass = GlassClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnGun
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AWeaponBase>          WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnGun(TSubclassOf<class AWeaponBase> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnGun");

	Params::LevelEditorManager_SpawnGun Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnHugeKillerFan
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SpawnHugeKillerFan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnHugeKillerFan");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnKillerFan
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SpawnKillerFan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnKillerFan");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnLight
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SpawnLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnLight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnMech
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AMech>                MechClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnMech(TSubclassOf<class AMech> MechClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnMech");

	Params::LevelEditorManager_SpawnMech Parms{};

	Parms.MechClass = MechClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnNPC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENPCType                                OfType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnNPC(ENPCType OfType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnNPC");

	Params::LevelEditorManager_SpawnNPC Parms{};

	Parms.OfType = OfType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnPickup
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SpawnPickup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnPickup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnProp(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnProp");

	Params::LevelEditorManager_SpawnProp Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnTriggerVolume
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::SpawnTriggerVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnTriggerVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnTurret
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATurret*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATurret* ALevelEditorManager::SpawnTurret()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnTurret");

	Params::LevelEditorManager_SpawnTurret Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnVoid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ARechargeStation>     VoidClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnVoid(TSubclassOf<class ARechargeStation> VoidClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnVoid");

	Params::LevelEditorManager_SpawnVoid Parms{};

	Parms.VoidClass = VoidClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.SpawnVoxProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PropName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::SpawnVoxProp(const class FString& PropName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "SpawnVoxProp");

	Params::LevelEditorManager_SpawnVoxProp Parms{};

	Parms.PropName = std::move(PropName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.StampPropToWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APropVoxelWorld*                  InProp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::StampPropToWorld(class APropVoxelWorld* InProp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "StampPropToWorld");

	Params::LevelEditorManager_StampPropToWorld Parms{};

	Parms.InProp = InProp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.TickSlice
// (Final, Native, Public)

void ALevelEditorManager::TickSlice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "TickSlice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ToggleBorderViz
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::ToggleBorderViz()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ToggleBorderViz");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ToggleCubicMode
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::ToggleCubicMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ToggleCubicMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ToggleFog
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::ToggleFog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ToggleFog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ToggleGrid
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::ToggleGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ToggleGrid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.ToggleVolumesViz
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::ToggleVolumesViz()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "ToggleVolumesViz");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.Undo
// (Final, Native, Public, BlueprintCallable)

void ALevelEditorManager::Undo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "Undo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.UploadCampaignToSteam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCustomCampaignStruct            ToUpload                                               (Parm, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success)>           WhenDone                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ALevelEditorManager::UploadCampaignToSteam(const struct FCustomCampaignStruct& ToUpload, TDelegate<void(bool Success)> WhenDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "UploadCampaignToSteam");

	Params::LevelEditorManager_UploadCampaignToSteam Parms{};

	Parms.ToUpload = std::move(ToUpload);
	Parms.WhenDone = WhenDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.UploadPropToSteam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CatName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCustomPropData>          ToUpload                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FPropCatUploadInfo               InInfo                                                 (Parm, NativeAccessSpecifierPublic)
// TDelegate<void(bool Success)>           WhenDone                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ALevelEditorManager::UploadPropToSteam(const class FString& CatName, const TArray<struct FCustomPropData>& ToUpload, const struct FPropCatUploadInfo& InInfo, TDelegate<void(bool Success)> WhenDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "UploadPropToSteam");

	Params::LevelEditorManager_UploadPropToSteam Parms{};

	Parms.CatName = std::move(CatName);
	Parms.ToUpload = std::move(ToUpload);
	Parms.InInfo = std::move(InInfo);
	Parms.WhenDone = WhenDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.UploadToSteam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Success)>           WhenDone                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ALevelEditorManager::UploadToSteam(TDelegate<void(bool Success)> WhenDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "UploadToSteam");

	Params::LevelEditorManager_UploadToSteam Parms{};

	Parms.WhenDone = WhenDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorManager.UserRequestedAttachment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ToAttach                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ToAttachTo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorManager::UserRequestedAttachment(class AActor* ToAttach, class AActor* ToAttachTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorManager", "UserRequestedAttachment");

	Params::LevelEditorManager_UserRequestedAttachment Parms{};

	Parms.ToAttach = ToAttach;
	Parms.ToAttachTo = ToAttachTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.ConvertSelectionToProp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorPawn::ConvertSelectionToProp(const class FString& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "ConvertSelectionToProp");

	Params::LevelEditorPawn_ConvertSelectionToProp Parms{};

	Parms.InName = std::move(InName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.CopyDown
// (Final, Native, Private)

void ALevelEditorPawn::CopyDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "CopyDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.CopyUp
// (Final, Native, Private)

void ALevelEditorPawn::CopyUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "CopyUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.GetCurrentEditMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EEditMode                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEditMode ALevelEditorPawn::GetCurrentEditMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "GetCurrentEditMode");

	Params::LevelEditorPawn_GetCurrentEditMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorPawn.GetCurrentEditType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EEditType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEditType ALevelEditorPawn::GetCurrentEditType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "GetCurrentEditType");

	Params::LevelEditorPawn_GetCurrentEditType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorPawn.GetScreenshot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ALevelEditorPawn::GetScreenshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "GetScreenshot");

	Params::LevelEditorPawn_GetScreenshot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorPawn.GetScreenshotForPropCat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CatName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ALevelEditorPawn::GetScreenshotForPropCat(const class FString& CatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "GetScreenshotForPropCat");

	Params::LevelEditorPawn_GetScreenshotForPropCat Parms{};

	Parms.CatName = std::move(CatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorPawn.LoadScreenshotForPropCat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           CatName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ALevelEditorPawn::LoadScreenshotForPropCat(const class FString& CatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "LoadScreenshotForPropCat");

	Params::LevelEditorPawn_LoadScreenshotForPropCat Parms{};

	Parms.CatName = std::move(CatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorPawn.MoveWithCameraDown
// (Final, Native, Private)

void ALevelEditorPawn::MoveWithCameraDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "MoveWithCameraDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.MoveWithCameraUp
// (Final, Native, Private)

void ALevelEditorPawn::MoveWithCameraUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "MoveWithCameraUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.PausePressed
// (Final, Native, Private)

void ALevelEditorPawn::PausePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "PausePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.QuickPickPressed
// (Final, Native, Private)

void ALevelEditorPawn::QuickPickPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "QuickPickPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.Redo
// (Final, Native, Public)

void ALevelEditorPawn::Redo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "Redo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.RequestRotateMode
// (Final, Native, Private)

void ALevelEditorPawn::RequestRotateMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "RequestRotateMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.RequestScaleMode
// (Final, Native, Private)

void ALevelEditorPawn::RequestScaleMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "RequestScaleMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.RequestTranslateMode
// (Final, Native, Private)

void ALevelEditorPawn::RequestTranslateMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "RequestTranslateMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.RightClickDown
// (Final, Native, Private)

void ALevelEditorPawn::RightClickDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "RightClickDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.RightClickUp
// (Final, Native, Private)

void ALevelEditorPawn::RightClickUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "RightClickUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.TickCircle
// (Final, Native, Public)

void ALevelEditorPawn::TickCircle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "TickCircle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.TickVoxelMove
// (Final, Native, Public)

void ALevelEditorPawn::TickVoxelMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "TickVoxelMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.TriggerDownMouse
// (Final, Native, Private)

void ALevelEditorPawn::TriggerDownMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "TriggerDownMouse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.TriggerUpMouse
// (Final, Native, Private)

void ALevelEditorPawn::TriggerUpMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "TriggerUpMouse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.Undo
// (Final, Native, Public)

void ALevelEditorPawn::Undo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "Undo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.UpdateBoxEdit
// (Final, Native, Public)

void ALevelEditorPawn::UpdateBoxEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "UpdateBoxEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.UpdateFaceEdit
// (Final, Native, Public)
// Parameters:
// EFaceDirection                          ForceDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelEditorPawn::UpdateFaceEdit(EFaceDirection ForceDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "UpdateFaceEdit");

	Params::LevelEditorPawn_UpdateFaceEdit Parms{};

	Parms.ForceDirection = ForceDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorPawn.UpdateLineEdit
// (Final, Native, Public)

void ALevelEditorPawn::UpdateLineEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorPawn", "UpdateLineEdit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LevelEditorWidget.DisplayPropertiesFor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ForActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::DisplayPropertiesFor(class AActor* ForActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "DisplayPropertiesFor");

	Params::LevelEditorWidget_DisplayPropertiesFor Parms{};

	Parms.ForActor = ForActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LevelEditorWidget.DisplaySavedValues
// (Event, Public, BlueprintEvent)
// Parameters:
// class ULevelEditorSave*                 SaveInfo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::DisplaySavedValues(class ULevelEditorSave* SaveInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "DisplaySavedValues");

	Params::LevelEditorWidget_DisplaySavedValues Parms{};

	Parms.SaveInfo = SaveInfo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LevelEditorWidget.DisplayToolDimensions
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FIntVector                       InDims                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::DisplayToolDimensions(const struct FIntVector& InDims)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "DisplayToolDimensions");

	Params::LevelEditorWidget_DisplayToolDimensions Parms{};

	Parms.InDims = std::move(InDims);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LevelEditorWidget.GetChapterData
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FWorkshopChapterData             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWorkshopChapterData ULevelEditorWidget::GetChapterData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "GetChapterData");

	Params::LevelEditorWidget_GetChapterData Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.LevelEditorWidget.GetSimSettings
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bEnableAI                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSpawnAtCamera                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::GetSimSettings(bool* bEnableAI, bool* bSpawnAtCamera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "GetSimSettings");

	Params::LevelEditorWidget_GetSimSettings Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnableAI != nullptr)
		*bEnableAI = Parms.bEnableAI;

	if (bSpawnAtCamera != nullptr)
		*bSpawnAtCamera = Parms.bSpawnAtCamera;
}


// Function ThankYouVeryCool.LevelEditorWidget.HideToolDimensions
// (Event, Public, BlueprintEvent)

void ULevelEditorWidget::HideToolDimensions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "HideToolDimensions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.LevelEditorWidget.HotKeyModePressed
// (Event, Public, BlueprintEvent)
// Parameters:
// EEditMode                               InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::HotKeyModePressed(EEditMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "HotKeyModePressed");

	Params::LevelEditorWidget_HotKeyModePressed Parms{};

	Parms.InMode = InMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LevelEditorWidget.HotKeyTypePressed
// (Event, Public, BlueprintEvent)
// Parameters:
// EEditType                               InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::HotKeyTypePressed(EEditType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "HotKeyTypePressed");

	Params::LevelEditorWidget_HotKeyTypePressed Parms{};

	Parms.InType = InType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LevelEditorWidget.RefreshPropLibrary
// (Event, Public, BlueprintEvent)

void ULevelEditorWidget::RefreshPropLibrary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "RefreshPropLibrary");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.LevelEditorWidget.RefreshWorkshopTab
// (Event, Public, BlueprintEvent)

void ULevelEditorWidget::RefreshWorkshopTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "RefreshWorkshopTab");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.LevelEditorWidget.SetAsDefault
// (Event, Public, BlueprintEvent)

void ULevelEditorWidget::SetAsDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "SetAsDefault");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.LevelEditorWidget.SetSelectedMaterial
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Mat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::SetSelectedMaterial(int32 Mat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "SetSelectedMaterial");

	Params::LevelEditorWidget_SetSelectedMaterial Parms{};

	Parms.Mat = Mat;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LevelEditorWidget.SetWorldSizeDisplay
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FVoxelIntBox                     InValue                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::SetWorldSizeDisplay(const struct FVoxelIntBox& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "SetWorldSizeDisplay");

	Params::LevelEditorWidget_SetWorldSizeDisplay Parms{};

	Parms.InValue = std::move(InValue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LevelEditorWidget.ShowSelectControls
// (Event, Public, BlueprintEvent)
// Parameters:
// ESelectStage                            InStage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelEditorWidget::ShowSelectControls(ESelectStage InStage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelEditorWidget", "ShowSelectControls");

	Params::LevelEditorWidget_ShowSelectControls Parms{};

	Parms.InStage = InStage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Lift.Build
// (Final, Native, Public, BlueprintCallable)

void ALift::Build()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lift", "Build");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Lift.CleanUp
// (Final, Native, Public, BlueprintCallable)

void ALift::CleanUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lift", "CleanUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Lift.OnBottomPressed
// (Final, Native, Public)

void ALift::OnBottomPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lift", "OnBottomPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Lift.OnLiftPressed
// (Final, Native, Public)

void ALift::OnLiftPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lift", "OnLiftPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Lift.OnTopPressed
// (Final, Native, Public)

void ALift::OnTopPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lift", "OnTopPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.LuckDisplay.Reset
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   MaxAmount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuckDisplay::Reset(int32 MaxAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LuckDisplay", "Reset");

	Params::LuckDisplay_Reset Parms{};

	Parms.MaxAmount = MaxAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LuckDisplay.SetLuck
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULuckDisplay::SetLuck(int32 Amount, bool bRestore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LuckDisplay", "SetLuck");

	Params::LuckDisplay_SetLuck Parms{};

	Parms.Amount = Amount;
	Parms.bRestore = bRestore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.LuosProjectile.OverlappedSomething
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Overlapped                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALuosProjectile::OverlappedSomething(class AActor* Overlapped, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LuosProjectile", "OverlappedSomething");

	Params::LuosProjectile_OverlappedSomething Parms{};

	Parms.Overlapped = Overlapped;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.AfterShutdown
// (Final, Native, Public)

void AMech::AfterShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "AfterShutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.AfterWakeUp
// (Final, Native, Public)

void AMech::AfterWakeUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "AfterWakeUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.DoDestructionGraph
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AVoxelWorld*                      OnWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMech::DoDestructionGraph(const struct FVector& WorldLocation, class AVoxelWorld* OnWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "DoDestructionGraph");

	Params::Mech_DoDestructionGraph Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.OnWorld = OnWorld;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Mech.DoHitLogic
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMech::DoHitLogic(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "DoHitLogic");

	Params::Mech_DoHitLogic Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Mech.DoWallTest
// (Final, Native, Public)

void AMech::DoWallTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "DoWallTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.GetInterpolatedLookAt
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          GoalLookAt                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AMech::GetInterpolatedLookAt(const struct FVector& GoalLookAt, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "GetInterpolatedLookAt");

	Params::Mech_GetInterpolatedLookAt Parms{};

	Parms.GoalLookAt = std::move(GoalLookAt);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Mech.GetShootOrigin
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AMech::GetShootOrigin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "GetShootOrigin");

	Params::Mech_GetShootOrigin Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Mech.LevelReady
// (Final, Native, Public)

void AMech::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.MakeDead
// (Final, Native, Public, BlueprintCallable)

void AMech::MakeDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "MakeDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.NotifyMechHit
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   Dmg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMech::NotifyMechHit(const struct FHitResult& HitResult, int32 Dmg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "NotifyMechHit");

	Params::Mech_NotifyMechHit Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.Dmg = Dmg;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Mech.SeenPlayer
// (Event, Public, BlueprintEvent)

void AMech::SeenPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "SeenPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Mech.SetShieldActive
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMech::SetShieldActive(bool bActive, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "SetShieldActive");

	Params::Mech_SetShieldActive Parms{};

	Parms.bActive = bActive;
	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.Mech.SetSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMech::SetSpeed(float InSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "SetSpeed");

	Params::Mech_SetSpeed Parms{};

	Parms.InSpeed = InSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.Shoot
// (Final, Native, Public, BlueprintCallable)

void AMech::Shoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "Shoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.ShutDown
// (Final, Native, Public, BlueprintCallable)

void AMech::ShutDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "ShutDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.WakeUp
// (Final, Native, Public, BlueprintCallable)

void AMech::WakeUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "WakeUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Mech.WokenUp
// (Final, Native, Public)

void AMech::WokenUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Mech", "WokenUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MechController.UpdateTargetPerception
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AMechController::UpdateTargetPerception(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MechController", "UpdateTargetPerception");

	Params::MechController_UpdateTargetPerception Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MenuPawn.LerpTransform
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AMenuPawn::LerpTransform(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuPawn", "LerpTransform");

	Params::MenuPawn_LerpTransform Parms{};

	Parms.Transform = std::move(Transform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.MenuPawn.OnCloseToPlayer
// (Final, Native, Public, BlueprintCallable)

void AMenuPawn::OnCloseToPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuPawn", "OnCloseToPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MenuPawn.OnTransformComplete
// (Final, Native, Public, BlueprintCallable)

void AMenuPawn::OnTransformComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuPawn", "OnTransformComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.CacheTrack
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class USoundBase>        ToCache                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMusicPlayer::CacheTrack(const TSoftObjectPtr<class USoundBase>& ToCache)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "CacheTrack");

	Params::MusicPlayer_CacheTrack Parms{};

	Parms.ToCache = ToCache;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.MusicPlayer.CustomTrackLoaded
// (Final, Native, Public)
// Parameters:
// class URuntimeAudioImporterLibrary*     Importer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UImportedSoundWave*               ImportedSoundWave                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERuntimeImportStatus                    Status                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMusicPlayer::CustomTrackLoaded(class URuntimeAudioImporterLibrary* Importer, class UImportedSoundWave* ImportedSoundWave, ERuntimeImportStatus Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "CustomTrackLoaded");

	Params::MusicPlayer_CustomTrackLoaded Parms{};

	Parms.Importer = Importer;
	Parms.ImportedSoundWave = ImportedSoundWave;
	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.FadeTrack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class USoundBase>        WhiteList                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMusicPlayer::FadeTrack(TSoftObjectPtr<class USoundBase> WhiteList, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "FadeTrack");

	Params::MusicPlayer_FadeTrack Parms{};

	Parms.WhiteList = WhiteList;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.GetCurrentTrackTitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AMusicPlayer::GetCurrentTrackTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "GetCurrentTrackTitle");

	Params::MusicPlayer_GetCurrentTrackTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.MusicPlayer.GetCustomTrackCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AMusicPlayer::GetCustomTrackCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "GetCustomTrackCount");

	Params::MusicPlayer_GetCustomTrackCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.MusicPlayer.GetCustomTrackPath
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           OutPath                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMusicPlayer::GetCustomTrackPath(class FString* OutPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "GetCustomTrackPath");

	Params::MusicPlayer_GetCustomTrackPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPath != nullptr)
		*OutPath = std::move(Parms.OutPath);
}


// Function ThankYouVeryCool.MusicPlayer.GetPCMData
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<float>                           PCMData                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMusicPlayer::GetPCMData(const TArray<float>& PCMData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "GetPCMData");

	Params::MusicPlayer_GetPCMData Parms{};

	Parms.PCMData = std::move(PCMData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.GetTitleOfTrack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class USoundBase>        track                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AMusicPlayer::GetTitleOfTrack(TSoftObjectPtr<class USoundBase> track)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "GetTitleOfTrack");

	Params::MusicPlayer_GetTitleOfTrack Parms{};

	Parms.track = track;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.MusicPlayer.IsAnyTrackPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMusicPlayer::IsAnyTrackPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "IsAnyTrackPlaying");

	Params::MusicPlayer_IsAnyTrackPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.MusicPlayer.IsAnyTrackPlayingBesidesTitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMusicPlayer::IsAnyTrackPlayingBesidesTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "IsAnyTrackPlayingBesidesTitle");

	Params::MusicPlayer_IsAnyTrackPlayingBesidesTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.MusicPlayer.IsTrackPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class USoundBase>        ToCheck                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMusicPlayer::IsTrackPlaying(TSoftObjectPtr<class USoundBase> ToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "IsTrackPlaying");

	Params::MusicPlayer_IsTrackPlaying Parms{};

	Parms.ToCheck = ToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.MusicPlayer.OnPaused
// (Final, Native, Public)
// Parameters:
// bool                                    bPaused                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMusicPlayer::OnPaused(bool bPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "OnPaused");

	Params::MusicPlayer_OnPaused Parms{};

	Parms.bPaused = bPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.OpenMusicPath
// (Final, Native, Public, BlueprintCallable)

void AMusicPlayer::OpenMusicPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "OpenMusicPath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.PlayIfNotPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class USoundBase>        ToPlay                                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMusicPlayer::PlayIfNotPlaying(TSoftObjectPtr<class USoundBase> ToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "PlayIfNotPlaying");

	Params::MusicPlayer_PlayIfNotPlaying Parms{};

	Parms.ToPlay = ToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.PlayRandomEditorTrack
// (Final, Native, Public, BlueprintCallable)

void AMusicPlayer::PlayRandomEditorTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "PlayRandomEditorTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.PlayRandomGameplayTrack
// (Final, Native, Public, BlueprintCallable)

void AMusicPlayer::PlayRandomGameplayTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "PlayRandomGameplayTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.PlayRandomUserTrack
// (Final, Native, Public, BlueprintCallable)

void AMusicPlayer::PlayRandomUserTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "PlayRandomUserTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.PlayTrack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class USoundBase>        InTrack                                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDontStoreAsLast                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCustom                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMusicPlayer::PlayTrack(TSoftObjectPtr<class USoundBase> InTrack, bool bDontStoreAsLast, bool bIsCustom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "PlayTrack");

	Params::MusicPlayer_PlayTrack Parms{};

	Parms.InTrack = InTrack;
	Parms.bDontStoreAsLast = bDontStoreAsLast;
	Parms.bIsCustom = bIsCustom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.MusicPlayer.StopTrack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class USoundBase>        WhiteList                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeOutTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMusicPlayer::StopTrack(TSoftObjectPtr<class USoundBase> WhiteList, bool bInstant, float FadeOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicPlayer", "StopTrack");

	Params::MusicPlayer_StopTrack Parms{};

	Parms.WhiteList = WhiteList;
	Parms.bInstant = bInstant;
	Parms.FadeOutTime = FadeOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NavLinkProxy_Jump.ReceiveSmartLinkReached_Internal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Agent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Destination                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavLinkProxy_Jump::ReceiveSmartLinkReached_Internal(class AActor* Agent, const struct FVector& Destination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkProxy_Jump", "ReceiveSmartLinkReached_Internal");

	Params::NavLinkProxy_Jump_ReceiveSmartLinkReached_Internal Parms{};

	Parms.Agent = Agent;
	Parms.Destination = std::move(Destination);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NdocRingWidget.CloseOuterAnimation
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UNdocRingWidget::CloseOuterAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NdocRingWidget", "CloseOuterAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.NdocRingWidget.StartOuterAnimation
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UNdocRingWidget::StartOuterAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NdocRingWidget", "StartOuterAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.NdocRingWidget.UpdateInnerRing
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   UpdateAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNdocRingWidget::UpdateInnerRing(float UpdateAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NdocRingWidget", "UpdateInnerRing");

	Params::NdocRingWidget_UpdateInnerRing Parms{};

	Parms.UpdateAmount = UpdateAmount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.NPC.ApplyHitForce
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::ApplyHitForce(const struct FVector& Impulse, class FName BoneName, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "ApplyHitForce");

	Params::NPC_ApplyHitForce Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.BoneName = BoneName;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.CapsuleHit
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANPC::CapsuleHit(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "CapsuleHit");

	Params::NPC_CapsuleHit Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.CapsuleTouched
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANPC::CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "CapsuleTouched");

	Params::NPC_CapsuleTouched Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.Detonate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bGivePlayerCredit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::Detonate(bool bGivePlayerCredit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "Detonate");

	Params::NPC_Detonate Parms{};

	Parms.bGivePlayerCredit = bGivePlayerCredit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.DisableCloak
// (Event, Public, BlueprintEvent)

void ANPC::DisableCloak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "DisableCloak");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.NPC.EndStun
// (Final, Native, Protected)

void ANPC::EndStun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "EndStun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.EquipPumpkin
// (Event, Public, BlueprintEvent)

void ANPC::EquipPumpkin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "EquipPumpkin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.NPC.EquipSidearm
// (Final, Native, Public, BlueprintCallable)

void ANPC::EquipSidearm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "EquipSidearm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.EquipXMas
// (Event, Public, BlueprintEvent)

void ANPC::EquipXMas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "EquipXMas");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.NPC.FireSayCallback
// (Final, Native, Public)

void ANPC::FireSayCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "FireSayCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.ForceSetFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorToFocus                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::ForceSetFocus(class AActor* ActorToFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "ForceSetFocus");

	Params::NPC_ForceSetFocus Parms{};

	Parms.ActorToFocus = ActorToFocus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.GetRecoil
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ANPC::GetRecoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "GetRecoil");

	Params::NPC_GetRecoil Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPC.GetSquad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASquad*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASquad* ANPC::GetSquad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "GetSquad");

	Params::NPC_GetSquad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPC.GetupFromKnockdown
// (Final, Native, Public)

void ANPC::GetupFromKnockdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "GetupFromKnockdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.Gib
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bGivePlayerCredit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPC::Gib(bool bGivePlayerCredit, bool bForce, const struct FVector& WorldDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "Gib");

	Params::NPC_Gib Parms{};

	Parms.bGivePlayerCredit = bGivePlayerCredit;
	Parms.bForce = bForce;
	Parms.WorldDir = std::move(WorldDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPC.GrabAnimationAtGrabPoint
// (Final, Native, Public, BlueprintCallable)

void ANPC::GrabAnimationAtGrabPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "GrabAnimationAtGrabPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.GrabSidearm
// (Final, Native, Public, BlueprintCallable)

void ANPC::GrabSidearm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "GrabSidearm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.GrabWeaponOnGround
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeaponBase*                      Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::GrabWeaponOnGround(class AWeaponBase* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "GrabWeaponOnGround");

	Params::NPC_GrabWeaponOnGround Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.HasSidearm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPC::HasSidearm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "HasSidearm");

	Params::NPC_HasSidearm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPC.HitReactionOver
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EffetedBoneName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::HitReactionOver(class UAnimMontage* AnimMontage, bool bInterrupted, class FName EffetedBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "HitReactionOver");

	Params::NPC_HitReactionOver Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;
	Parms.EffetedBoneName = EffetedBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.IsArmed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPC::IsArmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "IsArmed");

	Params::NPC_IsArmed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPC.LevelReady
// (Final, Native, Public)

void ANPC::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.LevelUnload
// (Final, Native, Public)

void ANPC::LevelUnload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "LevelUnload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.NotifyBlendedOutOfStumble
// (Final, Native, Public, BlueprintCallable)

void ANPC::NotifyBlendedOutOfStumble()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "NotifyBlendedOutOfStumble");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.NotifyBPDead
// (Event, Public, BlueprintEvent)

void ANPC::NotifyBPDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "NotifyBPDead");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.NPC.NotifyBPTargetSighted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSighted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPC::NotifyBPTargetSighted(bool bSighted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "NotifyBPTargetSighted");

	Params::NPC_NotifyBPTargetSighted Parms{};

	Parms.bSighted = bSighted;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPC.NotifyRagdollALS
// (Event, Public, BlueprintEvent)

void ANPC::NotifyRagdollALS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "NotifyRagdollALS");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.NPC.NotifyUnragdollALS
// (Event, Public, BlueprintEvent)

void ANPC::NotifyUnragdollALS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "NotifyUnragdollALS");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.NPC.OnBackpackOverlapBegin
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANPC::OnBackpackOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "OnBackpackOverlapBegin");

	Params::NPC_OnBackpackOverlapBegin Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.OnJetpackCrash
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ANPC::OnJetpackCrash(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "OnJetpackCrash");

	Params::NPC_OnJetpackCrash Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.PreLevelReady
// (Final, Native, Public)

void ANPC::PreLevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "PreLevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.ReactToBulletHit
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Joules                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HPdmg                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EImpactType                             ImpactType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHitArmor                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldContinue                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPC::ReactToBulletHit(const struct FHitResult& HitResult, float Joules, float HPdmg, EImpactType ImpactType, bool* bHitArmor, bool* bShouldContinue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "ReactToBulletHit");

	Params::NPC_ReactToBulletHit Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.Joules = Joules;
	Parms.HPdmg = HPdmg;
	Parms.ImpactType = ImpactType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bHitArmor != nullptr)
		*bHitArmor = Parms.bHitArmor;

	if (bShouldContinue != nullptr)
		*bShouldContinue = Parms.bShouldContinue;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPC.RequestResponse
// (Final, Native, Public)

void ANPC::RequestResponse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "RequestResponse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.Say
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Line                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideTimer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::Say(class FName Line, bool bOverrideTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "Say");

	Params::NPC_Say Parms{};

	Parms.Line = Line;
	Parms.bOverrideTimer = bOverrideTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.SayWithCallback
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     Line                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TDelegate<void(bool bWasInterrupted)>   Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOverrideTimer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::SayWithCallback(const TArray<class FName>& Line, const TDelegate<void(bool bWasInterrupted)>& Callback, bool bOverrideTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "SayWithCallback");

	Params::NPC_SayWithCallback Parms{};

	Parms.Line = std::move(Line);
	Parms.Callback = Callback;
	Parms.bOverrideTimer = bOverrideTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.SayWithResponse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     MyLine                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class ANPC*                             Responder                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ResponderLine                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bOverrideTimer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::SayWithResponse(const TArray<class FName>& MyLine, class ANPC* Responder, const TArray<class FName>& ResponderLine, bool bOverrideTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "SayWithResponse");

	Params::NPC_SayWithResponse Parms{};

	Parms.MyLine = std::move(MyLine);
	Parms.Responder = Responder;
	Parms.ResponderLine = std::move(ResponderLine);
	Parms.bOverrideTimer = bOverrideTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.SetBackpackLights
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bViz                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::SetBackpackLights(bool bViz)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "SetBackpackLights");

	Params::NPC_SetBackpackLights Parms{};

	Parms.bViz = bViz;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.NPC.SetCloakActive
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bShouldBeActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldAnimate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::SetCloakActive(bool bShouldBeActive, bool bShouldAnimate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "SetCloakActive");

	Params::NPC_SetCloakActive Parms{};

	Parms.bShouldBeActive = bShouldBeActive;
	Parms.bShouldAnimate = bShouldAnimate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.NPC.SetLean
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELeanState                              NewLean                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::SetLean(ELeanState NewLean)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "SetLean");

	Params::NPC_SetLean Parms{};

	Parms.NewLean = NewLean;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.SetWeaponPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWeaponPosition                         NewPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::SetWeaponPosition(EWeaponPosition NewPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "SetWeaponPosition");

	Params::NPC_SetWeaponPosition Parms{};

	Parms.NewPosition = NewPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPC.ShootAtFocalPoint
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   OutPoints                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCanBeKillingShot                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPC::ShootAtFocalPoint(int32* OutPoints, bool bCanBeKillingShot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "ShootAtFocalPoint");

	Params::NPC_ShootAtFocalPoint Parms{};

	Parms.bCanBeKillingShot = bCanBeKillingShot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPoints != nullptr)
		*OutPoints = Parms.OutPoints;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPC.SpawnGibFX
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          WorldDir                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::SpawnGibFX(const struct FVector& WorldDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "SpawnGibFX");

	Params::NPC_SpawnGibFX Parms{};

	Parms.WorldDir = std::move(WorldDir);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.NPC.UpdateCoverState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECoverState                             NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPC::UpdateCoverState(ECoverState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPC", "UpdateCoverState");

	Params::NPC_UpdateCoverState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPCController.CanSeeActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCController::CanSeeActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "CanSeeActor");

	Params::NPCController_CanSeeActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPCController.EnteredVisionDelayReached
// (Final, Native, Protected)

void ANPCController::EnteredVisionDelayReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "EnteredVisionDelayReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPCController.GetNPC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANPC*                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANPC* ANPCController::GetNPC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "GetNPC");

	Params::NPCController_GetNPC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPCController.GetSquad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASquad*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASquad* ANPCController::GetSquad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "GetSquad");

	Params::NPCController_GetSquad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPCController.InjectTree
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBehaviorTree*                    Order                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OrderTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANPCController::InjectTree(class UBehaviorTree* Order, const struct FGameplayTag& OrderTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "InjectTree");

	Params::NPCController_InjectTree Parms{};

	Parms.Order = Order;
	Parms.OrderTag = std::move(OrderTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPCController.IsPassive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANPCController::IsPassive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "IsPassive");

	Params::NPCController_IsPassive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.NPCController.Releash
// (Final, Native, Public, BlueprintCallable)

void ANPCController::Releash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "Releash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPCController.UpdatedPerception
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<class AActor*>                   Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ANPCController::UpdatedPerception(const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "UpdatedPerception");

	Params::NPCController_UpdatedPerception Parms{};

	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.NPCController.UpdateTargetPerception
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ANPCController::UpdateTargetPerception(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NPCController", "UpdateTargetPerception");

	Params::NPCController_UpdateTargetPerception Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.OverclockWidget.SetOverclockPercent
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InPercent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverclockWidget::SetOverclockPercent(float InPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverclockWidget", "SetOverclockPercent");

	Params::OverclockWidget_SetOverclockPercent Parms{};

	Parms.InPercent = InPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.OverclockWidget.SetupForCampaign
// (Event, Public, BlueprintEvent)

void UOverclockWidget::SetupForCampaign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverclockWidget", "SetupForCampaign");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.OverclockWidget.SetupForHunt
// (Event, Public, BlueprintEvent)

void UOverclockWidget::SetupForHunt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverclockWidget", "SetupForHunt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PickupWidget.OverrideText
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPickupWidget::OverrideText(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupWidget", "OverrideText");

	Params::PickupWidget_OverrideText Parms{};

	Parms.inString = std::move(inString);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PickupWidget.SetMode
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bController                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowThrow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPickupWidget::SetMode(bool bController, bool bShowThrow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupWidget", "SetMode");

	Params::PickupWidget_SetMode Parms{};

	Parms.bController = bController;
	Parms.bShowThrow = bShowThrow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PickupWidget.ShowPrompt
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShouldShow                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPickupWidget::ShowPrompt(bool bShouldShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupWidget", "ShowPrompt");

	Params::PickupWidget_ShowPrompt Parms{};

	Parms.bShouldShow = bShouldShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.GetActionInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EPlayerAction                           ForAction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForController                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutIsAxis                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::GetActionInfo(EPlayerAction ForAction, bool bForController, class FName* OutName, bool* OutIsAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerCharacter", "GetActionInfo");

	Params::PlayerCharacter_GetActionInfo Parms{};

	Parms.ForAction = ForAction;
	Parms.bForController = bForController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutName != nullptr)
		*OutName = Parms.OutName;

	if (OutIsAxis != nullptr)
		*OutIsAxis = Parms.OutIsAxis;
}


// Function ThankYouVeryCool.PlayerCharacter.AllowInstantAcceleration
// (Final, Native, Public)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::AllowInstantAcceleration(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "AllowInstantAcceleration");

	Params::PlayerCharacter_AllowInstantAcceleration Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.AtWeaponGrabPoint
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::AtWeaponGrabPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "AtWeaponGrabPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.CancelFanWinddown
// (Event, Public, BlueprintEvent)

void APlayerCharacter::CancelFanWinddown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CancelFanWinddown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PlayerCharacter.CancelFanWindUp
// (Event, Public, BlueprintEvent)

void APlayerCharacter::CancelFanWindUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CancelFanWindUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PlayerCharacter.CannonSelectGamepadPressed
// (Final, Native, Public)

void APlayerCharacter::CannonSelectGamepadPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CannonSelectGamepadPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.CannonSelectGamepadReleased
// (Final, Native, Public)

void APlayerCharacter::CannonSelectGamepadReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CannonSelectGamepadReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.CannonSelectMKBPressed
// (Final, Native, Public)

void APlayerCharacter::CannonSelectMKBPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CannonSelectMKBPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.CannonSelectMKBReleased
// (Final, Native, Public)

void APlayerCharacter::CannonSelectMKBReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CannonSelectMKBReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.CannonSelectPressedImp
// (Final, Native, Public)

void APlayerCharacter::CannonSelectPressedImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CannonSelectPressedImp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.CannonSelectReleasedImp
// (Final, Native, Public)

void APlayerCharacter::CannonSelectReleasedImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CannonSelectReleasedImp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.CapsuleHit
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APlayerCharacter::CapsuleHit(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CapsuleHit");

	Params::PlayerCharacter_CapsuleHit Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.CapsuleTouched
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APlayerCharacter::CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "CapsuleTouched");

	Params::PlayerCharacter_CapsuleTouched Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DebugAIGoToPressed
// (Final, Native, Protected)

void APlayerCharacter::DebugAIGoToPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DebugAIGoToPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DebugCameraPressed
// (Final, Native, Protected)

void APlayerCharacter::DebugCameraPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DebugCameraPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DebugInvisiblePlayer
// (Final, Native, Public)

void APlayerCharacter::DebugInvisiblePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DebugInvisiblePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DebugSpendLuckPressed
// (Final, Native, Public)

void APlayerCharacter::DebugSpendLuckPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DebugSpendLuckPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DisableAirControl
// (Final, Native, Public)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::DisableAirControl(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DisableAirControl");

	Params::PlayerCharacter_DisableAirControl Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.Dive
// (Final, Native, Public)

void APlayerCharacter::Dive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "Dive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DiveController
// (Final, Native, Public)

void APlayerCharacter::DiveController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DiveController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DiveImp
// (Final, Native, Public)

void APlayerCharacter::DiveImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DiveImp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DiveReleased
// (Final, Native, Public)

void APlayerCharacter::DiveReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DiveReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DiveReleasedController
// (Final, Native, Public)

void APlayerCharacter::DiveReleasedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DiveReleasedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DoKickAutoAim
// (Event, Public, BlueprintEvent)

void APlayerCharacter::DoKickAutoAim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DoKickAutoAim");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PlayerCharacter.DoLeftShoulderSlide
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInSlide                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::DoLeftShoulderSlide(bool bInSlide, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DoLeftShoulderSlide");

	Params::PlayerCharacter_DoLeftShoulderSlide Parms{};

	Parms.bInSlide = bInSlide;
	Parms.bInstant = bInstant;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.DrawFinished
// (Final, Native, Public)

void APlayerCharacter::DrawFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DrawFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DropWeapon
// (Final, Native, Public)

void APlayerCharacter::DropWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DropWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.DropWeaponPressed
// (Final, Native, Public)

void APlayerCharacter::DropWeaponPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "DropWeaponPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.EndSlide
// (Final, Native, Public)

void APlayerCharacter::EndSlide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "EndSlide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.EnsureStandValid
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::EnsureStandValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "EnsureStandValid");

	Params::PlayerCharacter_EnsureStandValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.EnterPressed
// (Final, Native, Protected)

void APlayerCharacter::EnterPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "EnterPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.EnterSlowMo
// (Final, Native, Public)

void APlayerCharacter::EnterSlowMo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "EnterSlowMo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FanWinddownComplete
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::FanWinddownComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FanWinddownComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishCapsuleLerp
// (Final, Native, Public)

void APlayerCharacter::FinishCapsuleLerp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishCapsuleLerp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishClimbForward
// (Final, Native, Public)

void APlayerCharacter::FinishClimbForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishClimbForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishClimbUp
// (Final, Native, Public)

void APlayerCharacter::FinishClimbUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishClimbUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishDeathCameraSwivel
// (Final, Native, Protected)

void APlayerCharacter::FinishDeathCameraSwivel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishDeathCameraSwivel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishedKickAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::FinishedKickAnim(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishedKickAnim");

	Params::PlayerCharacter_FinishedKickAnim Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishedProneFromStand
// (Final, Native, Public)

void APlayerCharacter::FinishedProneFromStand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishedProneFromStand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishedPunch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::FinishedPunch(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishedPunch");

	Params::PlayerCharacter_FinishedPunch Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishedStandingFromProne
// (Final, Native, Public)

void APlayerCharacter::FinishedStandingFromProne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishedStandingFromProne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishedUncrouching
// (Final, Native, Public)

void APlayerCharacter::FinishedUncrouching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishedUncrouching");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishKickSlide
// (Final, Native, Public)
// Parameters:
// bool                                    bToCrouch                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::FinishKickSlide(bool bToCrouch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishKickSlide");

	Params::PlayerCharacter_FinishKickSlide Parms{};

	Parms.bToCrouch = bToCrouch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FinishOnWallRunCameraCurve
// (Final, Native, Protected)

void APlayerCharacter::FinishOnWallRunCameraCurve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FinishOnWallRunCameraCurve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FireWeapon
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::FireWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FireWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FlashlightGamepadPressed
// (Final, Native, Public)

void APlayerCharacter::FlashlightGamepadPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FlashlightGamepadPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.FlashlightKBPressed
// (Final, Native, Public)

void APlayerCharacter::FlashlightKBPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "FlashlightKBPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ForceEquip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeaponBase*                      ToEquip                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ForceEquip(class AWeaponBase* ToEquip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ForceEquip");

	Params::PlayerCharacter_ForceEquip Parms{};

	Parms.ToEquip = ToEquip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ForceUpdateOverlaps
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::ForceUpdateOverlaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ForceUpdateOverlaps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ForwardPressed
// (Final, Native, Protected)

void APlayerCharacter::ForwardPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ForwardPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ForwardReleased
// (Final, Native, Protected)

void APlayerCharacter::ForwardReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ForwardReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.GetEquippedWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeaponBase*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeaponBase* APlayerCharacter::GetEquippedWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetEquippedWeapon");

	Params::PlayerCharacter_GetEquippedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.GetFirstPersonCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* APlayerCharacter::GetFirstPersonCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetFirstPersonCamera");

	Params::PlayerCharacter_GetFirstPersonCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.GetIsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::GetIsDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetIsDead");

	Params::PlayerCharacter_GetIsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.GetIsInDamageCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::GetIsInDamageCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetIsInDamageCooldown");

	Params::PlayerCharacter_GetIsInDamageCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.GetIsReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::GetIsReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetIsReady");

	Params::PlayerCharacter_GetIsReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.GetMovementMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMovementMode                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMovementMode APlayerCharacter::GetMovementMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "GetMovementMode");

	Params::PlayerCharacter_GetMovementMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.HideDamage
// (Event, Public, BlueprintEvent)

void APlayerCharacter::HideDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "HideDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PlayerCharacter.HolsterFinished
// (Final, Native, Public)

void APlayerCharacter::HolsterFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "HolsterFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.IsInStunt
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::IsInStunt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "IsInStunt");

	Params::PlayerCharacter_IsInStunt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.JumpPressedController
// (Final, Native, Protected)

void APlayerCharacter::JumpPressedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "JumpPressedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.JumpReleasedController
// (Final, Native, Protected)

void APlayerCharacter::JumpReleasedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "JumpReleasedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickPressed
// (Final, Native, Protected)

void APlayerCharacter::KickPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickPressedController
// (Final, Native, Protected)

void APlayerCharacter::KickPressedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickPressedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickReleased
// (Final, Native, Protected)

void APlayerCharacter::KickReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickReleasedController
// (Final, Native, Protected)

void APlayerCharacter::KickReleasedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickReleasedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickSlidePressedController
// (Final, Native, Protected)

void APlayerCharacter::KickSlidePressedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickSlidePressedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickSlidePressedImp
// (Final, Native, Protected)

void APlayerCharacter::KickSlidePressedImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickSlidePressedImp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickSlidePressedKB
// (Final, Native, Protected)

void APlayerCharacter::KickSlidePressedKB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickSlidePressedKB");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickSlideReleasedController
// (Final, Native, Protected)

void APlayerCharacter::KickSlideReleasedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickSlideReleasedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickSlideReleasedImp
// (Final, Native, Protected)

void APlayerCharacter::KickSlideReleasedImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickSlideReleasedImp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.KickSlideReleasedKB
// (Final, Native, Protected)

void APlayerCharacter::KickSlideReleasedKB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "KickSlideReleasedKB");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.LeaveDivePoseSnapshot
// (Final, Native, Public)

void APlayerCharacter::LeaveDivePoseSnapshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LeaveDivePoseSnapshot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.LeaveRollPoseSnapshot
// (Final, Native, Public)

void APlayerCharacter::LeaveRollPoseSnapshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LeaveRollPoseSnapshot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.LeaveSlowMo
// (Final, Native, Public)

void APlayerCharacter::LeaveSlowMo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LeaveSlowMo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.LerpRightShoulderTo
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          ToLerpTo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::LerpRightShoulderTo(const struct FVector& ToLerpTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LerpRightShoulderTo");

	Params::PlayerCharacter_LerpRightShoulderTo Parms{};

	Parms.ToLerpTo = std::move(ToLerpTo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.LevelReady
// (Final, Native, Public)

void APlayerCharacter::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.LoadJacket
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InJacket                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::LoadJacket(class FName InJacket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LoadJacket");

	Params::PlayerCharacter_LoadJacket Parms{};

	Parms.InJacket = InJacket;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.LookUp
// (Final, Native, Public)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::LookUp(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LookUp");

	Params::PlayerCharacter_LookUp Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.LookUpController
// (Final, Native, Public)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::LookUpController(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LookUpController");

	Params::PlayerCharacter_LookUpController Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.LookUpImp
// (Final, Native, Public)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::LookUpImp(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "LookUpImp");

	Params::PlayerCharacter_LookUpImp Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.MoveKickSlide
// (Final, Native, Protected)
// Parameters:
// float                                   Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::MoveKickSlide(float Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "MoveKickSlide");

	Params::PlayerCharacter_MoveKickSlide Parms{};

	Parms.Velocity = Velocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.NotifyArmCannonChargeAnimOver
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::NotifyArmCannonChargeAnimOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "NotifyArmCannonChargeAnimOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.NotifyArmCannonMinCharge
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::NotifyArmCannonMinCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "NotifyArmCannonMinCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.NotifyDoorKicked
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::NotifyDoorKicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "NotifyDoorKicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.NotifyFanStatus
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bFanStatus                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InFanLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InFanVector                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FanLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::NotifyFanStatus(bool bFanStatus, const struct FVector& InFanLocation, const struct FVector& InFanVector, float FanLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "NotifyFanStatus");

	Params::PlayerCharacter_NotifyFanStatus Parms{};

	Parms.bFanStatus = bFanStatus;
	Parms.InFanLocation = std::move(InFanLocation);
	Parms.InFanVector = std::move(InFanVector);
	Parms.FanLength = FanLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.NotifyFinishedUncrouch
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::NotifyFinishedUncrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "NotifyFinishedUncrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnDebugMontageComplete
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnDebugMontageComplete(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnDebugMontageComplete");

	Params::PlayerCharacter_OnDebugMontageComplete Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnGetUpFinished
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnGetUpFinished(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnGetUpFinished");

	Params::PlayerCharacter_OnGetUpFinished Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnKickApex
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::OnKickApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnKickApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnKickHeld
// (Final, Native, Public)

void APlayerCharacter::OnKickHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnKickHeld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnKickHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APlayerCharacter::OnKickHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnKickHit");

	Params::PlayerCharacter_OnKickHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnKickHitOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APlayerCharacter::OnKickHitOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnKickHitOverlap");

	Params::PlayerCharacter_OnKickHitOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnProneDebugPressed
// (Final, Native, Public)

void APlayerCharacter::OnProneDebugPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnProneDebugPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnPunchApex
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::OnPunchApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnPunchApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnPunchApexArmCannon
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::OnPunchApexArmCannon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnPunchApexArmCannon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnRollFinished
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnRollFinished(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnRollFinished");

	Params::PlayerCharacter_OnRollFinished Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnRollInterrupted
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::OnRollInterrupted(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnRollInterrupted");

	Params::PlayerCharacter_OnRollInterrupted Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnSlideKickSliding
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::OnSlideKickSliding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnSlideKickSliding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnSlideKickStanding
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::OnSlideKickStanding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnSlideKickStanding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.OnWallRunTimeOut
// (Final, Native, Protected)

void APlayerCharacter::OnWallRunTimeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "OnWallRunTimeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PassedThroughChargeBox
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::PassedThroughChargeBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PassedThroughChargeBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PauseDeath
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::PauseDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PauseDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PausePressedDev
// (Final, Native, Protected)

void APlayerCharacter::PausePressedDev()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PausePressedDev");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PausePressedGamepad
// (Final, Native, Protected)

void APlayerCharacter::PausePressedGamepad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PausePressedGamepad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PausePressedKB
// (Final, Native, Protected)

void APlayerCharacter::PausePressedKB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PausePressedKB");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PickupCallPressedController
// (Final, Native, Protected)

void APlayerCharacter::PickupCallPressedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PickupCallPressedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PickupCallPressedImp
// (Final, Native, Protected)

void APlayerCharacter::PickupCallPressedImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PickupCallPressedImp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PickupCallPressedKeyboard
// (Final, Native, Protected)

void APlayerCharacter::PickupCallPressedKeyboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PickupCallPressedKeyboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PickupLookedAtWeapon
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::PickupLookedAtWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PickupLookedAtWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PickupLookedAtWeaponController
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::PickupLookedAtWeaponController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PickupLookedAtWeaponController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PickupLookedAtWeaponImp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForced                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::PickupLookedAtWeaponImp(bool bForced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PickupLookedAtWeaponImp");

	Params::PlayerCharacter_PickupLookedAtWeaponImp Parms{};

	Parms.bForced = bForced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PlayDebugMontage
// (Final, Native, Public)

void APlayerCharacter::PlayDebugMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PlayDebugMontage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PlayerRequestLevelReset
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::PlayerRequestLevelReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PlayerRequestLevelReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.PlayerRequestLevelResetGamepad
// (Final, Native, Public, BlueprintCallable)

void APlayerCharacter::PlayerRequestLevelResetGamepad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "PlayerRequestLevelResetGamepad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ProcessForwardInput
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ProcessForwardInput(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ProcessForwardInput");

	Params::PlayerCharacter_ProcessForwardInput Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ProcessForwardInputController
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ProcessForwardInputController(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ProcessForwardInputController");

	Params::PlayerCharacter_ProcessForwardInputController Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ProcessForwardInputImp
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ProcessForwardInputImp(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ProcessForwardInputImp");

	Params::PlayerCharacter_ProcessForwardInputImp Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ProcessGyroAcceleration
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FVector                          AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ProcessGyroAcceleration(const struct FVector& AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ProcessGyroAcceleration");

	Params::PlayerCharacter_ProcessGyroAcceleration Parms{};

	Parms.AxisValue = std::move(AxisValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ProcessGyroRotationRate
// (Final, Native, Protected, HasDefaults)
// Parameters:
// struct FVector                          AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ProcessGyroRotationRate(const struct FVector& AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ProcessGyroRotationRate");

	Params::PlayerCharacter_ProcessGyroRotationRate Parms{};

	Parms.AxisValue = std::move(AxisValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ProcessRightInput
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ProcessRightInput(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ProcessRightInput");

	Params::PlayerCharacter_ProcessRightInput Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ProcessRightInputController
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ProcessRightInputController(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ProcessRightInputController");

	Params::PlayerCharacter_ProcessRightInputController Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ProcessRightInputImp
// (Final, Native, Protected)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ProcessRightInputImp(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ProcessRightInputImp");

	Params::PlayerCharacter_ProcessRightInputImp Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ReactToSlowMoChange
// (Final, Native, Protected)
// Parameters:
// bool                                    bNewStatus                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ReactToSlowMoChange(bool bNewStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ReactToSlowMoChange");

	Params::PlayerCharacter_ReactToSlowMoChange Parms{};

	Parms.bNewStatus = bNewStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ReleasePickupLookedAtWeapon
// (Final, Native, Public)

void APlayerCharacter::ReleasePickupLookedAtWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ReleasePickupLookedAtWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ReloadPressed
// (Final, Native, Public)

void APlayerCharacter::ReloadPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ReloadPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.SetControllerLookSensitivity
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InSens                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::SetControllerLookSensitivity(float InSens)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SetControllerLookSensitivity");

	Params::PlayerCharacter_SetControllerLookSensitivity Parms{};

	Parms.InSens = InSens;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.SetGamepadAcceleration
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bAccel                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::SetGamepadAcceleration(bool bAccel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SetGamepadAcceleration");

	Params::PlayerCharacter_SetGamepadAcceleration Parms{};

	Parms.bAccel = bAccel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.SetLeftArmNoise
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldNoise                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::SetLeftArmNoise(bool bShouldNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SetLeftArmNoise");

	Params::PlayerCharacter_SetLeftArmNoise Parms{};

	Parms.bShouldNoise = bShouldNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.SetLookSpeedBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   InSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::SetLookSpeedBP(float InSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SetLookSpeedBP");

	Params::PlayerCharacter_SetLookSpeedBP Parms{};

	Parms.InSpeed = InSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.SetTerminalVelocity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::SetTerminalVelocity(float InV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SetTerminalVelocity");

	Params::PlayerCharacter_SetTerminalVelocity Parms{};

	Parms.InV = InV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.SetupDecorativeGun
// (Event, Public, BlueprintEvent)

void APlayerCharacter::SetupDecorativeGun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SetupDecorativeGun");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PlayerCharacter.SetWallRunningViz
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsActive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::SetWallRunningViz(bool bIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SetWallRunningViz");

	Params::PlayerCharacter_SetWallRunningViz Parms{};

	Parms.bIsActive = bIsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.ShootCannonGamepadPressed
// (Final, Native, Public)

void APlayerCharacter::ShootCannonGamepadPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShootCannonGamepadPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ShootCannonGamepadReleased
// (Final, Native, Public)

void APlayerCharacter::ShootCannonGamepadReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShootCannonGamepadReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ShootCannonMKBPressed
// (Final, Native, Public)

void APlayerCharacter::ShootCannonMKBPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShootCannonMKBPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ShootCannonMKBReleased
// (Final, Native, Public)

void APlayerCharacter::ShootCannonMKBReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShootCannonMKBReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ShootCannonPressedImp
// (Final, Native, Public)

void APlayerCharacter::ShootCannonPressedImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShootCannonPressedImp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ShootCannonReleasedImp
// (Final, Native, Public)

void APlayerCharacter::ShootCannonReleasedImp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShootCannonReleasedImp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ShowDamage
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          DamageOrigin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ShowDamage(const struct FVector& DamageOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShowDamage");

	Params::PlayerCharacter_ShowDamage Parms{};

	Parms.DamageOrigin = std::move(DamageOrigin);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.ShowWeaponPickupUI
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AWeaponBase*                      Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::ShowWeaponPickupUI(class AWeaponBase* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ShowWeaponPickupUI");

	Params::PlayerCharacter_ShowWeaponPickupUI Parms{};

	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PlayerCharacter.SlowMoPressedController
// (Final, Native, Public)

void APlayerCharacter::SlowMoPressedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SlowMoPressedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.SlowMoPressedMouse
// (Final, Native, Public)

void APlayerCharacter::SlowMoPressedMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SlowMoPressedMouse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.SlowMoReleasedController
// (Final, Native, Public)

void APlayerCharacter::SlowMoReleasedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SlowMoReleasedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.SlowMoReleasedMouse
// (Final, Native, Public)

void APlayerCharacter::SlowMoReleasedMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SlowMoReleasedMouse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.SmoothControllerAxis
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   Xin                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yin                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Xout                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yout                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForTurning                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::SmoothControllerAxis(float Xin, float Yin, float* Xout, float* Yout, bool bForTurning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SmoothControllerAxis");

	Params::PlayerCharacter_SmoothControllerAxis Parms{};

	Parms.Xin = Xin;
	Parms.Yin = Yin;
	Parms.bForTurning = bForTurning;

	UObject::ProcessEvent(Func, &Parms);

	if (Xout != nullptr)
		*Xout = Parms.Xout;

	if (Yout != nullptr)
		*Yout = Parms.Yout;
}


// Function ThankYouVeryCool.PlayerCharacter.SpendLuck
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDir                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitOrigin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerCharacter::SpendLuck(int32 Amount, const struct FVector& HitDir, const struct FVector& HitOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SpendLuck");

	Params::PlayerCharacter_SpendLuck Parms{};

	Parms.Amount = Amount;
	Parms.HitDir = std::move(HitDir);
	Parms.HitOrigin = std::move(HitOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PlayerCharacter.StandFromProneStep2
// (Final, Native, Protected)

void APlayerCharacter::StandFromProneStep2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "StandFromProneStep2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.StopWallRunning
// (Final, Native, Protected)

void APlayerCharacter::StopWallRunning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "StopWallRunning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.SwapWeapon
// (Final, Native, Public)

void APlayerCharacter::SwapWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "SwapWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ThrowWeaponPressed
// (Final, Native, Public)

void APlayerCharacter::ThrowWeaponPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ThrowWeaponPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ThrowWeaponPressedController
// (Final, Native, Public)

void APlayerCharacter::ThrowWeaponPressedController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ThrowWeaponPressedController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TickCapsuleLerp
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::TickCapsuleLerp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TickCapsuleLerp");

	Params::PlayerCharacter_TickCapsuleLerp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TickClimbForward
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::TickClimbForward(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TickClimbForward");

	Params::PlayerCharacter_TickClimbForward Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TickClimbUp
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::TickClimbUp(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TickClimbUp");

	Params::PlayerCharacter_TickClimbUp Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ToggleRunPressed
// (Final, Native, Public)

void APlayerCharacter::ToggleRunPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ToggleRunPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.ToggleSlowMo
// (Final, Native, Public)

void APlayerCharacter::ToggleSlowMo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "ToggleSlowMo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TriggerDownController
// (Final, Native, Public)

void APlayerCharacter::TriggerDownController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TriggerDownController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TriggerDownMouse
// (Final, Native, Public)

void APlayerCharacter::TriggerDownMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TriggerDownMouse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TriggerUpController
// (Final, Native, Public)

void APlayerCharacter::TriggerUpController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TriggerUpController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TriggerUpMouse
// (Final, Native, Public)

void APlayerCharacter::TriggerUpMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TriggerUpMouse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.Turn
// (Final, Native, Public)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::Turn(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "Turn");

	Params::PlayerCharacter_Turn Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TurnController
// (Final, Native, Public)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::TurnController(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TurnController");

	Params::PlayerCharacter_TurnController Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.TurnImp
// (Final, Native, Public)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::TurnImp(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "TurnImp");

	Params::PlayerCharacter_TurnImp Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.UpdateAimAdjustDelta
// (Final, Native, Public)

void APlayerCharacter::UpdateAimAdjustDelta()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "UpdateAimAdjustDelta");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.UpdateDeathCameraSwivel
// (Final, Native, Protected)

void APlayerCharacter::UpdateDeathCameraSwivel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "UpdateDeathCameraSwivel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.UpdateOnWallRunCameraCurve
// (Final, Native, Protected)

void APlayerCharacter::UpdateOnWallRunCameraCurve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "UpdateOnWallRunCameraCurve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.UpdateProneFromStand
// (Final, Native, Protected)

void APlayerCharacter::UpdateProneFromStand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "UpdateProneFromStand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.UpdateStandFromProne
// (Final, Native, Protected)

void APlayerCharacter::UpdateStandFromProne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "UpdateStandFromProne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.UpdateTriggerPull
// (Final, Native, Public)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::UpdateTriggerPull(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "UpdateTriggerPull");

	Params::PlayerCharacter_UpdateTriggerPull Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.UpdateTriggerPullController
// (Final, Native, Public)
// Parameters:
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerCharacter::UpdateTriggerPullController(float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "UpdateTriggerPullController");

	Params::PlayerCharacter_UpdateTriggerPullController Parms{};

	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.UpdateWallRunZAndReleaseCurve
// (Final, Native, Protected)

void APlayerCharacter::UpdateWallRunZAndReleaseCurve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "UpdateWallRunZAndReleaseCurve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.WallRunCoolDownOver
// (Final, Native, Protected)

void APlayerCharacter::WallRunCoolDownOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "WallRunCoolDownOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PlayerCharacter.WindDownFan
// (Event, Public, BlueprintEvent)

void APlayerCharacter::WindDownFan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "WindDownFan");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PlayerCharacter.WindUpFan
// (Event, Public, BlueprintEvent)

void APlayerCharacter::WindUpFan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacter", "WindUpFan");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PoolableFire.MakeDormantBP
// (Event, Public, BlueprintEvent)

void APoolableFire::MakeDormantBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoolableFire", "MakeDormantBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PoolableFire.StartBurning
// (Event, Public, BlueprintEvent)

void APoolableFire::StartBurning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoolableFire", "StartBurning");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PoolableGlass.OnGlassSleep
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              SleepingComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoolableGlass::OnGlassSleep(class UPrimitiveComponent* SleepingComponent, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoolableGlass", "OnGlassSleep");

	Params::PoolableGlass_OnGlassSleep Parms{};

	Parms.SleepingComponent = SleepingComponent;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PoolableGlass.OnHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APoolableGlass::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoolableGlass", "OnHit");

	Params::PoolableGlass_OnHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PoolManager.GetPooledActorBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class APoolableActor>       InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* APoolManager::GetPooledActorBP(TSubclassOf<class APoolableActor> InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoolManager", "GetPooledActorBP");

	Params::PoolManager_GetPooledActorBP Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PropVoxelWorld.ApplySelfToData
// (Final, Native, Public, BlueprintCallable)

void APropVoxelWorld::ApplySelfToData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "ApplySelfToData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.Bounced
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::Bounced(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "Bounced");

	Params::PropVoxelWorld_Bounced Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.CacheShatteredChunks
// (Event, Public, BlueprintCallable, BlueprintEvent)

void APropVoxelWorld::CacheShatteredChunks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "CacheShatteredChunks");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PropVoxelWorld.CanCannonEdit
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APropVoxelWorld::CanCannonEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "CanCannonEdit");

	Params::PropVoxelWorld_CanCannonEdit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.PropVoxelWorld.CancelMoves
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void APropVoxelWorld::CancelMoves()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "CancelMoves");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PropVoxelWorld.DoMove
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          RelativeMove                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeToMove                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::DoMove(const struct FVector& RelativeMove, float TimeToMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "DoMove");

	Params::PropVoxelWorld_DoMove Parms{};

	Parms.RelativeMove = std::move(RelativeMove);
	Parms.TimeToMove = TimeToMove;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PropVoxelWorld.DoMyActions
// (Final, Native, Protected, BlueprintCallable)

void APropVoxelWorld::DoMyActions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "DoMyActions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.DoShake
// (Event, Public, BlueprintCallable, BlueprintEvent)

void APropVoxelWorld::DoShake()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "DoShake");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PropVoxelWorld.DoShatter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ShatterOrigin                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::DoShatter(const struct FVector& ShatterOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "DoShatter");

	Params::PropVoxelWorld_DoShatter Parms{};

	Parms.ShatterOrigin = std::move(ShatterOrigin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.EditorModeChanged_Implementation
// (Final, Native, Public)
// Parameters:
// EEditMode                               NewMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::EditorModeChanged_Implementation(EEditMode NewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "EditorModeChanged_Implementation");

	Params::PropVoxelWorld_EditorModeChanged_Implementation Parms{};

	Parms.NewMode = NewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.Explode
// (Event, Public, BlueprintCallable, BlueprintEvent)

void APropVoxelWorld::Explode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "Explode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PropVoxelWorld.HitByWidePulse
// (Event, Public, BlueprintEvent)

void APropVoxelWorld::HitByWidePulse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "HitByWidePulse");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PropVoxelWorld.HomeOnTarget
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::HomeOnTarget(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "HomeOnTarget");

	Params::PropVoxelWorld_HomeOnTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.ImpulseIfPossible
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::ImpulseIfPossible(const struct FVector& Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "ImpulseIfPossible");

	Params::PropVoxelWorld_ImpulseIfPossible Parms{};

	Parms.Impulse = std::move(Impulse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.InterpRelative
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          RelativeMove                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeToMove                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       WhenDone                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void APropVoxelWorld::InterpRelative(const struct FVector& RelativeMove, float TimeToMove, TDelegate<void()> WhenDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "InterpRelative");

	Params::PropVoxelWorld_InterpRelative Parms{};

	Parms.RelativeMove = std::move(RelativeMove);
	Parms.TimeToMove = TimeToMove;
	Parms.WhenDone = WhenDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.LevelReady
// (Native, Event, Public, BlueprintEvent)

void APropVoxelWorld::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.MoveDone
// (Final, Native, Protected, BlueprintCallable)

void APropVoxelWorld::MoveDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "MoveDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.Olap
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APropVoxelWorld::Olap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "Olap");

	Params::PropVoxelWorld_Olap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.OnSpawnedAtRuntime
// (Final, Native, Public, BlueprintCallable)

void APropVoxelWorld::OnSpawnedAtRuntime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "OnSpawnedAtRuntime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.OnThrownHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APropVoxelWorld::OnThrownHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "OnThrownHit");

	Params::PropVoxelWorld_OnThrownHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.OnThrownStop
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APropVoxelWorld::OnThrownStop(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "OnThrownStop");

	Params::PropVoxelWorld_OnThrownStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.ProcGenFractureLines
// (Final, Native, Public, BlueprintCallable)

void APropVoxelWorld::ProcGenFractureLines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "ProcGenFractureLines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.RecreateRenderDelayed
// (Final, Native, Public, BlueprintCallable)

void APropVoxelWorld::RecreateRenderDelayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "RecreateRenderDelayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.RemoveCompass
// (Event, Public, BlueprintEvent)

void APropVoxelWorld::RemoveCompass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "RemoveCompass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.PropVoxelWorld.RequestNavmeshUpdate
// (Final, Native, Public, BlueprintCallable)

void APropVoxelWorld::RequestNavmeshUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "RequestNavmeshUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.SetCanTip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCanTip                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetCanTip(bool bInCanTip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetCanTip");

	Params::PropVoxelWorld_SetCanTip Parms{};

	Parms.bInCanTip = bInCanTip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.SetExplosionInfo
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   EditRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShockwaveRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetExplosionInfo(float EditRadius, float ShockwaveRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetExplosionInfo");

	Params::PropVoxelWorld_SetExplosionInfo Parms{};

	Parms.EditRadius = EditRadius;
	Parms.ShockwaveRadius = ShockwaveRadius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.PropVoxelWorld.SetHighlightedGrav
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHighlighted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetHighlightedGrav(bool bHighlighted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetHighlightedGrav");

	Params::PropVoxelWorld_SetHighlightedGrav Parms{};

	Parms.bHighlighted = bHighlighted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.SetHighlightedHUD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHighlighted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetHighlightedHUD(bool bHighlighted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetHighlightedHUD");

	Params::PropVoxelWorld_SetHighlightedHUD Parms{};

	Parms.bHighlighted = bHighlighted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.SetHighRez
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsHiRez                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetHighRez(bool bIsHiRez)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetHighRez");

	Params::PropVoxelWorld_SetHighRez Parms{};

	Parms.bIsHiRez = bIsHiRez;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.SetLODEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetLODEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetLODEnabled");

	Params::PropVoxelWorld_SetLODEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.SetPlayerInteractionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerInteractionType                  InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetPlayerInteractionType(EPlayerInteractionType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetPlayerInteractionType");

	Params::PropVoxelWorld_SetPlayerInteractionType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.SetShake
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetShake(bool bSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetShake");

	Params::PropVoxelWorld_SetShake Parms{};

	Parms.bSet = bSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.SetShouldMove
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bInShouldMove                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APropVoxelWorld::SetShouldMove(bool bInShouldMove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "SetShouldMove");

	Params::PropVoxelWorld_SetShouldMove Parms{};

	Parms.bInShouldMove = bInShouldMove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.PropVoxelWorld.TargetHomeSuccess
// (Final, Native, Public, BlueprintCallable)

void APropVoxelWorld::TargetHomeSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PropVoxelWorld", "TargetHomeSuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.CardSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCardData*                        InCard                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARogueManager::CardSelected(class UCardData* InCard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "CardSelected");

	Params::RogueManager_CardSelected Parms{};

	Parms.InCard = InCard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.CheckNewCannon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   OldScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFoundNew                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TilNext                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARogueManager::CheckNewCannon(int32 OldScore, int32 NewScore, bool* bFoundNew, int32* TilNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "CheckNewCannon");

	Params::RogueManager_CheckNewCannon Parms{};

	Parms.OldScore = OldScore;
	Parms.NewScore = NewScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFoundNew != nullptr)
		*bFoundNew = Parms.bFoundNew;

	if (TilNext != nullptr)
		*TilNext = Parms.TilNext;
}


// Function ThankYouVeryCool.RogueManager.CheckNewJacket
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   OldScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFoundNew                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TilNext                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARogueManager::CheckNewJacket(int32 OldScore, int32 NewScore, bool* bFoundNew, int32* TilNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "CheckNewJacket");

	Params::RogueManager_CheckNewJacket Parms{};

	Parms.OldScore = OldScore;
	Parms.NewScore = NewScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFoundNew != nullptr)
		*bFoundNew = Parms.bFoundNew;

	if (TilNext != nullptr)
		*TilNext = Parms.TilNext;
}


// Function ThankYouVeryCool.RogueManager.Continue
// (Final, Native, Public, BlueprintCallable)

void ARogueManager::Continue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "Continue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.DrawCards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Tier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UCardData*>                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UCardData*> ARogueManager::DrawCards(int32 Count, int32 Tier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "DrawCards");

	Params::RogueManager_DrawCards Parms{};

	Parms.Count = Count;
	Parms.Tier = Tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.DrawEdensysCard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCardData*                        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCardData* ARogueManager::DrawEdensysCard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "DrawEdensysCard");

	Params::RogueManager_DrawEdensysCard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.GetCachedMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARogueManager::GetCachedMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "GetCachedMultiplier");

	Params::RogueManager_GetCachedMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.GetCurrentCardsTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARogueManager::GetCurrentCardsTier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "GetCurrentCardsTier");

	Params::RogueManager_GetCurrentCardsTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.GetNextLevelInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UTexture>          LevelScreen                                            (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Name_0                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    bIsArcade                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARogueManager::GetNextLevelInfo(TSoftObjectPtr<class UTexture>* LevelScreen, class FText* Name_0, bool* bIsArcade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "GetNextLevelInfo");

	Params::RogueManager_GetNextLevelInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LevelScreen != nullptr)
		*LevelScreen = Parms.LevelScreen;

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);

	if (bIsArcade != nullptr)
		*bIsArcade = Parms.bIsArcade;
}


// Function ThankYouVeryCool.RogueManager.HasCardBeenCollected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCardData*                        Card                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARogueManager::HasCardBeenCollected(class UCardData* Card)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "HasCardBeenCollected");

	Params::RogueManager_HasCardBeenCollected Parms{};

	Parms.Card = Card;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.HasSoftCardBeenCollected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             Card                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARogueManager::HasSoftCardBeenCollected(TSoftClassPtr<class UClass> Card)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "HasSoftCardBeenCollected");

	Params::RogueManager_HasSoftCardBeenCollected Parms{};

	Parms.Card = Card;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.IsCannonUnlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ForScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutScore                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARogueManager::IsCannonUnlocked(class FName RowName, int32 ForScore, int32* OutScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "IsCannonUnlocked");

	Params::RogueManager_IsCannonUnlocked Parms{};

	Parms.RowName = RowName;
	Parms.ForScore = ForScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScore != nullptr)
		*OutScore = Parms.OutScore;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.IsJacketUnlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ForScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutAtLevel                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARogueManager::IsJacketUnlocked(class FName RowName, int32 ForScore, int32* OutAtLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "IsJacketUnlocked");

	Params::RogueManager_IsJacketUnlocked Parms{};

	Parms.RowName = RowName;
	Parms.ForScore = ForScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAtLevel != nullptr)
		*OutAtLevel = Parms.OutAtLevel;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.NextLevelRequested
// (Final, Native, Public, BlueprintCallable)

void ARogueManager::NextLevelRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "NextLevelRequested");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCardData*                        StartingCard                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARogueManager::Play(class UCardData* StartingCard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "Play");

	Params::RogueManager_Play Parms{};

	Parms.StartingCard = StartingCard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.PlayerRequestTryAgain
// (Final, Native, Public, BlueprintCallable)

void ARogueManager::PlayerRequestTryAgain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "PlayerRequestTryAgain");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.PrepareForForcedMainMenu
// (Final, Native, Public, BlueprintCallable)

void ARogueManager::PrepareForForcedMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "PrepareForForcedMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.StupidAsyncCallback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FRogueLevel                      MP                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ARogueManager::StupidAsyncCallback(const struct FRogueLevel& MP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "StupidAsyncCallback");

	Params::RogueManager_StupidAsyncCallback Parms{};

	Parms.MP = std::move(MP);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.StupidAsyncCallbackForFF
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UArcadeLevelAsset>    ClassIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AChapter*                         InC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCampaignDataAsset*               CDA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelEditorSave*                 LoadedSave                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARogueManager::StupidAsyncCallbackForFF(TSubclassOf<class UArcadeLevelAsset> ClassIn, class AChapter* InC, class UCampaignDataAsset* CDA, class ULevelEditorSave* LoadedSave)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "StupidAsyncCallbackForFF");

	Params::RogueManager_StupidAsyncCallbackForFF Parms{};

	Parms.ClassIn = ClassIn;
	Parms.InC = InC;
	Parms.CDA = CDA;
	Parms.LoadedSave = LoadedSave;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.RogueManager.StupidAsyncLoadHack
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TSoftClassPtr<class UClass>             ClassIn                                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRogueLevel                      MP                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ARogueManager::StupidAsyncLoadHack(const TSoftClassPtr<class UClass>& ClassIn, const struct FRogueLevel& MP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "StupidAsyncLoadHack");

	Params::RogueManager_StupidAsyncLoadHack Parms{};

	Parms.ClassIn = ClassIn;
	Parms.MP = std::move(MP);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.RogueManager.StupidAsyncLoadHackForFirefight
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class UArcadeLevelAsset>    ClassIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AChapter*                         InC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCampaignDataAsset*               CDA                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARogueManager::StupidAsyncLoadHackForFirefight(TSubclassOf<class UArcadeLevelAsset> ClassIn, class AChapter* InC, class UCampaignDataAsset* CDA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "StupidAsyncLoadHackForFirefight");

	Params::RogueManager_StupidAsyncLoadHackForFirefight Parms{};

	Parms.ClassIn = ClassIn;
	Parms.InC = InC;
	Parms.CDA = CDA;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.RogueManager.GetCollectedCards
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARogueManager::GetCollectedCards() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "GetCollectedCards");

	Params::RogueManager_GetCollectedCards Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.RogueManager.GetTotalCards
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARogueManager::GetTotalCards() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RogueManager", "GetTotalCards");

	Params::RogueManager_GetTotalCards Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.VoxelWorldManager.ClearAll
// (Final, Native, Public, BlueprintCallable)

void AVoxelWorldManager::ClearAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorldManager", "ClearAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelWorldManager.GetWorldSave
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AVoxelWorldManager::GetWorldSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorldManager", "GetWorldSave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.VoxelWorldManager.SetupLevel
// (Final, Native, Public, BlueprintCallable)

void AVoxelWorldManager::SetupLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorldManager", "SetupLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VoxelWorldManager.UpdateAll
// (Final, Native, Public, BlueprintCallable)

void AVoxelWorldManager::UpdateAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelWorldManager", "UpdateAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.SlowMoProjectile.ResolveAsRaycast
// (Final, Native, Public)

void ASlowMoProjectile::ResolveAsRaycast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlowMoProjectile", "ResolveAsRaycast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.SlowMoProjectile.ResolveImpact
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASlowMoProjectile::ResolveImpact(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlowMoProjectile", "ResolveImpact");

	Params::SlowMoProjectile_ResolveImpact Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.SpeechBubbleComponent.CallSay
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Dialogue                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpeechBubbleComponent::CallSay(const class FString& Dialogue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeechBubbleComponent", "CallSay");

	Params::SpeechBubbleComponent_CallSay Parms{};

	Parms.Dialogue = std::move(Dialogue);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.SpeedrunOverlay.StartCountdown
// (Event, Public, BlueprintEvent)

void USpeedrunOverlay::StartCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeedrunOverlay", "StartCountdown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.SpeedrunOverlay.UpdateDisplayedGoal
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDifficulty                             Goal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpeedrunOverlay::UpdateDisplayedGoal(float Time, EDifficulty Goal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpeedrunOverlay", "UpdateDisplayedGoal");

	Params::SpeedrunOverlay_UpdateDisplayedGoal Parms{};

	Parms.Time = Time;
	Parms.Goal = Goal;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.SpentShell.OnBounce
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpentShell::OnBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpentShell", "OnBounce");

	Params::SpentShell_OnBounce Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.SpentShell.OnStop
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASpentShell::OnStop(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpentShell", "OnStop");

	Params::SpentShell_OnStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.SpreadingCrosshair.FadeInCrosshair
// (Event, Public, BlueprintEvent)

void USpreadingCrosshair::FadeInCrosshair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpreadingCrosshair", "FadeInCrosshair");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.SpreadingCrosshair.FadeOutCrosshair
// (Event, Public, BlueprintEvent)

void USpreadingCrosshair::FadeOutCrosshair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpreadingCrosshair", "FadeOutCrosshair");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.SpreadingCrosshair.Setup
// (Final, Native, Public, BlueprintCallable)

void USpreadingCrosshair::Setup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpreadingCrosshair", "Setup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.SpreadingCrosshair.ShowMarker
// (Event, Public, BlueprintEvent)

void USpreadingCrosshair::ShowMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpreadingCrosshair", "ShowMarker");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.Squad.GetRandomMember
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ANPCController*>           InList                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class ANPCController*>           ToIgnore                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<ESituationContext>               SitRepsToIgnore                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class ANPCController*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANPCController* ASquad::GetRandomMember(const TArray<class ANPCController*>& InList, const TArray<class ANPCController*>& ToIgnore, const TArray<ESituationContext>& SitRepsToIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("Squad", "GetRandomMember");

	Params::Squad_GetRandomMember Parms{};

	Parms.InList = std::move(InList);
	Parms.ToIgnore = std::move(ToIgnore);
	Parms.SitRepsToIgnore = std::move(SitRepsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.GetClosestToPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANPC*                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANPC* ASquad::GetClosestToPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "GetClosestToPlayer");

	Params::Squad_GetClosestToPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.GetClosestToPlayerWhoCanSee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ANPC*                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANPC* ASquad::GetClosestToPlayerWhoCanSee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "GetClosestToPlayerWhoCanSee");

	Params::Squad_GetClosestToPlayerWhoCanSee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.GetLivingCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASquad::GetLivingCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "GetLivingCount");

	Params::Squad_GetLivingCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.GetMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class ANPCController*>     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ANPCController*> ASquad::GetMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "GetMembers");

	Params::Squad_GetMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.GetMembersInRange
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ANPCController*>           ListOfNPCs                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class ANPCController*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ANPCController*> ASquad::GetMembersInRange(const struct FVector& Location, float Range, const TArray<class ANPCController*>& ListOfNPCs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "GetMembersInRange");

	Params::Squad_GetMembersInRange Parms{};

	Parms.Location = std::move(Location);
	Parms.Range = Range;
	Parms.ListOfNPCs = std::move(ListOfNPCs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.GetPlayerPositionModel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerPositionModel*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerPositionModel* ASquad::GetPlayerPositionModel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "GetPlayerPositionModel");

	Params::Squad_GetPlayerPositionModel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.GetRandomMembers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ANPCController*>           OutList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class ANPCController*>           ToIgnore                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASquad::GetRandomMembers(TArray<class ANPCController*>* OutList, const TArray<class ANPCController*>& ToIgnore, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "GetRandomMembers");

	Params::Squad_GetRandomMembers Parms{};

	Parms.ToIgnore = std::move(ToIgnore);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutList != nullptr)
		*OutList = std::move(Parms.OutList);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.GetRandomMembersClosestTo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ANPCController*>           OutList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class ANPCController*>           ToIgnore                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASquad::GetRandomMembersClosestTo(const struct FVector& Location, TArray<class ANPCController*>* OutList, const TArray<class ANPCController*>& ToIgnore, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "GetRandomMembersClosestTo");

	Params::Squad_GetRandomMembersClosestTo Parms{};

	Parms.Location = std::move(Location);
	Parms.ToIgnore = std::move(ToIgnore);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutList != nullptr)
		*OutList = std::move(Parms.OutList);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.HaveClosestMemberSay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ToSay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquad::HaveClosestMemberSay(class FName ToSay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "HaveClosestMemberSay");

	Params::Squad_HaveClosestMemberSay Parms{};

	Parms.ToSay = ToSay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Squad.HaveClosestMemberWhoCanSeeSay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ToSay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquad::HaveClosestMemberWhoCanSeeSay(class FName ToSay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "HaveClosestMemberWhoCanSeeSay");

	Params::Squad_HaveClosestMemberWhoCanSeeSay Parms{};

	Parms.ToSay = ToSay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Squad.IsPointInZone
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASquad::IsPointInZone(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "IsPointInZone");

	Params::Squad_IsPointInZone Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.Squad.MaybeSaySomething
// (Final, Native, Public)

void ASquad::MaybeSaySomething()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "MaybeSaySomething");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Squad.OnLevelReady
// (Final, Native, Public)

void ASquad::OnLevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "OnLevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Squad.OnLevelUnload
// (Final, Native, Public)

void ASquad::OnLevelUnload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "OnLevelUnload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Squad.OnSleepBoundsBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASquad::OnSleepBoundsBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "OnSleepBoundsBeginOverlap");

	Params::Squad_OnSleepBoundsBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Squad.OnSleepBoundsEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquad::OnSleepBoundsEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "OnSleepBoundsEndOverlap");

	Params::Squad_OnSleepBoundsEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Squad.Reset
// (Native, Public)

void ASquad::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Squad.SetPositionModelValidity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsValid                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASquad::SetPositionModelValidity(bool bIsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Squad", "SetPositionModelValidity");

	Params::Squad_SetPositionModelValidity Parms{};

	Parms.bIsValid = bIsValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.Teleporter.UpdateLinkID
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATeleporter::UpdateLinkID(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Teleporter", "UpdateLinkID");

	Params::Teleporter_UpdateLinkID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ExtractDataClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* AThankYouVeryCoolGameMode::ExtractDataClass(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThankYouVeryCoolGameMode", "ExtractDataClass");

	Params::ThankYouVeryCoolGameMode_ExtractDataClass Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetBaseNPCScore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetBaseNPCScore(class UObject* InObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ThankYouVeryCoolGameMode", "SetBaseNPCScore");

	Params::ThankYouVeryCoolGameMode_SetBaseNPCScore Parms{};

	Parms.InObject = InObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ApplyAudioSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FTYVCAudioSettings               InSettings                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    Save                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ApplyAudioSettings(const struct FTYVCAudioSettings& InSettings, bool Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ApplyAudioSettings");

	Params::ThankYouVeryCoolGameMode_ApplyAudioSettings Parms{};

	Parms.InSettings = std::move(InSettings);
	Parms.Save = Save;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ApplyControlSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FControlSettings                 InSettings                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Save                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ApplyControlSettings(const struct FControlSettings& InSettings, bool Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ApplyControlSettings");

	Params::ThankYouVeryCoolGameMode_ApplyControlSettings Parms{};

	Parms.InSettings = std::move(InSettings);
	Parms.Save = Save;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ApplyControlSettingsGamepad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FControlSettingsGamepad          InSettings                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    Save                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ApplyControlSettingsGamepad(const struct FControlSettingsGamepad& InSettings, bool Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ApplyControlSettingsGamepad");

	Params::ThankYouVeryCoolGameMode_ApplyControlSettingsGamepad Parms{};

	Parms.InSettings = std::move(InSettings);
	Parms.Save = Save;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ApplyGameSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameSettings                    InSettings                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    Save                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ApplyGameSettings(const struct FGameSettings& InSettings, bool Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ApplyGameSettings");

	Params::ThankYouVeryCoolGameMode_ApplyGameSettings Parms{};

	Parms.InSettings = std::move(InSettings);
	Parms.Save = Save;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ApplyVisualSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVisualSettings                  InSettings                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    Save                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ApplyVisualSettings(const struct FVisualSettings& InSettings, bool Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ApplyVisualSettings");

	Params::ThankYouVeryCoolGameMode_ApplyVisualSettings Parms{};

	Parms.InSettings = std::move(InSettings);
	Parms.Save = Save;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ArcadeResetComplete
// (Final, Native, Public)
// Parameters:
// struct FTYVCNodeMemory                  NodeMemory                                             (Parm, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ArcadeResetComplete(const struct FTYVCNodeMemory& NodeMemory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ArcadeResetComplete");

	Params::ThankYouVeryCoolGameMode_ArcadeResetComplete Parms{};

	Parms.NodeMemory = std::move(NodeMemory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.AwakeAll
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::AwakeAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "AwakeAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.bShouldShowNVStuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::bShouldShowNVStuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "bShouldShowNVStuff");

	Params::ThankYouVeryCoolGameMode_bShouldShowNVStuff Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.BumpTimerHUD
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AThankYouVeryCoolGameMode::BumpTimerHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "BumpTimerHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CacheOnSteamDeck
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::CacheOnSteamDeck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CacheOnSteamDeck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CacheUncompressedWorld
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bSholdCache                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::CacheUncompressedWorld(bool bSholdCache)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CacheUncompressedWorld");

	Params::ThankYouVeryCoolGameMode_CacheUncompressedWorld Parms{};

	Parms.bSholdCache = bSholdCache;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CalcRankThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BaseScore                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERank                                   ForRank                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AThankYouVeryCoolGameMode::CalcRankThreshold(int32 BaseScore, ERank ForRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CalcRankThreshold");

	Params::ThankYouVeryCoolGameMode_CalcRankThreshold Parms{};

	Parms.BaseScore = BaseScore;
	Parms.ForRank = ForRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CalculateCurrentRank
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ForScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERank                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERank AThankYouVeryCoolGameMode::CalculateCurrentRank(int32 ForScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CalculateCurrentRank");

	Params::ThankYouVeryCoolGameMode_CalculateCurrentRank Parms{};

	Parms.ForScore = ForScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CampaignRequestedFadeIn
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::CampaignRequestedFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CampaignRequestedFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CampaignRequestedFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SpeedModifier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::CampaignRequestedFadeOut(float SpeedModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CampaignRequestedFadeOut");

	Params::ThankYouVeryCoolGameMode_CampaignRequestedFadeOut Parms{};

	Parms.SpeedModifier = SpeedModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CanDoLeaderboard
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             ReasonWhyNo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::CanDoLeaderboard(class FText* ReasonWhyNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CanDoLeaderboard");

	Params::ThankYouVeryCoolGameMode_CanDoLeaderboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReasonWhyNo != nullptr)
		*ReasonWhyNo = std::move(Parms.ReasonWhyNo);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CanSaveRank
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             ReasonWhyNo                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::CanSaveRank(class FText* ReasonWhyNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CanSaveRank");

	Params::ThankYouVeryCoolGameMode_CanSaveRank Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ReasonWhyNo != nullptr)
		*ReasonWhyNo = std::move(Parms.ReasonWhyNo);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CheckLevelLoadProgress
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::CheckLevelLoadProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CheckLevelLoadProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CheckLevelResetProgress
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::CheckLevelResetProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CheckLevelResetProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ClearAllCompassMarkers
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AThankYouVeryCoolGameMode::ClearAllCompassMarkers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ClearAllCompassMarkers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ClearLevel
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::ClearLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ClearLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ClearRagdolls
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::ClearRagdolls()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ClearRagdolls");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CopyLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UArcadeLevelAssetWorkshop*        LevelAsset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DesiredName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UArcadeLevelAssetWorkshop*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UArcadeLevelAssetWorkshop* AThankYouVeryCoolGameMode::CopyLevel(class UArcadeLevelAssetWorkshop* LevelAsset, const class FString& DesiredName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CopyLevel");

	Params::ThankYouVeryCoolGameMode_CopyLevel Parms{};

	Parms.LevelAsset = LevelAsset;
	Parms.DesiredName = std::move(DesiredName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CopyLevelToCampaign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UArcadeLevelAssetWorkshop*        LevelAsset                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CampaignName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::CopyLevelToCampaign(class UArcadeLevelAssetWorkshop* LevelAsset, const class FString& CampaignName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CopyLevelToCampaign");

	Params::ThankYouVeryCoolGameMode_CopyLevelToCampaign Parms{};

	Parms.LevelAsset = LevelAsset;
	Parms.CampaignName = std::move(CampaignName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CorsairForceEvent
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Event                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::CorsairForceEvent(const class FString& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CorsairForceEvent");

	Params::ThankYouVeryCoolGameMode_CorsairForceEvent Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.CorsairForceState
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           State                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::CorsairForceState(const class FString& State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "CorsairForceState");

	Params::ThankYouVeryCoolGameMode_CorsairForceState Parms{};

	Parms.State = std::move(State);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.DebugCollection
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::DebugCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "DebugCollection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.DebugGyro
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::DebugGyro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "DebugGyro");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.DebugShowCoverPoints
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::DebugShowCoverPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "DebugShowCoverPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.DisableNPCsStocked
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::DisableNPCsStocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "DisableNPCsStocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.DoCinematicCam
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::DoCinematicCam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "DoCinematicCam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.DoCoverPostProcessing
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::DoCoverPostProcessing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "DoCoverPostProcessing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.DumpFeats
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::DumpFeats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "DumpFeats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.DumpRogueSave
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::DumpRogueSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "DumpRogueSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.EnableConsoleCheats
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::EnableConsoleCheats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "EnableConsoleCheats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.EnsureNoMap
// (Event, Public, BlueprintEvent)

void AThankYouVeryCoolGameMode::EnsureNoMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "EnsureNoMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.EnterPressed
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::EnterPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "EnterPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ExploitCheck
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   In                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ExploitCheck(int32 In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ExploitCheck");

	Params::ThankYouVeryCoolGameMode_ExploitCheck Parms{};

	Parms.In = In;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeInFromLoadOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeInFromLoadOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeInFromLoadOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeInOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeInOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeInOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeInTick
// (Final, Native, Private)

void AThankYouVeryCoolGameMode::FadeInTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeInTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeInToChallengesOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeInToChallengesOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeInToChallengesOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeInToResetOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeInToResetOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeInToResetOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeOutFromLoadOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeOutFromLoadOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeOutFromLoadOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeOutOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeOutOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeOutOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeOutToArcadeOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeOutToArcadeOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeOutToArcadeOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeOutToChallengesOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeOutToChallengesOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeOutToChallengesOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FadeOutToResetOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::FadeOutToResetOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FadeOutToResetOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FlushCompassMarkers
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOnlyInvalidTargets                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::FlushCompassMarkers(bool bOnlyInvalidTargets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FlushCompassMarkers");

	Params::ThankYouVeryCoolGameMode_FlushCompassMarkers Parms{};

	Parms.bOnlyInvalidTargets = bOnlyInvalidTargets;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.FlushRogueCheevs
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::FlushRogueCheevs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "FlushRogueCheevs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ForceGC
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::ForceGC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ForceGC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ForceLastStanding
// (Final, Exec, Native, Private)

void AThankYouVeryCoolGameMode::ForceLastStanding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ForceLastStanding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ForceLBOn
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::ForceLBOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ForceLBOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ForceRandomDaily
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::ForceRandomDaily()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ForceRandomDaily");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ForceVictory
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ForceVictory(int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ForceVictory");

	Params::ThankYouVeryCoolGameMode_ForceVictory Parms{};

	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ForceYesterdayDaily
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::ForceYesterdayDaily()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ForceYesterdayDaily");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GatherAndSaveInputMappings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Save                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::GatherAndSaveInputMappings(bool Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GatherAndSaveInputMappings");

	Params::ThankYouVeryCoolGameMode_GatherAndSaveInputMappings Parms{};

	Parms.Save = Save;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetCachedSteamdeckValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::GetCachedSteamdeckValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetCachedSteamdeckValue");

	Params::ThankYouVeryCoolGameMode_GetCachedSteamdeckValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetCampaignAssetFromPath
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FSoftClassPath                   InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCampaignDataAsset*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCampaignDataAsset* AThankYouVeryCoolGameMode::GetCampaignAssetFromPath(const struct FSoftClassPath& InPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetCampaignAssetFromPath");

	Params::ThankYouVeryCoolGameMode_GetCampaignAssetFromPath Parms{};

	Parms.InPath = std::move(InPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetCompletedChallenges
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AThankYouVeryCoolGameMode::GetCompletedChallenges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetCompletedChallenges");

	Params::ThankYouVeryCoolGameMode_GetCompletedChallenges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetConsoleCheatsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::GetConsoleCheatsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetConsoleCheatsEnabled");

	Params::ThankYouVeryCoolGameMode_GetConsoleCheatsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetCurrentVoxelWorldManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AVoxelWorldManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AVoxelWorldManager* AThankYouVeryCoolGameMode::GetCurrentVoxelWorldManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetCurrentVoxelWorldManager");

	Params::ThankYouVeryCoolGameMode_GetCurrentVoxelWorldManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetD3DApiLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AThankYouVeryCoolGameMode::GetD3DApiLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetD3DApiLevel");

	Params::ThankYouVeryCoolGameMode_GetD3DApiLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetDataForRecord
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> AThankYouVeryCoolGameMode::GetDataForRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetDataForRecord");

	Params::ThankYouVeryCoolGameMode_GetDataForRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetDataForShine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShineLevel                             InShine                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShinyData                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FShinyData AThankYouVeryCoolGameMode::GetDataForShine(EShineLevel InShine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetDataForShine");

	Params::ThankYouVeryCoolGameMode_GetDataForShine Parms{};

	Parms.InShine = InShine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetDesiredShiny
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShineLevel                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EShineLevel AThankYouVeryCoolGameMode::GetDesiredShiny()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetDesiredShiny");

	Params::ThankYouVeryCoolGameMode_GetDesiredShiny Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetDifficulty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDifficulty                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDifficulty AThankYouVeryCoolGameMode::GetDifficulty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetDifficulty");

	Params::ThankYouVeryCoolGameMode_GetDifficulty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetDistroName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AThankYouVeryCoolGameMode::GetDistroName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetDistroName");

	Params::ThankYouVeryCoolGameMode_GetDistroName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetFriendPersonaName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           FromID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AThankYouVeryCoolGameMode::GetFriendPersonaName(const class FString& FromID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetFriendPersonaName");

	Params::ThankYouVeryCoolGameMode_GetFriendPersonaName Parms{};

	Parms.FromID = std::move(FromID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetGameMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameMenuWidget*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameMenuWidget* AThankYouVeryCoolGameMode::GetGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetGameMenu");

	Params::ThankYouVeryCoolGameMode_GetGameMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetGameState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameState AThankYouVeryCoolGameMode::GetGameState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetGameState");

	Params::ThankYouVeryCoolGameMode_GetGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetHDRAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::GetHDRAllowed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetHDRAllowed");

	Params::ThankYouVeryCoolGameMode_GetHDRAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetHUD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTYVCHUD*                         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTYVCHUD* AThankYouVeryCoolGameMode::GetHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetHUD");

	Params::ThankYouVeryCoolGameMode_GetHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetImpactManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AImpactManager*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AImpactManager* AThankYouVeryCoolGameMode::GetImpactManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetImpactManager");

	Params::ThankYouVeryCoolGameMode_GetImpactManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetInfoForUser
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnFetched                                              (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::GetInfoForUser(const class FString& InID, TDelegate<void()> OnFetched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetInfoForUser");

	Params::ThankYouVeryCoolGameMode_GetInfoForUser Parms{};

	Parms.InID = std::move(InID);
	Parms.OnFetched = OnFetched;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetIsFading
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::GetIsFading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetIsFading");

	Params::ThankYouVeryCoolGameMode_GetIsFading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetIsInVictoryScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::GetIsInVictoryScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetIsInVictoryScreen");

	Params::ThankYouVeryCoolGameMode_GetIsInVictoryScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetIsLoadingWidgetVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::GetIsLoadingWidgetVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetIsLoadingWidgetVisible");

	Params::ThankYouVeryCoolGameMode_GetIsLoadingWidgetVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetIsPaused
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::GetIsPaused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetIsPaused");

	Params::ThankYouVeryCoolGameMode_GetIsPaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetLeaderboardFor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           BoardName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(ELeaderboardResult LeaderboardResult, TArray<struct FTYVCSteamLeaderboardEntry>& EntryList, const struct FTYVCSteamLeaderboardEntry& User, const struct FTYVCLBReadQueryParams& LBReadQueryParams)>OnDone                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bFriendsOnly                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::GetLeaderboardFor(const class FString& BoardName, TDelegate<void(ELeaderboardResult LeaderboardResult, TArray<struct FTYVCSteamLeaderboardEntry>& EntryList, const struct FTYVCSteamLeaderboardEntry& User, const struct FTYVCLBReadQueryParams& LBReadQueryParams)> OnDone, bool bFriendsOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetLeaderboardFor");

	Params::ThankYouVeryCoolGameMode_GetLeaderboardFor Parms{};

	Parms.BoardName = std::move(BoardName);
	Parms.OnDone = OnDone;
	Parms.bFriendsOnly = bFriendsOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetLevelForXP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AThankYouVeryCoolGameMode::GetLevelForXP(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetLevelForXP");

	Params::ThankYouVeryCoolGameMode_GetLevelForXP Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetMultiplierForMutator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameModifier                           InMut                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AThankYouVeryCoolGameMode::GetMultiplierForMutator(EGameModifier InMut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetMultiplierForMutator");

	Params::ThankYouVeryCoolGameMode_GetMultiplierForMutator Parms{};

	Parms.InMut = InMut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetNameForMutator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameModifier                           InMut                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AThankYouVeryCoolGameMode::GetNameForMutator(EGameModifier InMut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetNameForMutator");

	Params::ThankYouVeryCoolGameMode_GetNameForMutator Parms{};

	Parms.InMut = InMut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetPlayerGodMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::GetPlayerGodMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetPlayerGodMode");

	Params::ThankYouVeryCoolGameMode_GetPlayerGodMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetPrimaryVoxelWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APrimaryVoxelWorld*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APrimaryVoxelWorld* AThankYouVeryCoolGameMode::GetPrimaryVoxelWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetPrimaryVoxelWorld");

	Params::ThankYouVeryCoolGameMode_GetPrimaryVoxelWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetRankingMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<EGameModifier>                   Modifiers                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AThankYouVeryCoolGameMode::GetRankingMultiplier(const TArray<EGameModifier>& Modifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetRankingMultiplier");

	Params::ThankYouVeryCoolGameMode_GetRankingMultiplier Parms{};

	Parms.Modifiers = std::move(Modifiers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetRecordFromData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           InData                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FArcadeRecord                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FArcadeRecord AThankYouVeryCoolGameMode::GetRecordFromData(const TArray<int32>& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetRecordFromData");

	Params::ThankYouVeryCoolGameMode_GetRecordFromData Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetRowForMutator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameModifier                           InMut                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMutatorData                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMutatorData AThankYouVeryCoolGameMode::GetRowForMutator(EGameModifier InMut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetRowForMutator");

	Params::ThankYouVeryCoolGameMode_GetRowForMutator Parms{};

	Parms.InMut = InMut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetTheSquad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASquad*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASquad* AThankYouVeryCoolGameMode::GetTheSquad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetTheSquad");

	Params::ThankYouVeryCoolGameMode_GetTheSquad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetTotalMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDifficulty                             ForDiff                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EGameModifier>                   Modifiers                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TSubclassOf<class AWeaponBase>          WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AThankYouVeryCoolGameMode::GetTotalMultiplier(EDifficulty ForDiff, const TArray<EGameModifier>& Modifiers, TSubclassOf<class AWeaponBase> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetTotalMultiplier");

	Params::ThankYouVeryCoolGameMode_GetTotalMultiplier Parms{};

	Parms.ForDiff = ForDiff;
	Parms.Modifiers = std::move(Modifiers);
	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetTotalSRanks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AThankYouVeryCoolGameMode::GetTotalSRanks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetTotalSRanks");

	Params::ThankYouVeryCoolGameMode_GetTotalSRanks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetUnlocksForLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FUnlockData>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FUnlockData> AThankYouVeryCoolGameMode::GetUnlocksForLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetUnlocksForLevel");

	Params::ThankYouVeryCoolGameMode_GetUnlocksForLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetVictoryWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UVictoryWidget*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVictoryWidget* AThankYouVeryCoolGameMode::GetVictoryWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetVictoryWidget");

	Params::ThankYouVeryCoolGameMode_GetVictoryWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetVideoCutscene
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AThankYouVeryCoolGameMode::GetVideoCutscene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetVideoCutscene");

	Params::ThankYouVeryCoolGameMode_GetVideoCutscene Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GetXPForLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AThankYouVeryCoolGameMode::GetXPForLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GetXPForLevel");

	Params::ThankYouVeryCoolGameMode_GetXPForLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GiveBadCheevs
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::GiveBadCheevs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GiveBadCheevs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GlobalStatsCB
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::GlobalStatsCB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GlobalStatsCB");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.GodMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnableGodMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::GodMode(bool bEnableGodMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "GodMode");

	Params::ThankYouVeryCoolGameMode_GodMode Parms{};

	Parms.bEnableGodMode = bEnableGodMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.InitUserTracks
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::InitUserTracks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "InitUserTracks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.IsGenericKeyUnlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             UnlockInfo                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText                             HowToUnlockInfo                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::IsGenericKeyUnlocked(class FName InKey, class FText* UnlockInfo, class FText* HowToUnlockInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "IsGenericKeyUnlocked");

	Params::ThankYouVeryCoolGameMode_IsGenericKeyUnlocked Parms{};

	Parms.InKey = InKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (UnlockInfo != nullptr)
		*UnlockInfo = std::move(Parms.UnlockInfo);

	if (HowToUnlockInfo != nullptr)
		*HowToUnlockInfo = std::move(Parms.HowToUnlockInfo);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.IsKeyUnlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutLevel                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::IsKeyUnlocked(class FName InKey, int32* OutLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "IsKeyUnlocked");

	Params::ThankYouVeryCoolGameMode_IsKeyUnlocked Parms{};

	Parms.InKey = InKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLevel != nullptr)
		*OutLevel = Parms.OutLevel;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.IsMutUnlocked
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EGameModifier                           InKey                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutLevel                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::IsMutUnlocked(EGameModifier InKey, int32* OutLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "IsMutUnlocked");

	Params::ThankYouVeryCoolGameMode_IsMutUnlocked Parms{};

	Parms.InKey = InKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLevel != nullptr)
		*OutLevel = Parms.OutLevel;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.IsRunningCheats
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::IsRunningCheats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "IsRunningCheats");

	Params::ThankYouVeryCoolGameMode_IsRunningCheats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.IsShineUnlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShineLevel                             Shine                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::IsShineUnlocked(EShineLevel Shine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "IsShineUnlocked");

	Params::ThankYouVeryCoolGameMode_IsShineUnlocked Parms{};

	Parms.Shine = Shine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.IsSpawningActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::IsSpawningActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "IsSpawningActive");

	Params::ThankYouVeryCoolGameMode_IsSpawningActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.IsSteamLoggedOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::IsSteamLoggedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "IsSteamLoggedOn");

	Params::ThankYouVeryCoolGameMode_IsSteamLoggedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.KillAll
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::KillAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "KillAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.KnockdownAll
// (Final, Exec, Native, Public)
// Parameters:
// float                                   WithForce                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::KnockdownAll(float WithForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "KnockdownAll");

	Params::ThankYouVeryCoolGameMode_KnockdownAll Parms{};

	Parms.WithForce = WithForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.LeaveGameToArcadeMenu
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::LeaveGameToArcadeMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "LeaveGameToArcadeMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.LeaveGameToCredits
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::LeaveGameToCredits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "LeaveGameToCredits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.LeaveGameToMainMenu
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::LeaveGameToMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "LeaveGameToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.LevelLoadFailsafeCheck
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::LevelLoadFailsafeCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "LevelLoadFailsafeCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.LoadAllData
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::LoadAllData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "LoadAllData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.LocalGyro
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::LocalGyro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "LocalGyro");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.LogGlobalStats
// (Final, Exec, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::LogGlobalStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "LogGlobalStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.LoginEpic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       OnDone                                                 (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::LoginEpic(TDelegate<void()> OnDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "LoginEpic");

	Params::ThankYouVeryCoolGameMode_LoginEpic Parms{};

	Parms.OnDone = OnDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.MakeAllSleep
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::MakeAllSleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "MakeAllSleep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.MarkDemoComplete
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::MarkDemoComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "MarkDemoComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.MaxLevel
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::MaxLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "MaxLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.MovePawnAlongLoadingSpline
// (Final, Native, Public)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::MovePawnAlongLoadingSpline(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "MovePawnAlongLoadingSpline");

	Params::ThankYouVeryCoolGameMode_MovePawnAlongLoadingSpline Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.NegateTutorialPrompt
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::NegateTutorialPrompt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "NegateTutorialPrompt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.NewGamePlusUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::NewGamePlusUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "NewGamePlusUnlocked");

	Params::ThankYouVeryCoolGameMode_NewGamePlusUnlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.NotifyCountdownOver
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::NotifyCountdownOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "NotifyCountdownOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.NotifyCrosshairSettingsUpdated
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::NotifyCrosshairSettingsUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "NotifyCrosshairSettingsUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.NotifyIndicatorSettingUpdated
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::NotifyIndicatorSettingUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "NotifyIndicatorSettingUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.NotifyLocChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NewLoc                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::NotifyLocChanged(const class FString& NewLoc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "NotifyLocChanged");

	Params::ThankYouVeryCoolGameMode_NotifyLocChanged Parms{};

	Parms.NewLoc = std::move(NewLoc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.NotifyPropExploded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APropVoxelWorld*                  Exploded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::NotifyPropExploded(class APropVoxelWorld* Exploded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "NotifyPropExploded");

	Params::ThankYouVeryCoolGameMode_NotifyPropExploded Parms{};

	Parms.Exploded = Exploded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.NotifyWorldLoaded
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::NotifyWorldLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "NotifyWorldLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.OnDeathSlowMoFinish
// (Final, Native, Private)

void AThankYouVeryCoolGameMode::OnDeathSlowMoFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "OnDeathSlowMoFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.OnDeathSlowMoTick
// (Final, Native, Private)

void AThankYouVeryCoolGameMode::OnDeathSlowMoTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "OnDeathSlowMoTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.OnLevelUnloadFinished
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::OnLevelUnloadFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "OnLevelUnloadFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.OnLoadCameraInterpComplete
// (Final, Native, Private)

void AThankYouVeryCoolGameMode::OnLoadCameraInterpComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "OnLoadCameraInterpComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.OnOverworldLoaded
// (Final, Native, Private)

void AThankYouVeryCoolGameMode::OnOverworldLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "OnOverworldLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.PausePressed
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::PausePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "PausePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.PlayerRequestQuickReset
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::PlayerRequestQuickReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "PlayerRequestQuickReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.PostFadeArcadeReset
// (Final, Native, Private)

void AThankYouVeryCoolGameMode::PostFadeArcadeReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "PostFadeArcadeReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.PostFadeCampaignReset
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::PostFadeCampaignReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "PostFadeCampaignReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.PostFadeRogueReset
// (Final, Native, Private)

void AThankYouVeryCoolGameMode::PostFadeRogueReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "PostFadeRogueReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.PostFadeSkippedCampaign
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::PostFadeSkippedCampaign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "PostFadeSkippedCampaign");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.PreCacheVoxelWorlds
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bShouldCache                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::PreCacheVoxelWorlds(bool bShouldCache)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "PreCacheVoxelWorlds");

	Params::ThankYouVeryCoolGameMode_PreCacheVoxelWorlds Parms{};

	Parms.bShouldCache = bShouldCache;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.QuickResetPostSpawn
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::QuickResetPostSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "QuickResetPostSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.RequestResetArcadeScore
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::RequestResetArcadeScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "RequestResetArcadeScore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ResetInputMappings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Save                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ResetInputMappings(bool Save)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ResetInputMappings");

	Params::ThankYouVeryCoolGameMode_ResetInputMappings Parms{};

	Parms.Save = Save;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ResetLevelQuick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForEditor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ResetLevelQuick(bool bForEditor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ResetLevelQuick");

	Params::ThankYouVeryCoolGameMode_ResetLevelQuick Parms{};

	Parms.bForEditor = bForEditor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.RetryWriteToLeaderboard
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::RetryWriteToLeaderboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "RetryWriteToLeaderboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ReturnToEditor
// (Final, Native, Public, BlueprintCallable)

void AThankYouVeryCoolGameMode::ReturnToEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ReturnToEditor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SaveArcadeProgress
// (Final, Native, Public, HasOutParams)
// Parameters:
// int32                                   NewScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelEditorSave*                 ForLevel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ScoreThisRound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeThisRound                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldScore                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldTime                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERank                                   RankThisRound                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::SaveArcadeProgress(int32 NewScore, class ULevelEditorSave* ForLevel, int32 ScoreThisRound, float TimeThisRound, int32* OldScore, float* OldTime, ERank RankThisRound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SaveArcadeProgress");

	Params::ThankYouVeryCoolGameMode_SaveArcadeProgress Parms{};

	Parms.NewScore = NewScore;
	Parms.ForLevel = ForLevel;
	Parms.ScoreThisRound = ScoreThisRound;
	Parms.TimeThisRound = TimeThisRound;
	Parms.RankThisRound = RankThisRound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldScore != nullptr)
		*OldScore = Parms.OldScore;

	if (OldTime != nullptr)
		*OldTime = Parms.OldTime;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SaveArcadeSetup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForCampaign                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SaveArcadeSetup(bool bForCampaign)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SaveArcadeSetup");

	Params::ThankYouVeryCoolGameMode_SaveArcadeSetup Parms{};

	Parms.bForCampaign = bForCampaign;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SaveGameSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameSettings                    InSettings                                             (Parm, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SaveGameSettings(const struct FGameSettings& InSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SaveGameSettings");

	Params::ThankYouVeryCoolGameMode_SaveGameSettings Parms{};

	Parms.InSettings = std::move(InSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SaveJacketAndCannon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             JacketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CannonName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SaveJacketAndCannon(class FName JacketName, class FName CannonName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SaveJacketAndCannon");

	Params::ThankYouVeryCoolGameMode_SaveJacketAndCannon Parms{};

	Parms.JacketName = JacketName;
	Parms.CannonName = CannonName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SaveRogueConfig
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FRogueConfig                     InConfig                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SaveRogueConfig(const struct FRogueConfig& InConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SaveRogueConfig");

	Params::ThankYouVeryCoolGameMode_SaveRogueConfig Parms{};

	Parms.InConfig = std::move(InConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetAllowGameplaySound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetAllowGameplaySound(bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetAllowGameplaySound");

	Params::ThankYouVeryCoolGameMode_SetAllowGameplaySound Parms{};

	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetDifficult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDifficulty                             InDiff                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetDifficult(EDifficulty InDiff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetDifficult");

	Params::ThankYouVeryCoolGameMode_SetDifficult Parms{};

	Parms.InDiff = InDiff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetGameNoise
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanHear                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetGameNoise(bool bCanHear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetGameNoise");

	Params::ThankYouVeryCoolGameMode_SetGameNoise Parms{};

	Parms.bCanHear = bCanHear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetGameType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGameType                               InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetGameType(EGameType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetGameType");

	Params::ThankYouVeryCoolGameMode_SetGameType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetHighesLevel
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   KeyName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetHighesLevel(int32 KeyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetHighesLevel");

	Params::ThankYouVeryCoolGameMode_SetHighesLevel Parms{};

	Parms.KeyName = KeyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetIsInVictoryScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsInVictoryScreen                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetIsInVictoryScreen(bool IsInVictoryScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetIsInVictoryScreen");

	Params::ThankYouVeryCoolGameMode_SetIsInVictoryScreen Parms{};

	Parms.IsInVictoryScreen = IsInVictoryScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetIsPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsPaused                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetIsPaused(bool IsPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetIsPaused");

	Params::ThankYouVeryCoolGameMode_SetIsPaused Parms{};

	Parms.IsPaused = IsPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetKeepNPCsStocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FRespawnConfig                   InConfig                                               (Parm, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetKeepNPCsStocked(const struct FRespawnConfig& InConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetKeepNPCsStocked");

	Params::ThankYouVeryCoolGameMode_SetKeepNPCsStocked Parms{};

	Parms.InConfig = std::move(InConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetMouseSensitivity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewSens                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetMouseSensitivity(float NewSens)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetMouseSensitivity");

	Params::ThankYouVeryCoolGameMode_SetMouseSensitivity Parms{};

	Parms.NewSens = NewSens;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetNPCsToSpawnRed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldDo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetNPCsToSpawnRed(bool bShouldDo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetNPCsToSpawnRed");

	Params::ThankYouVeryCoolGameMode_SetNPCsToSpawnRed Parms{};

	Parms.bShouldDo = bShouldDo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetPlayerGodMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableGodMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetPlayerGodMode(bool bEnableGodMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetPlayerGodMode");

	Params::ThankYouVeryCoolGameMode_SetPlayerGodMode Parms{};

	Parms.bEnableGodMode = bEnableGodMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SetVideoCutscene
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           videoName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::SetVideoCutscene(const class FString& videoName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SetVideoCutscene");

	Params::ThankYouVeryCoolGameMode_SetVideoCutscene Parms{};

	Parms.videoName = std::move(videoName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ShouldRemovePatch2BigLevels
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AThankYouVeryCoolGameMode::ShouldRemovePatch2BigLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ShouldRemovePatch2BigLevels");

	Params::ThankYouVeryCoolGameMode_ShouldRemovePatch2BigLevels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ShowSpeed
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::ShowSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ShowSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ShowUserProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InPlatformOnlineID                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ShowUserProfile(const class FString& InPlatformOnlineID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ShowUserProfile");

	Params::ThankYouVeryCoolGameMode_ShowUserProfile Parms{};

	Parms.InPlatformOnlineID = std::move(InPlatformOnlineID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.ShowVictoryData
// (Final, Native, Public)
// Parameters:
// bool                                    bForCampaign                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::ShowVictoryData(bool bForCampaign)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "ShowVictoryData");

	Params::ThankYouVeryCoolGameMode_ShowVictoryData Parms{};

	Parms.bForCampaign = bForCampaign;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SimulateLaunchPS5CampaignActivity
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::SimulateLaunchPS5CampaignActivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SimulateLaunchPS5CampaignActivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SkipBonus
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::SkipBonus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SkipBonus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.SkipRogue
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::SkipRogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "SkipRogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.StressTestAfterLoad
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::StressTestAfterLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "StressTestAfterLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.TeleportInNPC
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TSubclassOf<class ANPC>                 ClassToSpawn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACampaignMarker*                  MySpawnMarker                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipFX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::TeleportInNPC(const struct FTransform& Transform, TSubclassOf<class ANPC> ClassToSpawn, class ACampaignMarker* MySpawnMarker, bool bSkipFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "TeleportInNPC");

	Params::ThankYouVeryCoolGameMode_TeleportInNPC Parms{};

	Parms.Transform = std::move(Transform);
	Parms.ClassToSpawn = ClassToSpawn;
	Parms.MySpawnMarker = MySpawnMarker;
	Parms.bSkipFX = bSkipFX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.TickPlaylist
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::TickPlaylist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "TickPlaylist");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.TickStressTest
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::TickStressTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "TickStressTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.TryNPCRefill
// (Final, Native, Public)

void AThankYouVeryCoolGameMode::TryNPCRefill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "TryNPCRefill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.tua
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::tua()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "tua");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.TYVCDeadZone
// (Final, Exec, Native, Public)
// Parameters:
// float                                   InZone                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::TYVCDeadZone(float InZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "TYVCDeadZone");

	Params::ThankYouVeryCoolGameMode_TYVCDeadZone Parms{};

	Parms.InZone = InZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.TYVCJumpTime
// (Final, Exec, Native, Public)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::TYVCJumpTime(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "TYVCJumpTime");

	Params::ThankYouVeryCoolGameMode_TYVCJumpTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.UnlockAll
// (Final, Exec, Native, Public)

void AThankYouVeryCoolGameMode::UnlockAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "UnlockAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.UnlockCheev
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ToUnlock                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::UnlockCheev(const class FString& ToUnlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "UnlockCheev");

	Params::ThankYouVeryCoolGameMode_UnlockCheev Parms{};

	Parms.ToUnlock = std::move(ToUnlock);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.UnlockKeyAndSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             KeyName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::UnlockKeyAndSave(class FName KeyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "UnlockKeyAndSave");

	Params::ThankYouVeryCoolGameMode_UnlockKeyAndSave Parms{};

	Parms.KeyName = KeyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.UserChooseShiny
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShineLevel                             InLvl                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::UserChooseShiny(EShineLevel InLvl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "UserChooseShiny");

	Params::ThankYouVeryCoolGameMode_UserChooseShiny Parms{};

	Parms.InLvl = InLvl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.WriteToLeaderboard
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UArcadeLevelAsset*                ForAsset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           RecordData                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::WriteToLeaderboard(class UArcadeLevelAsset* ForAsset, int32 Score, float Time, const TArray<int32>& RecordData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "WriteToLeaderboard");

	Params::ThankYouVeryCoolGameMode_WriteToLeaderboard Parms{};

	Parms.ForAsset = ForAsset;
	Parms.Score = Score;
	Parms.Time = Time;
	Parms.RecordData = std::move(RecordData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.ThankYouVeryCoolGameMode.WriteToLeaderboardC
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UArcadeLevelAsset*                ForAsset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           RecordData                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AThankYouVeryCoolGameMode::WriteToLeaderboardC(class UArcadeLevelAsset* ForAsset, int32 Score, float Time, const TArray<int32>& RecordData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolGameMode", "WriteToLeaderboardC");

	Params::ThankYouVeryCoolGameMode_WriteToLeaderboardC Parms{};

	Parms.ForAsset = ForAsset;
	Parms.Score = Score;
	Parms.Time = Time;
	Parms.RecordData = std::move(RecordData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.ThankYouVeryCoolProjectile.OnHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AThankYouVeryCoolProjectile::OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThankYouVeryCoolProjectile", "OnHit");

	Params::ThankYouVeryCoolProjectile_OnHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TurretHead.Shoot
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATurretHead::Shoot(class AActor* Target, const struct FVector& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TurretHead", "Shoot");

	Params::TurretHead_Shoot Parms{};

	Parms.Target = Target;
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TutorialPickup.MarkComplete
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ATutorialPickup::MarkComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPickup", "MarkComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.TutorialPickup.OnFound
// (Final, Native, Public, BlueprintCallable)

void ATutorialPickup::OnFound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialPickup", "OnFound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TutorialWidget.SetCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialWidget::SetCompleted(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialWidget", "SetCompleted");

	Params::TutorialWidget_SetCompleted Parms{};

	Parms.Num = Num;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TutorialWidget.SetTotal
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Total                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialWidget::SetTotal(int32 Total)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialWidget", "SetTotal");

	Params::TutorialWidget_SetTotal Parms{};

	Parms.Total = Total;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCAnimInstance.SetALSMovementModeC
// (Event, Public, BlueprintEvent)
// Parameters:
// EMovementMode                           MovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCAnimInstance::SetALSMovementModeC(EMovementMode MovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCAnimInstance", "SetALSMovementModeC");

	Params::TYVCAnimInstance_SetALSMovementModeC Parms{};

	Parms.MovementMode = MovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCAnimInstance.SetWeaponReadyOnMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsReady                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCAnimInstance::SetWeaponReadyOnMesh(bool bIsReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCAnimInstance", "SetWeaponReadyOnMesh");

	Params::TYVCAnimInstance_SetWeaponReadyOnMesh Parms{};

	Parms.bIsReady = bIsReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCAnimInstance.UpdateAnimationProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCAnimInstance::UpdateAnimationProperties(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCAnimInstance", "UpdateAnimationProperties");

	Params::TYVCAnimInstance_UpdateAnimationProperties Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.GetCurrentPlatform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlatformName                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformName UTYVCConsoleFunctionLibrary::GetCurrentPlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "GetCurrentPlatform");

	Params::TYVCConsoleFunctionLibrary_GetCurrentPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.GetCurrentPlatformRegion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlatformRegion                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformRegion UTYVCConsoleFunctionLibrary::GetCurrentPlatformRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "GetCurrentPlatformRegion");

	Params::TYVCConsoleFunctionLibrary_GetCurrentPlatformRegion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.GetGamepadButtonIcon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UTYVCConsoleFunctionLibrary::GetGamepadButtonIcon(const class UObject* WorldContextObject, const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "GetGamepadButtonIcon");

	Params::TYVCConsoleFunctionLibrary_GetGamepadButtonIcon Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.IsDemo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCConsoleFunctionLibrary::IsDemo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "IsDemo");

	Params::TYVCConsoleFunctionLibrary_IsDemo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.IsEnterButtonSwapped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCConsoleFunctionLibrary::IsEnterButtonSwapped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "IsEnterButtonSwapped");

	Params::TYVCConsoleFunctionLibrary_IsEnterButtonSwapped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.IsPlatform
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlatformName                           PlatformName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCConsoleFunctionLibrary::IsPlatform(EPlatformName PlatformName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "IsPlatform");

	Params::TYVCConsoleFunctionLibrary_IsPlatform Parms{};

	Parms.PlatformName = PlatformName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.IsPlatformRegion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlatformRegion                         PlatformRegion                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCConsoleFunctionLibrary::IsPlatformRegion(EPlatformRegion PlatformRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "IsPlatformRegion");

	Params::TYVCConsoleFunctionLibrary_IsPlatformRegion Parms{};

	Parms.PlatformRegion = PlatformRegion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.IsSwitchPortable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCConsoleFunctionLibrary::IsSwitchPortable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "IsSwitchPortable");

	Params::TYVCConsoleFunctionLibrary_IsSwitchPortable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.IsXboxSeriesS
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCConsoleFunctionLibrary::IsXboxSeriesS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "IsXboxSeriesS");

	Params::TYVCConsoleFunctionLibrary_IsXboxSeriesS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.PlatformNameFromString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PlatformNameString                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlatformName                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformName UTYVCConsoleFunctionLibrary::PlatformNameFromString(const class FString& PlatformNameString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "PlatformNameFromString");

	Params::TYVCConsoleFunctionLibrary_PlatformNameFromString Parms{};

	Parms.PlatformNameString = std::move(PlatformNameString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.PlatformNameToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlatformName                           PlatformName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTYVCConsoleFunctionLibrary::PlatformNameToString(EPlatformName PlatformName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "PlatformNameToString");

	Params::TYVCConsoleFunctionLibrary_PlatformNameToString Parms{};

	Parms.PlatformName = PlatformName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.PlatformRegionFromString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           PlatformRegionString                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlatformRegion                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlatformRegion UTYVCConsoleFunctionLibrary::PlatformRegionFromString(const class FString& PlatformRegionString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "PlatformRegionFromString");

	Params::TYVCConsoleFunctionLibrary_PlatformRegionFromString Parms{};

	Parms.PlatformRegionString = std::move(PlatformRegionString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCConsoleFunctionLibrary.PlatformRegionToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlatformRegion                         PlatformRegion                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTYVCConsoleFunctionLibrary::PlatformRegionToString(EPlatformRegion PlatformRegion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TYVCConsoleFunctionLibrary", "PlatformRegionToString");

	Params::TYVCConsoleFunctionLibrary_PlatformRegionToString Parms{};

	Parms.PlatformRegion = PlatformRegion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCProbeLight.UpdateLight
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Brightness                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATYVCProbeLight::UpdateLight(const struct FLinearColor& Color, float Brightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCProbeLight", "UpdateLight");

	Params::TYVCProbeLight_UpdateLight Parms{};

	Parms.Color = std::move(Color);
	Parms.Brightness = Brightness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCSaveController.DoInitialLoad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   SlotsToLoad                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::DoInitialLoad(const TArray<class FString>& SlotsToLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "DoInitialLoad");

	Params::TYVCSaveController_DoInitialLoad Parms{};

	Parms.SlotsToLoad = std::move(SlotsToLoad);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.GetAnySaveInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::GetAnySaveInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "GetAnySaveInProgress");

	Params::TYVCSaveController_GetAnySaveInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.GetInitialLoadComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::GetInitialLoadComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "GetInitialLoadComplete");

	Params::TYVCSaveController_GetInitialLoadComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.GetSaveExists
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::GetSaveExists(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "GetSaveExists");

	Params::TYVCSaveController_GetSaveExists Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.GetSaveInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::GetSaveInProgress(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "GetSaveInProgress");

	Params::TYVCSaveController_GetSaveInProgress Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.GetSaveLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::GetSaveLoaded(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "GetSaveLoaded");

	Params::TYVCSaveController_GetSaveLoaded Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.Load
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UTYVCSaveController::Load(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "Load");

	Params::TYVCSaveController_Load Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.Preload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCSaveController::Preload(const class FString& SlotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "Preload");

	Params::TYVCSaveController_Preload Parms{};

	Parms.SlotName = std::move(SlotName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCSaveController.ResetSaveController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::ResetSaveController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "ResetSaveController");

	Params::TYVCSaveController_ResetSaveController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.Save
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::Save(const class FString& SlotName, class USaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "Save");

	Params::TYVCSaveController_Save Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.SaveWithMetaData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DisplayName                                            (Parm, NativeAccessSpecifierPublic)
// class FText                             DisplaySubtitle                                        (Parm, NativeAccessSpecifierPublic)
// class FText                             DisplayDescription                                     (Parm, NativeAccessSpecifierPublic)
// class FString                           IconPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxBytes                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    KeepMetaData                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSaveController::SaveWithMetaData(const class FString& SlotName, class USaveGame* SaveGame, const class FText& DisplayName, const class FText& DisplaySubtitle, const class FText& DisplayDescription, const class FString& IconPath, int32 MaxBytes, bool KeepMetaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "SaveWithMetaData");

	Params::TYVCSaveController_SaveWithMetaData Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.SaveGame = SaveGame;
	Parms.DisplayName = std::move(DisplayName);
	Parms.DisplaySubtitle = std::move(DisplaySubtitle);
	Parms.DisplayDescription = std::move(DisplayDescription);
	Parms.IconPath = std::move(IconPath);
	Parms.MaxBytes = MaxBytes;
	Parms.KeepMetaData = KeepMetaData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSaveController.SetSaveMetadata
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DisplayName                                            (Parm, NativeAccessSpecifierPublic)
// class FText                             DisplaySubtitle                                        (Parm, NativeAccessSpecifierPublic)
// class FText                             DisplayDescription                                     (Parm, NativeAccessSpecifierPublic)
// class FString                           IconPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxBytes                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTYVCSaveController::SetSaveMetadata(const class FString& SlotName, const class FText& DisplayName, const class FText& DisplaySubtitle, const class FText& DisplayDescription, const class FString& IconPath, int32 MaxBytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSaveController", "SetSaveMetadata");

	Params::TYVCSaveController_SetSaveMetadata Parms{};

	Parms.SlotName = std::move(SlotName);
	Parms.DisplayName = std::move(DisplayName);
	Parms.DisplaySubtitle = std::move(DisplaySubtitle);
	Parms.DisplayDescription = std::move(DisplayDescription);
	Parms.IconPath = std::move(IconPath);
	Parms.MaxBytes = MaxBytes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCSky.GetTime
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATYVCSky::GetTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSky", "GetTime");

	Params::TYVCSky_GetTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSky.SetTime
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATYVCSky::SetTime(float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSky", "SetTime");

	Params::TYVCSky_SetTime Parms{};

	Parms.InTime = InTime;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSky.SetUseSkylight
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bUse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATYVCSky::SetUseSkylight(bool bUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSky", "SetUseSkylight");

	Params::TYVCSky_SetUseSkylight Parms{};

	Parms.bUse = bUse;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.TYVCSonyPrivilegeManager.CheckOnlinePrivilege
// (Final, Native, Public, BlueprintCallable)

void UTYVCSonyPrivilegeManager::CheckOnlinePrivilege()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSonyPrivilegeManager", "CheckOnlinePrivilege");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.TYVCSonyPrivilegeManager.GetAllowedOnline
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSonyPrivilegeManager::GetAllowedOnline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSonyPrivilegeManager", "GetAllowedOnline");

	Params::TYVCSonyPrivilegeManager_GetAllowedOnline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSonyPrivilegeManager.GetNeedsOnlineCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTYVCSonyPrivilegeManager::GetNeedsOnlineCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSonyPrivilegeManager", "GetNeedsOnlineCheck");

	Params::TYVCSonyPrivilegeManager_GetNeedsOnlineCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.TYVCSonyPrivilegeManager.ResetNeedsCheck
// (Final, Native, Public, BlueprintCallable)

void UTYVCSonyPrivilegeManager::ResetNeedsCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TYVCSonyPrivilegeManager", "ResetNeedsCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.UIKeyListener.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUIKeyListener::SetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIKeyListener", "SetActive");

	Params::UIKeyListener_SetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VictoryWidget.DoArcadeVictory
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   StartingPoints                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndPoints                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ScoreThisRound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeThisRound                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBeatOldScore                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldScore                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBeatOldTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictoryWidget::DoArcadeVictory(int32 StartingPoints, int32 EndPoints, int32 ScoreThisRound, float TimeThisRound, bool bBeatOldScore, int32 OldScore, bool bBeatOldTime, float OldTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictoryWidget", "DoArcadeVictory");

	Params::VictoryWidget_DoArcadeVictory Parms{};

	Parms.StartingPoints = StartingPoints;
	Parms.EndPoints = EndPoints;
	Parms.ScoreThisRound = ScoreThisRound;
	Parms.TimeThisRound = TimeThisRound;
	Parms.bBeatOldScore = bBeatOldScore;
	Parms.OldScore = OldScore;
	Parms.bBeatOldTime = bBeatOldTime;
	Parms.OldTime = OldTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.VictoryWidget.DoCampaignVictory
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   TimeThisRound                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictoryWidget::DoCampaignVictory(float TimeThisRound, float OldTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictoryWidget", "DoCampaignVictory");

	Params::VictoryWidget_DoCampaignVictory Parms{};

	Parms.TimeThisRound = TimeThisRound;
	Parms.OldTime = OldTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.VictoryWidget.FinishReturnToLevelSelect
// (Final, Native, Protected, BlueprintCallable)

void UVictoryWidget::FinishReturnToLevelSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictoryWidget", "FinishReturnToLevelSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VictoryWidget.K2_ReturnToLevelSelect
// (Event, Protected, BlueprintEvent)

void UVictoryWidget::K2_ReturnToLevelSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictoryWidget", "K2_ReturnToLevelSelect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.VictoryWidget.MattsSuperSpecialLeaderboardComplete
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictoryWidget::MattsSuperSpecialLeaderboardComplete(bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictoryWidget", "MattsSuperSpecialLeaderboardComplete");

	Params::VictoryWidget_MattsSuperSpecialLeaderboardComplete Parms{};

	Parms.bSuccess = bSuccess;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.VictoryWidget.ReturnToLevelSelect
// (Final, Native, Public, BlueprintCallable)

void UVictoryWidget::ReturnToLevelSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictoryWidget", "ReturnToLevelSelect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.VictoryWidget.ShowUploadResult
// (Event, Public, BlueprintEvent)
// Parameters:
// ELeaderboardResult                      LeaderboardResult                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWriteLeaderboardEnabled                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVictoryWidget::ShowUploadResult(ELeaderboardResult LeaderboardResult, bool bWriteLeaderboardEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VictoryWidget", "ShowUploadResult");

	Params::VictoryWidget_ShowUploadResult Parms{};

	Parms.LeaderboardResult = LeaderboardResult;
	Parms.bWriteLeaderboardEnabled = bWriteLeaderboardEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ThankYouVeryCool.VoxelLight.AddSpotlightAtTurtle
// (Final, Native, Public, BlueprintCallable)

void AVoxelLight::AddSpotlightAtTurtle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoxelLight", "AddSpotlightAtTurtle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.GetNPCHit
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BulletOrigin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InVector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAccuracy                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMustMissPlayer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult AWeaponBase::GetNPCHit(class UObject* Context, const struct FVector& BulletOrigin, const struct FVector& InVector, float InAccuracy, float InRange, bool bMustMissPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WeaponBase", "GetNPCHit");

	Params::WeaponBase_GetNPCHit Parms{};

	Parms.Context = Context;
	Parms.BulletOrigin = std::move(BulletOrigin);
	Parms.InVector = std::move(InVector);
	Parms.InAccuracy = InAccuracy;
	Parms.InRange = InRange;
	Parms.bMustMissPlayer = bMustMissPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponBase.ActorRequestPickUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AsSideArm                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeaponBase::ActorRequestPickUp(class AActor* Actor, bool AsSideArm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "ActorRequestPickUp");

	Params::WeaponBase_ActorRequestPickUp Parms{};

	Parms.Actor = Actor;
	Parms.AsSideArm = AsSideArm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponBase.AddRecoil
// (Final, Native, Public)

void AWeaponBase::AddRecoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "AddRecoil");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.CycleComplete
// (Final, Native, Public)

void AWeaponBase::CycleComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "CycleComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.DrawComplete
// (Final, Native, Public)

void AWeaponBase::DrawComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "DrawComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.DroppedEvent
// (Event, Public, BlueprintEvent)

void AWeaponBase::DroppedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "DroppedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WeaponBase.EmptyEvent
// (Event, Public, BlueprintEvent)

void AWeaponBase::EmptyEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "EmptyEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WeaponBase.FinishMuzzleFlash
// (Final, Native, Protected)

void AWeaponBase::FinishMuzzleFlash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "FinishMuzzleFlash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.GetCaliber
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EImpactType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EImpactType AWeaponBase::GetCaliber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "GetCaliber");

	Params::WeaponBase_GetCaliber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponBase.GetFireModeType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFireModeType                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFireModeType AWeaponBase::GetFireModeType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "GetFireModeType");

	Params::WeaponBase_GetFireModeType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponBase.GetHolder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AWeaponBase::GetHolder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "GetHolder");

	Params::WeaponBase_GetHolder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponBase.GetIndicatorColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor AWeaponBase::GetIndicatorColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "GetIndicatorColor");

	Params::WeaponBase_GetIndicatorColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponBase.HolsterComplete
// (Final, Native, Public)

void AWeaponBase::HolsterComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "HolsterComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.IsHeld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeaponBase::IsHeld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "IsHeld");

	Params::WeaponBase_IsHeld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponBase.IterateReloadLoop
// (Final, Native, Public)

void AWeaponBase::IterateReloadLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "IterateReloadLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.LevelReady
// (Final, Native, Public)

void AWeaponBase::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.MakePreview
// (Final, Native, Public, BlueprintCallable)

void AWeaponBase::MakePreview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "MakePreview");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.OnThrownHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AWeaponBase::OnThrownHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "OnThrownHit");

	Params::WeaponBase_OnThrownHit Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.OnThrownOverlappedSomething
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AWeaponBase::OnThrownOverlappedSomething(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "OnThrownOverlappedSomething");

	Params::WeaponBase_OnThrownOverlappedSomething Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.OnThrownStop
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AWeaponBase::OnThrownStop(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "OnThrownStop");

	Params::WeaponBase_OnThrownStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.PullTrigger
// (Final, Native, Public, BlueprintCallable)

void AWeaponBase::PullTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "PullTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.Randomize
// (Event, Protected, BlueprintEvent)

void AWeaponBase::Randomize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "Randomize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WeaponBase.ReleaseTrigger
// (Final, Native, Public, BlueprintCallable)

void AWeaponBase::ReleaseTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "ReleaseTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.ReloadFinished
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponBase::ReloadFinished(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "ReloadFinished");

	Params::WeaponBase_ReloadFinished Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.SetAsCloaked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCloaked                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponBase::SetAsCloaked(bool bCloaked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "SetAsCloaked");

	Params::WeaponBase_SetAsCloaked Parms{};

	Parms.bCloaked = bCloaked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.SetAsShiny
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShineLevel                             ForShineLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponBase::SetAsShiny(EShineLevel ForShineLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "SetAsShiny");

	Params::WeaponBase_SetAsShiny Parms{};

	Parms.ForShineLevel = ForShineLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.SetupAsSuppressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSuppressed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponBase::SetupAsSuppressed(bool bSuppressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "SetupAsSuppressed");

	Params::WeaponBase_SetupAsSuppressed Parms{};

	Parms.bSuppressed = bSuppressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.ShootEvent
// (Event, Public, BlueprintEvent)

void AWeaponBase::ShootEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "ShootEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WeaponBase.StartReloadLoop
// (Final, Native, Public)

void AWeaponBase::StartReloadLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "StartReloadLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.StopRecoil
// (Final, Native, Public)

void AWeaponBase::StopRecoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "StopRecoil");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.TickMuzzleFlash
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponBase::TickMuzzleFlash(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "TickMuzzleFlash");

	Params::WeaponBase_TickMuzzleFlash Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponBase.TriggerReleasedEvent
// (Event, Public, BlueprintEvent)

void AWeaponBase::TriggerReleasedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponBase", "TriggerReleasedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WeaponPreview.DisableRotate
// (Final, Native, Public, BlueprintCallable)

void AWeaponPreview::DisableRotate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "DisableRotate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponPreview.EnableRotate
// (Final, Native, Public, BlueprintCallable)

void AWeaponPreview::EnableRotate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "EnableRotate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponPreview.GetCurrentShown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AWeaponPreview::GetCurrentShown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "GetCurrentShown");

	Params::WeaponPreview_GetCurrentShown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponPreview.GetYawOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWeaponPreview::GetYawOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "GetYawOffset");

	Params::WeaponPreview_GetYawOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WeaponPreview.LevelReady
// (Final, Native, Public, BlueprintCallable)

void AWeaponPreview::LevelReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "LevelReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponPreview.Preview
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ToPreview                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponPreview::Preview(TSubclassOf<class AActor> ToPreview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "Preview");

	Params::WeaponPreview_Preview Parms{};

	Parms.ToPreview = ToPreview;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponPreview.PreviewCannon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECannonMode                             ForMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponPreview::PreviewCannon(ECannonMode ForMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "PreviewCannon");

	Params::WeaponPreview_PreviewCannon Parms{};

	Parms.ForMode = ForMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponPreview.SetLivePreview
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bin                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponPreview::SetLivePreview(bool bin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "SetLivePreview");

	Params::WeaponPreview_SetLivePreview Parms{};

	Parms.bin = bin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponPreview.SetRenderActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponPreview::SetRenderActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "SetRenderActive");

	Params::WeaponPreview_SetRenderActive Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WeaponPreview.SetYawOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   In                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponPreview::SetYawOffset(float In)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponPreview", "SetYawOffset");

	Params::WeaponPreview_SetYawOffset Parms{};

	Parms.In = In;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WirelessPowerNode.OnPlayerUse
// (Final, Native, Public, BlueprintCallable)

void AWirelessPowerNode::OnPlayerUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WirelessPowerNode", "OnPlayerUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WorkshopChapter.DoAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FAction                          InAction                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSimulated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWorkshopChapter::DoAction(const struct FAction& InAction, bool bSimulated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "DoAction");

	Params::WorkshopChapter_DoAction Parms{};

	Parms.InAction = std::move(InAction);
	Parms.bSimulated = bSimulated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WorkshopChapter.DoActionsForStage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ForStage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSimulated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWorkshopChapter::DoActionsForStage(int32 ForStage, bool bSimulated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "DoActionsForStage");

	Params::WorkshopChapter_DoActionsForStage Parms{};

	Parms.ForStage = ForStage;
	Parms.bSimulated = bSimulated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WorkshopChapter.DoCustomEnd
// (Event, Public, BlueprintEvent)

void AWorkshopChapter::DoCustomEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "DoCustomEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WorkshopChapter.ForceSkip
// (Event, Public, BlueprintEvent)

void AWorkshopChapter::ForceSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "ForceSkip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WorkshopChapter.MarkAllGoalsIncomplete
// (Final, Native, Public, BlueprintCallable)

void AWorkshopChapter::MarkAllGoalsIncomplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "MarkAllGoalsIncomplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WorkshopChapter.NotifyEnd
// (Event, Public, BlueprintEvent)

void AWorkshopChapter::NotifyEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "NotifyEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WorkshopChapter.NotifyGoalComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ForID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGoalType                               ForGoal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWorkshopChapter::NotifyGoalComplete(class FName ForID, EGoalType ForGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "NotifyGoalComplete");

	Params::WorkshopChapter_NotifyGoalComplete Parms{};

	Parms.ForID = ForID;
	Parms.ForGoal = ForGoal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ThankYouVeryCool.WorkshopChapter.NotifyNextStage
// (Event, Public, BlueprintEvent)

void AWorkshopChapter::NotifyNextStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "NotifyNextStage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ThankYouVeryCool.WorkshopChapter.SimulateGoalComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ForID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGoalType                               ForGoal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWorkshopChapter::SimulateGoalComplete(class FName ForID, EGoalType ForGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "SimulateGoalComplete");

	Params::WorkshopChapter_SimulateGoalComplete Parms{};

	Parms.ForID = ForID;
	Parms.ForGoal = ForGoal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ThankYouVeryCool.WorkshopChapter.SteelDiedInternal
// (Final, Native, Public, BlueprintCallable)

void AWorkshopChapter::SteelDiedInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorkshopChapter", "SteelDiedInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

