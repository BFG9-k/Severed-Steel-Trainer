#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ThankYouVeryCool

#include "Basic.hpp"

#include "Voxel_structs.hpp"
#include "Voxel_classes.hpp"
#include "UMG_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "ThankYouVeryCool_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "InputCore_structs.hpp"
#include "GameplayTasks_classes.hpp"
#include "RuntimeTransformer_classes.hpp"
#include "RuntimeAudioImporter_structs.hpp"
#include "ALSV4_CPP_structs.hpp"
#include "ALSV4_CPP_classes.hpp"
#include "SlateCore_structs.hpp"
#include "AutoSettingsInput_structs.hpp"


namespace SDK
{

// Class ThankYouVeryCool.StatsManager
// 0x0310 (0x0530 - 0x0220)
class AStatsManager : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnFreshUpdated;                                    // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x40];                                     // 0x0238(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentHeadshotCount;                              // 0x0278(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentKillCount;                                  // 0x027C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EFeat>                                 FeatsForFirefight;                                 // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EFeat, int32>                            FeatStyleOverrides;                                // 0x0290(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EFeat>                                 FeatsWithNoCooldown;                               // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFeat>                                 NyutieExploitCheck;                                // 0x02F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FreshTime;                                         // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x54];                                     // 0x030C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EFeat, int32>                            FeatMap;                                           // 0x0360(0x0050)(NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnStatsReset;                                      // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UEnum*                                  EnumPtr;                                           // 0x03C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EFeat, class FText>                      FeatTextMap;                                       // 0x03C8(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EFeat, class FText>                      FeatTextMapSingular;                               // 0x0418(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EFeat, class FText>                      FeatDescriptions;                                  // 0x0468(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B8[0x50];                                     // 0x04B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FChallenge>                     CompletedChallenges;                               // 0x0508(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x18];                                     // 0x0518(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckCompletion(const TArray<struct FChallenge>& SaveList, const struct FChallenge& ToCheck, EDifficulty* OutDifficulty);

	bool CheckFresh(EFeat InFeat);
	void DoChallengeComplete();
	class FText FeatToChallengeText(EFeat InFeat);
	class FText FeatToChallengeTextSingular(EFeat InFeat);
	struct FLinearColor GetColorForRank(int32 InRank);
	int32 GetCurrentDailyCount();
	class FText GetTextForRank(int32 InRank);
	void GiveCheevo(const class FString& ToGive);
	void GiveCheevoOthers(class FName ToGive);
	void GiveCheevos(const TArray<class FString>& ToGive);
	void GiveCheevosOthers(const TArray<class FName>& ToGive);
	void LoginToOSS();
	void OnGDKSessionManagerStatsRetrieved(int32 Headshots, int32 Kills);
	void OnLevelReady();
	void UpdateCheevos();
	void UpdateOfflineAchievements();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsManager">();
	}
	static class AStatsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStatsManager>();
	}
};
static_assert(alignof(AStatsManager) == 0x000008, "Wrong alignment on AStatsManager");
static_assert(sizeof(AStatsManager) == 0x000530, "Wrong size on AStatsManager");
static_assert(offsetof(AStatsManager, OnFreshUpdated) == 0x000220, "Member 'AStatsManager::OnFreshUpdated' has a wrong offset!");
static_assert(offsetof(AStatsManager, TYVCGameMode) == 0x000230, "Member 'AStatsManager::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AStatsManager, CurrentHeadshotCount) == 0x000278, "Member 'AStatsManager::CurrentHeadshotCount' has a wrong offset!");
static_assert(offsetof(AStatsManager, CurrentKillCount) == 0x00027C, "Member 'AStatsManager::CurrentKillCount' has a wrong offset!");
static_assert(offsetof(AStatsManager, FeatsForFirefight) == 0x000280, "Member 'AStatsManager::FeatsForFirefight' has a wrong offset!");
static_assert(offsetof(AStatsManager, FeatStyleOverrides) == 0x000290, "Member 'AStatsManager::FeatStyleOverrides' has a wrong offset!");
static_assert(offsetof(AStatsManager, FeatsWithNoCooldown) == 0x0002E0, "Member 'AStatsManager::FeatsWithNoCooldown' has a wrong offset!");
static_assert(offsetof(AStatsManager, NyutieExploitCheck) == 0x0002F8, "Member 'AStatsManager::NyutieExploitCheck' has a wrong offset!");
static_assert(offsetof(AStatsManager, FreshTime) == 0x000308, "Member 'AStatsManager::FreshTime' has a wrong offset!");
static_assert(offsetof(AStatsManager, FeatMap) == 0x000360, "Member 'AStatsManager::FeatMap' has a wrong offset!");
static_assert(offsetof(AStatsManager, OnStatsReset) == 0x0003B0, "Member 'AStatsManager::OnStatsReset' has a wrong offset!");
static_assert(offsetof(AStatsManager, EnumPtr) == 0x0003C0, "Member 'AStatsManager::EnumPtr' has a wrong offset!");
static_assert(offsetof(AStatsManager, FeatTextMap) == 0x0003C8, "Member 'AStatsManager::FeatTextMap' has a wrong offset!");
static_assert(offsetof(AStatsManager, FeatTextMapSingular) == 0x000418, "Member 'AStatsManager::FeatTextMapSingular' has a wrong offset!");
static_assert(offsetof(AStatsManager, FeatDescriptions) == 0x000468, "Member 'AStatsManager::FeatDescriptions' has a wrong offset!");
static_assert(offsetof(AStatsManager, CompletedChallenges) == 0x000508, "Member 'AStatsManager::CompletedChallenges' has a wrong offset!");

// Class ThankYouVeryCool.CoverGeneratorComponent
// 0x0030 (0x00E0 - 0x00B0)
class UCoverGeneratorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x21];                                      // 0x00B0(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bGenerateOnBeginPlay;                              // 0x00D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGeneratePerStaticMesh;                            // 0x00D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D3[0x1];                                       // 0x00D3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScanGridUnit;                                      // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmallestAgentHeight;                               // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GenerateCoverPoints();
	void OnNavmeshGenerationFinished(class ANavigationData* NavData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverGeneratorComponent">();
	}
	static class UCoverGeneratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverGeneratorComponent>();
	}
};
static_assert(alignof(UCoverGeneratorComponent) == 0x000008, "Wrong alignment on UCoverGeneratorComponent");
static_assert(sizeof(UCoverGeneratorComponent) == 0x0000E0, "Wrong size on UCoverGeneratorComponent");
static_assert(offsetof(UCoverGeneratorComponent, bGenerateOnBeginPlay) == 0x0000D1, "Member 'UCoverGeneratorComponent::bGenerateOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UCoverGeneratorComponent, bGeneratePerStaticMesh) == 0x0000D2, "Member 'UCoverGeneratorComponent::bGeneratePerStaticMesh' has a wrong offset!");
static_assert(offsetof(UCoverGeneratorComponent, ScanGridUnit) == 0x0000D4, "Member 'UCoverGeneratorComponent::ScanGridUnit' has a wrong offset!");
static_assert(offsetof(UCoverGeneratorComponent, SmallestAgentHeight) == 0x0000D8, "Member 'UCoverGeneratorComponent::SmallestAgentHeight' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotify_InCover
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_InCover final : public UAnimNotify
{
public:
	bool                                          Entering;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_InCover">();
	}
	static class UAnimNotify_InCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_InCover>();
	}
};
static_assert(alignof(UAnimNotify_InCover) == 0x000008, "Wrong alignment on UAnimNotify_InCover");
static_assert(sizeof(UAnimNotify_InCover) == 0x000040, "Wrong size on UAnimNotify_InCover");
static_assert(offsetof(UAnimNotify_InCover, Entering) == 0x000038, "Member 'UAnimNotify_InCover::Entering' has a wrong offset!");

// Class ThankYouVeryCool.SquadBT
// 0x0030 (0x02C8 - 0x0298)
class USquadBT final : public UBehaviorTreeComponent
{
public:
	class ASquad*                                 MySquad;                                           // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOrder*                                 MyOrder;                                           // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ANPCController*>                 NPCList;                                           // 0x02A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ManagedActors;                                     // 0x02B8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	class UBlackboardComponent* GetBB();
	void Stop(const class FString& Reason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadBT">();
	}
	static class USquadBT* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadBT>();
	}
};
static_assert(alignof(USquadBT) == 0x000008, "Wrong alignment on USquadBT");
static_assert(sizeof(USquadBT) == 0x0002C8, "Wrong size on USquadBT");
static_assert(offsetof(USquadBT, MySquad) == 0x000298, "Member 'USquadBT::MySquad' has a wrong offset!");
static_assert(offsetof(USquadBT, MyOrder) == 0x0002A0, "Member 'USquadBT::MyOrder' has a wrong offset!");
static_assert(offsetof(USquadBT, NPCList) == 0x0002A8, "Member 'USquadBT::NPCList' has a wrong offset!");
static_assert(offsetof(USquadBT, ManagedActors) == 0x0002B8, "Member 'USquadBT::ManagedActors' has a wrong offset!");

// Class ThankYouVeryCool.ChapterSaveV2
// 0x0098 (0x00C0 - 0x0028)
class UChapterSaveV2 final : public USaveGame
{
public:
	struct FSoftClassPath                         CurrentCampaignAsset;                              // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficulty                                   CampaignDifficulty;                                // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficulty                                   LowestDifficultyEverUsed;                          // 0x0041(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AWeaponBase>                PlayerHeldWeapon;                                  // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MagCount;                                          // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighestIdx;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FArcadeLevelSave>    Accomps;                                           // 0x0058(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<EGameModifier>                         CampaignModifiers;                                 // 0x00A8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsNGP;                                            // 0x00B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECannonMode                                   DesiredCannon;                                     // 0x00B9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChapterSaveV2">();
	}
	static class UChapterSaveV2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChapterSaveV2>();
	}
};
static_assert(alignof(UChapterSaveV2) == 0x000008, "Wrong alignment on UChapterSaveV2");
static_assert(sizeof(UChapterSaveV2) == 0x0000C0, "Wrong size on UChapterSaveV2");
static_assert(offsetof(UChapterSaveV2, CurrentCampaignAsset) == 0x000028, "Member 'UChapterSaveV2::CurrentCampaignAsset' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, CampaignDifficulty) == 0x000040, "Member 'UChapterSaveV2::CampaignDifficulty' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, LowestDifficultyEverUsed) == 0x000041, "Member 'UChapterSaveV2::LowestDifficultyEverUsed' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, PlayerHeldWeapon) == 0x000048, "Member 'UChapterSaveV2::PlayerHeldWeapon' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, MagCount) == 0x000050, "Member 'UChapterSaveV2::MagCount' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, HighestIdx) == 0x000054, "Member 'UChapterSaveV2::HighestIdx' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, Accomps) == 0x000058, "Member 'UChapterSaveV2::Accomps' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, CampaignModifiers) == 0x0000A8, "Member 'UChapterSaveV2::CampaignModifiers' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, bIsNGP) == 0x0000B8, "Member 'UChapterSaveV2::bIsNGP' has a wrong offset!");
static_assert(offsetof(UChapterSaveV2, DesiredCannon) == 0x0000B9, "Member 'UChapterSaveV2::DesiredCannon' has a wrong offset!");

// Class ThankYouVeryCool.AdamCrosshair
// 0x0000 (0x0260 - 0x0260)
class UAdamCrosshair : public UUserWidget
{
public:
	void DoHitFlare();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdamCrosshair">();
	}
	static class UAdamCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdamCrosshair>();
	}
};
static_assert(alignof(UAdamCrosshair) == 0x000008, "Wrong alignment on UAdamCrosshair");
static_assert(sizeof(UAdamCrosshair) == 0x000260, "Wrong size on UAdamCrosshair");

// Class ThankYouVeryCool.CloverWidget
// 0x0000 (0x0260 - 0x0260)
class UCloverWidget : public UUserWidget
{
public:
	void SetDisplayedLuck(int32 Luck);
	void SetupAsImpossible(bool bIsImpossible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloverWidget">();
	}
	static class UCloverWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloverWidget>();
	}
};
static_assert(alignof(UCloverWidget) == 0x000008, "Wrong alignment on UCloverWidget");
static_assert(sizeof(UCloverWidget) == 0x000260, "Wrong size on UCloverWidget");

// Class ThankYouVeryCool.AmmoCountWidget
// 0x0000 (0x0260 - 0x0260)
class UAmmoCountWidget : public UUserWidget
{
public:
	void SetAkimboAmmo(int32 InAmmo);
	void SetAmmo(int32 InAmmo, int32 MaxAmmo, bool bAnimate);
	void SetAmmoViz(bool bInViz);
	void SetDesireShowAkimbo(bool bDesire);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoCountWidget">();
	}
	static class UAmmoCountWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoCountWidget>();
	}
};
static_assert(alignof(UAmmoCountWidget) == 0x000008, "Wrong alignment on UAmmoCountWidget");
static_assert(sizeof(UAmmoCountWidget) == 0x000260, "Wrong size on UAmmoCountWidget");

// Class ThankYouVeryCool.AmmoIndicatorComponent
// 0x0040 (0x0520 - 0x04E0)
class UAmmoIndicatorComponent : public UStaticMeshComponent
{
public:
	uint8                                         Pad_4E0[0x8];                                      // 0x04E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      ColorCurve;                                        // 0x04E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynamicMat;                                        // 0x04F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F8[0x18];                                     // 0x04F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkSpeed;                                        // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EmHeld;                                            // 0x0514(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EmDropped;                                         // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ToggleBlink();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoIndicatorComponent">();
	}
	static class UAmmoIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoIndicatorComponent>();
	}
};
static_assert(alignof(UAmmoIndicatorComponent) == 0x000010, "Wrong alignment on UAmmoIndicatorComponent");
static_assert(sizeof(UAmmoIndicatorComponent) == 0x000520, "Wrong size on UAmmoIndicatorComponent");
static_assert(offsetof(UAmmoIndicatorComponent, ColorCurve) == 0x0004E8, "Member 'UAmmoIndicatorComponent::ColorCurve' has a wrong offset!");
static_assert(offsetof(UAmmoIndicatorComponent, DynamicMat) == 0x0004F0, "Member 'UAmmoIndicatorComponent::DynamicMat' has a wrong offset!");
static_assert(offsetof(UAmmoIndicatorComponent, BlinkSpeed) == 0x000510, "Member 'UAmmoIndicatorComponent::BlinkSpeed' has a wrong offset!");
static_assert(offsetof(UAmmoIndicatorComponent, EmHeld) == 0x000514, "Member 'UAmmoIndicatorComponent::EmHeld' has a wrong offset!");
static_assert(offsetof(UAmmoIndicatorComponent, EmDropped) == 0x000518, "Member 'UAmmoIndicatorComponent::EmDropped' has a wrong offset!");

// Class ThankYouVeryCool.TutorialGuide
// 0x0000 (0x0220 - 0x0220)
class ATutorialGuide final : public AActor
{
public:
	void SetInstructions(bool bForController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGuide">();
	}
	static class ATutorialGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGuide>();
	}
};
static_assert(alignof(ATutorialGuide) == 0x000008, "Wrong alignment on ATutorialGuide");
static_assert(sizeof(ATutorialGuide) == 0x000220, "Wrong size on ATutorialGuide");

// Class ThankYouVeryCool.ConsoleIconsDataAsset
// 0x0198 (0x01C8 - 0x0030)
class UConsoleIconsDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<struct FKey, class UTexture2D*>          PS4Icons;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FKey, class UTexture2D*>          PS5Icons;                                          // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FKey, class UTexture2D*>          XboxIcons;                                         // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FKey, class UTexture2D*>          SwitchIcons;                                       // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FKey, class UTexture2D*>          SwitchProIcons;                                    // 0x0170(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             TransparentIcon;                                   // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UTexture2D* GetGamepadButtonIcon(const class UObject* WorldContextObject, const struct FKey& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleIconsDataAsset">();
	}
	static class UConsoleIconsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleIconsDataAsset>();
	}
};
static_assert(alignof(UConsoleIconsDataAsset) == 0x000008, "Wrong alignment on UConsoleIconsDataAsset");
static_assert(sizeof(UConsoleIconsDataAsset) == 0x0001C8, "Wrong size on UConsoleIconsDataAsset");
static_assert(offsetof(UConsoleIconsDataAsset, PS4Icons) == 0x000030, "Member 'UConsoleIconsDataAsset::PS4Icons' has a wrong offset!");
static_assert(offsetof(UConsoleIconsDataAsset, PS5Icons) == 0x000080, "Member 'UConsoleIconsDataAsset::PS5Icons' has a wrong offset!");
static_assert(offsetof(UConsoleIconsDataAsset, XboxIcons) == 0x0000D0, "Member 'UConsoleIconsDataAsset::XboxIcons' has a wrong offset!");
static_assert(offsetof(UConsoleIconsDataAsset, SwitchIcons) == 0x000120, "Member 'UConsoleIconsDataAsset::SwitchIcons' has a wrong offset!");
static_assert(offsetof(UConsoleIconsDataAsset, SwitchProIcons) == 0x000170, "Member 'UConsoleIconsDataAsset::SwitchProIcons' has a wrong offset!");
static_assert(offsetof(UConsoleIconsDataAsset, TransparentIcon) == 0x0001C0, "Member 'UConsoleIconsDataAsset::TransparentIcon' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotify_CycleComplete
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_CycleComplete final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CycleComplete">();
	}
	static class UAnimNotify_CycleComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CycleComplete>();
	}
};
static_assert(alignof(UAnimNotify_CycleComplete) == 0x000008, "Wrong alignment on UAnimNotify_CycleComplete");
static_assert(sizeof(UAnimNotify_CycleComplete) == 0x000038, "Wrong size on UAnimNotify_CycleComplete");

// Class ThankYouVeryCool.CoverFinderService
// 0x0098 (0x0108 - 0x0070)
class UCoverFinderService final : public UBTService
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 DrawDebug;                                         // 0x0080(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 OutputVector;                                      // 0x00A8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Enemy;                                             // 0x00D0(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         AttackRange;                                       // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAttackRange;                                    // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponLeanOffset;                                  // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverPointMaxObjectHitDistance;                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverFinderService">();
	}
	static class UCoverFinderService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverFinderService>();
	}
};
static_assert(alignof(UCoverFinderService) == 0x000008, "Wrong alignment on UCoverFinderService");
static_assert(sizeof(UCoverFinderService) == 0x000108, "Wrong size on UCoverFinderService");
static_assert(offsetof(UCoverFinderService, DrawDebug) == 0x000080, "Member 'UCoverFinderService::DrawDebug' has a wrong offset!");
static_assert(offsetof(UCoverFinderService, OutputVector) == 0x0000A8, "Member 'UCoverFinderService::OutputVector' has a wrong offset!");
static_assert(offsetof(UCoverFinderService, Enemy) == 0x0000D0, "Member 'UCoverFinderService::Enemy' has a wrong offset!");
static_assert(offsetof(UCoverFinderService, AttackRange) == 0x0000F8, "Member 'UCoverFinderService::AttackRange' has a wrong offset!");
static_assert(offsetof(UCoverFinderService, MinAttackRange) == 0x0000FC, "Member 'UCoverFinderService::MinAttackRange' has a wrong offset!");
static_assert(offsetof(UCoverFinderService, WeaponLeanOffset) == 0x000100, "Member 'UCoverFinderService::WeaponLeanOffset' has a wrong offset!");
static_assert(offsetof(UCoverFinderService, CoverPointMaxObjectHitDistance) == 0x000104, "Member 'UCoverFinderService::CoverPointMaxObjectHitDistance' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotify_EjectMagazine
// 0x0018 (0x0050 - 0x0038)
class UAnimNotify_EjectMagazine final : public UAnimNotify
{
public:
	struct FVector                                Velocity;                                          // 0x0038(0x000C)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityFloat;                                     // 0x0044(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelSpeed;                                       // 0x0048(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelTime;                                        // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EjectMagazine">();
	}
	static class UAnimNotify_EjectMagazine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EjectMagazine>();
	}
};
static_assert(alignof(UAnimNotify_EjectMagazine) == 0x000008, "Wrong alignment on UAnimNotify_EjectMagazine");
static_assert(sizeof(UAnimNotify_EjectMagazine) == 0x000050, "Wrong size on UAnimNotify_EjectMagazine");
static_assert(offsetof(UAnimNotify_EjectMagazine, Velocity) == 0x000038, "Member 'UAnimNotify_EjectMagazine::Velocity' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EjectMagazine, VelocityFloat) == 0x000044, "Member 'UAnimNotify_EjectMagazine::VelocityFloat' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EjectMagazine, TravelSpeed) == 0x000048, "Member 'UAnimNotify_EjectMagazine::TravelSpeed' has a wrong offset!");
static_assert(offsetof(UAnimNotify_EjectMagazine, TravelTime) == 0x00004C, "Member 'UAnimNotify_EjectMagazine::TravelTime' has a wrong offset!");

// Class ThankYouVeryCool.CoverFinderVisData
// 0x0020 (0x0048 - 0x0028)
class UCoverFinderVisData final : public UObject
{
public:
	TArray<struct FDebugPoint>                    DebugPoints;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDebugArrow>                    DebugArrows;                                       // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverFinderVisData">();
	}
	static class UCoverFinderVisData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverFinderVisData>();
	}
};
static_assert(alignof(UCoverFinderVisData) == 0x000008, "Wrong alignment on UCoverFinderVisData");
static_assert(sizeof(UCoverFinderVisData) == 0x000048, "Wrong size on UCoverFinderVisData");
static_assert(offsetof(UCoverFinderVisData, DebugPoints) == 0x000028, "Member 'UCoverFinderVisData::DebugPoints' has a wrong offset!");
static_assert(offsetof(UCoverFinderVisData, DebugArrows) == 0x000038, "Member 'UCoverFinderVisData::DebugArrows' has a wrong offset!");

// Class ThankYouVeryCool.TYVCGDKSessionManager
// 0x0028 (0x0058 - 0x0030)
class UTYVCGDKSessionManager final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(int32 Headshots, int32 Kills)> OnStatsRetrieved;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestStats();
	void SendArcadeLevelCompleteEvent(const class FString& LevelName, int32 Score, float Time);
	void SendFirefightLevelEvent(int32 Level);
	void SendHeadshotEvent();
	void SendKillEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCGDKSessionManager">();
	}
	static class UTYVCGDKSessionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCGDKSessionManager>();
	}
};
static_assert(alignof(UTYVCGDKSessionManager) == 0x000008, "Wrong alignment on UTYVCGDKSessionManager");
static_assert(sizeof(UTYVCGDKSessionManager) == 0x000058, "Wrong size on UTYVCGDKSessionManager");
static_assert(offsetof(UTYVCGDKSessionManager, OnStatsRetrieved) == 0x000030, "Member 'UTYVCGDKSessionManager::OnStatsRetrieved' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotify_EjectShell
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_EjectShell final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_EjectShell">();
	}
	static class UAnimNotify_EjectShell* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_EjectShell>();
	}
};
static_assert(alignof(UAnimNotify_EjectShell) == 0x000008, "Wrong alignment on UAnimNotify_EjectShell");
static_assert(sizeof(UAnimNotify_EjectShell) == 0x000038, "Wrong size on UAnimNotify_EjectShell");

// Class ThankYouVeryCool.CoverFinderVisualizerService
// 0x0020 (0x0090 - 0x0070)
class UCoverFinderVisualizerService final : public UBTService
{
public:
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverFinderVisualizerService">();
	}
	static class UCoverFinderVisualizerService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverFinderVisualizerService>();
	}
};
static_assert(alignof(UCoverFinderVisualizerService) == 0x000008, "Wrong alignment on UCoverFinderVisualizerService");
static_assert(sizeof(UCoverFinderVisualizerService) == 0x000090, "Wrong size on UCoverFinderVisualizerService");

// Class ThankYouVeryCool.AnimNotify_GrabMag
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_GrabMag final : public UAnimNotify
{
public:
	bool                                          Grab;                                              // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_GrabMag">();
	}
	static class UAnimNotify_GrabMag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_GrabMag>();
	}
};
static_assert(alignof(UAnimNotify_GrabMag) == 0x000008, "Wrong alignment on UAnimNotify_GrabMag");
static_assert(sizeof(UAnimNotify_GrabMag) == 0x000040, "Wrong size on UAnimNotify_GrabMag");
static_assert(offsetof(UAnimNotify_GrabMag, Grab) == 0x000038, "Member 'UAnimNotify_GrabMag::Grab' has a wrong offset!");

// Class ThankYouVeryCool.CoverSystem
// 0x00F0 (0x0118 - 0x0028)
class UCoverSystem final : public UBlueprintFunctionLibrary
{
public:
	uint8                                         Pad_28[0xD1];                                      // 0x0028(0x00D1)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDraw;                                        // 0x00F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x1E];                                      // 0x00FA(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UCoverSystem* GetCoverSystem(class UObject* WorldContextObject);

	bool HoldCover(const struct FVector& ElementLocation);
	void OnBeginPlay();
	void OnNavMeshTilesUpdated(const TSet<uint32>& UpdatedTiles);
	bool ReleaseCover(const struct FVector& ElementLocation);
	void RemoveAll();
	void RemoveCoverPointsOfObject(const class AActor* CoverObject);
	void RemoveStaleCoverPoints(const struct FVector& Origin, const struct FVector& Extent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoverSystem">();
	}
	static class UCoverSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoverSystem>();
	}
};
static_assert(alignof(UCoverSystem) == 0x000008, "Wrong alignment on UCoverSystem");
static_assert(sizeof(UCoverSystem) == 0x000118, "Wrong size on UCoverSystem");
static_assert(offsetof(UCoverSystem, bDebugDraw) == 0x0000F9, "Member 'UCoverSystem::bDebugDraw' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotify_NPCPunchedC
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_NPCPunchedC final : public UAnimNotify
{
public:
	bool                                          bLeftHand;                                         // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_NPCPunchedC">();
	}
	static class UAnimNotify_NPCPunchedC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_NPCPunchedC>();
	}
};
static_assert(alignof(UAnimNotify_NPCPunchedC) == 0x000008, "Wrong alignment on UAnimNotify_NPCPunchedC");
static_assert(sizeof(UAnimNotify_NPCPunchedC) == 0x000040, "Wrong size on UAnimNotify_NPCPunchedC");
static_assert(offsetof(UAnimNotify_NPCPunchedC, bLeftHand) == 0x000038, "Member 'UAnimNotify_NPCPunchedC::bLeftHand' has a wrong offset!");

// Class ThankYouVeryCool.TYVCHUD
// 0x0040 (0x02A0 - 0x0260)
class UTYVCHUD : public UUserWidget
{
public:
	class UMaterialInterface*                     SpeedLineMaterial;                                 // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SpeedLineDynamicMaterial;                          // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               BlinkDynamicMaterial;                              // 0x0270(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MainCanvasPanel;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SpeedLines;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 FadeOut;                                           // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNdocRingWidget*                        NdocRingWidget;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevelIsLoaded;                                    // 0x0298(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNarrativeIsComplete;                              // 0x0299(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29A[0x2];                                      // 0x029A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxTasks;                                          // 0x029C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HideStartPrompt();
	void HideVictoryScreen();
	void IntroduceChapter(const class FString& ChapterTitle, const TDelegate<void()>& OnComplete);
	void NotifyLevelLoaded();
	void NotifyLoadNarrativeDone();
	void SetLoadBarViz(bool bIsViz);
	void SetupForHunt();
	void SetupForTime(const class FString& Time, bool bNewTrophy, bool bNewBestTime, EDifficulty TropyToShow);
	void Show3Remaining();
	void ShowFinishedScreenforChapter(const class FString& Title, bool bShowNext);
	void ShowVictoryScreen();
	void UpdateTaskDisplay(float Percentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCHUD">();
	}
	static class UTYVCHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCHUD>();
	}
};
static_assert(alignof(UTYVCHUD) == 0x000008, "Wrong alignment on UTYVCHUD");
static_assert(sizeof(UTYVCHUD) == 0x0002A0, "Wrong size on UTYVCHUD");
static_assert(offsetof(UTYVCHUD, SpeedLineMaterial) == 0x000260, "Member 'UTYVCHUD::SpeedLineMaterial' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, SpeedLineDynamicMaterial) == 0x000268, "Member 'UTYVCHUD::SpeedLineDynamicMaterial' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, BlinkDynamicMaterial) == 0x000270, "Member 'UTYVCHUD::BlinkDynamicMaterial' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, MainCanvasPanel) == 0x000278, "Member 'UTYVCHUD::MainCanvasPanel' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, SpeedLines) == 0x000280, "Member 'UTYVCHUD::SpeedLines' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, FadeOut) == 0x000288, "Member 'UTYVCHUD::FadeOut' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, NdocRingWidget) == 0x000290, "Member 'UTYVCHUD::NdocRingWidget' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, bLevelIsLoaded) == 0x000298, "Member 'UTYVCHUD::bLevelIsLoaded' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, bNarrativeIsComplete) == 0x000299, "Member 'UTYVCHUD::bNarrativeIsComplete' has a wrong offset!");
static_assert(offsetof(UTYVCHUD, MaxTasks) == 0x00029C, "Member 'UTYVCHUD::MaxTasks' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotify_PlayReloadSound
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_PlayReloadSound final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayReloadSound">();
	}
	static class UAnimNotify_PlayReloadSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayReloadSound>();
	}
};
static_assert(alignof(UAnimNotify_PlayReloadSound) == 0x000008, "Wrong alignment on UAnimNotify_PlayReloadSound");
static_assert(sizeof(UAnimNotify_PlayReloadSound) == 0x000038, "Wrong size on UAnimNotify_PlayReloadSound");

// Class ThankYouVeryCool.AnimNotify_SetHeadShow
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_SetHeadShow final : public UAnimNotify
{
public:
	bool                                          bShowHead;                                         // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetHeadShow">();
	}
	static class UAnimNotify_SetHeadShow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetHeadShow>();
	}
};
static_assert(alignof(UAnimNotify_SetHeadShow) == 0x000008, "Wrong alignment on UAnimNotify_SetHeadShow");
static_assert(sizeof(UAnimNotify_SetHeadShow) == 0x000040, "Wrong size on UAnimNotify_SetHeadShow");
static_assert(offsetof(UAnimNotify_SetHeadShow, bShowHead) == 0x000038, "Member 'UAnimNotify_SetHeadShow::bShowHead' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotify_SetIKTarget
// 0x0010 (0x0048 - 0x0038)
class UAnimNotify_SetIKTarget final : public UAnimNotify
{
public:
	class FName                                   SocketName;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIKTarget                                     Target;                                            // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIKSocketOwner                                SocketOwner;                                       // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_SetIKTarget">();
	}
	static class UAnimNotify_SetIKTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_SetIKTarget>();
	}
};
static_assert(alignof(UAnimNotify_SetIKTarget) == 0x000008, "Wrong alignment on UAnimNotify_SetIKTarget");
static_assert(sizeof(UAnimNotify_SetIKTarget) == 0x000048, "Wrong size on UAnimNotify_SetIKTarget");
static_assert(offsetof(UAnimNotify_SetIKTarget, SocketName) == 0x000038, "Member 'UAnimNotify_SetIKTarget::SocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SetIKTarget, Target) == 0x000040, "Member 'UAnimNotify_SetIKTarget::Target' has a wrong offset!");
static_assert(offsetof(UAnimNotify_SetIKTarget, SocketOwner) == 0x000041, "Member 'UAnimNotify_SetIKTarget::SocketOwner' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotify_Throw
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_Throw final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Throw">();
	}
	static class UAnimNotify_Throw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Throw>();
	}
};
static_assert(alignof(UAnimNotify_Throw) == 0x000008, "Wrong alignment on UAnimNotify_Throw");
static_assert(sizeof(UAnimNotify_Throw) == 0x000038, "Wrong size on UAnimNotify_Throw");

// Class ThankYouVeryCool.TYVCActor
// 0x0050 (0x0270 - 0x0220)
class ATYVCActor : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PlayerActor;                                       // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsElectronic;                                     // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       PromptComponent;                                   // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInteractable;                                   // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                PickupWidgetClass;                                 // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CustomReset();
	bool OnImpact(const struct FHitResult& HitResult, float Joules, EImpactType ImpactType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCActor">();
	}
	static class ATYVCActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCActor>();
	}
};
static_assert(alignof(ATYVCActor) == 0x000008, "Wrong alignment on ATYVCActor");
static_assert(sizeof(ATYVCActor) == 0x000270, "Wrong size on ATYVCActor");
static_assert(offsetof(ATYVCActor, PlayerActor) == 0x000228, "Member 'ATYVCActor::PlayerActor' has a wrong offset!");
static_assert(offsetof(ATYVCActor, bIsElectronic) == 0x000230, "Member 'ATYVCActor::bIsElectronic' has a wrong offset!");
static_assert(offsetof(ATYVCActor, PromptComponent) == 0x000238, "Member 'ATYVCActor::PromptComponent' has a wrong offset!");
static_assert(offsetof(ATYVCActor, bIsInteractable) == 0x000258, "Member 'ATYVCActor::bIsInteractable' has a wrong offset!");
static_assert(offsetof(ATYVCActor, PickupWidgetClass) == 0x000260, "Member 'ATYVCActor::PickupWidgetClass' has a wrong offset!");

// Class ThankYouVeryCool.TYVCLight
// 0x0120 (0x0390 - 0x0270)
class ATYVCLight : public ATYVCActor
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       ShadowRangeViz;                                    // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCastShadow;                                       // 0x0280(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShadowRange;                                       // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowRangeSquared;                                // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATYVCProbeLight*>                ProbeLights;                                       // 0x0290(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               LightDynMat;                                       // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightMatIndex;                                     // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LightBlendName;                                    // 0x02AC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              FlickerRange;                                      // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlickerUpdateRate;                                 // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinCutOffRatio;                                    // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x98];                                     // 0x02D8(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATYVCProbeLight>            ProbeLightClass;                                   // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        OnHitParticle;                                     // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShadowCheckInterval;                               // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0xC];                                      // 0x0384(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDistance();
	class ATYVCProbeLight* CreateProbeLight();
	void UpdateFlicker(float DeltaTime);
	void UpdateProbeLights();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCLight">();
	}
	static class ATYVCLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCLight>();
	}
};
static_assert(alignof(ATYVCLight) == 0x000008, "Wrong alignment on ATYVCLight");
static_assert(sizeof(ATYVCLight) == 0x000390, "Wrong size on ATYVCLight");
static_assert(offsetof(ATYVCLight, StaticMesh) == 0x000270, "Member 'ATYVCLight::StaticMesh' has a wrong offset!");
static_assert(offsetof(ATYVCLight, ShadowRangeViz) == 0x000278, "Member 'ATYVCLight::ShadowRangeViz' has a wrong offset!");
static_assert(offsetof(ATYVCLight, bCastShadow) == 0x000280, "Member 'ATYVCLight::bCastShadow' has a wrong offset!");
static_assert(offsetof(ATYVCLight, ShadowRange) == 0x000284, "Member 'ATYVCLight::ShadowRange' has a wrong offset!");
static_assert(offsetof(ATYVCLight, ShadowRangeSquared) == 0x000288, "Member 'ATYVCLight::ShadowRangeSquared' has a wrong offset!");
static_assert(offsetof(ATYVCLight, ProbeLights) == 0x000290, "Member 'ATYVCLight::ProbeLights' has a wrong offset!");
static_assert(offsetof(ATYVCLight, LightDynMat) == 0x0002A0, "Member 'ATYVCLight::LightDynMat' has a wrong offset!");
static_assert(offsetof(ATYVCLight, LightMatIndex) == 0x0002A8, "Member 'ATYVCLight::LightMatIndex' has a wrong offset!");
static_assert(offsetof(ATYVCLight, LightBlendName) == 0x0002AC, "Member 'ATYVCLight::LightBlendName' has a wrong offset!");
static_assert(offsetof(ATYVCLight, FlickerRange) == 0x0002B8, "Member 'ATYVCLight::FlickerRange' has a wrong offset!");
static_assert(offsetof(ATYVCLight, FlickerUpdateRate) == 0x0002D0, "Member 'ATYVCLight::FlickerUpdateRate' has a wrong offset!");
static_assert(offsetof(ATYVCLight, MinCutOffRatio) == 0x0002D4, "Member 'ATYVCLight::MinCutOffRatio' has a wrong offset!");
static_assert(offsetof(ATYVCLight, ProbeLightClass) == 0x000370, "Member 'ATYVCLight::ProbeLightClass' has a wrong offset!");
static_assert(offsetof(ATYVCLight, OnHitParticle) == 0x000378, "Member 'ATYVCLight::OnHitParticle' has a wrong offset!");
static_assert(offsetof(ATYVCLight, ShadowCheckInterval) == 0x000380, "Member 'ATYVCLight::ShadowCheckInterval' has a wrong offset!");

// Class ThankYouVeryCool.TYVCLight_Directional
// 0x0008 (0x0398 - 0x0390)
class ATYVCLight_Directional final : public ATYVCLight
{
public:
	class UDirectionalLightComponent*             DirectionalLight;                                  // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCLight_Directional">();
	}
	static class ATYVCLight_Directional* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCLight_Directional>();
	}
};
static_assert(alignof(ATYVCLight_Directional) == 0x000008, "Wrong alignment on ATYVCLight_Directional");
static_assert(sizeof(ATYVCLight_Directional) == 0x000398, "Wrong size on ATYVCLight_Directional");
static_assert(offsetof(ATYVCLight_Directional, DirectionalLight) == 0x000390, "Member 'ATYVCLight_Directional::DirectionalLight' has a wrong offset!");

// Class ThankYouVeryCool.AnimNotifyBlendOutRoll
// 0x0000 (0x0038 - 0x0038)
class UAnimNotifyBlendOutRoll final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyBlendOutRoll">();
	}
	static class UAnimNotifyBlendOutRoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyBlendOutRoll>();
	}
};
static_assert(alignof(UAnimNotifyBlendOutRoll) == 0x000008, "Wrong alignment on UAnimNotifyBlendOutRoll");
static_assert(sizeof(UAnimNotifyBlendOutRoll) == 0x000038, "Wrong size on UAnimNotifyBlendOutRoll");

// Class ThankYouVeryCool.RechargeStation
// 0x0020 (0x0240 - 0x0220)
class ARechargeStation : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CampaignID;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FLinearColor GetRandomColor();
	void OnEditorModeChange(EEditMode NewEditMode);
	void OnLevelReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RechargeStation">();
	}
	static class ARechargeStation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARechargeStation>();
	}
};
static_assert(alignof(ARechargeStation) == 0x000008, "Wrong alignment on ARechargeStation");
static_assert(sizeof(ARechargeStation) == 0x000240, "Wrong size on ARechargeStation");
static_assert(offsetof(ARechargeStation, CampaignID) == 0x000238, "Member 'ARechargeStation::CampaignID' has a wrong offset!");

// Class ThankYouVeryCool.ANPCSpawner
// 0x0028 (0x0268 - 0x0240)
class AANPCSpawner final : public ARechargeStation
{
public:
	int32                                         NPCLevelToMaintain;                                // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ANPC>                       ClassToSpawn;                                      // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   SpawnViz;                                          // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void LevelReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ANPCSpawner">();
	}
	static class AANPCSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AANPCSpawner>();
	}
};
static_assert(alignof(AANPCSpawner) == 0x000008, "Wrong alignment on AANPCSpawner");
static_assert(sizeof(AANPCSpawner) == 0x000268, "Wrong size on AANPCSpawner");
static_assert(offsetof(AANPCSpawner, NPCLevelToMaintain) == 0x000240, "Member 'AANPCSpawner::NPCLevelToMaintain' has a wrong offset!");
static_assert(offsetof(AANPCSpawner, TYVCGameMode) == 0x000248, "Member 'AANPCSpawner::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AANPCSpawner, ClassToSpawn) == 0x000250, "Member 'AANPCSpawner::ClassToSpawn' has a wrong offset!");
static_assert(offsetof(AANPCSpawner, SpawnViz) == 0x000260, "Member 'AANPCSpawner::SpawnViz' has a wrong offset!");

// Class ThankYouVeryCool.ArcadeLevelAsset
// 0x00D0 (0x0100 - 0x0030)
class UArcadeLevelAsset : public UDataAsset
{
public:
	TSoftObjectPtr<class ULevelEditorSave>        LevelSave;                                         // 0x0030(0x0028)(Edit, BlueprintVisible, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChallenge>                     Challenges;                                        // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                LevelScreen;                                       // 0x0068(0x0028)(Edit, BlueprintVisible, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Key;                                               // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0098(0x0018)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	struct FGuid                                  UniqueId;                                          // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CorsairAmbient;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              SpecificTrack;                                     // 0x00D0(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BaseNPCScore;                                      // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ULevelEditorSave* GetLevelSave();
	class UTexture2D* GetPreviewImage();
	bool GetShouldFetchImgFromDisc();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeLevelAsset">();
	}
	static class UArcadeLevelAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArcadeLevelAsset>();
	}
};
static_assert(alignof(UArcadeLevelAsset) == 0x000008, "Wrong alignment on UArcadeLevelAsset");
static_assert(sizeof(UArcadeLevelAsset) == 0x000100, "Wrong size on UArcadeLevelAsset");
static_assert(offsetof(UArcadeLevelAsset, LevelSave) == 0x000030, "Member 'UArcadeLevelAsset::LevelSave' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAsset, Challenges) == 0x000058, "Member 'UArcadeLevelAsset::Challenges' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAsset, LevelScreen) == 0x000068, "Member 'UArcadeLevelAsset::LevelScreen' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAsset, Key) == 0x000090, "Member 'UArcadeLevelAsset::Key' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAsset, DisplayName) == 0x000098, "Member 'UArcadeLevelAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAsset, UniqueId) == 0x0000B0, "Member 'UArcadeLevelAsset::UniqueId' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAsset, CorsairAmbient) == 0x0000C0, "Member 'UArcadeLevelAsset::CorsairAmbient' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAsset, SpecificTrack) == 0x0000D0, "Member 'UArcadeLevelAsset::SpecificTrack' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAsset, BaseNPCScore) == 0x0000F8, "Member 'UArcadeLevelAsset::BaseNPCScore' has a wrong offset!");

// Class ThankYouVeryCool.ArcadeLevelAssetWorkshop
// 0x00A0 (0x01A0 - 0x0100)
class UArcadeLevelAssetWorkshop final : public UArcadeLevelAsset
{
public:
	class FString                                 PathToLevelSave;                                   // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToLevelDir;                                    // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorkshopID;                                        // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOnSteam;                                        // 0x0130(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   WorkshopDescription;                               // 0x0138(0x0018)(BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	class FText                                   WorkshopName;                                      // 0x0150(0x0018)(BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	bool                                          bFirefight;                                        // 0x0168(0x0001)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCampaign;                                         // 0x0169(0x0001)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16A[0x6];                                      // 0x016A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWorkshopChapterData                   ChapterData;                                       // 0x0170(0x0020)(BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	class FString                                 AuthorName;                                        // 0x0190(0x0010)(BlueprintVisible, ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArcadeLevelAssetWorkshop">();
	}
	static class UArcadeLevelAssetWorkshop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArcadeLevelAssetWorkshop>();
	}
};
static_assert(alignof(UArcadeLevelAssetWorkshop) == 0x000008, "Wrong alignment on UArcadeLevelAssetWorkshop");
static_assert(sizeof(UArcadeLevelAssetWorkshop) == 0x0001A0, "Wrong size on UArcadeLevelAssetWorkshop");
static_assert(offsetof(UArcadeLevelAssetWorkshop, PathToLevelSave) == 0x000100, "Member 'UArcadeLevelAssetWorkshop::PathToLevelSave' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, PathToLevelDir) == 0x000110, "Member 'UArcadeLevelAssetWorkshop::PathToLevelDir' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, WorkshopID) == 0x000120, "Member 'UArcadeLevelAssetWorkshop::WorkshopID' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, bIsOnSteam) == 0x000130, "Member 'UArcadeLevelAssetWorkshop::bIsOnSteam' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, WorkshopDescription) == 0x000138, "Member 'UArcadeLevelAssetWorkshop::WorkshopDescription' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, WorkshopName) == 0x000150, "Member 'UArcadeLevelAssetWorkshop::WorkshopName' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, bFirefight) == 0x000168, "Member 'UArcadeLevelAssetWorkshop::bFirefight' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, bCampaign) == 0x000169, "Member 'UArcadeLevelAssetWorkshop::bCampaign' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, ChapterData) == 0x000170, "Member 'UArcadeLevelAssetWorkshop::ChapterData' has a wrong offset!");
static_assert(offsetof(UArcadeLevelAssetWorkshop, AuthorName) == 0x000190, "Member 'UArcadeLevelAssetWorkshop::AuthorName' has a wrong offset!");

// Class ThankYouVeryCool.ArmCannon
// 0x06F0 (0x0910 - 0x0220)
class AArmCannon : public AActor
{
public:
	uint8                                         Pad_220[0x20];                                     // 0x0220(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PreviewTransform;                                  // 0x0240(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GravWallSize;                                      // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGravSupercharged;                                 // 0x0274(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275[0x8B];                                     // 0x0275(0x008B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GravRange;                                         // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ShootGunAnim;                                      // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShootGunAnimHeavy;                                 // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x10];                                     // 0x0318(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelTransformableGenerator*           WidePulseImpactGraph;                              // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmCannonThrusterForce;                            // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCinematicOC;                                    // 0x0334(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_335[0xB];                                      // 0x0335(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WPSkipProjectileThreshold;                         // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USpotLightComponent*                    FlashlightComp;                                    // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MainCannon;                                        // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 BasicUpgrade;                                      // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MagnetUpgrade;                                     // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 FoamUpgrade;                                       // 0x0378(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 BoosterCannon;                                     // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LaserMesh;                                         // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PaintingPlaneMesh;                                 // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               PaintingPlaneMat;                                  // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToKillOldFoam;                                 // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WidePulseChargeDrainRate;                          // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               FlashParticleComponent;                            // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       Player;                                            // 0x03B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MeltSystem;                                        // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        HitSystem;                                         // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               SpawnedWidePulseChargeSystem;                      // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PunchPauseAmount;                                  // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             PunchSwingSound;                                   // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PunchHitSound;                                     // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        SmokePuff;                                         // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             SmokePuffTransform;                                // 0x03F0(0x0030)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UParticleSystem*                        WidePulseChargeSystem_1;                           // 0x0420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        WidePulseChargeSystem_2;                           // 0x0428(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        WidePulseChargeSystem_3;                           // 0x0430(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MegaPulseChargeSystem_1;                           // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MegaPulseChargeSystem_2;                           // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MegaPulseChargeSystem_3;                           // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        OCChargeSystem;                                    // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        WidePulseSmoke;                                    // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        PunchHitSystem;                                    // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x4];                                      // 0x0468(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimePerWidePulseStage;                             // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x4];                                      // 0x0470(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BeamAimOffset;                                     // 0x0474(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_480[0x8];                                      // 0x0480(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             WidePulseChargeReadyBeep;                          // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             BackpackChargeSound;                               // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             WidePulseChargeReadyBuzz;                          // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AImpactManager*                         ImpactManager;                                     // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECannonMode                                   CurrentMode;                                       // 0x04B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                ModeSelectWidgetClass;                             // 0x04B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           BasicRecoilMontage;                                // 0x04C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           BasicRecoilMontageForArms;                         // 0x04C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           PunchMontageForArms;                               // 0x04D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             FoamFireSound;                                     // 0x04D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             MagnetGrabSound;                                   // 0x04E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             MagnetFireSound;                                   // 0x04E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RechargeRate;                                      // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MagnetForce;                                       // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4FC[0xC];                                      // 0x04FC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OCChargeTime;                                      // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FoamCoolDownTime;                                  // 0x050C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MagnetCooldownTime;                                // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_514[0x4];                                      // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    HeldObject;                                        // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        LoopingAudioComp;                                  // 0x0520(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   HeldObjectSlot;                                    // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicsConstraintComponent*            ConstraintComp;                                    // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        HeldObjectDefaultLocation;                         // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        AkimboDefaultLocation;                             // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0xC];                                      // 0x0548(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ShieldRot;                                         // 0x0554(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ShieldLoc;                                         // 0x0560(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HeldObjectLoc;                                     // 0x056C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                HeldObjectLocWeaponOffset;                         // 0x0578(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               DoorRot;                                           // 0x0584(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         MagnetChargeAmount;                                // 0x0590(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PulseChargeAmount;                                 // 0x0594(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WidePulseCooldownTime;                             // 0x0598(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59C[0x4];                                      // 0x059C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FoamChargeAmount;                                  // 0x05A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVoxelFalloff                                 FoamFalloffType;                                   // 0x05A4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A5[0x3];                                      // 0x05A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FoamFalloff;                                       // 0x05A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 MagnetColor;                                       // 0x05AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinNPCWPDMG;                                       // 0x05B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxNPCWPDMG;                                       // 0x05B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 PulseColor;                                        // 0x05B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BC[0x4];                                      // 0x05BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 CuttingColor;                                      // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 FoamColor;                                         // 0x05C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 PunchColor;                                        // 0x05C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 OverchargeColor;                                   // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartingChargeAmount;                              // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         BackpackChargeSystem;                              // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         GravBeamSystem;                                    // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        BlastMuzzleSystem;                                 // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        GravMuzzleSystem;                                  // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      BackpackChargeComp;                                // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_600[0x98];                                     // 0x0600(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             OverchargeCharge;                                  // 0x0698(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             OverchargeLoop;                                    // 0x06A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             OverchargeEnd;                                     // 0x06A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B0[0x8];                                      // 0x06B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            ChargeCurve;                                       // 0x06B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NarrowPulseRange;                                  // 0x06C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C4[0x4];                                      // 0x06C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OCBurnRate;                                        // 0x06C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPBurnRate;                                        // 0x06CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FoamRange;                                         // 0x06D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AVoxelWorld*                            FoamWorld;                                         // 0x06D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                WPScale;                                           // 0x06E0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WPMaterialScaleFactor;                             // 0x06EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WidePulseVFXThickness;                             // 0x06F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GooScale;                                          // 0x06F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WideXOffset;                                       // 0x0700(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_704[0x4];                                      // 0x0704(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AGoop>                      GoopClass;                                         // 0x0708(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AFoamVoxelWorld>            FoamVoxelWorldClass;                               // 0x0710(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        GoopParticle;                                      // 0x0718(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        PunchChargeParticle;                               // 0x0720(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          WidePulseIdleSequence;                             // 0x0728(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          DesiredIdleSeq;                                    // 0x0730(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          PunchIdleSequence;                                 // 0x0738(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               PunchChargeParticleComp;                           // 0x0740(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_748[0x4];                                      // 0x0748(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverchargeEMGoal;                                  // 0x074C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        OCLoopComp;                                        // 0x0750(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OCFireTime;                                        // 0x0758(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_75C[0xC];                                      // 0x075C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     NarrowBeamMat;                                     // 0x0768(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     OverchargeBeamMat;                                 // 0x0770(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MagnetMat;                                         // 0x0778(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_780[0x4];                                      // 0x0780(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OCTickRate;                                        // 0x0784(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_788[0x8];                                      // 0x0788(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackEffect*                   PulseShootFeedback;                                // 0x0790(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeaponBase*                            MyAkimboGun;                                       // 0x0798(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A0[0x1];                                      // 0x07A0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMagPulling;                                     // 0x07A1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A2[0x2];                                      // 0x07A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BeamRot;                                           // 0x07A4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MainCannonDynMat;                                  // 0x07B0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CannonDefaultMat;                                  // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CannonTriplanarMat;                                // 0x07C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPointLightComponent*                   GrabSlotLight;                                     // 0x07D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverchargeMaxRange;                                // 0x07D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverchargeMinRange;                                // 0x07DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E0[0x4];                                      // 0x07E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverchargeRangeSpeed;                              // 0x07E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverchargeRangeTime;                               // 0x07E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7EC[0x4];                                      // 0x07EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BackpackChargeTime;                                // 0x07F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F4[0xC];                                      // 0x07F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FoamAimRadius;                                     // 0x0800(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoamAimHeight;                                     // 0x0804(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   FoamCannonGuide;                                   // 0x0808(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           OverchargeShake;                                   // 0x0810(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraShakeBase*                       CurrentOCShake;                                    // 0x0818(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_820[0x8];                                      // 0x0820(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AFoamVoxelWorld*                        CurrentPaintingWorld;                              // 0x0828(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFoamVoxelWorld*                        LastPaintingWorld;                                 // 0x0830(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_838[0x18];                                     // 0x0838(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               FoamMuzzleBlast;                                   // 0x0850(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               GravPullPart;                                      // 0x0858(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_860[0x8];                                      // 0x0860(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBackpack*                              BackpackToChargeFrom;                              // 0x0868(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_870[0x4];                                      // 0x0870(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DriverLaunchStrength;                              // 0x0874(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DriverLaunchZ;                                     // 0x0878(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87C[0xC];                                      // 0x087C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             WidePulseChargeCue;                                // 0x0888(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ShieldSolid;                                       // 0x0890(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ShieldT;                                           // 0x0898(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DoorSolid;                                         // 0x08A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DoorT;                                             // 0x08A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenNarrowPulseEdits;                       // 0x08B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenWidePulseEdits;                         // 0x08B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenNarrowPulseParticles;                   // 0x08B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidePulseDamageRadius;                             // 0x08BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C0[0xC];                                      // 0x08C0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeRadiusMax;                                   // 0x08CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeRadiusMin;                                   // 0x08D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoamProjectionRadius;                              // 0x08D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoamSignedSculptStrength;                          // 0x08D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoamSignedPaintStrength;                           // 0x08DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoamSignedSculptStrength_OnNPC;                    // 0x08E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoamSignedSculptStrength_DropOffNPC;               // 0x08E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x10];                                     // 0x08E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PassiveRechargeInterval;                           // 0x08F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8FC[0x4];                                      // 0x08FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             FailCue;                                           // 0x0900(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ConfirmCue;                                        // 0x0908(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DoCinematicOvercharge(const TArray<struct FTransform>& ChargePoints, bool bForWorkshopSwap);
	void DoHeldObjectLogic();
	void DoHeldObjectLogicDeferred();
	void DoPunchCharge(const struct FVector& WorldDir);
	void FinishCharge();
	class ALuosProjectile* FireWidePulseProjectile(const struct FTransform& StartingTransform, float Chargetime, float MagmaUV, bool bMega);
	void LoadSkin(class FName InJacket);
	void NotifyCinematicCharge();
	void NotifyMagPullComplete();
	void OCChargeDone();
	void OCDoneFiring();
	void OnFoamHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnLevelReady();
	void OnThrownHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnWidePulseHit(const struct FTransform& Transform, class AActor* OnActor, const struct FVector& HitVelocity, const struct FHitResult& HitResult, float Chargetime, float MagmaUV, class UActorComponent* HitComp);
	ECannonMode QueryRadialForMode();
	void RechargeFromBackpack(class UBackpack* BackpackComp);
	void RechargeFromStation(class AActor* Station);
	void SetArmCannonRaise(bool bShouldRaise);
	void SetBeamEndPoint(const struct FVector& InEnd);
	void SetIdleSeqTo(class UAnimSequence* IdleSeq);
	void SetModeTo(ECannonMode InMode);
	void SetVisualsForMode(ECannonMode ForMode);
	void ShowChargePercent(float InPercent);
	void ShowOvercharge(bool bShow, bool bInstant);
	void StartPullObject();
	void StartWPAim();
	void StopPullObject();
	void StopWPAim();
	void TickCharge(float Value);
	void TryDoPassiveRecharge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmCannon">();
	}
	static class AArmCannon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AArmCannon>();
	}
};
static_assert(alignof(AArmCannon) == 0x000010, "Wrong alignment on AArmCannon");
static_assert(sizeof(AArmCannon) == 0x000910, "Wrong size on AArmCannon");
static_assert(offsetof(AArmCannon, PreviewTransform) == 0x000240, "Member 'AArmCannon::PreviewTransform' has a wrong offset!");
static_assert(offsetof(AArmCannon, GravWallSize) == 0x000270, "Member 'AArmCannon::GravWallSize' has a wrong offset!");
static_assert(offsetof(AArmCannon, bGravSupercharged) == 0x000274, "Member 'AArmCannon::bGravSupercharged' has a wrong offset!");
static_assert(offsetof(AArmCannon, GravRange) == 0x000300, "Member 'AArmCannon::GravRange' has a wrong offset!");
static_assert(offsetof(AArmCannon, ShootGunAnim) == 0x000308, "Member 'AArmCannon::ShootGunAnim' has a wrong offset!");
static_assert(offsetof(AArmCannon, ShootGunAnimHeavy) == 0x000310, "Member 'AArmCannon::ShootGunAnimHeavy' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseImpactGraph) == 0x000328, "Member 'AArmCannon::WidePulseImpactGraph' has a wrong offset!");
static_assert(offsetof(AArmCannon, ArmCannonThrusterForce) == 0x000330, "Member 'AArmCannon::ArmCannonThrusterForce' has a wrong offset!");
static_assert(offsetof(AArmCannon, bIsCinematicOC) == 0x000334, "Member 'AArmCannon::bIsCinematicOC' has a wrong offset!");
static_assert(offsetof(AArmCannon, WPSkipProjectileThreshold) == 0x000340, "Member 'AArmCannon::WPSkipProjectileThreshold' has a wrong offset!");
static_assert(offsetof(AArmCannon, FlashlightComp) == 0x000348, "Member 'AArmCannon::FlashlightComp' has a wrong offset!");
static_assert(offsetof(AArmCannon, TYVCGameMode) == 0x000358, "Member 'AArmCannon::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AArmCannon, MainCannon) == 0x000360, "Member 'AArmCannon::MainCannon' has a wrong offset!");
static_assert(offsetof(AArmCannon, BasicUpgrade) == 0x000368, "Member 'AArmCannon::BasicUpgrade' has a wrong offset!");
static_assert(offsetof(AArmCannon, MagnetUpgrade) == 0x000370, "Member 'AArmCannon::MagnetUpgrade' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamUpgrade) == 0x000378, "Member 'AArmCannon::FoamUpgrade' has a wrong offset!");
static_assert(offsetof(AArmCannon, BoosterCannon) == 0x000380, "Member 'AArmCannon::BoosterCannon' has a wrong offset!");
static_assert(offsetof(AArmCannon, LaserMesh) == 0x000388, "Member 'AArmCannon::LaserMesh' has a wrong offset!");
static_assert(offsetof(AArmCannon, PaintingPlaneMesh) == 0x000390, "Member 'AArmCannon::PaintingPlaneMesh' has a wrong offset!");
static_assert(offsetof(AArmCannon, PaintingPlaneMat) == 0x000398, "Member 'AArmCannon::PaintingPlaneMat' has a wrong offset!");
static_assert(offsetof(AArmCannon, TimeToKillOldFoam) == 0x0003A0, "Member 'AArmCannon::TimeToKillOldFoam' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseChargeDrainRate) == 0x0003A4, "Member 'AArmCannon::WidePulseChargeDrainRate' has a wrong offset!");
static_assert(offsetof(AArmCannon, FlashParticleComponent) == 0x0003A8, "Member 'AArmCannon::FlashParticleComponent' has a wrong offset!");
static_assert(offsetof(AArmCannon, Player) == 0x0003B0, "Member 'AArmCannon::Player' has a wrong offset!");
static_assert(offsetof(AArmCannon, MeltSystem) == 0x0003B8, "Member 'AArmCannon::MeltSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, HitSystem) == 0x0003C0, "Member 'AArmCannon::HitSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, SpawnedWidePulseChargeSystem) == 0x0003C8, "Member 'AArmCannon::SpawnedWidePulseChargeSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchPauseAmount) == 0x0003D0, "Member 'AArmCannon::PunchPauseAmount' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchSwingSound) == 0x0003D8, "Member 'AArmCannon::PunchSwingSound' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchHitSound) == 0x0003E0, "Member 'AArmCannon::PunchHitSound' has a wrong offset!");
static_assert(offsetof(AArmCannon, SmokePuff) == 0x0003E8, "Member 'AArmCannon::SmokePuff' has a wrong offset!");
static_assert(offsetof(AArmCannon, SmokePuffTransform) == 0x0003F0, "Member 'AArmCannon::SmokePuffTransform' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseChargeSystem_1) == 0x000420, "Member 'AArmCannon::WidePulseChargeSystem_1' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseChargeSystem_2) == 0x000428, "Member 'AArmCannon::WidePulseChargeSystem_2' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseChargeSystem_3) == 0x000430, "Member 'AArmCannon::WidePulseChargeSystem_3' has a wrong offset!");
static_assert(offsetof(AArmCannon, MegaPulseChargeSystem_1) == 0x000438, "Member 'AArmCannon::MegaPulseChargeSystem_1' has a wrong offset!");
static_assert(offsetof(AArmCannon, MegaPulseChargeSystem_2) == 0x000440, "Member 'AArmCannon::MegaPulseChargeSystem_2' has a wrong offset!");
static_assert(offsetof(AArmCannon, MegaPulseChargeSystem_3) == 0x000448, "Member 'AArmCannon::MegaPulseChargeSystem_3' has a wrong offset!");
static_assert(offsetof(AArmCannon, OCChargeSystem) == 0x000450, "Member 'AArmCannon::OCChargeSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseSmoke) == 0x000458, "Member 'AArmCannon::WidePulseSmoke' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchHitSystem) == 0x000460, "Member 'AArmCannon::PunchHitSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, TimePerWidePulseStage) == 0x00046C, "Member 'AArmCannon::TimePerWidePulseStage' has a wrong offset!");
static_assert(offsetof(AArmCannon, BeamAimOffset) == 0x000474, "Member 'AArmCannon::BeamAimOffset' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseChargeReadyBeep) == 0x000488, "Member 'AArmCannon::WidePulseChargeReadyBeep' has a wrong offset!");
static_assert(offsetof(AArmCannon, BackpackChargeSound) == 0x000490, "Member 'AArmCannon::BackpackChargeSound' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseChargeReadyBuzz) == 0x0004A0, "Member 'AArmCannon::WidePulseChargeReadyBuzz' has a wrong offset!");
static_assert(offsetof(AArmCannon, ImpactManager) == 0x0004A8, "Member 'AArmCannon::ImpactManager' has a wrong offset!");
static_assert(offsetof(AArmCannon, CurrentMode) == 0x0004B0, "Member 'AArmCannon::CurrentMode' has a wrong offset!");
static_assert(offsetof(AArmCannon, ModeSelectWidgetClass) == 0x0004B8, "Member 'AArmCannon::ModeSelectWidgetClass' has a wrong offset!");
static_assert(offsetof(AArmCannon, BasicRecoilMontage) == 0x0004C0, "Member 'AArmCannon::BasicRecoilMontage' has a wrong offset!");
static_assert(offsetof(AArmCannon, BasicRecoilMontageForArms) == 0x0004C8, "Member 'AArmCannon::BasicRecoilMontageForArms' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchMontageForArms) == 0x0004D0, "Member 'AArmCannon::PunchMontageForArms' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamFireSound) == 0x0004D8, "Member 'AArmCannon::FoamFireSound' has a wrong offset!");
static_assert(offsetof(AArmCannon, MagnetGrabSound) == 0x0004E0, "Member 'AArmCannon::MagnetGrabSound' has a wrong offset!");
static_assert(offsetof(AArmCannon, MagnetFireSound) == 0x0004E8, "Member 'AArmCannon::MagnetFireSound' has a wrong offset!");
static_assert(offsetof(AArmCannon, RechargeRate) == 0x0004F0, "Member 'AArmCannon::RechargeRate' has a wrong offset!");
static_assert(offsetof(AArmCannon, MagnetForce) == 0x0004F8, "Member 'AArmCannon::MagnetForce' has a wrong offset!");
static_assert(offsetof(AArmCannon, OCChargeTime) == 0x000508, "Member 'AArmCannon::OCChargeTime' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamCoolDownTime) == 0x00050C, "Member 'AArmCannon::FoamCoolDownTime' has a wrong offset!");
static_assert(offsetof(AArmCannon, MagnetCooldownTime) == 0x000510, "Member 'AArmCannon::MagnetCooldownTime' has a wrong offset!");
static_assert(offsetof(AArmCannon, HeldObject) == 0x000518, "Member 'AArmCannon::HeldObject' has a wrong offset!");
static_assert(offsetof(AArmCannon, LoopingAudioComp) == 0x000520, "Member 'AArmCannon::LoopingAudioComp' has a wrong offset!");
static_assert(offsetof(AArmCannon, HeldObjectSlot) == 0x000528, "Member 'AArmCannon::HeldObjectSlot' has a wrong offset!");
static_assert(offsetof(AArmCannon, ConstraintComp) == 0x000530, "Member 'AArmCannon::ConstraintComp' has a wrong offset!");
static_assert(offsetof(AArmCannon, HeldObjectDefaultLocation) == 0x000538, "Member 'AArmCannon::HeldObjectDefaultLocation' has a wrong offset!");
static_assert(offsetof(AArmCannon, AkimboDefaultLocation) == 0x000540, "Member 'AArmCannon::AkimboDefaultLocation' has a wrong offset!");
static_assert(offsetof(AArmCannon, ShieldRot) == 0x000554, "Member 'AArmCannon::ShieldRot' has a wrong offset!");
static_assert(offsetof(AArmCannon, ShieldLoc) == 0x000560, "Member 'AArmCannon::ShieldLoc' has a wrong offset!");
static_assert(offsetof(AArmCannon, HeldObjectLoc) == 0x00056C, "Member 'AArmCannon::HeldObjectLoc' has a wrong offset!");
static_assert(offsetof(AArmCannon, HeldObjectLocWeaponOffset) == 0x000578, "Member 'AArmCannon::HeldObjectLocWeaponOffset' has a wrong offset!");
static_assert(offsetof(AArmCannon, DoorRot) == 0x000584, "Member 'AArmCannon::DoorRot' has a wrong offset!");
static_assert(offsetof(AArmCannon, MagnetChargeAmount) == 0x000590, "Member 'AArmCannon::MagnetChargeAmount' has a wrong offset!");
static_assert(offsetof(AArmCannon, PulseChargeAmount) == 0x000594, "Member 'AArmCannon::PulseChargeAmount' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseCooldownTime) == 0x000598, "Member 'AArmCannon::WidePulseCooldownTime' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamChargeAmount) == 0x0005A0, "Member 'AArmCannon::FoamChargeAmount' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamFalloffType) == 0x0005A4, "Member 'AArmCannon::FoamFalloffType' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamFalloff) == 0x0005A8, "Member 'AArmCannon::FoamFalloff' has a wrong offset!");
static_assert(offsetof(AArmCannon, MagnetColor) == 0x0005AC, "Member 'AArmCannon::MagnetColor' has a wrong offset!");
static_assert(offsetof(AArmCannon, MinNPCWPDMG) == 0x0005B0, "Member 'AArmCannon::MinNPCWPDMG' has a wrong offset!");
static_assert(offsetof(AArmCannon, MaxNPCWPDMG) == 0x0005B4, "Member 'AArmCannon::MaxNPCWPDMG' has a wrong offset!");
static_assert(offsetof(AArmCannon, PulseColor) == 0x0005B8, "Member 'AArmCannon::PulseColor' has a wrong offset!");
static_assert(offsetof(AArmCannon, CuttingColor) == 0x0005C0, "Member 'AArmCannon::CuttingColor' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamColor) == 0x0005C4, "Member 'AArmCannon::FoamColor' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchColor) == 0x0005C8, "Member 'AArmCannon::PunchColor' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeColor) == 0x0005CC, "Member 'AArmCannon::OverchargeColor' has a wrong offset!");
static_assert(offsetof(AArmCannon, StartingChargeAmount) == 0x0005D0, "Member 'AArmCannon::StartingChargeAmount' has a wrong offset!");
static_assert(offsetof(AArmCannon, BackpackChargeSystem) == 0x0005D8, "Member 'AArmCannon::BackpackChargeSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, GravBeamSystem) == 0x0005E0, "Member 'AArmCannon::GravBeamSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, BlastMuzzleSystem) == 0x0005E8, "Member 'AArmCannon::BlastMuzzleSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, GravMuzzleSystem) == 0x0005F0, "Member 'AArmCannon::GravMuzzleSystem' has a wrong offset!");
static_assert(offsetof(AArmCannon, BackpackChargeComp) == 0x0005F8, "Member 'AArmCannon::BackpackChargeComp' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeCharge) == 0x000698, "Member 'AArmCannon::OverchargeCharge' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeLoop) == 0x0006A0, "Member 'AArmCannon::OverchargeLoop' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeEnd) == 0x0006A8, "Member 'AArmCannon::OverchargeEnd' has a wrong offset!");
static_assert(offsetof(AArmCannon, ChargeCurve) == 0x0006B8, "Member 'AArmCannon::ChargeCurve' has a wrong offset!");
static_assert(offsetof(AArmCannon, NarrowPulseRange) == 0x0006C0, "Member 'AArmCannon::NarrowPulseRange' has a wrong offset!");
static_assert(offsetof(AArmCannon, OCBurnRate) == 0x0006C8, "Member 'AArmCannon::OCBurnRate' has a wrong offset!");
static_assert(offsetof(AArmCannon, NPBurnRate) == 0x0006CC, "Member 'AArmCannon::NPBurnRate' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamRange) == 0x0006D0, "Member 'AArmCannon::FoamRange' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamWorld) == 0x0006D8, "Member 'AArmCannon::FoamWorld' has a wrong offset!");
static_assert(offsetof(AArmCannon, WPScale) == 0x0006E0, "Member 'AArmCannon::WPScale' has a wrong offset!");
static_assert(offsetof(AArmCannon, WPMaterialScaleFactor) == 0x0006EC, "Member 'AArmCannon::WPMaterialScaleFactor' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseVFXThickness) == 0x0006F0, "Member 'AArmCannon::WidePulseVFXThickness' has a wrong offset!");
static_assert(offsetof(AArmCannon, GooScale) == 0x0006F4, "Member 'AArmCannon::GooScale' has a wrong offset!");
static_assert(offsetof(AArmCannon, WideXOffset) == 0x000700, "Member 'AArmCannon::WideXOffset' has a wrong offset!");
static_assert(offsetof(AArmCannon, GoopClass) == 0x000708, "Member 'AArmCannon::GoopClass' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamVoxelWorldClass) == 0x000710, "Member 'AArmCannon::FoamVoxelWorldClass' has a wrong offset!");
static_assert(offsetof(AArmCannon, GoopParticle) == 0x000718, "Member 'AArmCannon::GoopParticle' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchChargeParticle) == 0x000720, "Member 'AArmCannon::PunchChargeParticle' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseIdleSequence) == 0x000728, "Member 'AArmCannon::WidePulseIdleSequence' has a wrong offset!");
static_assert(offsetof(AArmCannon, DesiredIdleSeq) == 0x000730, "Member 'AArmCannon::DesiredIdleSeq' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchIdleSequence) == 0x000738, "Member 'AArmCannon::PunchIdleSequence' has a wrong offset!");
static_assert(offsetof(AArmCannon, PunchChargeParticleComp) == 0x000740, "Member 'AArmCannon::PunchChargeParticleComp' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeEMGoal) == 0x00074C, "Member 'AArmCannon::OverchargeEMGoal' has a wrong offset!");
static_assert(offsetof(AArmCannon, OCLoopComp) == 0x000750, "Member 'AArmCannon::OCLoopComp' has a wrong offset!");
static_assert(offsetof(AArmCannon, OCFireTime) == 0x000758, "Member 'AArmCannon::OCFireTime' has a wrong offset!");
static_assert(offsetof(AArmCannon, NarrowBeamMat) == 0x000768, "Member 'AArmCannon::NarrowBeamMat' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeBeamMat) == 0x000770, "Member 'AArmCannon::OverchargeBeamMat' has a wrong offset!");
static_assert(offsetof(AArmCannon, MagnetMat) == 0x000778, "Member 'AArmCannon::MagnetMat' has a wrong offset!");
static_assert(offsetof(AArmCannon, OCTickRate) == 0x000784, "Member 'AArmCannon::OCTickRate' has a wrong offset!");
static_assert(offsetof(AArmCannon, PulseShootFeedback) == 0x000790, "Member 'AArmCannon::PulseShootFeedback' has a wrong offset!");
static_assert(offsetof(AArmCannon, MyAkimboGun) == 0x000798, "Member 'AArmCannon::MyAkimboGun' has a wrong offset!");
static_assert(offsetof(AArmCannon, bIsMagPulling) == 0x0007A1, "Member 'AArmCannon::bIsMagPulling' has a wrong offset!");
static_assert(offsetof(AArmCannon, BeamRot) == 0x0007A4, "Member 'AArmCannon::BeamRot' has a wrong offset!");
static_assert(offsetof(AArmCannon, MainCannonDynMat) == 0x0007B0, "Member 'AArmCannon::MainCannonDynMat' has a wrong offset!");
static_assert(offsetof(AArmCannon, CannonDefaultMat) == 0x0007B8, "Member 'AArmCannon::CannonDefaultMat' has a wrong offset!");
static_assert(offsetof(AArmCannon, CannonTriplanarMat) == 0x0007C0, "Member 'AArmCannon::CannonTriplanarMat' has a wrong offset!");
static_assert(offsetof(AArmCannon, GrabSlotLight) == 0x0007D0, "Member 'AArmCannon::GrabSlotLight' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeMaxRange) == 0x0007D8, "Member 'AArmCannon::OverchargeMaxRange' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeMinRange) == 0x0007DC, "Member 'AArmCannon::OverchargeMinRange' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeRangeSpeed) == 0x0007E4, "Member 'AArmCannon::OverchargeRangeSpeed' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeRangeTime) == 0x0007E8, "Member 'AArmCannon::OverchargeRangeTime' has a wrong offset!");
static_assert(offsetof(AArmCannon, BackpackChargeTime) == 0x0007F0, "Member 'AArmCannon::BackpackChargeTime' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamAimRadius) == 0x000800, "Member 'AArmCannon::FoamAimRadius' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamAimHeight) == 0x000804, "Member 'AArmCannon::FoamAimHeight' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamCannonGuide) == 0x000808, "Member 'AArmCannon::FoamCannonGuide' has a wrong offset!");
static_assert(offsetof(AArmCannon, OverchargeShake) == 0x000810, "Member 'AArmCannon::OverchargeShake' has a wrong offset!");
static_assert(offsetof(AArmCannon, CurrentOCShake) == 0x000818, "Member 'AArmCannon::CurrentOCShake' has a wrong offset!");
static_assert(offsetof(AArmCannon, CurrentPaintingWorld) == 0x000828, "Member 'AArmCannon::CurrentPaintingWorld' has a wrong offset!");
static_assert(offsetof(AArmCannon, LastPaintingWorld) == 0x000830, "Member 'AArmCannon::LastPaintingWorld' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamMuzzleBlast) == 0x000850, "Member 'AArmCannon::FoamMuzzleBlast' has a wrong offset!");
static_assert(offsetof(AArmCannon, GravPullPart) == 0x000858, "Member 'AArmCannon::GravPullPart' has a wrong offset!");
static_assert(offsetof(AArmCannon, BackpackToChargeFrom) == 0x000868, "Member 'AArmCannon::BackpackToChargeFrom' has a wrong offset!");
static_assert(offsetof(AArmCannon, DriverLaunchStrength) == 0x000874, "Member 'AArmCannon::DriverLaunchStrength' has a wrong offset!");
static_assert(offsetof(AArmCannon, DriverLaunchZ) == 0x000878, "Member 'AArmCannon::DriverLaunchZ' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseChargeCue) == 0x000888, "Member 'AArmCannon::WidePulseChargeCue' has a wrong offset!");
static_assert(offsetof(AArmCannon, ShieldSolid) == 0x000890, "Member 'AArmCannon::ShieldSolid' has a wrong offset!");
static_assert(offsetof(AArmCannon, ShieldT) == 0x000898, "Member 'AArmCannon::ShieldT' has a wrong offset!");
static_assert(offsetof(AArmCannon, DoorSolid) == 0x0008A0, "Member 'AArmCannon::DoorSolid' has a wrong offset!");
static_assert(offsetof(AArmCannon, DoorT) == 0x0008A8, "Member 'AArmCannon::DoorT' has a wrong offset!");
static_assert(offsetof(AArmCannon, TimeBetweenNarrowPulseEdits) == 0x0008B0, "Member 'AArmCannon::TimeBetweenNarrowPulseEdits' has a wrong offset!");
static_assert(offsetof(AArmCannon, TimeBetweenWidePulseEdits) == 0x0008B4, "Member 'AArmCannon::TimeBetweenWidePulseEdits' has a wrong offset!");
static_assert(offsetof(AArmCannon, TimeBetweenNarrowPulseParticles) == 0x0008B8, "Member 'AArmCannon::TimeBetweenNarrowPulseParticles' has a wrong offset!");
static_assert(offsetof(AArmCannon, WidePulseDamageRadius) == 0x0008BC, "Member 'AArmCannon::WidePulseDamageRadius' has a wrong offset!");
static_assert(offsetof(AArmCannon, ChargeRadiusMax) == 0x0008CC, "Member 'AArmCannon::ChargeRadiusMax' has a wrong offset!");
static_assert(offsetof(AArmCannon, ChargeRadiusMin) == 0x0008D0, "Member 'AArmCannon::ChargeRadiusMin' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamProjectionRadius) == 0x0008D4, "Member 'AArmCannon::FoamProjectionRadius' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamSignedSculptStrength) == 0x0008D8, "Member 'AArmCannon::FoamSignedSculptStrength' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamSignedPaintStrength) == 0x0008DC, "Member 'AArmCannon::FoamSignedPaintStrength' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamSignedSculptStrength_OnNPC) == 0x0008E0, "Member 'AArmCannon::FoamSignedSculptStrength_OnNPC' has a wrong offset!");
static_assert(offsetof(AArmCannon, FoamSignedSculptStrength_DropOffNPC) == 0x0008E4, "Member 'AArmCannon::FoamSignedSculptStrength_DropOffNPC' has a wrong offset!");
static_assert(offsetof(AArmCannon, PassiveRechargeInterval) == 0x0008F8, "Member 'AArmCannon::PassiveRechargeInterval' has a wrong offset!");
static_assert(offsetof(AArmCannon, FailCue) == 0x000900, "Member 'AArmCannon::FailCue' has a wrong offset!");
static_assert(offsetof(AArmCannon, ConfirmCue) == 0x000908, "Member 'AArmCannon::ConfirmCue' has a wrong offset!");

// Class ThankYouVeryCool.ArmCannonModeWidget
// 0x0000 (0x0260 - 0x0260)
class UArmCannonModeWidget : public UUserWidget
{
public:
	ECannonMode GetSelectedMode();
	void SetupModes(const TArray<ECannonMode>& Modes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmCannonModeWidget">();
	}
	static class UArmCannonModeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmCannonModeWidget>();
	}
};
static_assert(alignof(UArmCannonModeWidget) == 0x000008, "Wrong alignment on UArmCannonModeWidget");
static_assert(sizeof(UArmCannonModeWidget) == 0x000260, "Wrong size on UArmCannonModeWidget");

// Class ThankYouVeryCool.ArmorAnimInstance
// 0x0040 (0x0300 - 0x02C0)
class UArmorAnimInstance : public UAnimInstance
{
public:
	struct FPoseSnapshot                          PoseSnapshot;                                      // 0x02B8(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bUsePoseSnapshot;                                  // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0xF];                                      // 0x02F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmorAnimInstance">();
	}
	static class UArmorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmorAnimInstance>();
	}
};
static_assert(alignof(UArmorAnimInstance) == 0x000010, "Wrong alignment on UArmorAnimInstance");
static_assert(sizeof(UArmorAnimInstance) == 0x000300, "Wrong size on UArmorAnimInstance");
static_assert(offsetof(UArmorAnimInstance, PoseSnapshot) == 0x0002B8, "Member 'UArmorAnimInstance::PoseSnapshot' has a wrong offset!");
static_assert(offsetof(UArmorAnimInstance, bUsePoseSnapshot) == 0x0002F0, "Member 'UArmorAnimInstance::bUsePoseSnapshot' has a wrong offset!");

// Class ThankYouVeryCool.Backpack
// 0x0150 (0x1020 - 0x0ED0)
class UBackpack : public USkeletalMeshComponent
{
public:
	class ANPC*                                   MyNPC;                                             // 0x0EC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ED0[0x8];                                      // 0x0ED0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AImpactManager*                         ImpactManager;                                     // 0x0ED8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0EE0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TraceOffsetFromBone;                               // 0x0EE8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RoundsPerMinute;                                   // 0x0EEC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlashBrightness;                                   // 0x0EF0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EF4[0xE];                                      // 0x0EF4(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	EBackpackType                                 BackpackType;                                      // 0x0F02(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F03[0x5];                                      // 0x0F03(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        MuzzleFlash;                                       // 0x0F08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F10[0xA0];                                     // 0x0F10(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UPointLightComponent*                   MuzzleFlashPointLightLeft;                         // 0x0FB0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPointLightComponent*                   MuzzleFlashPointLightRight;                        // 0x0FB8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBackpackAnimInstance*                  BackpackAnimInst;                                  // 0x0FC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeSize;                                          // 0x0FC8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadRocketsTime;                                 // 0x0FCC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD0[0x8];                                      // 0x0FD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AM203_Round>                RocketActorClass;                                  // 0x0FD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE0[0x8];                                      // 0x0FE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        SoundLoop;                                         // 0x0FE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ShootSound;                                        // 0x0FF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               BackpackDynMat;                                    // 0x0FF8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RocketBurstCount;                                  // 0x1000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RocketBurstSpeed;                                  // 0x1004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1008[0x18];                                    // 0x1008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoRocketBurst();
	void FinishMuzzleFlash();
	void RocketsLoaded();
	void ShootMinigun();
	void ShootRocket();
	void TickMuzzleFlash(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Backpack">();
	}
	static class UBackpack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackpack>();
	}
};
static_assert(alignof(UBackpack) == 0x000010, "Wrong alignment on UBackpack");
static_assert(sizeof(UBackpack) == 0x001020, "Wrong size on UBackpack");
static_assert(offsetof(UBackpack, MyNPC) == 0x000EC8, "Member 'UBackpack::MyNPC' has a wrong offset!");
static_assert(offsetof(UBackpack, ImpactManager) == 0x000ED8, "Member 'UBackpack::ImpactManager' has a wrong offset!");
static_assert(offsetof(UBackpack, TYVCGameMode) == 0x000EE0, "Member 'UBackpack::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(UBackpack, TraceOffsetFromBone) == 0x000EE8, "Member 'UBackpack::TraceOffsetFromBone' has a wrong offset!");
static_assert(offsetof(UBackpack, RoundsPerMinute) == 0x000EEC, "Member 'UBackpack::RoundsPerMinute' has a wrong offset!");
static_assert(offsetof(UBackpack, FlashBrightness) == 0x000EF0, "Member 'UBackpack::FlashBrightness' has a wrong offset!");
static_assert(offsetof(UBackpack, BackpackType) == 0x000F02, "Member 'UBackpack::BackpackType' has a wrong offset!");
static_assert(offsetof(UBackpack, MuzzleFlash) == 0x000F08, "Member 'UBackpack::MuzzleFlash' has a wrong offset!");
static_assert(offsetof(UBackpack, MuzzleFlashPointLightLeft) == 0x000FB0, "Member 'UBackpack::MuzzleFlashPointLightLeft' has a wrong offset!");
static_assert(offsetof(UBackpack, MuzzleFlashPointLightRight) == 0x000FB8, "Member 'UBackpack::MuzzleFlashPointLightRight' has a wrong offset!");
static_assert(offsetof(UBackpack, BackpackAnimInst) == 0x000FC0, "Member 'UBackpack::BackpackAnimInst' has a wrong offset!");
static_assert(offsetof(UBackpack, ConeSize) == 0x000FC8, "Member 'UBackpack::ConeSize' has a wrong offset!");
static_assert(offsetof(UBackpack, ReloadRocketsTime) == 0x000FCC, "Member 'UBackpack::ReloadRocketsTime' has a wrong offset!");
static_assert(offsetof(UBackpack, RocketActorClass) == 0x000FD8, "Member 'UBackpack::RocketActorClass' has a wrong offset!");
static_assert(offsetof(UBackpack, SoundLoop) == 0x000FE8, "Member 'UBackpack::SoundLoop' has a wrong offset!");
static_assert(offsetof(UBackpack, ShootSound) == 0x000FF0, "Member 'UBackpack::ShootSound' has a wrong offset!");
static_assert(offsetof(UBackpack, BackpackDynMat) == 0x000FF8, "Member 'UBackpack::BackpackDynMat' has a wrong offset!");
static_assert(offsetof(UBackpack, RocketBurstCount) == 0x001000, "Member 'UBackpack::RocketBurstCount' has a wrong offset!");
static_assert(offsetof(UBackpack, RocketBurstSpeed) == 0x001004, "Member 'UBackpack::RocketBurstSpeed' has a wrong offset!");

// Class ThankYouVeryCool.BackpackAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UBackpackAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_2B8[0x4];                                      // 0x02B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AO_Pitch;                                          // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AO_Yaw;                                            // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentRightBarrelRotation;                        // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrelRotationSpeed;                               // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackpackAnimInstance">();
	}
	static class UBackpackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackpackAnimInstance>();
	}
};
static_assert(alignof(UBackpackAnimInstance) == 0x000010, "Wrong alignment on UBackpackAnimInstance");
static_assert(sizeof(UBackpackAnimInstance) == 0x0002D0, "Wrong size on UBackpackAnimInstance");
static_assert(offsetof(UBackpackAnimInstance, AO_Pitch) == 0x0002BC, "Member 'UBackpackAnimInstance::AO_Pitch' has a wrong offset!");
static_assert(offsetof(UBackpackAnimInstance, AO_Yaw) == 0x0002C0, "Member 'UBackpackAnimInstance::AO_Yaw' has a wrong offset!");
static_assert(offsetof(UBackpackAnimInstance, CurrentRightBarrelRotation) == 0x0002C4, "Member 'UBackpackAnimInstance::CurrentRightBarrelRotation' has a wrong offset!");
static_assert(offsetof(UBackpackAnimInstance, BarrelRotationSpeed) == 0x0002C8, "Member 'UBackpackAnimInstance::BarrelRotationSpeed' has a wrong offset!");

// Class ThankYouVeryCool.VoxelBuilder2
// 0x01A0 (0x0A18 - 0x0878)
class AVoxelBuilder2 : public AVoxelWorld
{
public:
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSubtractive;                                    // 0x0880(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_881[0x7];                                      // 0x0881(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVoxelBuilder2*>                 ExclusiveSubs;                                     // 0x0888(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AVoxelBuilder2*>                 WorldsImSubtractingFrom;                           // 0x0898(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FShape>                         SelfSubShapes;                                     // 0x08A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class AVoxelBuilder2*, struct FShapeList> SubtractiveMap;                                    // 0x08B8(0x0050)(NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0908(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90C[0x4];                                      // 0x090C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ActorRoot;                                         // 0x0910(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipBake;                                         // 0x0918(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnAsPhysicsWorld;                              // 0x0919(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReportEventsToCampaign;                           // 0x091A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91B[0x1];                                      // 0x091B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CampaignID;                                        // 0x091C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnAsVoxelWorld;                                // 0x0924(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPackageBuilder;                                   // 0x0925(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_926[0xA];                                      // 0x0926(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	class AVoxelBrush*                            MyBrush;                                           // 0x0930(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelDataAsset*                        TestMaterial;                                      // 0x0938(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            PreviewWorld;                                      // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AVoxelAssetActor*>               ManagedAssets;                                     // 0x0948(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ManagedActors;                                     // 0x0958(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	class UArrowComponent*                        TurtleArrow;                                       // 0x0968(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWorldsCreated;                                    // 0x0970(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_971[0x7];                                      // 0x0971(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, class AVoxelWorld*>              IndexWorldMap;                                     // 0x0978(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            PrimaryVoxelWorld;                                 // 0x09C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            SecondaryVoxelWorld;                               // 0x09D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            TertiaryVoxelWorld;                                // 0x09D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            QuaternaryVoxelWorld;                              // 0x09E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E8[0x10];                                     // 0x09E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTriPrism*                              CurrentGen;                                        // 0x09F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EForWorld                                     ForWorld;                                          // 0x0A00(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A01[0x17];                                     // 0x0A01(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBoxToGenerator(const struct FVector& BoxDims, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot, bool bIsSub);
	void AddHexPrismGenerator(float Radius, float Thickness, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot);
	void AddOctohedronToGenerator(float Radius, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot);
	void AddRoundedCylinderGenerator(float Radius, float Smoothness, float Height, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot);
	void AddTorusGenerator(float Radius, float Thickness, bool bHollow, float ShellSize, EVoxelMaterial Mat, const struct FColor& RGB, bool bIsRoot);
	void BlueprintBuildImp();
	void Build(bool bStampToOuterWorlds, bool bForceSubtractive, bool bSubtractFromAll);
	bool Build_Imp(bool bStampToOuterWorlds, bool bForceSubtractive);
	void DeleteManagedAssets();
	TArray<class AVoxelWorld*> GetOuterWorldsAffected();
	struct FTransform GetTurtleWorldTransform();
	void MoveTurtle(int32 Units, bool bMinusOne);
	void RebuildAllCalled();
	void ReturnTurtleToRoot();
	void RotateTurtle(const struct FRotator& RotateDelta);
	void SetTurtleWorldTransform(const struct FTransform& ToSet);
	void SlideTurtleRight(int32 Units, bool bMinusOne);
	void SlideTurtleUp(int32 Units, bool bMinusOne);
	void SpawnActorAtTurtle(TSubclassOf<class AActor> ToSpawn, class AActor** SpawnedActor, const struct FVector& Scale);
	void SpawnActorsInGrid(int32 XDistance, int32 YDistance, int32 XCount, int32 YCount, TSubclassOf<class AActor> ActorClass, const struct FIntVector& OffsetSpawnLocation, const struct FRotator& RotationFromTurtleStart, TArray<class AActor*>* OutActors, const struct FVector& Scale, bool SpawnFirstAtCurrentLocation, int32 TrimFromMiddleX, int32 TrimFromMiddleY, int32 ToTrimFromEdgeX, int32 ToTrimFromEdgeY);
	void SpawnActorsInLine(int32 LineDistance, int32 ActorCount, TSubclassOf<class AActor> ActorClass, const struct FIntVector& OffsetSpawnLocation, const struct FRotator& RotationFromLine, TArray<class AActor*>* OutActors, const struct FVector& Scale, bool ReturnTurtleWhenFinished, bool SpawnFirstAtCurrentLocation, int32 TrimFromMiddle, int32 TrimFromEdge);
	void StampActors();
	bool StampAssets(int32 Priority_0, bool bToOuterWorld);
	void TestSpawn();
	void TurnTurtleYaw(int32 Degrees);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBuilder2">();
	}
	static class AVoxelBuilder2* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelBuilder2>();
	}
};
static_assert(alignof(AVoxelBuilder2) == 0x000008, "Wrong alignment on AVoxelBuilder2");
static_assert(sizeof(AVoxelBuilder2) == 0x000A18, "Wrong size on AVoxelBuilder2");
static_assert(offsetof(AVoxelBuilder2, bIsSubtractive) == 0x000880, "Member 'AVoxelBuilder2::bIsSubtractive' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, ExclusiveSubs) == 0x000888, "Member 'AVoxelBuilder2::ExclusiveSubs' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, WorldsImSubtractingFrom) == 0x000898, "Member 'AVoxelBuilder2::WorldsImSubtractingFrom' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, SelfSubShapes) == 0x0008A8, "Member 'AVoxelBuilder2::SelfSubShapes' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, SubtractiveMap) == 0x0008B8, "Member 'AVoxelBuilder2::SubtractiveMap' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, Priority) == 0x000908, "Member 'AVoxelBuilder2::Priority' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, ActorRoot) == 0x000910, "Member 'AVoxelBuilder2::ActorRoot' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, bSkipBake) == 0x000918, "Member 'AVoxelBuilder2::bSkipBake' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, bSpawnAsPhysicsWorld) == 0x000919, "Member 'AVoxelBuilder2::bSpawnAsPhysicsWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, bReportEventsToCampaign) == 0x00091A, "Member 'AVoxelBuilder2::bReportEventsToCampaign' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, CampaignID) == 0x00091C, "Member 'AVoxelBuilder2::CampaignID' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, bSpawnAsVoxelWorld) == 0x000924, "Member 'AVoxelBuilder2::bSpawnAsVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, bPackageBuilder) == 0x000925, "Member 'AVoxelBuilder2::bPackageBuilder' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, MyBrush) == 0x000930, "Member 'AVoxelBuilder2::MyBrush' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, TestMaterial) == 0x000938, "Member 'AVoxelBuilder2::TestMaterial' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, PreviewWorld) == 0x000940, "Member 'AVoxelBuilder2::PreviewWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, ManagedAssets) == 0x000948, "Member 'AVoxelBuilder2::ManagedAssets' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, ManagedActors) == 0x000958, "Member 'AVoxelBuilder2::ManagedActors' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, TurtleArrow) == 0x000968, "Member 'AVoxelBuilder2::TurtleArrow' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, bWorldsCreated) == 0x000970, "Member 'AVoxelBuilder2::bWorldsCreated' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, IndexWorldMap) == 0x000978, "Member 'AVoxelBuilder2::IndexWorldMap' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, PrimaryVoxelWorld) == 0x0009C8, "Member 'AVoxelBuilder2::PrimaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, SecondaryVoxelWorld) == 0x0009D0, "Member 'AVoxelBuilder2::SecondaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, TertiaryVoxelWorld) == 0x0009D8, "Member 'AVoxelBuilder2::TertiaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, QuaternaryVoxelWorld) == 0x0009E0, "Member 'AVoxelBuilder2::QuaternaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, CurrentGen) == 0x0009F8, "Member 'AVoxelBuilder2::CurrentGen' has a wrong offset!");
static_assert(offsetof(AVoxelBuilder2, ForWorld) == 0x000A00, "Member 'AVoxelBuilder2::ForWorld' has a wrong offset!");

// Class ThankYouVeryCool.BedBuilder
// 0x0060 (0x0A78 - 0x0A18)
class ABedBuilder final : public AVoxelBuilder2
{
public:
	class UVoxelDataAsset*                        FrameMaterial;                                     // 0x0A18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoxelDataAsset*                        MatMaterial;                                       // 0x0A20(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoxelDataAsset*                        PillowMat;                                         // 0x0A28(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             LegDims;                                           // 0x0A30(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             WholeDims;                                         // 0x0A3C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             FrameDims;                                         // 0x0A48(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             MattressDims;                                      // 0x0A54(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             HeadboardDims;                                     // 0x0A60(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             PillowDims;                                        // 0x0A6C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BedBuilder">();
	}
	static class ABedBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABedBuilder>();
	}
};
static_assert(alignof(ABedBuilder) == 0x000008, "Wrong alignment on ABedBuilder");
static_assert(sizeof(ABedBuilder) == 0x000A78, "Wrong size on ABedBuilder");
static_assert(offsetof(ABedBuilder, FrameMaterial) == 0x000A18, "Member 'ABedBuilder::FrameMaterial' has a wrong offset!");
static_assert(offsetof(ABedBuilder, MatMaterial) == 0x000A20, "Member 'ABedBuilder::MatMaterial' has a wrong offset!");
static_assert(offsetof(ABedBuilder, PillowMat) == 0x000A28, "Member 'ABedBuilder::PillowMat' has a wrong offset!");
static_assert(offsetof(ABedBuilder, LegDims) == 0x000A30, "Member 'ABedBuilder::LegDims' has a wrong offset!");
static_assert(offsetof(ABedBuilder, WholeDims) == 0x000A3C, "Member 'ABedBuilder::WholeDims' has a wrong offset!");
static_assert(offsetof(ABedBuilder, FrameDims) == 0x000A48, "Member 'ABedBuilder::FrameDims' has a wrong offset!");
static_assert(offsetof(ABedBuilder, MattressDims) == 0x000A54, "Member 'ABedBuilder::MattressDims' has a wrong offset!");
static_assert(offsetof(ABedBuilder, HeadboardDims) == 0x000A60, "Member 'ABedBuilder::HeadboardDims' has a wrong offset!");
static_assert(offsetof(ABedBuilder, PillowDims) == 0x000A6C, "Member 'ABedBuilder::PillowDims' has a wrong offset!");

// Class ThankYouVeryCool.PoolableActor
// 0x0018 (0x0288 - 0x0270)
class APoolableActor : public ATYVCActor
{
public:
	bool                                          bIsDormant;                                        // 0x0270(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APoolManager*                           PoolManager;                                       // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableActor">();
	}
	static class APoolableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoolableActor>();
	}
};
static_assert(alignof(APoolableActor) == 0x000008, "Wrong alignment on APoolableActor");
static_assert(sizeof(APoolableActor) == 0x000288, "Wrong size on APoolableActor");
static_assert(offsetof(APoolableActor, bIsDormant) == 0x000270, "Member 'APoolableActor::bIsDormant' has a wrong offset!");
static_assert(offsetof(APoolableActor, PoolManager) == 0x000278, "Member 'APoolableActor::PoolManager' has a wrong offset!");

// Class ThankYouVeryCool.BloodSplatter
// 0x0048 (0x02D0 - 0x0288)
class ABloodSplatter : public APoolableActor
{
public:
	class USphereComponent*                       CollisionComp;                                     // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynMat;                                            // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x4];                                      // 0x02A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BloodGrowStart;                                    // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BloodGrowGoal;                                     // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BloodGrowRate;                                     // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BloodGrowTime;                                     // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BC[0xC];                                      // 0x02BC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AImpactManager*                         ImpactManager;                                     // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodSplatter">();
	}
	static class ABloodSplatter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABloodSplatter>();
	}
};
static_assert(alignof(ABloodSplatter) == 0x000008, "Wrong alignment on ABloodSplatter");
static_assert(sizeof(ABloodSplatter) == 0x0002D0, "Wrong size on ABloodSplatter");
static_assert(offsetof(ABloodSplatter, CollisionComp) == 0x000288, "Member 'ABloodSplatter::CollisionComp' has a wrong offset!");
static_assert(offsetof(ABloodSplatter, StaticMesh) == 0x000290, "Member 'ABloodSplatter::StaticMesh' has a wrong offset!");
static_assert(offsetof(ABloodSplatter, ProjectileMovementComponent) == 0x000298, "Member 'ABloodSplatter::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(ABloodSplatter, DynMat) == 0x0002A0, "Member 'ABloodSplatter::DynMat' has a wrong offset!");
static_assert(offsetof(ABloodSplatter, BloodGrowStart) == 0x0002AC, "Member 'ABloodSplatter::BloodGrowStart' has a wrong offset!");
static_assert(offsetof(ABloodSplatter, BloodGrowGoal) == 0x0002B0, "Member 'ABloodSplatter::BloodGrowGoal' has a wrong offset!");
static_assert(offsetof(ABloodSplatter, BloodGrowRate) == 0x0002B4, "Member 'ABloodSplatter::BloodGrowRate' has a wrong offset!");
static_assert(offsetof(ABloodSplatter, BloodGrowTime) == 0x0002B8, "Member 'ABloodSplatter::BloodGrowTime' has a wrong offset!");
static_assert(offsetof(ABloodSplatter, ImpactManager) == 0x0002C8, "Member 'ABloodSplatter::ImpactManager' has a wrong offset!");

// Class ThankYouVeryCool.BorderVoxelWorld
// 0x0018 (0x0890 - 0x0878)
class ABorderVoxelWorld final : public AVoxelWorld
{
public:
	class UVoxelBasicMaterialCollection*          LookingGlassCollection;                            // 0x0878(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoxelBasicMaterialCollection*          NoLookingGlassCollection;                          // 0x0880(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_888[0x8];                                      // 0x0888(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BorderVoxelWorld">();
	}
	static class ABorderVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABorderVoxelWorld>();
	}
};
static_assert(alignof(ABorderVoxelWorld) == 0x000008, "Wrong alignment on ABorderVoxelWorld");
static_assert(sizeof(ABorderVoxelWorld) == 0x000890, "Wrong size on ABorderVoxelWorld");
static_assert(offsetof(ABorderVoxelWorld, LookingGlassCollection) == 0x000878, "Member 'ABorderVoxelWorld::LookingGlassCollection' has a wrong offset!");
static_assert(offsetof(ABorderVoxelWorld, NoLookingGlassCollection) == 0x000880, "Member 'ABorderVoxelWorld::NoLookingGlassCollection' has a wrong offset!");

// Class ThankYouVeryCool.SquadTask_Base
// 0x0008 (0x0078 - 0x0070)
class USquadTask_Base : public UBTTaskNode
{
public:
	struct FGameplayTag                           OrderTag;                                          // 0x0070(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UBlackboardComponent* GetBB(class UBehaviorTreeComponent* BTComp);
	class USquadBT* GetSquadBT(class UBehaviorTreeComponent* BTComp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadTask_Base">();
	}
	static class USquadTask_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadTask_Base>();
	}
};
static_assert(alignof(USquadTask_Base) == 0x000008, "Wrong alignment on USquadTask_Base");
static_assert(sizeof(USquadTask_Base) == 0x000078, "Wrong size on USquadTask_Base");
static_assert(offsetof(USquadTask_Base, OrderTag) == 0x000070, "Member 'USquadTask_Base::OrderTag' has a wrong offset!");

// Class ThankYouVeryCool.BT_GroupSearch
// 0x0080 (0x00F8 - 0x0078)
class UBT_GroupSearch final : public USquadTask_Base
{
public:
	float                                         DistanceBetweenPositions;                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 ToLocationKey;                                     // 0x0080(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 LeaderKey;                                         // 0x00A8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          BasicSearchLeaderBT;                               // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          BasicSearchFollowerBT;                             // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AFormationPosition*>             FormationActors;                                   // 0x00E0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	EFormationShape                               FormationShape;                                    // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_GroupSearch">();
	}
	static class UBT_GroupSearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_GroupSearch>();
	}
};
static_assert(alignof(UBT_GroupSearch) == 0x000008, "Wrong alignment on UBT_GroupSearch");
static_assert(sizeof(UBT_GroupSearch) == 0x0000F8, "Wrong size on UBT_GroupSearch");
static_assert(offsetof(UBT_GroupSearch, DistanceBetweenPositions) == 0x000078, "Member 'UBT_GroupSearch::DistanceBetweenPositions' has a wrong offset!");
static_assert(offsetof(UBT_GroupSearch, ToLocationKey) == 0x000080, "Member 'UBT_GroupSearch::ToLocationKey' has a wrong offset!");
static_assert(offsetof(UBT_GroupSearch, LeaderKey) == 0x0000A8, "Member 'UBT_GroupSearch::LeaderKey' has a wrong offset!");
static_assert(offsetof(UBT_GroupSearch, BasicSearchLeaderBT) == 0x0000D0, "Member 'UBT_GroupSearch::BasicSearchLeaderBT' has a wrong offset!");
static_assert(offsetof(UBT_GroupSearch, BasicSearchFollowerBT) == 0x0000D8, "Member 'UBT_GroupSearch::BasicSearchFollowerBT' has a wrong offset!");
static_assert(offsetof(UBT_GroupSearch, FormationActors) == 0x0000E0, "Member 'UBT_GroupSearch::FormationActors' has a wrong offset!");
static_assert(offsetof(UBT_GroupSearch, FormationShape) == 0x0000F0, "Member 'UBT_GroupSearch::FormationShape' has a wrong offset!");

// Class ThankYouVeryCool.BTD_AbortIfCoverExposed
// 0x00B8 (0x0120 - 0x0068)
class UBTD_AbortIfCoverExposed final : public UBTDecorator
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 EnemyKey;                                          // 0x0070(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 CoverLocationKey;                                  // 0x0098(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 CoverNormalKey;                                    // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 ShowDebugKey;                                      // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	float                                         TickInterval;                                      // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DebugTime;                                         // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DotThreshold;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_AbortIfCoverExposed">();
	}
	static class UBTD_AbortIfCoverExposed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_AbortIfCoverExposed>();
	}
};
static_assert(alignof(UBTD_AbortIfCoverExposed) == 0x000008, "Wrong alignment on UBTD_AbortIfCoverExposed");
static_assert(sizeof(UBTD_AbortIfCoverExposed) == 0x000120, "Wrong size on UBTD_AbortIfCoverExposed");
static_assert(offsetof(UBTD_AbortIfCoverExposed, EnemyKey) == 0x000070, "Member 'UBTD_AbortIfCoverExposed::EnemyKey' has a wrong offset!");
static_assert(offsetof(UBTD_AbortIfCoverExposed, CoverLocationKey) == 0x000098, "Member 'UBTD_AbortIfCoverExposed::CoverLocationKey' has a wrong offset!");
static_assert(offsetof(UBTD_AbortIfCoverExposed, CoverNormalKey) == 0x0000C0, "Member 'UBTD_AbortIfCoverExposed::CoverNormalKey' has a wrong offset!");
static_assert(offsetof(UBTD_AbortIfCoverExposed, ShowDebugKey) == 0x0000E8, "Member 'UBTD_AbortIfCoverExposed::ShowDebugKey' has a wrong offset!");
static_assert(offsetof(UBTD_AbortIfCoverExposed, TickInterval) == 0x000110, "Member 'UBTD_AbortIfCoverExposed::TickInterval' has a wrong offset!");
static_assert(offsetof(UBTD_AbortIfCoverExposed, DebugTime) == 0x000114, "Member 'UBTD_AbortIfCoverExposed::DebugTime' has a wrong offset!");
static_assert(offsetof(UBTD_AbortIfCoverExposed, DotThreshold) == 0x000118, "Member 'UBTD_AbortIfCoverExposed::DotThreshold' has a wrong offset!");

// Class ThankYouVeryCool.BTS_MaybeReload
// 0x00C8 (0x0138 - 0x0070)
class UBTS_MaybeReload final : public UBTService
{
public:
	struct FBlackboardKeySelector                 CurrentWeaponKey;                                  // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 IsReloadingKey;                                    // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 IsShootingKey;                                     // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 ShouldReloadKey;                                   // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 IsReactingToHitKey;                                // 0x0110(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_MaybeReload">();
	}
	static class UBTS_MaybeReload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_MaybeReload>();
	}
};
static_assert(alignof(UBTS_MaybeReload) == 0x000008, "Wrong alignment on UBTS_MaybeReload");
static_assert(sizeof(UBTS_MaybeReload) == 0x000138, "Wrong size on UBTS_MaybeReload");
static_assert(offsetof(UBTS_MaybeReload, CurrentWeaponKey) == 0x000070, "Member 'UBTS_MaybeReload::CurrentWeaponKey' has a wrong offset!");
static_assert(offsetof(UBTS_MaybeReload, IsReloadingKey) == 0x000098, "Member 'UBTS_MaybeReload::IsReloadingKey' has a wrong offset!");
static_assert(offsetof(UBTS_MaybeReload, IsShootingKey) == 0x0000C0, "Member 'UBTS_MaybeReload::IsShootingKey' has a wrong offset!");
static_assert(offsetof(UBTS_MaybeReload, ShouldReloadKey) == 0x0000E8, "Member 'UBTS_MaybeReload::ShouldReloadKey' has a wrong offset!");
static_assert(offsetof(UBTS_MaybeReload, IsReactingToHitKey) == 0x000110, "Member 'UBTS_MaybeReload::IsReactingToHitKey' has a wrong offset!");

// Class ThankYouVeryCool.BTS_NPCGatherInfo
// 0x0140 (0x01D8 - 0x0098)
class UBTS_NPCGatherInfo final : public UBTService_BlackboardBase
{
public:
	struct FBlackboardKeySelector                 IsArmedKey;                                        // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 HasSidearmKey;                                     // 0x00C0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 CurrentWeaponKey;                                  // 0x00E8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 bGunEmptyKey;                                      // 0x0110(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 CanShootKey;                                       // 0x0138(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 CanReloadKey;                                      // 0x0160(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 PositionModelKey;                                  // 0x0188(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 PositionModelPositionKey;                          // 0x01B0(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_NPCGatherInfo">();
	}
	static class UBTS_NPCGatherInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_NPCGatherInfo>();
	}
};
static_assert(alignof(UBTS_NPCGatherInfo) == 0x000008, "Wrong alignment on UBTS_NPCGatherInfo");
static_assert(sizeof(UBTS_NPCGatherInfo) == 0x0001D8, "Wrong size on UBTS_NPCGatherInfo");
static_assert(offsetof(UBTS_NPCGatherInfo, IsArmedKey) == 0x000098, "Member 'UBTS_NPCGatherInfo::IsArmedKey' has a wrong offset!");
static_assert(offsetof(UBTS_NPCGatherInfo, HasSidearmKey) == 0x0000C0, "Member 'UBTS_NPCGatherInfo::HasSidearmKey' has a wrong offset!");
static_assert(offsetof(UBTS_NPCGatherInfo, CurrentWeaponKey) == 0x0000E8, "Member 'UBTS_NPCGatherInfo::CurrentWeaponKey' has a wrong offset!");
static_assert(offsetof(UBTS_NPCGatherInfo, bGunEmptyKey) == 0x000110, "Member 'UBTS_NPCGatherInfo::bGunEmptyKey' has a wrong offset!");
static_assert(offsetof(UBTS_NPCGatherInfo, CanShootKey) == 0x000138, "Member 'UBTS_NPCGatherInfo::CanShootKey' has a wrong offset!");
static_assert(offsetof(UBTS_NPCGatherInfo, CanReloadKey) == 0x000160, "Member 'UBTS_NPCGatherInfo::CanReloadKey' has a wrong offset!");
static_assert(offsetof(UBTS_NPCGatherInfo, PositionModelKey) == 0x000188, "Member 'UBTS_NPCGatherInfo::PositionModelKey' has a wrong offset!");
static_assert(offsetof(UBTS_NPCGatherInfo, PositionModelPositionKey) == 0x0001B0, "Member 'UBTS_NPCGatherInfo::PositionModelPositionKey' has a wrong offset!");

// Class ThankYouVeryCool.BTS_OperateWeapon
// 0x01D8 (0x0248 - 0x0070)
class UBTS_OperateWeapon : public UBTService
{
public:
	struct FBlackboardKeySelector                 CanShootKey;                                       // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 IsShootingKey;                                     // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 IsReloadingKey;                                    // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 IsReactingToHitKey;                                // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 WeaponEmptyKey;                                    // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 CanReloadKey;                                      // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 CurrentWeaponKey;                                  // 0x0160(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 CurrentTargetKey;                                  // 0x0188(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ShootLeanStandingLeft;                             // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ShootLeanStandingRight;                            // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ShootOutOfCover;                                   // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadStandingLeft;                                // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadStandingRight;                               // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadOutOfCoverRifle;                             // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadOutOfCoverPistol;                            // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ReloadWithShield;                                  // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F0[0x8];                                      // 0x01F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackboardComponent*                   MyBB;                                              // 0x01F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200[0x10];                                     // 0x0200(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDoingBurst;                                       // 0x0210(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponBase*                            HeldWeapon;                                        // 0x0218(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentTarget;                                     // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANPCController*                         NPCController;                                     // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ANPC*                                   NPC;                                               // 0x0230(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNPCAnimInstance*                       NPCAnimInstance;                                   // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SemiFullDistance;                                  // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BurstShot(float BurstLength, float CoolDownTime);
	void MagDump();
	void ReloadComplete(class UAnimMontage* AnimMontage, bool bInterrupted);
	void SingleShot(float CoolDownTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_OperateWeapon">();
	}
	static class UBTS_OperateWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_OperateWeapon>();
	}
};
static_assert(alignof(UBTS_OperateWeapon) == 0x000008, "Wrong alignment on UBTS_OperateWeapon");
static_assert(sizeof(UBTS_OperateWeapon) == 0x000248, "Wrong size on UBTS_OperateWeapon");
static_assert(offsetof(UBTS_OperateWeapon, CanShootKey) == 0x000070, "Member 'UBTS_OperateWeapon::CanShootKey' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, IsShootingKey) == 0x000098, "Member 'UBTS_OperateWeapon::IsShootingKey' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, IsReloadingKey) == 0x0000C0, "Member 'UBTS_OperateWeapon::IsReloadingKey' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, IsReactingToHitKey) == 0x0000E8, "Member 'UBTS_OperateWeapon::IsReactingToHitKey' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, WeaponEmptyKey) == 0x000110, "Member 'UBTS_OperateWeapon::WeaponEmptyKey' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, CanReloadKey) == 0x000138, "Member 'UBTS_OperateWeapon::CanReloadKey' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, CurrentWeaponKey) == 0x000160, "Member 'UBTS_OperateWeapon::CurrentWeaponKey' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, CurrentTargetKey) == 0x000188, "Member 'UBTS_OperateWeapon::CurrentTargetKey' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, ShootLeanStandingLeft) == 0x0001B0, "Member 'UBTS_OperateWeapon::ShootLeanStandingLeft' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, ShootLeanStandingRight) == 0x0001B8, "Member 'UBTS_OperateWeapon::ShootLeanStandingRight' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, ShootOutOfCover) == 0x0001C0, "Member 'UBTS_OperateWeapon::ShootOutOfCover' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, ReloadStandingLeft) == 0x0001C8, "Member 'UBTS_OperateWeapon::ReloadStandingLeft' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, ReloadStandingRight) == 0x0001D0, "Member 'UBTS_OperateWeapon::ReloadStandingRight' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, ReloadOutOfCoverRifle) == 0x0001D8, "Member 'UBTS_OperateWeapon::ReloadOutOfCoverRifle' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, ReloadOutOfCoverPistol) == 0x0001E0, "Member 'UBTS_OperateWeapon::ReloadOutOfCoverPistol' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, ReloadWithShield) == 0x0001E8, "Member 'UBTS_OperateWeapon::ReloadWithShield' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, MyBB) == 0x0001F8, "Member 'UBTS_OperateWeapon::MyBB' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, bDoingBurst) == 0x000210, "Member 'UBTS_OperateWeapon::bDoingBurst' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, HeldWeapon) == 0x000218, "Member 'UBTS_OperateWeapon::HeldWeapon' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, CurrentTarget) == 0x000220, "Member 'UBTS_OperateWeapon::CurrentTarget' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, NPCController) == 0x000228, "Member 'UBTS_OperateWeapon::NPCController' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, NPC) == 0x000230, "Member 'UBTS_OperateWeapon::NPC' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, NPCAnimInstance) == 0x000238, "Member 'UBTS_OperateWeapon::NPCAnimInstance' has a wrong offset!");
static_assert(offsetof(UBTS_OperateWeapon, SemiFullDistance) == 0x000244, "Member 'UBTS_OperateWeapon::SemiFullDistance' has a wrong offset!");

// Class ThankYouVeryCool.BTS_UpdatePuppetMasterData
// 0x0028 (0x0098 - 0x0070)
class UBTS_UpdatePuppetMasterData final : public UBTService
{
public:
	struct FBlackboardKeySelector                 LocationKey;                                       // 0x0070(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTS_UpdatePuppetMasterData">();
	}
	static class UBTS_UpdatePuppetMasterData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTS_UpdatePuppetMasterData>();
	}
};
static_assert(alignof(UBTS_UpdatePuppetMasterData) == 0x000008, "Wrong alignment on UBTS_UpdatePuppetMasterData");
static_assert(sizeof(UBTS_UpdatePuppetMasterData) == 0x000098, "Wrong size on UBTS_UpdatePuppetMasterData");
static_assert(offsetof(UBTS_UpdatePuppetMasterData, LocationKey) == 0x000070, "Member 'UBTS_UpdatePuppetMasterData::LocationKey' has a wrong offset!");

// Class ThankYouVeryCool.BTT_MemberReportOrder
// 0x0008 (0x0078 - 0x0070)
class UBTT_MemberReportOrder final : public UBTTaskNode
{
public:
	bool                                          bSuccess;                                          // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_MemberReportOrder">();
	}
	static class UBTT_MemberReportOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_MemberReportOrder>();
	}
};
static_assert(alignof(UBTT_MemberReportOrder) == 0x000008, "Wrong alignment on UBTT_MemberReportOrder");
static_assert(sizeof(UBTT_MemberReportOrder) == 0x000078, "Wrong size on UBTT_MemberReportOrder");
static_assert(offsetof(UBTT_MemberReportOrder, bSuccess) == 0x000070, "Member 'UBTT_MemberReportOrder::bSuccess' has a wrong offset!");

// Class ThankYouVeryCool.BTTask_DrawSidearm
// 0x0010 (0x0080 - 0x0070)
class UBTTask_DrawSidearm final : public UBTTaskNode
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DrawMontage;                                       // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DrawComplete(class UAnimMontage* AnimMontage, bool bInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_DrawSidearm">();
	}
	static class UBTTask_DrawSidearm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_DrawSidearm>();
	}
};
static_assert(alignof(UBTTask_DrawSidearm) == 0x000008, "Wrong alignment on UBTTask_DrawSidearm");
static_assert(sizeof(UBTTask_DrawSidearm) == 0x000080, "Wrong size on UBTTask_DrawSidearm");
static_assert(offsetof(UBTTask_DrawSidearm, DrawMontage) == 0x000078, "Member 'UBTTask_DrawSidearm::DrawMontage' has a wrong offset!");

// Class ThankYouVeryCool.BTTask_EnterCover
// 0x0148 (0x01B8 - 0x0070)
class UBTTask_EnterCover final : public UBTTaskNode
{
public:
	bool                                          bEnterInLeanState;                                 // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 NormalKey;                                         // 0x0078(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 LeanDirectionKey;                                  // 0x00A0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 UnderFireKey;                                      // 0x00C8(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 bCoverCrouchedKey;                                 // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 CoverLocationKey;                                  // 0x0118(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 LeanLocationKey;                                   // 0x0140(0x0028)(Edit, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 IsReloadingKey;                                    // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 GunEmptyKey;                                       // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_EnterCover">();
	}
	static class UBTTask_EnterCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_EnterCover>();
	}
};
static_assert(alignof(UBTTask_EnterCover) == 0x000008, "Wrong alignment on UBTTask_EnterCover");
static_assert(sizeof(UBTTask_EnterCover) == 0x0001B8, "Wrong size on UBTTask_EnterCover");
static_assert(offsetof(UBTTask_EnterCover, bEnterInLeanState) == 0x000070, "Member 'UBTTask_EnterCover::bEnterInLeanState' has a wrong offset!");
static_assert(offsetof(UBTTask_EnterCover, NormalKey) == 0x000078, "Member 'UBTTask_EnterCover::NormalKey' has a wrong offset!");
static_assert(offsetof(UBTTask_EnterCover, LeanDirectionKey) == 0x0000A0, "Member 'UBTTask_EnterCover::LeanDirectionKey' has a wrong offset!");
static_assert(offsetof(UBTTask_EnterCover, UnderFireKey) == 0x0000C8, "Member 'UBTTask_EnterCover::UnderFireKey' has a wrong offset!");
static_assert(offsetof(UBTTask_EnterCover, bCoverCrouchedKey) == 0x0000F0, "Member 'UBTTask_EnterCover::bCoverCrouchedKey' has a wrong offset!");
static_assert(offsetof(UBTTask_EnterCover, CoverLocationKey) == 0x000118, "Member 'UBTTask_EnterCover::CoverLocationKey' has a wrong offset!");
static_assert(offsetof(UBTTask_EnterCover, LeanLocationKey) == 0x000140, "Member 'UBTTask_EnterCover::LeanLocationKey' has a wrong offset!");
static_assert(offsetof(UBTTask_EnterCover, IsReloadingKey) == 0x000168, "Member 'UBTTask_EnterCover::IsReloadingKey' has a wrong offset!");
static_assert(offsetof(UBTTask_EnterCover, GunEmptyKey) == 0x000190, "Member 'UBTTask_EnterCover::GunEmptyKey' has a wrong offset!");

// Class ThankYouVeryCool.BTTask_MakeSquadIdle
// 0x0008 (0x0080 - 0x0078)
class UBTTask_MakeSquadIdle final : public USquadTask_Base
{
public:
	class UBehaviorTree*                          IdleTree;                                          // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MakeSquadIdle">();
	}
	static class UBTTask_MakeSquadIdle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MakeSquadIdle>();
	}
};
static_assert(alignof(UBTTask_MakeSquadIdle) == 0x000008, "Wrong alignment on UBTTask_MakeSquadIdle");
static_assert(sizeof(UBTTask_MakeSquadIdle) == 0x000080, "Wrong size on UBTTask_MakeSquadIdle");
static_assert(offsetof(UBTTask_MakeSquadIdle, IdleTree) == 0x000078, "Member 'UBTTask_MakeSquadIdle::IdleTree' has a wrong offset!");

// Class ThankYouVeryCool.BuildingBoundsTrigger
// 0x0000 (0x0258 - 0x0258)
class ABuildingBoundsTrigger final : public ATriggerVolume
{
public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuildingBoundsTrigger">();
	}
	static class ABuildingBoundsTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABuildingBoundsTrigger>();
	}
};
static_assert(alignof(ABuildingBoundsTrigger) == 0x000008, "Wrong alignment on ABuildingBoundsTrigger");
static_assert(sizeof(ABuildingBoundsTrigger) == 0x000258, "Wrong size on ABuildingBoundsTrigger");

// Class ThankYouVeryCool.BulletTrace
// 0x0050 (0x02D8 - 0x0288)
class ABulletTrace : public APoolableActor
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynMat;                                            // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0xC];                                      // 0x0298(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FadeTime;                                          // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0xC];                                      // 0x02A8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Speed;                                             // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TickFade();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulletTrace">();
	}
	static class ABulletTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABulletTrace>();
	}
};
static_assert(alignof(ABulletTrace) == 0x000008, "Wrong alignment on ABulletTrace");
static_assert(sizeof(ABulletTrace) == 0x0002D8, "Wrong size on ABulletTrace");
static_assert(offsetof(ABulletTrace, StaticMesh) == 0x000288, "Member 'ABulletTrace::StaticMesh' has a wrong offset!");
static_assert(offsetof(ABulletTrace, DynMat) == 0x000290, "Member 'ABulletTrace::DynMat' has a wrong offset!");
static_assert(offsetof(ABulletTrace, FadeTime) == 0x0002A4, "Member 'ABulletTrace::FadeTime' has a wrong offset!");
static_assert(offsetof(ABulletTrace, Speed) == 0x0002B4, "Member 'ABulletTrace::Speed' has a wrong offset!");

// Class ThankYouVeryCool.CameraSplineManager
// 0x0008 (0x0228 - 0x0220)
class ACameraSplineManager final : public AActor
{
public:
	class USplineComponent*                       DemoSpline;                                        // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraSplineManager">();
	}
	static class ACameraSplineManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACameraSplineManager>();
	}
};
static_assert(alignof(ACameraSplineManager) == 0x000008, "Wrong alignment on ACameraSplineManager");
static_assert(sizeof(ACameraSplineManager) == 0x000228, "Wrong size on ACameraSplineManager");
static_assert(offsetof(ACameraSplineManager, DemoSpline) == 0x000220, "Member 'ACameraSplineManager::DemoSpline' has a wrong offset!");

// Class ThankYouVeryCool.CampaignDataAsset
// 0x0078 (0x00A8 - 0x0030)
class UCampaignDataAsset : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   ChapterClass;                                      // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                LevelScreen;                                       // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0080(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   WorldID;                                           // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OrderIndex;                                        // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignDataAsset">();
	}
	static class UCampaignDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCampaignDataAsset>();
	}
};
static_assert(alignof(UCampaignDataAsset) == 0x000008, "Wrong alignment on UCampaignDataAsset");
static_assert(sizeof(UCampaignDataAsset) == 0x0000A8, "Wrong size on UCampaignDataAsset");
static_assert(offsetof(UCampaignDataAsset, ChapterClass) == 0x000030, "Member 'UCampaignDataAsset::ChapterClass' has a wrong offset!");
static_assert(offsetof(UCampaignDataAsset, LevelScreen) == 0x000058, "Member 'UCampaignDataAsset::LevelScreen' has a wrong offset!");
static_assert(offsetof(UCampaignDataAsset, DisplayName) == 0x000080, "Member 'UCampaignDataAsset::DisplayName' has a wrong offset!");
static_assert(offsetof(UCampaignDataAsset, WorldID) == 0x000098, "Member 'UCampaignDataAsset::WorldID' has a wrong offset!");
static_assert(offsetof(UCampaignDataAsset, OrderIndex) == 0x0000A0, "Member 'UCampaignDataAsset::OrderIndex' has a wrong offset!");

// Class ThankYouVeryCool.ThankYouVeryCoolHUD
// 0x0010 (0x0320 - 0x0310)
class AThankYouVeryCoolHUD : public AHUD
{
public:
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             CrosshairTexture;                                  // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThankYouVeryCoolHUD">();
	}
	static class AThankYouVeryCoolHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThankYouVeryCoolHUD>();
	}
};
static_assert(alignof(AThankYouVeryCoolHUD) == 0x000008, "Wrong alignment on AThankYouVeryCoolHUD");
static_assert(sizeof(AThankYouVeryCoolHUD) == 0x000320, "Wrong size on AThankYouVeryCoolHUD");
static_assert(offsetof(AThankYouVeryCoolHUD, CrosshairTexture) == 0x000318, "Member 'AThankYouVeryCoolHUD::CrosshairTexture' has a wrong offset!");

// Class ThankYouVeryCool.CampaignIDInterface
// 0x0000 (0x0028 - 0x0028)
class ICampaignIDInterface final : public IInterface
{
public:
	class FName GetID();
	void SetHighlighted(bool bIsHighlighted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignIDInterface">();
	}
	static class ICampaignIDInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICampaignIDInterface>();
	}
};
static_assert(alignof(ICampaignIDInterface) == 0x000008, "Wrong alignment on ICampaignIDInterface");
static_assert(sizeof(ICampaignIDInterface) == 0x000028, "Wrong size on ICampaignIDInterface");

// Class ThankYouVeryCool.CampaignManager
// 0x00F8 (0x0318 - 0x0220)
class ACampaignManager : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPostCutscene;                                    // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TSubclassOf<class UTextDisplayWidget>         TextDisplayWidgetclass;                            // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTextDisplayWidget>         TutorialTextDisplayWidgetclass;                    // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_UnloadNode*               UnloadNodeTask;                                    // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x38];                                     // 0x0250(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AChapter>                   NextChapterToLoad;                                 // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_LoadChapter*              LoadChapterTask;                                   // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_LoadNode*                 LoadNodeTask;                                      // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AWorkshopChapter>           WorkshopChapterClass;                              // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInCampaignSkipMode;                             // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTasksComponent*                GameplayTasksComponent;                            // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_SaveChapter*              NewLevelSaveTask;                                  // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTYVCSaveController*                    TYVCSaveController;                                // 0x02D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelStreaming*                        OverworldLevel;                                    // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AChapter*                               CurrentChapter;                                    // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCampaignDataAsset*                     CurrentChapterAsset;                               // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomCampaign*                        CurrentCustomCampaign;                             // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x4];                                      // 0x02F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPlayingCustomCampaign;                          // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD[0x3];                                      // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AOverworldManager*                      OverworldManager;                                  // 0x0300(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IGameplayTaskOwnerInterface> SelfInterface;                                     // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void AttachArmCannon();
	void CleanupEdenMap();
	void DoCompassReveal();
	void DoEdenMapThing(class FName From, class FName To, const class FText& DestinationText);
	void EndCampaignLevel(TSoftClassPtr<class UClass> NextChapter);
	void FadeAndStopGameplay();
	void FinishNewLevelSave();
	class AChapter* GetCurrentChapter();
	class APlayerCharacter* GetNewPlayer(const struct FTransform& AtTransform, TSubclassOf<class AWeaponBase> WithWeapon, int32 MagCount);
	void NodeLoadDuringGameplayDone(const struct FTYVCNodeMemory& InNodeMemory);
	void NodeUnloaded(const TArray<class FName>& NodeName);
	void NotifyActorDestroyed(class FName ActorId);
	void NotifyActorTookDamage(class FName ActorId, float Damage);
	void NotifyCinematicChargeEnd();
	void NotifyCustomEvent(class FName EventName);
	void NotifyFadeOutOver();
	void PickupCallPressed();
	void PlayCutscene(class UFileMediaSource* InSource);
	void PlayerRequestedNextChapter();
	void PossessPlayer();
	void RequestFadeIn();
	void RequestFadeOut();
	void RequestKillPlayer();
	void RequestLevelLoad(class FName LevelName);
	void RequestLevelStart();
	void RequestReturnToMainMenu();
	void SaveCampaign(TSoftClassPtr<class UClass> OnChapter, EDifficulty ForDifficulty, class UCampaignDataAsset* LoadedNextAsset);
	void SetCustomEmmisiveColor(int32 Channel, const struct FColor& InColor);
	void SetPlayFDVid(bool bShouldPlay);
	void SpawnNPCDuringChapter(TSubclassOf<class ANPC> ClassToSpawn, const struct FTransform& SpawnTransform, class ACampaignMarker* MyMarker, bool bSpawnUnleased);
	void StartChapterObject(TSubclassOf<class UCampaignDataAsset> InData, EDifficulty Difficulty, bool bIsSkip);
	void StartChapterObjectWorkshop(class UArcadeLevelAssetWorkshop* InAsset, EDifficulty Difficulty, bool bIsSkip);
	void StartCustomCampaign(class UCustomCampaign* InAsset, EDifficulty Difficulty, bool bIsSkip);
	void UnloadFadeOutOver();
	void UnloadOver(class FName UnloadedName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignManager">();
	}
	static class ACampaignManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampaignManager>();
	}
};
static_assert(alignof(ACampaignManager) == 0x000008, "Wrong alignment on ACampaignManager");
static_assert(sizeof(ACampaignManager) == 0x000318, "Wrong size on ACampaignManager");
static_assert(offsetof(ACampaignManager, OnPostCutscene) == 0x000228, "Member 'ACampaignManager::OnPostCutscene' has a wrong offset!");
static_assert(offsetof(ACampaignManager, TextDisplayWidgetclass) == 0x000238, "Member 'ACampaignManager::TextDisplayWidgetclass' has a wrong offset!");
static_assert(offsetof(ACampaignManager, TutorialTextDisplayWidgetclass) == 0x000240, "Member 'ACampaignManager::TutorialTextDisplayWidgetclass' has a wrong offset!");
static_assert(offsetof(ACampaignManager, UnloadNodeTask) == 0x000248, "Member 'ACampaignManager::UnloadNodeTask' has a wrong offset!");
static_assert(offsetof(ACampaignManager, NextChapterToLoad) == 0x000288, "Member 'ACampaignManager::NextChapterToLoad' has a wrong offset!");
static_assert(offsetof(ACampaignManager, LoadChapterTask) == 0x000290, "Member 'ACampaignManager::LoadChapterTask' has a wrong offset!");
static_assert(offsetof(ACampaignManager, LoadNodeTask) == 0x000298, "Member 'ACampaignManager::LoadNodeTask' has a wrong offset!");
static_assert(offsetof(ACampaignManager, WorkshopChapterClass) == 0x0002A8, "Member 'ACampaignManager::WorkshopChapterClass' has a wrong offset!");
static_assert(offsetof(ACampaignManager, bIsInCampaignSkipMode) == 0x0002B0, "Member 'ACampaignManager::bIsInCampaignSkipMode' has a wrong offset!");
static_assert(offsetof(ACampaignManager, GameplayTasksComponent) == 0x0002B8, "Member 'ACampaignManager::GameplayTasksComponent' has a wrong offset!");
static_assert(offsetof(ACampaignManager, TYVCGameMode) == 0x0002C0, "Member 'ACampaignManager::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ACampaignManager, NewLevelSaveTask) == 0x0002C8, "Member 'ACampaignManager::NewLevelSaveTask' has a wrong offset!");
static_assert(offsetof(ACampaignManager, TYVCSaveController) == 0x0002D0, "Member 'ACampaignManager::TYVCSaveController' has a wrong offset!");
static_assert(offsetof(ACampaignManager, OverworldLevel) == 0x0002D8, "Member 'ACampaignManager::OverworldLevel' has a wrong offset!");
static_assert(offsetof(ACampaignManager, CurrentChapter) == 0x0002E0, "Member 'ACampaignManager::CurrentChapter' has a wrong offset!");
static_assert(offsetof(ACampaignManager, CurrentChapterAsset) == 0x0002E8, "Member 'ACampaignManager::CurrentChapterAsset' has a wrong offset!");
static_assert(offsetof(ACampaignManager, CurrentCustomCampaign) == 0x0002F0, "Member 'ACampaignManager::CurrentCustomCampaign' has a wrong offset!");
static_assert(offsetof(ACampaignManager, bIsPlayingCustomCampaign) == 0x0002FC, "Member 'ACampaignManager::bIsPlayingCustomCampaign' has a wrong offset!");
static_assert(offsetof(ACampaignManager, OverworldManager) == 0x000300, "Member 'ACampaignManager::OverworldManager' has a wrong offset!");
static_assert(offsetof(ACampaignManager, SelfInterface) == 0x000308, "Member 'ACampaignManager::SelfInterface' has a wrong offset!");

// Class ThankYouVeryCool.SquadNavArea
// 0x0000 (0x0048 - 0x0048)
class USquadNavArea final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadNavArea">();
	}
	static class USquadNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadNavArea>();
	}
};
static_assert(alignof(USquadNavArea) == 0x000008, "Wrong alignment on USquadNavArea");
static_assert(sizeof(USquadNavArea) == 0x000048, "Wrong size on USquadNavArea");

// Class ThankYouVeryCool.CampaignMarker
// 0x0058 (0x0278 - 0x0220)
class ACampaignMarker : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      CapsuleComp;                                       // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        ArrowComp;                                         // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CampaignID;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForNPCSpawn;                                   // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ANPC>>               NPCsToSpawn;                                       // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundToPlay;                                       // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipSpawnFX;                                      // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoManualSpawn(bool bForceSpecial, bool bSkipFX);
	void EditorModeChanged_Implementation(EEditMode NewMode);
	TSubclassOf<class ANPC> GetRandomSpecialType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignMarker">();
	}
	static class ACampaignMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampaignMarker>();
	}
};
static_assert(alignof(ACampaignMarker) == 0x000008, "Wrong alignment on ACampaignMarker");
static_assert(sizeof(ACampaignMarker) == 0x000278, "Wrong size on ACampaignMarker");
static_assert(offsetof(ACampaignMarker, CapsuleComp) == 0x000230, "Member 'ACampaignMarker::CapsuleComp' has a wrong offset!");
static_assert(offsetof(ACampaignMarker, ArrowComp) == 0x000238, "Member 'ACampaignMarker::ArrowComp' has a wrong offset!");
static_assert(offsetof(ACampaignMarker, CampaignID) == 0x000240, "Member 'ACampaignMarker::CampaignID' has a wrong offset!");
static_assert(offsetof(ACampaignMarker, bUseForNPCSpawn) == 0x000248, "Member 'ACampaignMarker::bUseForNPCSpawn' has a wrong offset!");
static_assert(offsetof(ACampaignMarker, NPCsToSpawn) == 0x000250, "Member 'ACampaignMarker::NPCsToSpawn' has a wrong offset!");
static_assert(offsetof(ACampaignMarker, SoundToPlay) == 0x000268, "Member 'ACampaignMarker::SoundToPlay' has a wrong offset!");
static_assert(offsetof(ACampaignMarker, bSkipSpawnFX) == 0x000270, "Member 'ACampaignMarker::bSkipSpawnFX' has a wrong offset!");

// Class ThankYouVeryCool.CampaignTriggerVolume
// 0x0098 (0x02B8 - 0x0220)
class ACampaignTriggerVolume : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   StaticMeshViz;                                     // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundToPlay;                                       // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CampaignID;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MyDims;                                            // 0x0250(0x000C)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteractable;                                   // 0x025C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     TMat;                                              // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MMat;                                              // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0270(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACampaignManager*                       CampaignManager;                                   // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKillBox;                                          // 0x0280(0x0001)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBeginBeenTriggered;                            // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasEndBeenTriggered;                              // 0x0282(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggerOnce;                                      // 0x0283(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForNavBlocking;                                // 0x0284(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlaySoundOnGoalComplete;                          // 0x0285(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_286[0x2];                                      // 0x0286(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAction>                        Actions;                                           // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<struct FAction>                        ActionsIndependent;                                // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   AttachPoint;                                       // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x02B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireEventsOnceEvenIfHasID;                        // 0x02B1(0x0001)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EditorModeChanged_Implementation(EEditMode NewMode);
	void ForceLevelReady();
	TArray<class ANPC*> GetNPCsWithin();
	void LevelReady();
	void LevelReset();
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
	void SetDims(const struct FVector& InDims);
	void SetHighlightedHUD(bool bHighlighted);
	void SetInteractable(bool bInteractable);
	void SetNavBlocking(bool bNavBlocking);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CampaignTriggerVolume">();
	}
	static class ACampaignTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACampaignTriggerVolume>();
	}
};
static_assert(alignof(ACampaignTriggerVolume) == 0x000008, "Wrong alignment on ACampaignTriggerVolume");
static_assert(sizeof(ACampaignTriggerVolume) == 0x0002B8, "Wrong size on ACampaignTriggerVolume");
static_assert(offsetof(ACampaignTriggerVolume, StaticMeshViz) == 0x000238, "Member 'ACampaignTriggerVolume::StaticMeshViz' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, SoundToPlay) == 0x000240, "Member 'ACampaignTriggerVolume::SoundToPlay' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, CampaignID) == 0x000248, "Member 'ACampaignTriggerVolume::CampaignID' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, MyDims) == 0x000250, "Member 'ACampaignTriggerVolume::MyDims' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bIsInteractable) == 0x00025C, "Member 'ACampaignTriggerVolume::bIsInteractable' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, TMat) == 0x000260, "Member 'ACampaignTriggerVolume::TMat' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, MMat) == 0x000268, "Member 'ACampaignTriggerVolume::MMat' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, TYVCGameMode) == 0x000270, "Member 'ACampaignTriggerVolume::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, CampaignManager) == 0x000278, "Member 'ACampaignTriggerVolume::CampaignManager' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bKillBox) == 0x000280, "Member 'ACampaignTriggerVolume::bKillBox' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bHasBeginBeenTriggered) == 0x000281, "Member 'ACampaignTriggerVolume::bHasBeginBeenTriggered' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bHasEndBeenTriggered) == 0x000282, "Member 'ACampaignTriggerVolume::bHasEndBeenTriggered' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bTriggerOnce) == 0x000283, "Member 'ACampaignTriggerVolume::bTriggerOnce' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bUseForNavBlocking) == 0x000284, "Member 'ACampaignTriggerVolume::bUseForNavBlocking' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bPlaySoundOnGoalComplete) == 0x000285, "Member 'ACampaignTriggerVolume::bPlaySoundOnGoalComplete' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, Actions) == 0x000288, "Member 'ACampaignTriggerVolume::Actions' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, ActionsIndependent) == 0x000298, "Member 'ACampaignTriggerVolume::ActionsIndependent' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, AttachPoint) == 0x0002A8, "Member 'ACampaignTriggerVolume::AttachPoint' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bIsActive) == 0x0002B0, "Member 'ACampaignTriggerVolume::bIsActive' has a wrong offset!");
static_assert(offsetof(ACampaignTriggerVolume, bFireEventsOnceEvenIfHasID) == 0x0002B1, "Member 'ACampaignTriggerVolume::bFireEventsOnceEvenIfHasID' has a wrong offset!");

// Class ThankYouVeryCool.Turret
// 0x0000 (0x0240 - 0x0240)
class ATurret : public ARechargeStation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Turret">();
	}
	static class ATurret* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATurret>();
	}
};
static_assert(alignof(ATurret) == 0x000008, "Wrong alignment on ATurret");
static_assert(sizeof(ATurret) == 0x000240, "Wrong size on ATurret");

// Class ThankYouVeryCool.CardboardBox
// 0x0020 (0x0A38 - 0x0A18)
class ACardboardBox final : public AVoxelBuilder2
{
public:
	class UVoxelDataAsset*                        CardboardMaterial;                                 // 0x0A18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoxelDataAsset*                        HoleMaterial;                                      // 0x0A20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             Dimensions;                                        // 0x0A28(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A34[0x4];                                      // 0x0A34(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CardboardBox">();
	}
	static class ACardboardBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACardboardBox>();
	}
};
static_assert(alignof(ACardboardBox) == 0x000008, "Wrong alignment on ACardboardBox");
static_assert(sizeof(ACardboardBox) == 0x000A38, "Wrong size on ACardboardBox");
static_assert(offsetof(ACardboardBox, CardboardMaterial) == 0x000A18, "Member 'ACardboardBox::CardboardMaterial' has a wrong offset!");
static_assert(offsetof(ACardboardBox, HoleMaterial) == 0x000A20, "Member 'ACardboardBox::HoleMaterial' has a wrong offset!");
static_assert(offsetof(ACardboardBox, Dimensions) == 0x000A28, "Member 'ACardboardBox::Dimensions' has a wrong offset!");

// Class ThankYouVeryCool.CardData
// 0x0068 (0x0090 - 0x0028)
class UCardData : public UObject
{
public:
	class FText                                   Title;                                             // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, AssetRegistrySearchable, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         multiplier;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierForFF;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Texture;                                           // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStack;                                         // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AThankYouVeryCoolGameMode* GetTYVCGameMode();
	void OnFirstAdded();
	void OnGameplayStart();
	void OnLevelEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CardData">();
	}
	static class UCardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCardData>();
	}
};
static_assert(alignof(UCardData) == 0x000008, "Wrong alignment on UCardData");
static_assert(sizeof(UCardData) == 0x000090, "Wrong size on UCardData");
static_assert(offsetof(UCardData, Title) == 0x000028, "Member 'UCardData::Title' has a wrong offset!");
static_assert(offsetof(UCardData, Description) == 0x000040, "Member 'UCardData::Description' has a wrong offset!");
static_assert(offsetof(UCardData, multiplier) == 0x000058, "Member 'UCardData::multiplier' has a wrong offset!");
static_assert(offsetof(UCardData, MultiplierForFF) == 0x00005C, "Member 'UCardData::MultiplierForFF' has a wrong offset!");
static_assert(offsetof(UCardData, Texture) == 0x000060, "Member 'UCardData::Texture' has a wrong offset!");
static_assert(offsetof(UCardData, bCanStack) == 0x000088, "Member 'UCardData::bCanStack' has a wrong offset!");

// Class ThankYouVeryCool.TYVCSkelMeshComp
// 0x0000 (0x0ED0 - 0x0ED0)
class UTYVCSkelMeshComp final : public USkeletalMeshComponent
{
public:
	bool                                          bTYVCTest;                                         // 0x0EC8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC9[0x7];                                      // 0x0EC9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCSkelMeshComp">();
	}
	static class UTYVCSkelMeshComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCSkelMeshComp>();
	}
};
static_assert(alignof(UTYVCSkelMeshComp) == 0x000010, "Wrong alignment on UTYVCSkelMeshComp");
static_assert(sizeof(UTYVCSkelMeshComp) == 0x000ED0, "Wrong size on UTYVCSkelMeshComp");
static_assert(offsetof(UTYVCSkelMeshComp, bTYVCTest) == 0x000EC8, "Member 'UTYVCSkelMeshComp::bTYVCTest' has a wrong offset!");

// Class ThankYouVeryCool.ChallengesSave
// 0x00F0 (0x0118 - 0x0028)
class UChallengesSave final : public USaveGame
{
public:
	int32                                         Progress;                                          // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FArcadeLevelSave>   ArcadeLevelSaves;                                  // 0x0030(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bShouldDoTutorialPrompt;                           // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FArcadeSettings                        LastArcadeSettings;                                // 0x0088(0x0048)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bCompletedDemo;                                    // 0x00D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           UnlockedKeys;                                      // 0x00D8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Headshots;                                         // 0x00E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kills;                                             // 0x00EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         UnlockedAchievements;                              // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EShineLevel                                   LastSelectedShine;                                 // 0x0100(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         CompletedDailys;                                   // 0x0108(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengesSave">();
	}
	static class UChallengesSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallengesSave>();
	}
};
static_assert(alignof(UChallengesSave) == 0x000008, "Wrong alignment on UChallengesSave");
static_assert(sizeof(UChallengesSave) == 0x000118, "Wrong size on UChallengesSave");
static_assert(offsetof(UChallengesSave, Progress) == 0x000028, "Member 'UChallengesSave::Progress' has a wrong offset!");
static_assert(offsetof(UChallengesSave, ArcadeLevelSaves) == 0x000030, "Member 'UChallengesSave::ArcadeLevelSaves' has a wrong offset!");
static_assert(offsetof(UChallengesSave, bShouldDoTutorialPrompt) == 0x000080, "Member 'UChallengesSave::bShouldDoTutorialPrompt' has a wrong offset!");
static_assert(offsetof(UChallengesSave, LastArcadeSettings) == 0x000088, "Member 'UChallengesSave::LastArcadeSettings' has a wrong offset!");
static_assert(offsetof(UChallengesSave, bCompletedDemo) == 0x0000D0, "Member 'UChallengesSave::bCompletedDemo' has a wrong offset!");
static_assert(offsetof(UChallengesSave, UnlockedKeys) == 0x0000D8, "Member 'UChallengesSave::UnlockedKeys' has a wrong offset!");
static_assert(offsetof(UChallengesSave, Headshots) == 0x0000E8, "Member 'UChallengesSave::Headshots' has a wrong offset!");
static_assert(offsetof(UChallengesSave, Kills) == 0x0000EC, "Member 'UChallengesSave::Kills' has a wrong offset!");
static_assert(offsetof(UChallengesSave, UnlockedAchievements) == 0x0000F0, "Member 'UChallengesSave::UnlockedAchievements' has a wrong offset!");
static_assert(offsetof(UChallengesSave, LastSelectedShine) == 0x000100, "Member 'UChallengesSave::LastSelectedShine' has a wrong offset!");
static_assert(offsetof(UChallengesSave, CompletedDailys) == 0x000108, "Member 'UChallengesSave::CompletedDailys' has a wrong offset!");

// Class ThankYouVeryCool.Chameleon
// 0x0268 (0x0488 - 0x0220)
class AChameleon : public AActor
{
public:
	uint8                                         Pad_220[0x4];                                      // 0x0220(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MBAmount;                                          // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x4];                                      // 0x0228(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitUV;                                             // 0x022C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x18];                                     // 0x0238(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0250(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0xC];                                      // 0x0258(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LuckVisualsInterpSpeed;                            // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTYVCHUD*                               GameHUD;                                           // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SpeedLineMaterial;                                 // 0x0270(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     HeadshotMaterial;                                  // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               HeadshotDynamicMaterial;                           // 0x0280(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               SlowMoDynamicMaterial;                             // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     GlitchMaterial;                                    // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               GlitchDynamicMaterial;                             // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     EnemyOutlineMaterial;                              // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               EnemyOutlineDynamicMaterial;                       // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CelShadeMaterial;                                  // 0x02B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               CelShadeDynamicMaterial;                           // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     SlowMoMaterial;                                    // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BlinkMaterial;                                     // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     LowHealthMaterial;                                 // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     DistortionMaterial;                                // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x130];                                    // 0x02E0(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StuntEndFadeoutCurve;                              // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            StuntStartFadeinCurve;                             // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            FreezeCurve;                                       // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APostProcessVolume*                     PostProcessVolume;                                 // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             DeathLUT;                                          // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedLinesDefaultSpeed;                            // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowMoLerpSpeed;                                   // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlowMoLensFlareStrength;                           // 0x0450(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowMoLUTStrength;                                 // 0x0454(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowMoBloomStrength;                               // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlowMoSaturationStrength;                          // 0x045C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               SpeedLineDynamicMaterial;                          // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               BlinkDynamicMaterial;                              // 0x0468(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowMoEffectMin;                                   // 0x0470(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowMoEffectMax;                                   // 0x0474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_478[0x10];                                     // 0x0478(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallBWOverDel();
	void CallOnBlinkClosed();
	void CancelBWFade();
	void DoBlink();
	void DoHeadshot(const struct FVector& HeadshotLocation);
	void DoHitEffect();
	void FadeOutToArcade();
	void FadeToBW();
	void ForceFadeOutOpacity(float Value);
	void ForceStopHitEffect();
	class APostProcessVolume* GetPPVol();
	class APostProcessVolume* GetPPVolume();
	void HideBloodOnScreen();
	void LerpFadeIn();
	void LerpFadeInFromLoad();
	void LerpFadeInToChallenges();
	void LerpFadeInToReset();
	void LerpFadeOut(float SpeedModifier);
	void LerpFadeOutToChallenges();
	void LerpFadeOutToLoad();
	void LerpFadeOutToReset();
	void SetBlinkHalfOpen(bool bOpen);
	void SetEffectSpeed(float SpeedFactor);
	void ShowBloodOnScreen(float Strength);
	void StuntFadeInEnd();
	void StuntFadeInUpdate();
	void StuntFadeOutEnd();
	void StuntFadeOutUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Chameleon">();
	}
	static class AChameleon* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChameleon>();
	}
};
static_assert(alignof(AChameleon) == 0x000008, "Wrong alignment on AChameleon");
static_assert(sizeof(AChameleon) == 0x000488, "Wrong size on AChameleon");
static_assert(offsetof(AChameleon, MBAmount) == 0x000224, "Member 'AChameleon::MBAmount' has a wrong offset!");
static_assert(offsetof(AChameleon, HitUV) == 0x00022C, "Member 'AChameleon::HitUV' has a wrong offset!");
static_assert(offsetof(AChameleon, TYVCGameMode) == 0x000250, "Member 'AChameleon::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AChameleon, LuckVisualsInterpSpeed) == 0x000264, "Member 'AChameleon::LuckVisualsInterpSpeed' has a wrong offset!");
static_assert(offsetof(AChameleon, GameHUD) == 0x000268, "Member 'AChameleon::GameHUD' has a wrong offset!");
static_assert(offsetof(AChameleon, SpeedLineMaterial) == 0x000270, "Member 'AChameleon::SpeedLineMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, HeadshotMaterial) == 0x000278, "Member 'AChameleon::HeadshotMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, HeadshotDynamicMaterial) == 0x000280, "Member 'AChameleon::HeadshotDynamicMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoDynamicMaterial) == 0x000288, "Member 'AChameleon::SlowMoDynamicMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, GlitchMaterial) == 0x000290, "Member 'AChameleon::GlitchMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, GlitchDynamicMaterial) == 0x000298, "Member 'AChameleon::GlitchDynamicMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, EnemyOutlineMaterial) == 0x0002A0, "Member 'AChameleon::EnemyOutlineMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, EnemyOutlineDynamicMaterial) == 0x0002A8, "Member 'AChameleon::EnemyOutlineDynamicMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, CelShadeMaterial) == 0x0002B0, "Member 'AChameleon::CelShadeMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, CelShadeDynamicMaterial) == 0x0002B8, "Member 'AChameleon::CelShadeDynamicMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoMaterial) == 0x0002C0, "Member 'AChameleon::SlowMoMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, BlinkMaterial) == 0x0002C8, "Member 'AChameleon::BlinkMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, LowHealthMaterial) == 0x0002D0, "Member 'AChameleon::LowHealthMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, DistortionMaterial) == 0x0002D8, "Member 'AChameleon::DistortionMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, StuntEndFadeoutCurve) == 0x000410, "Member 'AChameleon::StuntEndFadeoutCurve' has a wrong offset!");
static_assert(offsetof(AChameleon, StuntStartFadeinCurve) == 0x000418, "Member 'AChameleon::StuntStartFadeinCurve' has a wrong offset!");
static_assert(offsetof(AChameleon, FreezeCurve) == 0x000420, "Member 'AChameleon::FreezeCurve' has a wrong offset!");
static_assert(offsetof(AChameleon, PostProcessVolume) == 0x000430, "Member 'AChameleon::PostProcessVolume' has a wrong offset!");
static_assert(offsetof(AChameleon, DeathLUT) == 0x000438, "Member 'AChameleon::DeathLUT' has a wrong offset!");
static_assert(offsetof(AChameleon, SpeedLinesDefaultSpeed) == 0x000440, "Member 'AChameleon::SpeedLinesDefaultSpeed' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoLerpSpeed) == 0x000444, "Member 'AChameleon::SlowMoLerpSpeed' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoLensFlareStrength) == 0x000450, "Member 'AChameleon::SlowMoLensFlareStrength' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoLUTStrength) == 0x000454, "Member 'AChameleon::SlowMoLUTStrength' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoBloomStrength) == 0x000458, "Member 'AChameleon::SlowMoBloomStrength' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoSaturationStrength) == 0x00045C, "Member 'AChameleon::SlowMoSaturationStrength' has a wrong offset!");
static_assert(offsetof(AChameleon, SpeedLineDynamicMaterial) == 0x000460, "Member 'AChameleon::SpeedLineDynamicMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, BlinkDynamicMaterial) == 0x000468, "Member 'AChameleon::BlinkDynamicMaterial' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoEffectMin) == 0x000470, "Member 'AChameleon::SlowMoEffectMin' has a wrong offset!");
static_assert(offsetof(AChameleon, SlowMoEffectMax) == 0x000474, "Member 'AChameleon::SlowMoEffectMax' has a wrong offset!");

// Class ThankYouVeryCool.ChangeNotifyingRecastNavMesh
// 0x0108 (0x05E0 - 0x04D8)
class AChangeNotifyingRecastNavMesh final : public ARecastNavMesh
{
public:
	uint8                                         Pad_4D8[0xD8];                                     // 0x04D8(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(TSet<uint32>& ChangedTiles)> NavmeshTilesUpdatedImmediateDelegate;              // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TSet<uint32>& ChangedTiles)> NavmeshTilesUpdatedBufferedDelegate;               // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TSet<uint32>& ChangedTiles)> NavmeshTilesUpdatedUntilFinishedDelegate;          // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void OnNavmeshGenerationFinishedHandler(class ANavigationData* NavData);
	void ProcessQueuedTiles();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeNotifyingRecastNavMesh">();
	}
	static class AChangeNotifyingRecastNavMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChangeNotifyingRecastNavMesh>();
	}
};
static_assert(alignof(AChangeNotifyingRecastNavMesh) == 0x000008, "Wrong alignment on AChangeNotifyingRecastNavMesh");
static_assert(sizeof(AChangeNotifyingRecastNavMesh) == 0x0005E0, "Wrong size on AChangeNotifyingRecastNavMesh");
static_assert(offsetof(AChangeNotifyingRecastNavMesh, NavmeshTilesUpdatedImmediateDelegate) == 0x0005B0, "Member 'AChangeNotifyingRecastNavMesh::NavmeshTilesUpdatedImmediateDelegate' has a wrong offset!");
static_assert(offsetof(AChangeNotifyingRecastNavMesh, NavmeshTilesUpdatedBufferedDelegate) == 0x0005C0, "Member 'AChangeNotifyingRecastNavMesh::NavmeshTilesUpdatedBufferedDelegate' has a wrong offset!");
static_assert(offsetof(AChangeNotifyingRecastNavMesh, NavmeshTilesUpdatedUntilFinishedDelegate) == 0x0005D0, "Member 'AChangeNotifyingRecastNavMesh::NavmeshTilesUpdatedUntilFinishedDelegate' has a wrong offset!");

// Class ThankYouVeryCool.TypewriterTextBlock
// 0x0050 (0x06C8 - 0x0678)
class UTypewriterTextBlock final : public URichTextBlock
{
public:
	uint8                                         Pad_678[0x1C];                                     // 0x0678(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenLetters;                                // 0x0694(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeBetweenLettersFast;                            // 0x0698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69C[0x24];                                     // 0x069C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundPerCharacter;                                 // 0x06C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayFromStart(TDelegate<void()> FinishedDel, class USoundBase* SoundToPlay);
	void SetSpeedToFast();
	void SetSpeedToNormal();
	void SetTextToType(const class FText& InText);
	void Tick(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TypewriterTextBlock">();
	}
	static class UTypewriterTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTypewriterTextBlock>();
	}
};
static_assert(alignof(UTypewriterTextBlock) == 0x000008, "Wrong alignment on UTypewriterTextBlock");
static_assert(sizeof(UTypewriterTextBlock) == 0x0006C8, "Wrong size on UTypewriterTextBlock");
static_assert(offsetof(UTypewriterTextBlock, TimeBetweenLetters) == 0x000694, "Member 'UTypewriterTextBlock::TimeBetweenLetters' has a wrong offset!");
static_assert(offsetof(UTypewriterTextBlock, TimeBetweenLettersFast) == 0x000698, "Member 'UTypewriterTextBlock::TimeBetweenLettersFast' has a wrong offset!");
static_assert(offsetof(UTypewriterTextBlock, SoundPerCharacter) == 0x0006C0, "Member 'UTypewriterTextBlock::SoundPerCharacter' has a wrong offset!");

// Class ThankYouVeryCool.Chapter
// 0x0128 (0x0348 - 0x0220)
class AChapter : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceSimpleLighting;                              // 0x0228(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayTitle;                                      // 0x0230(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnWithArmCannon;                               // 0x0240(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECannonMode                                   CannonMode;                                        // 0x0241(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanOverrideCannon;                                // 0x0242(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowNGPSpawns;                                   // 0x0243(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseIDsForWaves;                                // 0x0244(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245[0x3];                                      // 0x0245(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NGPExtraSpawns;                                    // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideCompassAtStart;                               // 0x024C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideLuckAtStart;                                  // 0x024D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideSloMoAtStart;                                 // 0x024E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideObjAtStart;                                   // 0x024F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CorsairAmbient;                                    // 0x0250(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelEditorSave*                       MyLevelData;                                       // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                PlayerSpawnWeapon;                                 // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficulty                                   SelectedDifficulty;                                // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       Eve;                                               // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IGameplayTaskOwnerInterface> SelfInterface;                                     // 0x0280(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UGameplayTask_StartEditor*              StartEditorTask;                                   // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACampaignManager*                       MyCampaignManager;                                 // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FActorList>          IDActorMap;                                        // 0x02A0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x50];                                     // 0x02F0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNoNPCSleeping;                                    // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelMyDelays();
	void EndChapter(TSoftClassPtr<class UClass> NextChapter);
	class UObject* GetActorFromID(class FName InID, TSubclassOf<class AActor> GetAsClass);
	TArray<class AActor*> GetActorsFromID(class FName InID);
	TArray<class FName> GetLevelsToLoad();
	TArray<class AEditorLight*> GetLightsFromID(class FName InID);
	struct FTransform GetPlayerSpawnTransform();
	struct FTransform GetTransformOfID(class FName InID);
	void NotifyActivatedSlowMo();
	void NotifyActorDestroyed(class FName ID);
	void NotifyActorTookDamage(class FName ID, float Damage);
	void NotifyCinematicChargeEnded();
	void NotifyCombatStarted();
	void NotifyCustomEvent(class FName EventName);
	void NotifyDidWallRun();
	void NotifyDidWallRunJump();
	void NotifyFadeInOver();
	void NotifyFadeOutOver();
	void NotifyKickslideStart();
	void NotifyLevelLoaded();
	void NotifyLoadComplete();
	void NotifyLoadNarrativeOver();
	void NotifyLoadStart();
	void NotifyLongLoadStarted();
	void NotifyNPCDied(class ANPC* DeadNPC);
	void NotifyOverlapStart(class FName ID, class AActor* OhterActor, class AActor* TriggerVolume);
	void NotifyOverlapStop(class FName ID);
	void NotifyPlayerDive();
	void NotifyPlayerDoubleJump();
	void NotifyPlayerEndedKickslide();
	void NotifyPlayerMoveStatus(bool bIsMoving);
	void NotifyReset();
	void NotifySteelDied();
	void NotifyVoxelDamage(float Volume);
	void OnAllNPCsDead();
	void OnCannonEmpty();
	void OnCannonRecharge();
	void OnCannonRechargeFromStation();
	void OnEvePickedUpWeapon();
	void OnSkipTo();
	void OnSpawnsOver();
	void OnWeaponEmpty();
	void RequestObjectiveReminder();
	void SetObjectiveText(const class FString& Text, bool bDoNotify);
	void SetupLoaded();
	void SetupNew();
	void StartLoadedSave();
	void StartNew();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Chapter">();
	}
	static class AChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChapter>();
	}
};
static_assert(alignof(AChapter) == 0x000008, "Wrong alignment on AChapter");
static_assert(sizeof(AChapter) == 0x000348, "Wrong size on AChapter");
static_assert(offsetof(AChapter, bForceSimpleLighting) == 0x000228, "Member 'AChapter::bForceSimpleLighting' has a wrong offset!");
static_assert(offsetof(AChapter, DisplayTitle) == 0x000230, "Member 'AChapter::DisplayTitle' has a wrong offset!");
static_assert(offsetof(AChapter, bSpawnWithArmCannon) == 0x000240, "Member 'AChapter::bSpawnWithArmCannon' has a wrong offset!");
static_assert(offsetof(AChapter, CannonMode) == 0x000241, "Member 'AChapter::CannonMode' has a wrong offset!");
static_assert(offsetof(AChapter, bCanOverrideCannon) == 0x000242, "Member 'AChapter::bCanOverrideCannon' has a wrong offset!");
static_assert(offsetof(AChapter, bAllowNGPSpawns) == 0x000243, "Member 'AChapter::bAllowNGPSpawns' has a wrong offset!");
static_assert(offsetof(AChapter, bCanUseIDsForWaves) == 0x000244, "Member 'AChapter::bCanUseIDsForWaves' has a wrong offset!");
static_assert(offsetof(AChapter, NGPExtraSpawns) == 0x000248, "Member 'AChapter::NGPExtraSpawns' has a wrong offset!");
static_assert(offsetof(AChapter, bHideCompassAtStart) == 0x00024C, "Member 'AChapter::bHideCompassAtStart' has a wrong offset!");
static_assert(offsetof(AChapter, bHideLuckAtStart) == 0x00024D, "Member 'AChapter::bHideLuckAtStart' has a wrong offset!");
static_assert(offsetof(AChapter, bHideSloMoAtStart) == 0x00024E, "Member 'AChapter::bHideSloMoAtStart' has a wrong offset!");
static_assert(offsetof(AChapter, bHideObjAtStart) == 0x00024F, "Member 'AChapter::bHideObjAtStart' has a wrong offset!");
static_assert(offsetof(AChapter, CorsairAmbient) == 0x000250, "Member 'AChapter::CorsairAmbient' has a wrong offset!");
static_assert(offsetof(AChapter, MyLevelData) == 0x000260, "Member 'AChapter::MyLevelData' has a wrong offset!");
static_assert(offsetof(AChapter, PlayerSpawnWeapon) == 0x000268, "Member 'AChapter::PlayerSpawnWeapon' has a wrong offset!");
static_assert(offsetof(AChapter, SelectedDifficulty) == 0x000270, "Member 'AChapter::SelectedDifficulty' has a wrong offset!");
static_assert(offsetof(AChapter, Eve) == 0x000278, "Member 'AChapter::Eve' has a wrong offset!");
static_assert(offsetof(AChapter, SelfInterface) == 0x000280, "Member 'AChapter::SelfInterface' has a wrong offset!");
static_assert(offsetof(AChapter, StartEditorTask) == 0x000290, "Member 'AChapter::StartEditorTask' has a wrong offset!");
static_assert(offsetof(AChapter, MyCampaignManager) == 0x000298, "Member 'AChapter::MyCampaignManager' has a wrong offset!");
static_assert(offsetof(AChapter, IDActorMap) == 0x0002A0, "Member 'AChapter::IDActorMap' has a wrong offset!");
static_assert(offsetof(AChapter, bNoNPCSleeping) == 0x000340, "Member 'AChapter::bNoNPCSleeping' has a wrong offset!");

// Class ThankYouVeryCool.ChapterSave
// 0x0138 (0x0160 - 0x0028)
class UChapterSave final : public USaveGame
{
public:
	class FString                                 Description;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ChapterPath;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 ChapterData;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FVoxelUncompressedWorldSave> VoxelWorldSaves;                                   // 0x0058(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerTransform;                                   // 0x00B0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                PlayerWeapon;                                      // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeaponAmmoLeft;                                    // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNPCSave>                       NPCSaveList;                                       // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EDifficulty                                   SelectedDifficulty;                                // 0x0100(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECannonMode, float>                      ArmCannonCharges;                                  // 0x0108(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x8];                                      // 0x0158(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChapterSave">();
	}
	static class UChapterSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChapterSave>();
	}
};
static_assert(alignof(UChapterSave) == 0x000010, "Wrong alignment on UChapterSave");
static_assert(sizeof(UChapterSave) == 0x000160, "Wrong size on UChapterSave");
static_assert(offsetof(UChapterSave, Description) == 0x000028, "Member 'UChapterSave::Description' has a wrong offset!");
static_assert(offsetof(UChapterSave, ChapterPath) == 0x000038, "Member 'UChapterSave::ChapterPath' has a wrong offset!");
static_assert(offsetof(UChapterSave, ChapterData) == 0x000048, "Member 'UChapterSave::ChapterData' has a wrong offset!");
static_assert(offsetof(UChapterSave, VoxelWorldSaves) == 0x000058, "Member 'UChapterSave::VoxelWorldSaves' has a wrong offset!");
static_assert(offsetof(UChapterSave, PlayerTransform) == 0x0000B0, "Member 'UChapterSave::PlayerTransform' has a wrong offset!");
static_assert(offsetof(UChapterSave, PlayerWeapon) == 0x0000E0, "Member 'UChapterSave::PlayerWeapon' has a wrong offset!");
static_assert(offsetof(UChapterSave, WeaponAmmoLeft) == 0x0000E8, "Member 'UChapterSave::WeaponAmmoLeft' has a wrong offset!");
static_assert(offsetof(UChapterSave, NPCSaveList) == 0x0000F0, "Member 'UChapterSave::NPCSaveList' has a wrong offset!");
static_assert(offsetof(UChapterSave, SelectedDifficulty) == 0x000100, "Member 'UChapterSave::SelectedDifficulty' has a wrong offset!");
static_assert(offsetof(UChapterSave, ArmCannonCharges) == 0x000108, "Member 'UChapterSave::ArmCannonCharges' has a wrong offset!");

// Class ThankYouVeryCool.ColumnBuilder
// 0x0078 (0x0A90 - 0x0A18)
class AColumnBuilder : public AVoxelBuilder2
{
public:
	EVoxelWorld                                   WhichWorld;                                        // 0x0A18(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelShape                                   Shape;                                             // 0x0A19(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelMaterial                                Material;                                          // 0x0A1A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1B[0x1];                                      // 0x0A1B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Radius;                                            // 0x0A1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Thickness;                                         // 0x0A20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoot;                                           // 0x0A24(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A25[0x3];                                      // 0x0A25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Length;                                            // 0x0A28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0A2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SinAngle;                                          // 0x0A30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CosAngle;                                          // 0x0A34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartRadius;                                       // 0x0A38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndRadius;                                         // 0x0A3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxDims;                                           // 0x0A40(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 RGBVal;                                            // 0x0A4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Smoothness;                                        // 0x0A50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSubtractive;                                      // 0x0A54(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHollow;                                           // 0x0A55(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A56[0x2];                                      // 0x0A56(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShellSize;                                         // 0x0A58(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCustomBounds;                                  // 0x0A5C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5D[0x3];                                      // 0x0A5D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelIntBox                           CustomBounds;                                      // 0x0A60(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A78[0x18];                                     // 0x0A78(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColumnBuilder">();
	}
	static class AColumnBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AColumnBuilder>();
	}
};
static_assert(alignof(AColumnBuilder) == 0x000008, "Wrong alignment on AColumnBuilder");
static_assert(sizeof(AColumnBuilder) == 0x000A90, "Wrong size on AColumnBuilder");
static_assert(offsetof(AColumnBuilder, WhichWorld) == 0x000A18, "Member 'AColumnBuilder::WhichWorld' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, Shape) == 0x000A19, "Member 'AColumnBuilder::Shape' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, Material) == 0x000A1A, "Member 'AColumnBuilder::Material' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, Radius) == 0x000A1C, "Member 'AColumnBuilder::Radius' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, Thickness) == 0x000A20, "Member 'AColumnBuilder::Thickness' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, bIsRoot) == 0x000A24, "Member 'AColumnBuilder::bIsRoot' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, Length) == 0x000A28, "Member 'AColumnBuilder::Length' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, Height) == 0x000A2C, "Member 'AColumnBuilder::Height' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, SinAngle) == 0x000A30, "Member 'AColumnBuilder::SinAngle' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, CosAngle) == 0x000A34, "Member 'AColumnBuilder::CosAngle' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, StartRadius) == 0x000A38, "Member 'AColumnBuilder::StartRadius' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, EndRadius) == 0x000A3C, "Member 'AColumnBuilder::EndRadius' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, BoxDims) == 0x000A40, "Member 'AColumnBuilder::BoxDims' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, RGBVal) == 0x000A4C, "Member 'AColumnBuilder::RGBVal' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, Smoothness) == 0x000A50, "Member 'AColumnBuilder::Smoothness' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, bSubtractive) == 0x000A54, "Member 'AColumnBuilder::bSubtractive' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, bHollow) == 0x000A55, "Member 'AColumnBuilder::bHollow' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, ShellSize) == 0x000A58, "Member 'AColumnBuilder::ShellSize' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, bUseCustomBounds) == 0x000A5C, "Member 'AColumnBuilder::bUseCustomBounds' has a wrong offset!");
static_assert(offsetof(AColumnBuilder, CustomBounds) == 0x000A60, "Member 'AColumnBuilder::CustomBounds' has a wrong offset!");

// Class ThankYouVeryCool.DailyManager
// 0x00C8 (0x02E8 - 0x0220)
class ADailyManager : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnChallengeRandomized;                             // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bFetchedString;                                    // 0x0230(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              MyDateTime;                                        // 0x0238(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UArcadeLevelAsset>>  LevelPool;                                         // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UArcadeLevelAsset>>  BigLevelFilterPool;                                // 0x0250(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<EGameModifier>                         ModPool;                                           // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AWeaponBase>>        WeaponPool;                                        // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<ECannonMode>                           CannonPool;                                        // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDailyChallenge                        DebugChallenge;                                    // 0x0290(0x0028)(Edit, BlueprintVisible, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         MinMut;                                            // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxMut;                                            // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EGameModifier>                         ModifiersSkipList;                                 // 0x02C0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FString                                 ConsoleDailyLeaderboardName;                       // 0x02D0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x02E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class FString GetTimespanAsString(const struct FTimespan& In);
	static bool TimespanTicksNegative(const struct FTimespan& In);

	struct FDailyChallenge GetChallengeFromDateTime(const struct FDateTime& DateTimeIn);
	class FString GetConsoleLeaderboardNameFromChallenge(const class FString& Challenge);
	struct FDateTime GetConsoleNetworkDateTimeUTC();
	struct FDateTime GetMyDateTime();
	void GetMyString(class FString* Out);
	float GetSecondsToMidnight();
	struct FTimespan GetSpanToMidnight();
	void GetYesterday(const struct FDateTime& InDateTime, class FString* OutString, struct FDateTime* OutDateTime);
	bool HasStringBeenSet();
	void InvalidateString();
	void PlayChallenge(const struct FDailyChallenge& ToPlay, EDifficulty InDiff);
	void SetTodayAsDateTime(const struct FDateTime& InDt);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyManager">();
	}
	static class ADailyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADailyManager>();
	}
};
static_assert(alignof(ADailyManager) == 0x000008, "Wrong alignment on ADailyManager");
static_assert(sizeof(ADailyManager) == 0x0002E8, "Wrong size on ADailyManager");
static_assert(offsetof(ADailyManager, OnChallengeRandomized) == 0x000220, "Member 'ADailyManager::OnChallengeRandomized' has a wrong offset!");
static_assert(offsetof(ADailyManager, bFetchedString) == 0x000230, "Member 'ADailyManager::bFetchedString' has a wrong offset!");
static_assert(offsetof(ADailyManager, MyDateTime) == 0x000238, "Member 'ADailyManager::MyDateTime' has a wrong offset!");
static_assert(offsetof(ADailyManager, LevelPool) == 0x000240, "Member 'ADailyManager::LevelPool' has a wrong offset!");
static_assert(offsetof(ADailyManager, BigLevelFilterPool) == 0x000250, "Member 'ADailyManager::BigLevelFilterPool' has a wrong offset!");
static_assert(offsetof(ADailyManager, ModPool) == 0x000260, "Member 'ADailyManager::ModPool' has a wrong offset!");
static_assert(offsetof(ADailyManager, WeaponPool) == 0x000270, "Member 'ADailyManager::WeaponPool' has a wrong offset!");
static_assert(offsetof(ADailyManager, CannonPool) == 0x000280, "Member 'ADailyManager::CannonPool' has a wrong offset!");
static_assert(offsetof(ADailyManager, DebugChallenge) == 0x000290, "Member 'ADailyManager::DebugChallenge' has a wrong offset!");
static_assert(offsetof(ADailyManager, MinMut) == 0x0002B8, "Member 'ADailyManager::MinMut' has a wrong offset!");
static_assert(offsetof(ADailyManager, MaxMut) == 0x0002BC, "Member 'ADailyManager::MaxMut' has a wrong offset!");
static_assert(offsetof(ADailyManager, ModifiersSkipList) == 0x0002C0, "Member 'ADailyManager::ModifiersSkipList' has a wrong offset!");
static_assert(offsetof(ADailyManager, ConsoleDailyLeaderboardName) == 0x0002D0, "Member 'ADailyManager::ConsoleDailyLeaderboardName' has a wrong offset!");
static_assert(offsetof(ADailyManager, TYVCGameMode) == 0x0002E0, "Member 'ADailyManager::TYVCGameMode' has a wrong offset!");

// Class ThankYouVeryCool.debris
// 0x0020 (0x02A8 - 0x0288)
class Adebris : public APoolableActor
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               DynMat;                                            // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseStrength;                                   // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStop(class UPrimitiveComponent* SleepingComponent, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"debris">();
	}
	static class Adebris* GetDefaultObj()
	{
		return GetDefaultObjImpl<Adebris>();
	}
};
static_assert(alignof(Adebris) == 0x000008, "Wrong alignment on Adebris");
static_assert(sizeof(Adebris) == 0x0002A8, "Wrong size on Adebris");
static_assert(offsetof(Adebris, StaticMesh) == 0x000288, "Member 'Adebris::StaticMesh' has a wrong offset!");
static_assert(offsetof(Adebris, DynMat) == 0x000298, "Member 'Adebris::DynMat' has a wrong offset!");
static_assert(offsetof(Adebris, ImpulseStrength) == 0x0002A0, "Member 'Adebris::ImpulseStrength' has a wrong offset!");

// Class ThankYouVeryCool.TYVCAnimInstance_Post
// 0x0000 (0x02C0 - 0x02C0)
class UTYVCAnimInstance_Post final : public UAnimInstance
{
public:
	bool                                          bEnableIKC;                                        // 0x02B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetALSMovementModeC(EMovementMode MovementMode);
	void SetIKEnabledC(bool Enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCAnimInstance_Post">();
	}
	static class UTYVCAnimInstance_Post* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCAnimInstance_Post>();
	}
};
static_assert(alignof(UTYVCAnimInstance_Post) == 0x000010, "Wrong alignment on UTYVCAnimInstance_Post");
static_assert(sizeof(UTYVCAnimInstance_Post) == 0x0002C0, "Wrong size on UTYVCAnimInstance_Post");
static_assert(offsetof(UTYVCAnimInstance_Post, bEnableIKC) == 0x0002B8, "Member 'UTYVCAnimInstance_Post::bEnableIKC' has a wrong offset!");

// Class ThankYouVeryCool.DroppedCasing
// 0x0030 (0x0250 - 0x0220)
class ADroppedCasing final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UArrowComponent*                        DirArrow;                                          // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeaponBase*                            Weapon;                                            // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x18];                                     // 0x0238(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateEject();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedCasing">();
	}
	static class ADroppedCasing* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedCasing>();
	}
};
static_assert(alignof(ADroppedCasing) == 0x000008, "Wrong alignment on ADroppedCasing");
static_assert(sizeof(ADroppedCasing) == 0x000250, "Wrong size on ADroppedCasing");
static_assert(offsetof(ADroppedCasing, DirArrow) == 0x000228, "Member 'ADroppedCasing::DirArrow' has a wrong offset!");
static_assert(offsetof(ADroppedCasing, Weapon) == 0x000230, "Member 'ADroppedCasing::Weapon' has a wrong offset!");

// Class ThankYouVeryCool.DummyWeapon
// 0x0008 (0x0228 - 0x0220)
class ADummyWeapon final : public AActor
{
public:
	class USkeletalMeshComponent*                 GunMesh;                                           // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DummyWeapon">();
	}
	static class ADummyWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADummyWeapon>();
	}
};
static_assert(alignof(ADummyWeapon) == 0x000008, "Wrong alignment on ADummyWeapon");
static_assert(sizeof(ADummyWeapon) == 0x000228, "Wrong size on ADummyWeapon");
static_assert(offsetof(ADummyWeapon, GunMesh) == 0x000220, "Member 'ADummyWeapon::GunMesh' has a wrong offset!");

// Class ThankYouVeryCool.DynamicTexture
// 0x0028 (0x0050 - 0x0028)
class UDynamicTexture final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 Buffer;                                            // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicTexture">();
	}
	static class UDynamicTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicTexture>();
	}
};
static_assert(alignof(UDynamicTexture) == 0x000008, "Wrong alignment on UDynamicTexture");
static_assert(sizeof(UDynamicTexture) == 0x000050, "Wrong size on UDynamicTexture");
static_assert(offsetof(UDynamicTexture, Buffer) == 0x000038, "Member 'UDynamicTexture::Buffer' has a wrong offset!");
static_assert(offsetof(UDynamicTexture, Texture) == 0x000048, "Member 'UDynamicTexture::Texture' has a wrong offset!");

// Class ThankYouVeryCool.EditorInterface
// 0x0000 (0x0028 - 0x0028)
class IEditorInterface final : public IInterface
{
public:
	void DoActions(EActionType ToDo, bool bSimulated);
	void EditorModeChanged(EEditMode NewMode);
	TArray<EActionType> GetActions();
	TArray<EGoalType> GetGoals();
	bool GetShouldSave();
	void NotifyMoved();
	void NotifyPlayingReverse();
	void PostDataLoaded();
	void SetInEditor(bool bInEditor);
	void SetSelected(bool bIsSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorInterface">();
	}
	static class IEditorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEditorInterface>();
	}
};
static_assert(alignof(IEditorInterface) == 0x000008, "Wrong alignment on IEditorInterface");
static_assert(sizeof(IEditorInterface) == 0x000028, "Wrong size on IEditorInterface");

// Class ThankYouVeryCool.TrailerPawn
// 0x0000 (0x02A8 - 0x02A8)
class ATrailerPawn : public ADefaultPawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrailerPawn">();
	}
	static class ATrailerPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrailerPawn>();
	}
};
static_assert(alignof(ATrailerPawn) == 0x000008, "Wrong alignment on ATrailerPawn");
static_assert(sizeof(ATrailerPawn) == 0x0002A8, "Wrong size on ATrailerPawn");

// Class ThankYouVeryCool.EditorLight
// 0x0080 (0x02A0 - 0x0220)
class AEditorLight : public AActor
{
public:
	uint8                                         Pad_220[0x10];                                     // 0x0220(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CampaignID;                                        // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpotLightComponent*                    SpotLightComp;                                     // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinCutOffRatio;                                    // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FlickerMaterial;                                   // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBillboardComponent*                    BillboardComp;                                     // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       SphereComp;                                        // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       VizSphereComp;                                     // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachedTo;                                        // 0x0270(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        ArrowComp;                                         // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyIntensity;                                       // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyTemp;                                            // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MyRadius;                                          // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 MyColor;                                           // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowWhenSimple;                                   // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachPoint;                                       // 0x0294(0x0008)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoShortFlicker(float ForTime);
	void EditorModeChanged_Implementation(EEditMode NewMode);
	void LevelReady();
	void PostSettingsChanged();
	void RandomizeLightColor();
	void SetFlicker(bool bFlicker);
	void Setup(float Intensity, float Temp, float Radius, const struct FColor& Color, bool bSaveTransaction, bool bInShowWhenSimple);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorLight">();
	}
	static class AEditorLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEditorLight>();
	}
};
static_assert(alignof(AEditorLight) == 0x000008, "Wrong alignment on AEditorLight");
static_assert(sizeof(AEditorLight) == 0x0002A0, "Wrong size on AEditorLight");
static_assert(offsetof(AEditorLight, CampaignID) == 0x000230, "Member 'AEditorLight::CampaignID' has a wrong offset!");
static_assert(offsetof(AEditorLight, SpotLightComp) == 0x000238, "Member 'AEditorLight::SpotLightComp' has a wrong offset!");
static_assert(offsetof(AEditorLight, MinCutOffRatio) == 0x000244, "Member 'AEditorLight::MinCutOffRatio' has a wrong offset!");
static_assert(offsetof(AEditorLight, FlickerMaterial) == 0x000250, "Member 'AEditorLight::FlickerMaterial' has a wrong offset!");
static_assert(offsetof(AEditorLight, BillboardComp) == 0x000258, "Member 'AEditorLight::BillboardComp' has a wrong offset!");
static_assert(offsetof(AEditorLight, SphereComp) == 0x000260, "Member 'AEditorLight::SphereComp' has a wrong offset!");
static_assert(offsetof(AEditorLight, VizSphereComp) == 0x000268, "Member 'AEditorLight::VizSphereComp' has a wrong offset!");
static_assert(offsetof(AEditorLight, AttachedTo) == 0x000270, "Member 'AEditorLight::AttachedTo' has a wrong offset!");
static_assert(offsetof(AEditorLight, ArrowComp) == 0x000278, "Member 'AEditorLight::ArrowComp' has a wrong offset!");
static_assert(offsetof(AEditorLight, MyIntensity) == 0x000280, "Member 'AEditorLight::MyIntensity' has a wrong offset!");
static_assert(offsetof(AEditorLight, MyTemp) == 0x000284, "Member 'AEditorLight::MyTemp' has a wrong offset!");
static_assert(offsetof(AEditorLight, MyRadius) == 0x000288, "Member 'AEditorLight::MyRadius' has a wrong offset!");
static_assert(offsetof(AEditorLight, MyColor) == 0x00028C, "Member 'AEditorLight::MyColor' has a wrong offset!");
static_assert(offsetof(AEditorLight, bShowWhenSimple) == 0x000290, "Member 'AEditorLight::bShowWhenSimple' has a wrong offset!");
static_assert(offsetof(AEditorLight, AttachPoint) == 0x000294, "Member 'AEditorLight::AttachPoint' has a wrong offset!");

// Class ThankYouVeryCool.EnvQueryGenerator_Grid3D
// 0x0078 (0x00F8 - 0x0080)
class UEnvQueryGenerator_Grid3D final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	struct FAIDataProviderFloatValue              GridSize;                                          // 0x0080(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              SpaceBetween;                                      // 0x00B8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           GenerateAround;                                    // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryGenerator_Grid3D">();
	}
	static class UEnvQueryGenerator_Grid3D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryGenerator_Grid3D>();
	}
};
static_assert(alignof(UEnvQueryGenerator_Grid3D) == 0x000008, "Wrong alignment on UEnvQueryGenerator_Grid3D");
static_assert(sizeof(UEnvQueryGenerator_Grid3D) == 0x0000F8, "Wrong size on UEnvQueryGenerator_Grid3D");
static_assert(offsetof(UEnvQueryGenerator_Grid3D, GridSize) == 0x000080, "Member 'UEnvQueryGenerator_Grid3D::GridSize' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Grid3D, SpaceBetween) == 0x0000B8, "Member 'UEnvQueryGenerator_Grid3D::SpaceBetween' has a wrong offset!");
static_assert(offsetof(UEnvQueryGenerator_Grid3D, GenerateAround) == 0x0000F0, "Member 'UEnvQueryGenerator_Grid3D::GenerateAround' has a wrong offset!");

// Class ThankYouVeryCool.EnvQueryTest_DroppedGun
// 0x0000 (0x01F8 - 0x01F8)
class UEnvQueryTest_DroppedGun final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_DroppedGun">();
	}
	static class UEnvQueryTest_DroppedGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_DroppedGun>();
	}
};
static_assert(alignof(UEnvQueryTest_DroppedGun) == 0x000008, "Wrong alignment on UEnvQueryTest_DroppedGun");
static_assert(sizeof(UEnvQueryTest_DroppedGun) == 0x0001F8, "Wrong size on UEnvQueryTest_DroppedGun");

// Class ThankYouVeryCool.FeedbackActor
// 0x0028 (0x02B0 - 0x0288)
class AFeedbackActor : public APoolableActor
{
public:
	TSubclassOf<class UFeedbackWidget>            FeedbackWidgetClass;                               // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetComponent*                       WidgetComp;                                        // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFeedbackWidget*                        FeedbackWidget;                                    // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerCharacter*                       Player;                                            // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANPC*                                   MyNPC;                                             // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DoFade(int32 Stack);
	void FadeOver();
	void OnLevelUnload();
	void SetupText(const class FText& InText);
	void SetupTexture(EFeedback ForType);
	void SetupValue(int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeedbackActor">();
	}
	static class AFeedbackActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFeedbackActor>();
	}
};
static_assert(alignof(AFeedbackActor) == 0x000008, "Wrong alignment on AFeedbackActor");
static_assert(sizeof(AFeedbackActor) == 0x0002B0, "Wrong size on AFeedbackActor");
static_assert(offsetof(AFeedbackActor, FeedbackWidgetClass) == 0x000288, "Member 'AFeedbackActor::FeedbackWidgetClass' has a wrong offset!");
static_assert(offsetof(AFeedbackActor, WidgetComp) == 0x000290, "Member 'AFeedbackActor::WidgetComp' has a wrong offset!");
static_assert(offsetof(AFeedbackActor, FeedbackWidget) == 0x000298, "Member 'AFeedbackActor::FeedbackWidget' has a wrong offset!");
static_assert(offsetof(AFeedbackActor, Player) == 0x0002A0, "Member 'AFeedbackActor::Player' has a wrong offset!");
static_assert(offsetof(AFeedbackActor, MyNPC) == 0x0002A8, "Member 'AFeedbackActor::MyNPC' has a wrong offset!");

// Class ThankYouVeryCool.TYVCPlayerInput
// 0x0008 (0x03B0 - 0x03A8)
class UTYVCPlayerInput final : public UPlayerInput
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCPlayerInput">();
	}
	static class UTYVCPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCPlayerInput>();
	}
};
static_assert(alignof(UTYVCPlayerInput) == 0x000008, "Wrong alignment on UTYVCPlayerInput");
static_assert(sizeof(UTYVCPlayerInput) == 0x0003B0, "Wrong size on UTYVCPlayerInput");

// Class ThankYouVeryCool.FeedbackWidget
// 0x0000 (0x0260 - 0x0260)
class UFeedbackWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FeedbackWidget">();
	}
	static class UFeedbackWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFeedbackWidget>();
	}
};
static_assert(alignof(UFeedbackWidget) == 0x000008, "Wrong alignment on UFeedbackWidget");
static_assert(sizeof(UFeedbackWidget) == 0x000260, "Wrong size on UFeedbackWidget");

// Class ThankYouVeryCool.FindCover
// 0x01E8 (0x0258 - 0x0070)
class UFindCover final : public UBTTaskNode
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoverFinderVisData*                    debugData;                                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointsToTestPerTick;                               // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTakeCoverNearPoint;                               // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 CoverNearPointKey;                                 // 0x0098(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         CoverNearPointRange;                               // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 DrawDebug;                                         // 0x00C8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 OutputVector;                                      // 0x00F0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 LeanLocationKey;                                   // 0x0118(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 SuccessKey;                                        // 0x0140(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Enemy;                                             // 0x0168(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 LeanDirectionOutput;                               // 0x0190(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 bIsCrouchedOutput;                                 // 0x01B8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 CoverNormalOutput;                                 // 0x01E0(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         AttackRange;                                       // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAttackRange;                                    // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponLeanOffset;                                  // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchedLeanUpOffset;                              // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverPointMaxObjectHitDistance;                    // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForSuppression;                                 // 0x021C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStayInSquadZone;                                  // 0x021D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E[0x2];                                      // 0x021E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 SquadKey;                                          // 0x0220(0x0028)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FindCover">();
	}
	static class UFindCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFindCover>();
	}
};
static_assert(alignof(UFindCover) == 0x000008, "Wrong alignment on UFindCover");
static_assert(sizeof(UFindCover) == 0x000258, "Wrong size on UFindCover");
static_assert(offsetof(UFindCover, debugData) == 0x000080, "Member 'UFindCover::debugData' has a wrong offset!");
static_assert(offsetof(UFindCover, PointsToTestPerTick) == 0x000088, "Member 'UFindCover::PointsToTestPerTick' has a wrong offset!");
static_assert(offsetof(UFindCover, bTakeCoverNearPoint) == 0x000090, "Member 'UFindCover::bTakeCoverNearPoint' has a wrong offset!");
static_assert(offsetof(UFindCover, CoverNearPointKey) == 0x000098, "Member 'UFindCover::CoverNearPointKey' has a wrong offset!");
static_assert(offsetof(UFindCover, CoverNearPointRange) == 0x0000C0, "Member 'UFindCover::CoverNearPointRange' has a wrong offset!");
static_assert(offsetof(UFindCover, DrawDebug) == 0x0000C8, "Member 'UFindCover::DrawDebug' has a wrong offset!");
static_assert(offsetof(UFindCover, OutputVector) == 0x0000F0, "Member 'UFindCover::OutputVector' has a wrong offset!");
static_assert(offsetof(UFindCover, LeanLocationKey) == 0x000118, "Member 'UFindCover::LeanLocationKey' has a wrong offset!");
static_assert(offsetof(UFindCover, SuccessKey) == 0x000140, "Member 'UFindCover::SuccessKey' has a wrong offset!");
static_assert(offsetof(UFindCover, Enemy) == 0x000168, "Member 'UFindCover::Enemy' has a wrong offset!");
static_assert(offsetof(UFindCover, LeanDirectionOutput) == 0x000190, "Member 'UFindCover::LeanDirectionOutput' has a wrong offset!");
static_assert(offsetof(UFindCover, bIsCrouchedOutput) == 0x0001B8, "Member 'UFindCover::bIsCrouchedOutput' has a wrong offset!");
static_assert(offsetof(UFindCover, CoverNormalOutput) == 0x0001E0, "Member 'UFindCover::CoverNormalOutput' has a wrong offset!");
static_assert(offsetof(UFindCover, AttackRange) == 0x000208, "Member 'UFindCover::AttackRange' has a wrong offset!");
static_assert(offsetof(UFindCover, MinAttackRange) == 0x00020C, "Member 'UFindCover::MinAttackRange' has a wrong offset!");
static_assert(offsetof(UFindCover, WeaponLeanOffset) == 0x000210, "Member 'UFindCover::WeaponLeanOffset' has a wrong offset!");
static_assert(offsetof(UFindCover, CrouchedLeanUpOffset) == 0x000214, "Member 'UFindCover::CrouchedLeanUpOffset' has a wrong offset!");
static_assert(offsetof(UFindCover, CoverPointMaxObjectHitDistance) == 0x000218, "Member 'UFindCover::CoverPointMaxObjectHitDistance' has a wrong offset!");
static_assert(offsetof(UFindCover, bIsForSuppression) == 0x00021C, "Member 'UFindCover::bIsForSuppression' has a wrong offset!");
static_assert(offsetof(UFindCover, bStayInSquadZone) == 0x00021D, "Member 'UFindCover::bStayInSquadZone' has a wrong offset!");
static_assert(offsetof(UFindCover, SquadKey) == 0x000220, "Member 'UFindCover::SquadKey' has a wrong offset!");

// Class ThankYouVeryCool.FireNumberOfShots
// 0x0038 (0x0068 - 0x0030)
class UFireNumberOfShots final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              DoneShooting;                                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Points, bool DidShoot)> PerShot;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFireNumberOfShots* FireShots(class ANPC* InShooter, const int32 InShotCount);

	void Chambered();
	void ExecuteAfterShootingComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireNumberOfShots">();
	}
	static class UFireNumberOfShots* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireNumberOfShots>();
	}
};
static_assert(alignof(UFireNumberOfShots) == 0x000008, "Wrong alignment on UFireNumberOfShots");
static_assert(sizeof(UFireNumberOfShots) == 0x000068, "Wrong size on UFireNumberOfShots");
static_assert(offsetof(UFireNumberOfShots, DoneShooting) == 0x000030, "Member 'UFireNumberOfShots::DoneShooting' has a wrong offset!");
static_assert(offsetof(UFireNumberOfShots, PerShot) == 0x000040, "Member 'UFireNumberOfShots::PerShot' has a wrong offset!");

// Class ThankYouVeryCool.FloorCeilingBuilder
// 0x0060 (0x0A78 - 0x0A18)
class AFloorCeilingBuilder final : public AVoxelBuilder2
{
public:
	bool                                          bShouldTileNotStretch;                             // 0x0A18(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bBuildLayersUp;                                    // 0x0A19(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVoxelWorld                                   VoxelWorld;                                        // 0x0A1A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1B[0x1];                                      // 0x0A1B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Dimensions;                                        // 0x0A1C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A24[0x4];                                      // 0x0A24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialThickness>             MaterialLayers;                                    // 0x0A28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATYVCLight>                 TopLightClass;                                     // 0x0A38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              TopLightCount;                                     // 0x0A40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGridPattern                                  TopLightPattern;                                   // 0x0A48(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A49[0x3];                                      // 0x0A49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TopLightRotation;                                  // 0x0A4C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATYVCLight>                 BottomLightClass;                                  // 0x0A58(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              BottomLightCount;                                  // 0x0A60(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGridPattern                                  BottomLightPattern;                                // 0x0A68(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A69[0x3];                                      // 0x0A69(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BottomLightRotation;                               // 0x0A6C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorCeilingBuilder">();
	}
	static class AFloorCeilingBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFloorCeilingBuilder>();
	}
};
static_assert(alignof(AFloorCeilingBuilder) == 0x000008, "Wrong alignment on AFloorCeilingBuilder");
static_assert(sizeof(AFloorCeilingBuilder) == 0x000A78, "Wrong size on AFloorCeilingBuilder");
static_assert(offsetof(AFloorCeilingBuilder, bShouldTileNotStretch) == 0x000A18, "Member 'AFloorCeilingBuilder::bShouldTileNotStretch' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, bBuildLayersUp) == 0x000A19, "Member 'AFloorCeilingBuilder::bBuildLayersUp' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, VoxelWorld) == 0x000A1A, "Member 'AFloorCeilingBuilder::VoxelWorld' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, Dimensions) == 0x000A1C, "Member 'AFloorCeilingBuilder::Dimensions' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, MaterialLayers) == 0x000A28, "Member 'AFloorCeilingBuilder::MaterialLayers' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, TopLightClass) == 0x000A38, "Member 'AFloorCeilingBuilder::TopLightClass' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, TopLightCount) == 0x000A40, "Member 'AFloorCeilingBuilder::TopLightCount' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, TopLightPattern) == 0x000A48, "Member 'AFloorCeilingBuilder::TopLightPattern' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, TopLightRotation) == 0x000A4C, "Member 'AFloorCeilingBuilder::TopLightRotation' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, BottomLightClass) == 0x000A58, "Member 'AFloorCeilingBuilder::BottomLightClass' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, BottomLightCount) == 0x000A60, "Member 'AFloorCeilingBuilder::BottomLightCount' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, BottomLightPattern) == 0x000A68, "Member 'AFloorCeilingBuilder::BottomLightPattern' has a wrong offset!");
static_assert(offsetof(AFloorCeilingBuilder, BottomLightRotation) == 0x000A6C, "Member 'AFloorCeilingBuilder::BottomLightRotation' has a wrong offset!");

// Class ThankYouVeryCool.TYVCPS5ActivityManager
// 0x0028 (0x0058 - 0x0030)
class UTYVCPS5ActivityManager final : public UGameInstanceSubsystem
{
public:
	class FString                                 CampaignActivityID;                                // 0x0030(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              PS5CampaignActivityRequested;                      // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckEndCampaign();
	void EndCampaign();
	bool IsCampaignActivityLaunchRequested();
	void ResetCampaignActivityLaunchRequest();
	void ResumeCampaign();
	void SimulateLaunchPS5CampaignActivity();
	void StartCampaign();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCPS5ActivityManager">();
	}
	static class UTYVCPS5ActivityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCPS5ActivityManager>();
	}
};
static_assert(alignof(UTYVCPS5ActivityManager) == 0x000008, "Wrong alignment on UTYVCPS5ActivityManager");
static_assert(sizeof(UTYVCPS5ActivityManager) == 0x000058, "Wrong size on UTYVCPS5ActivityManager");
static_assert(offsetof(UTYVCPS5ActivityManager, CampaignActivityID) == 0x000030, "Member 'UTYVCPS5ActivityManager::CampaignActivityID' has a wrong offset!");
static_assert(offsetof(UTYVCPS5ActivityManager, PS5CampaignActivityRequested) == 0x000040, "Member 'UTYVCPS5ActivityManager::PS5CampaignActivityRequested' has a wrong offset!");

// Class ThankYouVeryCool.FoamVoxelWorld
// 0x0080 (0x08F8 - 0x0878)
class AFoamVoxelWorld : public AVoxelWorld
{
public:
	class UVoxelTransformableGenerator*           OnNPCStarterGen;                                   // 0x0878(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelTransformableGeneratorInstanceWrapper* SeedStarterGen;                                    // 0x0880(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FoamMaterialInitial;                               // 0x0888(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FoamMaterialMaterializing;                         // 0x0890(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     FoamMaterialFinished;                              // 0x0898(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynFoamMaterial;                                   // 0x08A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BaseColorEndpoint;                                 // 0x08A8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EMEndpoint;                                        // 0x08B4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAdditionalWeight;                               // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C4[0x1C];                                     // 0x08C4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinZ;                                              // 0x08E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxZ;                                              // 0x08E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPC*                                   MyNPC;                                             // 0x08E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F0[0x4];                                      // 0x08F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestructionScale;                                  // 0x08F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DoDestruction();
	void DoLurch();
	void DoMaterialize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoamVoxelWorld">();
	}
	static class AFoamVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoamVoxelWorld>();
	}
};
static_assert(alignof(AFoamVoxelWorld) == 0x000008, "Wrong alignment on AFoamVoxelWorld");
static_assert(sizeof(AFoamVoxelWorld) == 0x0008F8, "Wrong size on AFoamVoxelWorld");
static_assert(offsetof(AFoamVoxelWorld, OnNPCStarterGen) == 0x000878, "Member 'AFoamVoxelWorld::OnNPCStarterGen' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, SeedStarterGen) == 0x000880, "Member 'AFoamVoxelWorld::SeedStarterGen' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, FoamMaterialInitial) == 0x000888, "Member 'AFoamVoxelWorld::FoamMaterialInitial' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, FoamMaterialMaterializing) == 0x000890, "Member 'AFoamVoxelWorld::FoamMaterialMaterializing' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, FoamMaterialFinished) == 0x000898, "Member 'AFoamVoxelWorld::FoamMaterialFinished' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, DynFoamMaterial) == 0x0008A0, "Member 'AFoamVoxelWorld::DynFoamMaterial' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, BaseColorEndpoint) == 0x0008A8, "Member 'AFoamVoxelWorld::BaseColorEndpoint' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, EMEndpoint) == 0x0008B4, "Member 'AFoamVoxelWorld::EMEndpoint' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, MaxAdditionalWeight) == 0x0008C0, "Member 'AFoamVoxelWorld::MaxAdditionalWeight' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, MinZ) == 0x0008E0, "Member 'AFoamVoxelWorld::MinZ' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, MaxZ) == 0x0008E4, "Member 'AFoamVoxelWorld::MaxZ' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, MyNPC) == 0x0008E8, "Member 'AFoamVoxelWorld::MyNPC' has a wrong offset!");
static_assert(offsetof(AFoamVoxelWorld, DestructionScale) == 0x0008F4, "Member 'AFoamVoxelWorld::DestructionScale' has a wrong offset!");

// Class ThankYouVeryCool.FootstepComponent
// 0x0068 (0x0118 - 0x00B0)
class UFootstepComponent : public UActorComponent
{
public:
	class AALSBaseCharacter*                      MyCharacter;                                       // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AImpactManager*                         ImpactManager;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EMaterialType, class USoundBase*>        MaterialSoundMap;                                  // 0x00C0(0x0050)(Edit, NativeAccessSpecifierPublic)
	int32                                         OverrideIndex;                                     // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateOnLand(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepComponent">();
	}
	static class UFootstepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepComponent>();
	}
};
static_assert(alignof(UFootstepComponent) == 0x000008, "Wrong alignment on UFootstepComponent");
static_assert(sizeof(UFootstepComponent) == 0x000118, "Wrong size on UFootstepComponent");
static_assert(offsetof(UFootstepComponent, MyCharacter) == 0x0000B0, "Member 'UFootstepComponent::MyCharacter' has a wrong offset!");
static_assert(offsetof(UFootstepComponent, ImpactManager) == 0x0000B8, "Member 'UFootstepComponent::ImpactManager' has a wrong offset!");
static_assert(offsetof(UFootstepComponent, MaterialSoundMap) == 0x0000C0, "Member 'UFootstepComponent::MaterialSoundMap' has a wrong offset!");
static_assert(offsetof(UFootstepComponent, OverrideIndex) == 0x000110, "Member 'UFootstepComponent::OverrideIndex' has a wrong offset!");

// Class ThankYouVeryCool.TYVCLight_Spot
// 0x0008 (0x0398 - 0x0390)
class ATYVCLight_Spot final : public ATYVCLight
{
public:
	class USpotLightComponent*                    SpotLight;                                         // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCLight_Spot">();
	}
	static class ATYVCLight_Spot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCLight_Spot>();
	}
};
static_assert(alignof(ATYVCLight_Spot) == 0x000008, "Wrong alignment on ATYVCLight_Spot");
static_assert(sizeof(ATYVCLight_Spot) == 0x000398, "Wrong size on ATYVCLight_Spot");
static_assert(offsetof(ATYVCLight_Spot, SpotLight) == 0x000390, "Member 'ATYVCLight_Spot::SpotLight' has a wrong offset!");

// Class ThankYouVeryCool.FormationPosition
// 0x0010 (0x0230 - 0x0220)
class AFormationPosition final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        RC;                                                // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FormationPosition">();
	}
	static class AFormationPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFormationPosition>();
	}
};
static_assert(alignof(AFormationPosition) == 0x000008, "Wrong alignment on AFormationPosition");
static_assert(sizeof(AFormationPosition) == 0x000230, "Wrong size on AFormationPosition");
static_assert(offsetof(AFormationPosition, RC) == 0x000228, "Member 'AFormationPosition::RC' has a wrong offset!");

// Class ThankYouVeryCool.GameMenuWidget
// 0x0008 (0x0268 - 0x0260)
class UGameMenuWidget : public UUserWidget
{
public:
	bool                                          bCurrentInputController;                           // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClosePauseScreen();
	void DoEndGameCredits();
	void DoPreGame();
	void FadeIn();
	void FadeOut();
	class UWidget* GetDefaultFocus();
	class UWidget* GetPauseDefaultFocus();
	void PlayVideos();
	void ShowArcadeScreen();
	void ShowCampaignLevelSelectScreen();
	void ShowChallengeScreen();
	void ShowPauseScreen();
	void ShowRogueScreen();
	void ShowThisVictoryWidget(class UUserWidget* InWidget);
	void StartArcade(EDifficulty Difficulty, EGameType GameType, bool bSpawnWithArmCannon, bool bCustomLevel, class UArcadeLevelAsset* InAsset, bool bBizarre);
	void StartLevelEditorLoad(class UArcadeLevelAssetWorkshop* LevelAsset);
	void StartLevelEditorNew(const class FString& LevelPath);
	void StartLevelEditorVox(const class FString& LevelPath);
	void StopVideos();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameMenuWidget">();
	}
	static class UGameMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameMenuWidget>();
	}
};
static_assert(alignof(UGameMenuWidget) == 0x000008, "Wrong alignment on UGameMenuWidget");
static_assert(sizeof(UGameMenuWidget) == 0x000268, "Wrong size on UGameMenuWidget");
static_assert(offsetof(UGameMenuWidget, bCurrentInputController) == 0x000260, "Member 'UGameMenuWidget::bCurrentInputController' has a wrong offset!");

// Class ThankYouVeryCool.TYVCConsoleLeaderboardManager
// 0x0098 (0x00C8 - 0x0030)
class UTYVCConsoleLeaderboardManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTYVCLeaderboardWriteData*              CurrentWrite;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTYVCLeaderboardReadData*               CurrentRead;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTYVCLeaderboardWriteData*>      WriteQueue;                                        // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTYVCLeaderboardReadData*>       ReadQueue;                                         // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x48];                                      // 0x0068(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& LevelName)> OnLBReadThrottled;                                 // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bWasReadThrottled;                                 // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSonyPrivilegeCheckComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCConsoleLeaderboardManager">();
	}
	static class UTYVCConsoleLeaderboardManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCConsoleLeaderboardManager>();
	}
};
static_assert(alignof(UTYVCConsoleLeaderboardManager) == 0x000008, "Wrong alignment on UTYVCConsoleLeaderboardManager");
static_assert(sizeof(UTYVCConsoleLeaderboardManager) == 0x0000C8, "Wrong size on UTYVCConsoleLeaderboardManager");
static_assert(offsetof(UTYVCConsoleLeaderboardManager, CurrentWrite) == 0x000038, "Member 'UTYVCConsoleLeaderboardManager::CurrentWrite' has a wrong offset!");
static_assert(offsetof(UTYVCConsoleLeaderboardManager, CurrentRead) == 0x000040, "Member 'UTYVCConsoleLeaderboardManager::CurrentRead' has a wrong offset!");
static_assert(offsetof(UTYVCConsoleLeaderboardManager, WriteQueue) == 0x000048, "Member 'UTYVCConsoleLeaderboardManager::WriteQueue' has a wrong offset!");
static_assert(offsetof(UTYVCConsoleLeaderboardManager, ReadQueue) == 0x000058, "Member 'UTYVCConsoleLeaderboardManager::ReadQueue' has a wrong offset!");
static_assert(offsetof(UTYVCConsoleLeaderboardManager, OnLBReadThrottled) == 0x0000B0, "Member 'UTYVCConsoleLeaderboardManager::OnLBReadThrottled' has a wrong offset!");
static_assert(offsetof(UTYVCConsoleLeaderboardManager, bWasReadThrottled) == 0x0000C0, "Member 'UTYVCConsoleLeaderboardManager::bWasReadThrottled' has a wrong offset!");

// Class ThankYouVeryCool.GameplayGask_EndArcade
// 0x0030 (0x0098 - 0x0068)
class UGameplayGask_EndArcade final : public UGameplayTask
{
public:
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              GameMode;                                          // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_UnloadNode*               UnloadNodeTask;                                    // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayGask_EndArcade* TaskEndArcade(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class AThankYouVeryCoolGameMode* InGameMode, EGameType InGameType, const uint8 Priority);

	void FadeOutOver();
	void NodeUnloaded(const TArray<class FName>& Levelnames);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayGask_EndArcade">();
	}
	static class UGameplayGask_EndArcade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayGask_EndArcade>();
	}
};
static_assert(alignof(UGameplayGask_EndArcade) == 0x000008, "Wrong alignment on UGameplayGask_EndArcade");
static_assert(sizeof(UGameplayGask_EndArcade) == 0x000098, "Wrong size on UGameplayGask_EndArcade");
static_assert(offsetof(UGameplayGask_EndArcade, GameMode) == 0x000080, "Member 'UGameplayGask_EndArcade::GameMode' has a wrong offset!");
static_assert(offsetof(UGameplayGask_EndArcade, UnloadNodeTask) == 0x000088, "Member 'UGameplayGask_EndArcade::UnloadNodeTask' has a wrong offset!");

// Class ThankYouVeryCool.GameplayHUD
// 0x0028 (0x0288 - 0x0260)
class UGameplayHUD : public UUserWidget
{
public:
	class UUserWidget*                            Compass;                                           // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCloverWidget*                          CloverWidget;                                      // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverclockWidget*                       OverclockWidget;                                   // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAmmoCountWidget*                       AmmoCountWidget;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAdamCrosshair*                         CrosshairWidget;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DoExploitDetected();
	void DoFresh(EFeat ForFeat);
	void DoStale(EFeat ForFeat);
	void FocusOnWeapon(class AWeaponBase* ToFocus);
	void NotifyCannonMode(ECannonMode NewMode);
	void RefreshCards();
	void SetAmmoViz(bool bViz, bool bAnimate);
	void SetCannonChargeViz(bool bIsViz);
	void SetCannonPercentage(float InPercent);
	void SetCannonShots(int32 Left, int32 Total);
	void SetCannonShotsViz(bool bIsViz);
	void SetCardsViz(bool bViz);
	void SetCompassViz(bool bViz, bool bAnimate);
	void SetCompressedHUD(bool bCompressed);
	void SetCrosshairTexture(class UTexture2D* ToSet);
	void SetCrosshairViz(bool bViz);
	void SetEnemiesRemaining(int32 Remaining, int32 Total);
	void SetKickPromptViz(bool Viz);
	void SetLuckViz(bool bViz, bool bAnimate);
	void SetMultiplier(int32 multiplier, bool bIsUp, bool bShouldAnimate);
	void SetMultiplierOnlyCorner(int32 multiplier);
	void SetNoWeaponFocus();
	void SetObjectiveProgress(float Progress);
	void SetObjectiveText(const class FString& InText, bool bDoNotify);
	void SetObjectiveViz(bool bViz, bool bAnimate);
	void SetScore(int32 Score);
	void SetSloMoViz(bool bViz, bool bAnimate);
	void SetSpeedrunnersViz(bool bIsViz);
	void SetupForMode(EGameType ForMode);
	void ShowArcadeOver(bool bArcadeOver);
	void ShowRemainingNotification(int32 Remaining);
	void UpdateChallengeCount(const TArray<struct FChallengeDisplay>& ToDisplay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayHUD">();
	}
	static class UGameplayHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayHUD>();
	}
};
static_assert(alignof(UGameplayHUD) == 0x000008, "Wrong alignment on UGameplayHUD");
static_assert(sizeof(UGameplayHUD) == 0x000288, "Wrong size on UGameplayHUD");
static_assert(offsetof(UGameplayHUD, Compass) == 0x000260, "Member 'UGameplayHUD::Compass' has a wrong offset!");
static_assert(offsetof(UGameplayHUD, CloverWidget) == 0x000268, "Member 'UGameplayHUD::CloverWidget' has a wrong offset!");
static_assert(offsetof(UGameplayHUD, OverclockWidget) == 0x000270, "Member 'UGameplayHUD::OverclockWidget' has a wrong offset!");
static_assert(offsetof(UGameplayHUD, AmmoCountWidget) == 0x000278, "Member 'UGameplayHUD::AmmoCountWidget' has a wrong offset!");
static_assert(offsetof(UGameplayHUD, CrosshairWidget) == 0x000280, "Member 'UGameplayHUD::CrosshairWidget' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_LoadChapter
// 0x0080 (0x00E8 - 0x0068)
class UGameplayTask_LoadChapter final : public UGameplayTask
{
public:
	class ACampaignManager*                       MyCampaignManager;                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTask_StartEditor*              StartEditorTask;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChapterSave*                           LoadedSave;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChapterSaveV2*                         LoadedSaveV2;                                      // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              LoadComplete;                                      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimerHandle                           CheckVoxelWorldResetHandle;                        // 0x00B0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_LoadNode*                 LoadNodeTask;                                      // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ResetNodeToGen*           ResetNodeTask;                                     // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AChapter*                               LoadedChapter;                                     // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCampaignDataAsset*                     LoadedCampaignAsset;                               // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ANPC*>                           NPCsToNotify;                                      // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UGameplayTask_LoadChapter* TaskLoadChapter(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const uint8 Priority);
	static class UGameplayTask_LoadChapter* TaskLoadChapterQuick(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const uint8 Priority);
	static class UGameplayTask_LoadChapter* TaskStartChapter(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class AChapter* InChapter, EDifficulty Difficulty, class UCampaignDataAsset* DataAsset, const uint8 Priority);

	void CheckVoxelWorldResetProgress();
	void DoLoad();
	void FadeOutOver();
	void NodeReset(const struct FTYVCNodeMemory& InNodeMemory);
	void PlayerRequestLevelStart();
	void PostNodeLoaded(const struct FTYVCNodeMemory& NodeMemory);
	void PostNonQuickLoad();
	void PostReset();
	void PostWorldsReady();
	void PQR();
	void VoxelDataLoaded(const struct FVoxelUncompressedWorldSave& Save);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_LoadChapter">();
	}
	static class UGameplayTask_LoadChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_LoadChapter>();
	}
};
static_assert(alignof(UGameplayTask_LoadChapter) == 0x000008, "Wrong alignment on UGameplayTask_LoadChapter");
static_assert(sizeof(UGameplayTask_LoadChapter) == 0x0000E8, "Wrong size on UGameplayTask_LoadChapter");
static_assert(offsetof(UGameplayTask_LoadChapter, MyCampaignManager) == 0x000068, "Member 'UGameplayTask_LoadChapter::MyCampaignManager' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, StartEditorTask) == 0x000070, "Member 'UGameplayTask_LoadChapter::StartEditorTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, LoadedSave) == 0x000078, "Member 'UGameplayTask_LoadChapter::LoadedSave' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, LoadedSaveV2) == 0x000080, "Member 'UGameplayTask_LoadChapter::LoadedSaveV2' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, LoadComplete) == 0x0000A0, "Member 'UGameplayTask_LoadChapter::LoadComplete' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, CheckVoxelWorldResetHandle) == 0x0000B0, "Member 'UGameplayTask_LoadChapter::CheckVoxelWorldResetHandle' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, LoadNodeTask) == 0x0000B8, "Member 'UGameplayTask_LoadChapter::LoadNodeTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, ResetNodeTask) == 0x0000C0, "Member 'UGameplayTask_LoadChapter::ResetNodeTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, LoadedChapter) == 0x0000C8, "Member 'UGameplayTask_LoadChapter::LoadedChapter' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, LoadedCampaignAsset) == 0x0000D0, "Member 'UGameplayTask_LoadChapter::LoadedCampaignAsset' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadChapter, NPCsToNotify) == 0x0000D8, "Member 'UGameplayTask_LoadChapter::NPCsToNotify' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_LoadNode
// 0x0138 (0x01A0 - 0x0068)
class UGameplayTask_LoadNode final : public UGameplayTask
{
public:
	uint8                                         Pad_68[0x50];                                      // 0x0068(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ACampaignManager*                       MyCampaignManager;                                 // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelDataAsset*                        EditorDataAsset;                                   // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         StandaloneWorlds;                                  // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AChapter*                               LoadedChapter;                                     // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x80];                                     // 0x0118(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              GameMode;                                          // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UGameplayTask_LoadNode* TaskLoadNode_ForArcade(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeName, class AThankYouVeryCoolGameMode* InGameMode, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, const uint8 Priority);
	static class UGameplayTask_LoadNode* TaskLoadNode_ForCampaign(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeName, class AChapter* InChapter, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, const uint8 Priority);
	static class UGameplayTask_LoadNode* TaskLoadNode_ForEditorLoad(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeName, class AThankYouVeryCoolGameMode* InGameMode, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, TDelegate<void()> PreVDel, const uint8 Priority);
	static class UGameplayTask_LoadNode* TaskLoadNode_ForEditorVox(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeName, class AThankYouVeryCoolGameMode* InGameMode, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, class UVoxelDataAsset* InDataAsset, TDelegate<void()> PreVDel, const uint8 Priority);

	void LevelLoaded();
	void NotifyVoxelWorldLoaded(class AVoxelWorld* LoadedWorld);
	void PostActorsSpawned();
	void TickCacheWorld();
	void TickLoadingStandalones(class AVoxelWorld* LoadedWorld);
	void UpdateTasksCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_LoadNode">();
	}
	static class UGameplayTask_LoadNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_LoadNode>();
	}
};
static_assert(alignof(UGameplayTask_LoadNode) == 0x000008, "Wrong alignment on UGameplayTask_LoadNode");
static_assert(sizeof(UGameplayTask_LoadNode) == 0x0001A0, "Wrong size on UGameplayTask_LoadNode");
static_assert(offsetof(UGameplayTask_LoadNode, MyCampaignManager) == 0x0000B8, "Member 'UGameplayTask_LoadNode::MyCampaignManager' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadNode, EditorDataAsset) == 0x0000D0, "Member 'UGameplayTask_LoadNode::EditorDataAsset' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadNode, StandaloneWorlds) == 0x0000F0, "Member 'UGameplayTask_LoadNode::StandaloneWorlds' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadNode, LoadedChapter) == 0x000110, "Member 'UGameplayTask_LoadNode::LoadedChapter' has a wrong offset!");
static_assert(offsetof(UGameplayTask_LoadNode, GameMode) == 0x000198, "Member 'UGameplayTask_LoadNode::GameMode' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_ResetArcade
// 0x0028 (0x0090 - 0x0068)
class UGameplayTask_ResetArcade final : public UGameplayTask
{
public:
	TDelegate<void()>                             OnResetCompleteForEditor;                          // 0x0068(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UGameplayTask_ResetNodeToGen*           ResetNodeTask;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForEditor;                                        // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              GameMode;                                          // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UGameplayTask_ResetArcade* TaskResetArcade(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class AThankYouVeryCoolGameMode* InGameMode, const uint8 Priority);
	static class UGameplayTask_ResetArcade* TaskResetEditor(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class AThankYouVeryCoolGameMode* InGameMode, TDelegate<void()> OnComplete, const uint8 Priority);

	void CountdownOver();
	void FadeOutOver();
	void PQR();
	void ResetComplete(const struct FTYVCNodeMemory& NodeMemory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ResetArcade">();
	}
	static class UGameplayTask_ResetArcade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ResetArcade>();
	}
};
static_assert(alignof(UGameplayTask_ResetArcade) == 0x000008, "Wrong alignment on UGameplayTask_ResetArcade");
static_assert(sizeof(UGameplayTask_ResetArcade) == 0x000090, "Wrong size on UGameplayTask_ResetArcade");
static_assert(offsetof(UGameplayTask_ResetArcade, OnResetCompleteForEditor) == 0x000068, "Member 'UGameplayTask_ResetArcade::OnResetCompleteForEditor' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ResetArcade, ResetNodeTask) == 0x000078, "Member 'UGameplayTask_ResetArcade::ResetNodeTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ResetArcade, bForEditor) == 0x000080, "Member 'UGameplayTask_ResetArcade::bForEditor' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ResetArcade, GameMode) == 0x000088, "Member 'UGameplayTask_ResetArcade::GameMode' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_ResetNodeToGen
// 0x0090 (0x00F8 - 0x0068)
class UGameplayTask_ResetNodeToGen final : public UGameplayTask
{
public:
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ACampaignManager*                       MyCampaignManager;                                 // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThankYouVeryCoolGameMode*              GameMode;                                          // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x38];                                      // 0x0098(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVoxelWorld*>                    PropWorlds;                                        // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayTask_ResetNodeToGen* TaskReloadVox(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class FName NodeName, class AThankYouVeryCoolGameMode* InGameMode, const TArray<struct FVoxelIntBox>& InPrimaryBoxes, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, const uint8 Priority);
	static class UGameplayTask_ResetNodeToGen* TaskResetNode(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class FName NodeName, class AThankYouVeryCoolGameMode* InGameMode, const TArray<struct FVoxelIntBox>& InPrimaryBoxes, TDelegate<void(const struct FTYVCNodeMemory& NodeMemory)> OnCompleteDel, const uint8 Priority);

	void CheckLevelResetProgress();
	void NotifyVoxelWorldLoaded();
	void TickLoadingStandalones();
	void WorldLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ResetNodeToGen">();
	}
	static class UGameplayTask_ResetNodeToGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ResetNodeToGen>();
	}
};
static_assert(alignof(UGameplayTask_ResetNodeToGen) == 0x000008, "Wrong alignment on UGameplayTask_ResetNodeToGen");
static_assert(sizeof(UGameplayTask_ResetNodeToGen) == 0x0000F8, "Wrong size on UGameplayTask_ResetNodeToGen");
static_assert(offsetof(UGameplayTask_ResetNodeToGen, MyCampaignManager) == 0x000088, "Member 'UGameplayTask_ResetNodeToGen::MyCampaignManager' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ResetNodeToGen, GameMode) == 0x000090, "Member 'UGameplayTask_ResetNodeToGen::GameMode' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ResetNodeToGen, PropWorlds) == 0x0000D0, "Member 'UGameplayTask_ResetNodeToGen::PropWorlds' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_SaveChapter
// 0x0038 (0x00A0 - 0x0068)
class UGameplayTask_SaveChapter final : public UGameplayTask
{
public:
	class ACampaignManager*                       MyCampaignManager;                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChapterSave*                           WorkingSave;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   NodeToSave;                                        // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              SaveComplete;                                      // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bSaving;                                           // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTYVCSaveController*                    TYVCSaveController;                                // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UGameplayTask_SaveChapter* TaskSaveChapter(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class FName InNode, const uint8 Priority);

	void AsyncSaveDone(const class FString& Name_0, const int32 Slot, bool bSuccess);
	void GetCompleteSave(const struct FVoxelUncompressedWorldSave& Save);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_SaveChapter">();
	}
	static class UGameplayTask_SaveChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_SaveChapter>();
	}
};
static_assert(alignof(UGameplayTask_SaveChapter) == 0x000008, "Wrong alignment on UGameplayTask_SaveChapter");
static_assert(sizeof(UGameplayTask_SaveChapter) == 0x0000A0, "Wrong size on UGameplayTask_SaveChapter");
static_assert(offsetof(UGameplayTask_SaveChapter, MyCampaignManager) == 0x000068, "Member 'UGameplayTask_SaveChapter::MyCampaignManager' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SaveChapter, WorkingSave) == 0x000070, "Member 'UGameplayTask_SaveChapter::WorkingSave' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SaveChapter, NodeToSave) == 0x000078, "Member 'UGameplayTask_SaveChapter::NodeToSave' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SaveChapter, SaveComplete) == 0x000080, "Member 'UGameplayTask_SaveChapter::SaveComplete' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SaveChapter, bSaving) == 0x000090, "Member 'UGameplayTask_SaveChapter::bSaving' has a wrong offset!");
static_assert(offsetof(UGameplayTask_SaveChapter, TYVCSaveController) == 0x000098, "Member 'UGameplayTask_SaveChapter::TYVCSaveController' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_ShowText
// 0x0050 (0x00B8 - 0x0068)
class UGameplayTask_ShowText final : public UGameplayTask
{
public:
	class ACampaignManager*                       MyCampaignManager;                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   MyText;                                            // 0x0070(0x0018)(NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              OnShowTextFinish;                                  // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextDisplayWidget*                     TextWidget;                                        // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECharacter                                    ForCharacter;                                      // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayTask_ShowText* TaskIntermissionText(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FText& InText, ECharacter InForCharacter, const uint8 Priority);
	static class UGameplayTask_ShowText* TaskTutorialText(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FText& InText, const uint8 Priority);

	void KillMe();
	void MarkComplete();
	void MsgComplete();
	void PauseStatusChanged(bool bPauseStatus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_ShowText">();
	}
	static class UGameplayTask_ShowText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_ShowText>();
	}
};
static_assert(alignof(UGameplayTask_ShowText) == 0x000008, "Wrong alignment on UGameplayTask_ShowText");
static_assert(sizeof(UGameplayTask_ShowText) == 0x0000B8, "Wrong size on UGameplayTask_ShowText");
static_assert(offsetof(UGameplayTask_ShowText, MyCampaignManager) == 0x000068, "Member 'UGameplayTask_ShowText::MyCampaignManager' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ShowText, MyText) == 0x000070, "Member 'UGameplayTask_ShowText::MyText' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ShowText, OnShowTextFinish) == 0x000088, "Member 'UGameplayTask_ShowText::OnShowTextFinish' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ShowText, TextWidget) == 0x0000A8, "Member 'UGameplayTask_ShowText::TextWidget' has a wrong offset!");
static_assert(offsetof(UGameplayTask_ShowText, ForCharacter) == 0x0000B0, "Member 'UGameplayTask_ShowText::ForCharacter' has a wrong offset!");

// Class ThankYouVeryCool.TYVCVoxelWorld
// 0x0018 (0x0890 - 0x0878)
class ATYVCVoxelWorld : public AVoxelWorld
{
public:
	uint8                                         Pad_878[0x18];                                     // 0x0878(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCVoxelWorld">();
	}
	static class ATYVCVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCVoxelWorld>();
	}
};
static_assert(alignof(ATYVCVoxelWorld) == 0x000008, "Wrong alignment on ATYVCVoxelWorld");
static_assert(sizeof(ATYVCVoxelWorld) == 0x000890, "Wrong size on ATYVCVoxelWorld");

// Class ThankYouVeryCool.TYVCInteractableVoxelWorld
// 0x0028 (0x08B8 - 0x0890)
class ATYVCInteractableVoxelWorld final : public ATYVCVoxelWorld
{
public:
	uint8                                         Pad_890[0x8];                                      // 0x0890(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       PromptComponent;                                   // 0x0898(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A0[0x18];                                     // 0x08A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCInteractableVoxelWorld">();
	}
	static class ATYVCInteractableVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCInteractableVoxelWorld>();
	}
};
static_assert(alignof(ATYVCInteractableVoxelWorld) == 0x000008, "Wrong alignment on ATYVCInteractableVoxelWorld");
static_assert(sizeof(ATYVCInteractableVoxelWorld) == 0x0008B8, "Wrong size on ATYVCInteractableVoxelWorld");
static_assert(offsetof(ATYVCInteractableVoxelWorld, PromptComponent) == 0x000898, "Member 'ATYVCInteractableVoxelWorld::PromptComponent' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_StartArcade
// 0x0050 (0x00B8 - 0x0068)
class UGameplayTask_StartArcade final : public UGameplayTask
{
public:
	class UArcadeLevelAsset*                      LOverride;                                         // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_LoadNode*                 LoadNodeTask;                                      // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_StartEditor*              StartEditorTask;                                   // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              GameMode;                                          // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayTask_StartArcade* TaskStartArcade(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, EDifficulty InDifficulty, class AThankYouVeryCoolGameMode* InGameMode, EGameType InGameType, bool bCustomLevel, class UArcadeLevelAsset* InArcadeAsset, const uint8 Priority);

	void CountdownOver();
	void FadeOutOver();
	void PostNodeLoaded(const struct FTYVCNodeMemory& NodeMemory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_StartArcade">();
	}
	static class UGameplayTask_StartArcade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_StartArcade>();
	}
};
static_assert(alignof(UGameplayTask_StartArcade) == 0x000008, "Wrong alignment on UGameplayTask_StartArcade");
static_assert(sizeof(UGameplayTask_StartArcade) == 0x0000B8, "Wrong size on UGameplayTask_StartArcade");
static_assert(offsetof(UGameplayTask_StartArcade, LOverride) == 0x000068, "Member 'UGameplayTask_StartArcade::LOverride' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartArcade, LoadNodeTask) == 0x000070, "Member 'UGameplayTask_StartArcade::LoadNodeTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartArcade, StartEditorTask) == 0x000078, "Member 'UGameplayTask_StartArcade::StartEditorTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartArcade, GameMode) == 0x0000A8, "Member 'UGameplayTask_StartArcade::GameMode' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_StartEditor
// 0x0068 (0x00D0 - 0x0068)
class UGameplayTask_StartEditor final : public UGameplayTask
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelEditorManager*                    LevelEditorManager;                                // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_LoadNode*                 LoadNodeTask;                                      // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelDataAsset*                        MagicaAsset;                                       // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ResetNodeToGen*           ResetNodeTask;                                     // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArcadeLevelAsset*                      LevelAsset;                                        // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelEditorSave*                       LoadedSave;                                        // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UGameplayTask_StartEditor* TaskReloadVox(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FString& InVoxPath, class ALevelEditorManager* InLevelEditorManager, const uint8 Priority);
	static class UGameplayTask_StartEditor* TaskStartEditorLoad(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class UArcadeLevelAsset* InLevelAsset, class ALevelEditorManager* InLevelEditorManager, bool bForArcade, const uint8 Priority, class ULevelEditorSave* SaveOverride);
	static class UGameplayTask_StartEditor* TaskStartEditorNew(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FString& NewName, class ALevelEditorManager* InLevelEditorManager, const uint8 Priority);
	static class UGameplayTask_StartEditor* TaskStartEditorVox(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const class FString& InVoxPath, class ALevelEditorManager* InLevelEditorManager, const uint8 Priority);

	void FadeOutOver();
	void PostNodeLoad(const struct FTYVCNodeMemory& NodeMemory);
	void PostSpawnSaved();
	void PreV();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_StartEditor">();
	}
	static class UGameplayTask_StartEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_StartEditor>();
	}
};
static_assert(alignof(UGameplayTask_StartEditor) == 0x000008, "Wrong alignment on UGameplayTask_StartEditor");
static_assert(sizeof(UGameplayTask_StartEditor) == 0x0000D0, "Wrong size on UGameplayTask_StartEditor");
static_assert(offsetof(UGameplayTask_StartEditor, LevelEditorManager) == 0x000070, "Member 'UGameplayTask_StartEditor::LevelEditorManager' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartEditor, LoadNodeTask) == 0x000078, "Member 'UGameplayTask_StartEditor::LoadNodeTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartEditor, TYVCGameMode) == 0x000088, "Member 'UGameplayTask_StartEditor::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartEditor, MagicaAsset) == 0x0000A8, "Member 'UGameplayTask_StartEditor::MagicaAsset' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartEditor, ResetNodeTask) == 0x0000B0, "Member 'UGameplayTask_StartEditor::ResetNodeTask' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartEditor, LevelAsset) == 0x0000B8, "Member 'UGameplayTask_StartEditor::LevelAsset' has a wrong offset!");
static_assert(offsetof(UGameplayTask_StartEditor, LoadedSave) == 0x0000C8, "Member 'UGameplayTask_StartEditor::LoadedSave' has a wrong offset!");

// Class ThankYouVeryCool.SquadTask_AllTakeCover
// 0x0048 (0x00C0 - 0x0078)
class USquadTask_AllTakeCover final : public USquadTask_Base
{
public:
	class UBehaviorTree*                          TakeCoverLeaderTree;                               // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTree*                          TakeCoverFollowerTree;                             // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBlackboardKeySelector                 LeaderLocationKey;                                 // 0x0088(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadTask_AllTakeCover">();
	}
	static class USquadTask_AllTakeCover* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadTask_AllTakeCover>();
	}
};
static_assert(alignof(USquadTask_AllTakeCover) == 0x000008, "Wrong alignment on USquadTask_AllTakeCover");
static_assert(sizeof(USquadTask_AllTakeCover) == 0x0000C0, "Wrong size on USquadTask_AllTakeCover");
static_assert(offsetof(USquadTask_AllTakeCover, TakeCoverLeaderTree) == 0x000078, "Member 'USquadTask_AllTakeCover::TakeCoverLeaderTree' has a wrong offset!");
static_assert(offsetof(USquadTask_AllTakeCover, TakeCoverFollowerTree) == 0x000080, "Member 'USquadTask_AllTakeCover::TakeCoverFollowerTree' has a wrong offset!");
static_assert(offsetof(USquadTask_AllTakeCover, LeaderLocationKey) == 0x000088, "Member 'USquadTask_AllTakeCover::LeaderLocationKey' has a wrong offset!");

// Class ThankYouVeryCool.GameplayTask_UnloadNode
// 0x00D0 (0x0138 - 0x0068)
class UGameplayTask_UnloadNode final : public UGameplayTask
{
public:
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ACampaignManager*                       MyCampaignManager;                                 // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0xA8];                                      // 0x0090(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UGameplayTask_UnloadNode* TaskUnloadNode_ForCampaign(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, const TArray<class FName>& NodeNames, TDelegate<void(const TArray<class FName>& UnloadedName)> OnCompleteDel, const struct FTYVCNodeMemory& InNodeMemory, const uint8 Priority);

	void LevelUnloaded();
	void TickDeleteCache();
	void TickUnloadVoxelWorld();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayTask_UnloadNode">();
	}
	static class UGameplayTask_UnloadNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayTask_UnloadNode>();
	}
};
static_assert(alignof(UGameplayTask_UnloadNode) == 0x000008, "Wrong alignment on UGameplayTask_UnloadNode");
static_assert(sizeof(UGameplayTask_UnloadNode) == 0x000138, "Wrong size on UGameplayTask_UnloadNode");
static_assert(offsetof(UGameplayTask_UnloadNode, MyCampaignManager) == 0x000080, "Member 'UGameplayTask_UnloadNode::MyCampaignManager' has a wrong offset!");
static_assert(offsetof(UGameplayTask_UnloadNode, TYVCGameMode) == 0x000088, "Member 'UGameplayTask_UnloadNode::TYVCGameMode' has a wrong offset!");

// Class ThankYouVeryCool.GenericGridSpawner
// 0x0040 (0x0A58 - 0x0A18)
class AGenericGridSpawner final : public AVoxelBuilder2
{
public:
	TSubclassOf<class AVoxelBuilder2>             ToSpawn;                                           // 0x0A18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              Dimensions;                                        // 0x0A20(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<uint32>                                RowsToSkip;                                        // 0x0A28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<uint32>                                ColumnsToSkip;                                     // 0x0A38(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FVector2D                              GridCount;                                         // 0x0A48(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EGridPattern                                  GridPattern;                                       // 0x0A50(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A51[0x7];                                      // 0x0A51(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericGridSpawner">();
	}
	static class AGenericGridSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGenericGridSpawner>();
	}
};
static_assert(alignof(AGenericGridSpawner) == 0x000008, "Wrong alignment on AGenericGridSpawner");
static_assert(sizeof(AGenericGridSpawner) == 0x000A58, "Wrong size on AGenericGridSpawner");
static_assert(offsetof(AGenericGridSpawner, ToSpawn) == 0x000A18, "Member 'AGenericGridSpawner::ToSpawn' has a wrong offset!");
static_assert(offsetof(AGenericGridSpawner, Dimensions) == 0x000A20, "Member 'AGenericGridSpawner::Dimensions' has a wrong offset!");
static_assert(offsetof(AGenericGridSpawner, RowsToSkip) == 0x000A28, "Member 'AGenericGridSpawner::RowsToSkip' has a wrong offset!");
static_assert(offsetof(AGenericGridSpawner, ColumnsToSkip) == 0x000A38, "Member 'AGenericGridSpawner::ColumnsToSkip' has a wrong offset!");
static_assert(offsetof(AGenericGridSpawner, GridCount) == 0x000A48, "Member 'AGenericGridSpawner::GridCount' has a wrong offset!");
static_assert(offsetof(AGenericGridSpawner, GridPattern) == 0x000A50, "Member 'AGenericGridSpawner::GridPattern' has a wrong offset!");

// Class ThankYouVeryCool.ValidateCoverPoint
// 0x00F0 (0x0160 - 0x0070)
class UValidateCoverPoint final : public UBTService
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 DrawDebug;                                         // 0x0078(0x0028)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIsForSuppression;                                 // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 CoverLocation;                                     // 0x00A8(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 OutputBool;                                        // 0x00D0(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Enemy;                                             // 0x00F8(0x0028)(Edit, NativeAccessSpecifierPublic)
	float                                         AttackRange;                                       // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAttackRange;                                    // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponLeanOffset;                                  // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverPointMaxObjectHitDistance;                    // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 LeanDirectionOutput;                               // 0x0138(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ValidateCoverPoint">();
	}
	static class UValidateCoverPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UValidateCoverPoint>();
	}
};
static_assert(alignof(UValidateCoverPoint) == 0x000008, "Wrong alignment on UValidateCoverPoint");
static_assert(sizeof(UValidateCoverPoint) == 0x000160, "Wrong size on UValidateCoverPoint");
static_assert(offsetof(UValidateCoverPoint, DrawDebug) == 0x000078, "Member 'UValidateCoverPoint::DrawDebug' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, bIsForSuppression) == 0x0000A0, "Member 'UValidateCoverPoint::bIsForSuppression' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, CoverLocation) == 0x0000A8, "Member 'UValidateCoverPoint::CoverLocation' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, OutputBool) == 0x0000D0, "Member 'UValidateCoverPoint::OutputBool' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, Enemy) == 0x0000F8, "Member 'UValidateCoverPoint::Enemy' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, AttackRange) == 0x000120, "Member 'UValidateCoverPoint::AttackRange' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, MinAttackRange) == 0x000124, "Member 'UValidateCoverPoint::MinAttackRange' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, WeaponLeanOffset) == 0x000128, "Member 'UValidateCoverPoint::WeaponLeanOffset' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, CoverPointMaxObjectHitDistance) == 0x00012C, "Member 'UValidateCoverPoint::CoverPointMaxObjectHitDistance' has a wrong offset!");
static_assert(offsetof(UValidateCoverPoint, LeanDirectionOutput) == 0x000138, "Member 'UValidateCoverPoint::LeanDirectionOutput' has a wrong offset!");

// Class ThankYouVeryCool.GlassVoxelWorld
// 0x0068 (0x0AF8 - 0x0A90)
class AGlassVoxelWorld : public AColumnBuilder
{
public:
	uint8                                         Pad_A90[0x18];                                     // 0x0A90(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     PristineMat;                                       // 0x0AA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  MyGUID;                                            // 0x0AB0(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC0[0x8];                                      // 0x0AC0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ShatteredMatRaw;                                   // 0x0AC8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPaper;                                          // 0x0AD0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD1[0x7];                                      // 0x0AD1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ShatteredMat;                                      // 0x0AD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipShatteredTexture;                             // 0x0AE0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE1[0x3];                                      // 0x0AE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MyDims;                                            // 0x0AE4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          CollComp;                                          // 0x0AF0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DoHole(const struct FVector& Location, float HoleRadius, const struct FVector& DirVec, bool bDoDebris);
	void EditorModeChanged_Implementation(EEditMode NewMode);
	void LevelReady();
	void MakeDebris(const struct FVector& DirVec, const TArray<struct FModifiedVoxelValue>& ModdelVals);
	void SetDims(int32 InLength, int32 InHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassVoxelWorld">();
	}
	static class AGlassVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGlassVoxelWorld>();
	}
};
static_assert(alignof(AGlassVoxelWorld) == 0x000008, "Wrong alignment on AGlassVoxelWorld");
static_assert(sizeof(AGlassVoxelWorld) == 0x000AF8, "Wrong size on AGlassVoxelWorld");
static_assert(offsetof(AGlassVoxelWorld, PristineMat) == 0x000AA8, "Member 'AGlassVoxelWorld::PristineMat' has a wrong offset!");
static_assert(offsetof(AGlassVoxelWorld, MyGUID) == 0x000AB0, "Member 'AGlassVoxelWorld::MyGUID' has a wrong offset!");
static_assert(offsetof(AGlassVoxelWorld, ShatteredMatRaw) == 0x000AC8, "Member 'AGlassVoxelWorld::ShatteredMatRaw' has a wrong offset!");
static_assert(offsetof(AGlassVoxelWorld, bIsPaper) == 0x000AD0, "Member 'AGlassVoxelWorld::bIsPaper' has a wrong offset!");
static_assert(offsetof(AGlassVoxelWorld, ShatteredMat) == 0x000AD8, "Member 'AGlassVoxelWorld::ShatteredMat' has a wrong offset!");
static_assert(offsetof(AGlassVoxelWorld, bSkipShatteredTexture) == 0x000AE0, "Member 'AGlassVoxelWorld::bSkipShatteredTexture' has a wrong offset!");
static_assert(offsetof(AGlassVoxelWorld, MyDims) == 0x000AE4, "Member 'AGlassVoxelWorld::MyDims' has a wrong offset!");
static_assert(offsetof(AGlassVoxelWorld, CollComp) == 0x000AF0, "Member 'AGlassVoxelWorld::CollComp' has a wrong offset!");

// Class ThankYouVeryCool.M203_Round
// 0x0058 (0x02E0 - 0x0288)
class AM203_Round : public APoolableActor
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CollisionComp;                                     // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               TrailComp;                                         // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionSize;                                     // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EditSize;                                          // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionSizeNPC;                                  // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        HitSpark;                                          // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MyLauncher;                                        // 0x02C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PlayerKickedSound;                                 // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddIgnoredActor(class AActor* ToIgnore);
	void Launch(const struct FTransform& StartTransform, bool bInFiredByPlayer, class AActor* Launcher);
	void MakeDormantBP();
	void NadeOverlap(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnStop(const struct FHitResult& ImpactResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"M203_Round">();
	}
	static class AM203_Round* GetDefaultObj()
	{
		return GetDefaultObjImpl<AM203_Round>();
	}
};
static_assert(alignof(AM203_Round) == 0x000008, "Wrong alignment on AM203_Round");
static_assert(sizeof(AM203_Round) == 0x0002E0, "Wrong size on AM203_Round");
static_assert(offsetof(AM203_Round, StaticMesh) == 0x000288, "Member 'AM203_Round::StaticMesh' has a wrong offset!");
static_assert(offsetof(AM203_Round, CollisionComp) == 0x000290, "Member 'AM203_Round::CollisionComp' has a wrong offset!");
static_assert(offsetof(AM203_Round, ProjectileMovementComponent) == 0x000298, "Member 'AM203_Round::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AM203_Round, TrailComp) == 0x0002A0, "Member 'AM203_Round::TrailComp' has a wrong offset!");
static_assert(offsetof(AM203_Round, ExplosionSize) == 0x0002A8, "Member 'AM203_Round::ExplosionSize' has a wrong offset!");
static_assert(offsetof(AM203_Round, EditSize) == 0x0002AC, "Member 'AM203_Round::EditSize' has a wrong offset!");
static_assert(offsetof(AM203_Round, ExplosionSizeNPC) == 0x0002B0, "Member 'AM203_Round::ExplosionSizeNPC' has a wrong offset!");
static_assert(offsetof(AM203_Round, HitSpark) == 0x0002B8, "Member 'AM203_Round::HitSpark' has a wrong offset!");
static_assert(offsetof(AM203_Round, MyLauncher) == 0x0002C8, "Member 'AM203_Round::MyLauncher' has a wrong offset!");
static_assert(offsetof(AM203_Round, PlayerKickedSound) == 0x0002D0, "Member 'AM203_Round::PlayerKickedSound' has a wrong offset!");

// Class ThankYouVeryCool.TextDisplayWidget
// 0x0018 (0x0278 - 0x0260)
class UTextDisplayWidget : public UUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnRequestNext;                                     // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	class URichTextBlock*                         IntermissionDialogue;                              // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void MarkAsComplete();
	void SetupForCharacter(ECharacter InForCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TextDisplayWidget">();
	}
	static class UTextDisplayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTextDisplayWidget>();
	}
};
static_assert(alignof(UTextDisplayWidget) == 0x000008, "Wrong alignment on UTextDisplayWidget");
static_assert(sizeof(UTextDisplayWidget) == 0x000278, "Wrong size on UTextDisplayWidget");
static_assert(offsetof(UTextDisplayWidget, OnRequestNext) == 0x000260, "Member 'UTextDisplayWidget::OnRequestNext' has a wrong offset!");
static_assert(offsetof(UTextDisplayWidget, IntermissionDialogue) == 0x000270, "Member 'UTextDisplayWidget::IntermissionDialogue' has a wrong offset!");

// Class ThankYouVeryCool.Goop
// 0x0020 (0x0300 - 0x02E0)
class AGoop : public AM203_Round
{
public:
	float                                         SpinSpeed;                                         // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AArmCannon*                             MyArmCannon;                                       // 0x02E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GoopParticle;                                      // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               MistComp;                                          // 0x02F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Goop">();
	}
	static class AGoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGoop>();
	}
};
static_assert(alignof(AGoop) == 0x000008, "Wrong alignment on AGoop");
static_assert(sizeof(AGoop) == 0x000300, "Wrong size on AGoop");
static_assert(offsetof(AGoop, SpinSpeed) == 0x0002E0, "Member 'AGoop::SpinSpeed' has a wrong offset!");
static_assert(offsetof(AGoop, MyArmCannon) == 0x0002E8, "Member 'AGoop::MyArmCannon' has a wrong offset!");
static_assert(offsetof(AGoop, GoopParticle) == 0x0002F0, "Member 'AGoop::GoopParticle' has a wrong offset!");
static_assert(offsetof(AGoop, MistComp) == 0x0002F8, "Member 'AGoop::MistComp' has a wrong offset!");

// Class ThankYouVeryCool.GunAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UGunAnimInstance : public UAnimInstance
{
public:
	bool                                          bIsEmpty;                                          // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          EmptyPose;                                         // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          LoadedPose;                                        // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunAnimInstance">();
	}
	static class UGunAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunAnimInstance>();
	}
};
static_assert(alignof(UGunAnimInstance) == 0x000010, "Wrong alignment on UGunAnimInstance");
static_assert(sizeof(UGunAnimInstance) == 0x0002D0, "Wrong size on UGunAnimInstance");
static_assert(offsetof(UGunAnimInstance, bIsEmpty) == 0x0002B8, "Member 'UGunAnimInstance::bIsEmpty' has a wrong offset!");
static_assert(offsetof(UGunAnimInstance, EmptyPose) == 0x0002C0, "Member 'UGunAnimInstance::EmptyPose' has a wrong offset!");
static_assert(offsetof(UGunAnimInstance, LoadedPose) == 0x0002C8, "Member 'UGunAnimInstance::LoadedPose' has a wrong offset!");

// Class ThankYouVeryCool.TYVCPlayerController
// 0x0060 (0x05D0 - 0x0570)
class ATYVCPlayerController : public APlayerController
{
public:
	TSubclassOf<class UUserWidget>                GameHUDClass;                                      // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameplayHUD>               EveHUDClass;                                       // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastInputController;                              // 0x0580(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x7];                                      // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTYVCHUD*                               TYVCGameHUD;                                       // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       Eve;                                               // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayHUD*                           EveHUD;                                            // 0x0598(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x05A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                ControllerDisconnectedWidgetClass;                 // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ControllerDisconnectedWidget;                      // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x18];                                     // 0x05B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetGamertag();
	class FString GetGamertagSuffix();
	class UTYVCHUD* GetTYVCHUD();
	bool IsControllerConnected();
	bool IsSwitchHandheldController();
	bool IsSwitchProController();
	class UGameplayHUD* RequestEveHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCPlayerController">();
	}
	static class ATYVCPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCPlayerController>();
	}
};
static_assert(alignof(ATYVCPlayerController) == 0x000008, "Wrong alignment on ATYVCPlayerController");
static_assert(sizeof(ATYVCPlayerController) == 0x0005D0, "Wrong size on ATYVCPlayerController");
static_assert(offsetof(ATYVCPlayerController, GameHUDClass) == 0x000570, "Member 'ATYVCPlayerController::GameHUDClass' has a wrong offset!");
static_assert(offsetof(ATYVCPlayerController, EveHUDClass) == 0x000578, "Member 'ATYVCPlayerController::EveHUDClass' has a wrong offset!");
static_assert(offsetof(ATYVCPlayerController, bLastInputController) == 0x000580, "Member 'ATYVCPlayerController::bLastInputController' has a wrong offset!");
static_assert(offsetof(ATYVCPlayerController, TYVCGameHUD) == 0x000588, "Member 'ATYVCPlayerController::TYVCGameHUD' has a wrong offset!");
static_assert(offsetof(ATYVCPlayerController, Eve) == 0x000590, "Member 'ATYVCPlayerController::Eve' has a wrong offset!");
static_assert(offsetof(ATYVCPlayerController, EveHUD) == 0x000598, "Member 'ATYVCPlayerController::EveHUD' has a wrong offset!");
static_assert(offsetof(ATYVCPlayerController, TYVCGameMode) == 0x0005A0, "Member 'ATYVCPlayerController::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ATYVCPlayerController, ControllerDisconnectedWidgetClass) == 0x0005A8, "Member 'ATYVCPlayerController::ControllerDisconnectedWidgetClass' has a wrong offset!");
static_assert(offsetof(ATYVCPlayerController, ControllerDisconnectedWidget) == 0x0005B0, "Member 'ATYVCPlayerController::ControllerDisconnectedWidget' has a wrong offset!");

// Class ThankYouVeryCool.HealingGlassDecal
// 0x0018 (0x02A0 - 0x0288)
class AHealingGlassDecal : public APoolableActor
{
public:
	class UStaticMeshComponent*                   SMComp;                                            // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               DynMat;                                            // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LifeTime;                                          // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealingGlassDecal">();
	}
	static class AHealingGlassDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHealingGlassDecal>();
	}
};
static_assert(alignof(AHealingGlassDecal) == 0x000008, "Wrong alignment on AHealingGlassDecal");
static_assert(sizeof(AHealingGlassDecal) == 0x0002A0, "Wrong size on AHealingGlassDecal");
static_assert(offsetof(AHealingGlassDecal, SMComp) == 0x000288, "Member 'AHealingGlassDecal::SMComp' has a wrong offset!");
static_assert(offsetof(AHealingGlassDecal, DynMat) == 0x000290, "Member 'AHealingGlassDecal::DynMat' has a wrong offset!");
static_assert(offsetof(AHealingGlassDecal, LifeTime) == 0x000298, "Member 'AHealingGlassDecal::LifeTime' has a wrong offset!");

// Class ThankYouVeryCool.ImpactManager
// 0x0780 (0x09A0 - 0x0220)
class alignas(0x10) AImpactManager : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bNewStatus)> OnSlowMoChange;                                    // 0x0228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x40];                                     // 0x0238(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDoingXGraph;                                    // 0x0278(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         DebrisSystem;                                      // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOfLastVoxelResultGather;                       // 0x0288(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         TracerSystem;                                      // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TracerSystemLaser;                                 // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TracerSystemNPP;                                   // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            KickSpeedDmgMultipierCurve;                        // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameRadius;                                       // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OCRadius;                                          // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameRange;                                        // 0x02B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OCRange;                                           // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlameRays;                                         // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OCRays;                                            // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         TracerSystemMinigun;                               // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactCullDistance;                                // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APoolableGlass>             PoolableGlassClass;                                // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APoolableBlood>             PoolableBloodClass;                                // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BloodMinGap;                                       // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0xC];                                      // 0x02EC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNPCEditsPerTick;                                // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x8];                                      // 0x02FC(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             PhysicsCheckExtents;                               // 0x0304(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             ShatterCheckExtents;                               // 0x0310(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             FoamCheckExtents;                                  // 0x031C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           ExplosionShake;                                    // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ExplosionForceFeedback;                            // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   GlassForceFeedback;                                // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNiagaraComponent*>              GibSystems;                                        // 0x0340(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           GunShake;                                          // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APoolableFire>              PoolableFireClass;                                 // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenFlameSpawn;                             // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x34];                                     // 0x0364(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsWaitingForPhysicsTask;                          // 0x0398(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGlooInfo>                      GlooInfo;                                          // 0x03A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class AVoxelWorld*, struct FVector>      SpawnedWorldsToPhysicsCheck;                       // 0x03B0(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APropVoxelWorld>            PhysicsWorldClass;                                 // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        StickParticle;                                     // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_438[0x4];                                      // 0x0438(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBulletTraceViz                        LazerLook;                                         // 0x043C(0x001C)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	EDestructionDetail                            DestructionDetail;                                 // 0x0458(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundConcurrency*                      ImpactSoundConcurrencyRules;                       // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FleshSound;                                        // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             WhizSound;                                         // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APoolableDecal>             ExplosionDecalClass;                               // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactSoundChance;                                 // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        PaintParticle;                                     // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      ImpactSoundAttenuation;                            // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityToStick;                                // 0x0498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundMix*                              SlowMoMixModifier;                                 // 0x04A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PaintRadius;                                       // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AC[0x4];                                      // 0x04AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DummyRoot;                                         // 0x04B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FImpactConfig                          ImpactConfig;                                      // 0x04B8(0x0060)(Edit, NativeAccessSpecifierPublic)
	bool                                          bIsDebugMode;                                      // 0x0518(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_519[0x7];                                      // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialProperties>            MatPropsList;                                      // 0x0520(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FMaterialProperties>       SpecialIndices;                                    // 0x0530(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         TestInnerRadius;                                   // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URadialForceComponent*                  RadialForceComp;                                   // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ExplosionFX;                                       // 0x0590(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ExplosionFXOverrideSimplified;                     // 0x0598(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ExplosionFXNiagara;                                // 0x05A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         ExplosionFXNiagaraSimplified;                      // 0x05A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ExplosionSound;                                    // 0x05B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TestDirection;                                     // 0x05B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C4[0x4];                                      // 0x05C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UVoxelProceduralMeshComponent> ShatterMeshClass;                                  // 0x05C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TestTaper;                                         // 0x05D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelBasicMaterialCollection*          VoxelMatCollection;                                // 0x05D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelMaterialCollectionBase*           VoxelMatCollectionForPhysics;                      // 0x05E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelPhysicsPartSpawner_VoxelWorlds*   VoxelPhysicsSpawner;                               // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelPhysicsPartSpawner_VoxelWorlds*   VoxelPhysicsShatterSpawner;                        // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UVoxelPhysicsPartSpawner_Cubes> GlassSpawnerClass;                                 // 0x05F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelPhysicsPartSpawner_Cubes*         GlassPhysicsSpawner;                               // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelPhysicsPartSpawner_VoxelWorlds*   ShearPhysicsSpawner;                               // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlassLaunchStrength;                               // 0x0610(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShearLaunchStrength;                               // 0x0614(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoxelGeneratorPicker                  EmptyWorldGen;                                     // 0x0618(0x0068)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AVoxelWorld*>                    SpawnedPhysicsWorlds;                              // 0x0680(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class USoundBase*                             SmallExplosionSound;                               // 0x0690(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCExplosionGibRange;                              // 0x0698(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EImpactType, struct FImpactDamageData>   ImpactDamageMap;                                   // 0x06A0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EImpactType, float>                      JouleMap;                                          // 0x06F0(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TMap<EImpactType, float>                      HPDmgMap;                                          // 0x0740(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	int32                                         PhysicsBoxExtension;                               // 0x0790(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0798(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        BloodParticle;                                     // 0x07A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        BloodParticleSimpleFX;                             // 0x07A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ArmorParticle;                                     // 0x07B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APoolableActor>             BloodClass;                                        // 0x07B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APoolableActor>             DefaultDebrisClass;                                // 0x07C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           VoxelBloodColor;                                   // 0x07C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D8[0x1];                                      // 0x07D8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWorldInSlowMo;                                    // 0x07D9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7DA[0x2];                                      // 0x07DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeDilationAmount;                                // 0x07DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AChameleon*                             Chameleon;                                         // 0x07E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           KillTraceHitColor;                                 // 0x07E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           CloseTraceHitColor;                                // 0x07F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           MediumTraceHitColor;                               // 0x0808(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           FarTraceHitColor;                                  // 0x0818(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0828(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_830[0x8];                                      // 0x0830(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APoolableActor>             HealingGlassDecalClass;                            // 0x0838(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        GlassParticle;                                     // 0x0840(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MeltSystem;                                        // 0x0848(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             GlassSound;                                        // 0x0850(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             PaperSound;                                        // 0x0858(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        PaperParticleSystem;                               // 0x0860(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GlassEditSizeBullet;                               // 0x0868(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GlassEditSizeEve;                                  // 0x086C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        BorderHitParticle;                                 // 0x0870(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BorderHitDecal;                                    // 0x0878(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AFoamVoxelWorld>            FoamWorldClass;                                    // 0x0880(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BorderHitDecalSize;                                // 0x0888(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BorderImpactMaterialRadius;                        // 0x0894(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_898[0x20];                                     // 0x0898(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BorderRepairSpeed;                                 // 0x08B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BorderRepairMatSpeed;                              // 0x08BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BloodSplatSize;                                    // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletWoundSize;                                   // 0x08C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletWoundStrength;                               // 0x08C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletWoundHeight;                                 // 0x08CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletWoundDistance;                               // 0x08D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BulletWoundStep;                                   // 0x08D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D8[0x68];                                     // 0x08D8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      DebugPenetrationCurve;                             // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVoxelWorld*                            CurrentVoxelWorld;                                 // 0x0948(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ArmorParticleSimpleFX;                             // 0x0950(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_958[0x4];                                      // 0x0958(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BulletImpactStrength;                              // 0x095C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_960[0x20];                                     // 0x0960(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            BloodCurve;                                        // 0x0980(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCVoxelDamageChance;                              // 0x0988(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionCullDistance;                             // 0x098C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusForNavUpdate;                                // 0x0990(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_994[0xC];                                      // 0x0994(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AsyncExplosion(const struct FVector& WorldPosition, float Radius, float Value);
	void CalculateVoxelPhysics(class AVoxelWorld* VoxelWorld, const struct FVoxelIntBox& Box, int32 MinWorlds, bool bCanShatter);
	void CheckVoxelPhysicsNearPlayerForWorld();
	void ConfigureFoamWorld(class AVoxelWorld* InWorld);
	void ConfigureGlassChunk(class AVoxelWorld* InWorld);
	void ConfigurePhysicsWorld(class AVoxelWorld* InWorld);
	void ConfigureShatterWorld(class AVoxelWorld* InWorld);
	void ConfigureShearChunk(class AVoxelWorld* InWorld);
	void CreateExplosion(const struct FVector& Location, const struct FRotator& Rotation, float ShockwaveRadius, float EditRadius, bool bPlayerMade, bool Async, class UParticleSystem* ParticleOverride, class USoundBase* SoundOverride, bool bNoGib, class AVoxelWorld* OverrideWorld, bool bPropCaused, bool bKickedBack, bool bGravThrown, bool bSwitchCull);
	void DoBulletTrace(const struct FVector& TraceStart, const struct FVector& TraceStop);
	void DoExplosionGraph(class AVoxelWorld* OnWorld, const struct FVector& WorldLocation, const struct FRotator& Rotation, bool bPlayerMade, float EditRadius);
	void DummyCallback();
	float GetCurrentTimeDilation();
	void NotifyGraphFinished();
	void NotifyGraphFinishedWithResults(const TArray<struct FModifiedVoxelValue>& Info, const struct FVoxelIntBox& Bounds);
	void NotifyVoxelPhysicsTaskDone(TArray<TScriptInterface<class IVoxelPhysicsPartSpawnerResult>>* Results);
	void OnVoxelChunkHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void PhysicsCheckDone();
	void ReceiveChunkUpdate(const struct FVoxelIntBox& InBox);
	bool ResolveImpact(const struct FHitResult& HitResult, EImpactType Impact, bool FiredByPlayer, class AActor* Shooter, struct FVector* TraceOrigin, float PenetrationModifier, bool bAlreadyKilledNPC);
	void SetSendChapterEdits(bool bSend);
	void ShatterWorldLoaded(class AVoxelWorld* LoadedWorld);
	void WorldToggleSlowMo(bool Value, bool Force);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpactManager">();
	}
	static class AImpactManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AImpactManager>();
	}
};
static_assert(alignof(AImpactManager) == 0x000010, "Wrong alignment on AImpactManager");
static_assert(sizeof(AImpactManager) == 0x0009A0, "Wrong size on AImpactManager");
static_assert(offsetof(AImpactManager, OnSlowMoChange) == 0x000228, "Member 'AImpactManager::OnSlowMoChange' has a wrong offset!");
static_assert(offsetof(AImpactManager, bIsDoingXGraph) == 0x000278, "Member 'AImpactManager::bIsDoingXGraph' has a wrong offset!");
static_assert(offsetof(AImpactManager, DebrisSystem) == 0x000280, "Member 'AImpactManager::DebrisSystem' has a wrong offset!");
static_assert(offsetof(AImpactManager, TimeOfLastVoxelResultGather) == 0x000288, "Member 'AImpactManager::TimeOfLastVoxelResultGather' has a wrong offset!");
static_assert(offsetof(AImpactManager, TracerSystem) == 0x000290, "Member 'AImpactManager::TracerSystem' has a wrong offset!");
static_assert(offsetof(AImpactManager, TracerSystemLaser) == 0x000298, "Member 'AImpactManager::TracerSystemLaser' has a wrong offset!");
static_assert(offsetof(AImpactManager, TracerSystemNPP) == 0x0002A0, "Member 'AImpactManager::TracerSystemNPP' has a wrong offset!");
static_assert(offsetof(AImpactManager, KickSpeedDmgMultipierCurve) == 0x0002A8, "Member 'AImpactManager::KickSpeedDmgMultipierCurve' has a wrong offset!");
static_assert(offsetof(AImpactManager, FlameRadius) == 0x0002B0, "Member 'AImpactManager::FlameRadius' has a wrong offset!");
static_assert(offsetof(AImpactManager, OCRadius) == 0x0002B4, "Member 'AImpactManager::OCRadius' has a wrong offset!");
static_assert(offsetof(AImpactManager, FlameRange) == 0x0002B8, "Member 'AImpactManager::FlameRange' has a wrong offset!");
static_assert(offsetof(AImpactManager, OCRange) == 0x0002BC, "Member 'AImpactManager::OCRange' has a wrong offset!");
static_assert(offsetof(AImpactManager, FlameRays) == 0x0002C0, "Member 'AImpactManager::FlameRays' has a wrong offset!");
static_assert(offsetof(AImpactManager, OCRays) == 0x0002C4, "Member 'AImpactManager::OCRays' has a wrong offset!");
static_assert(offsetof(AImpactManager, TracerSystemMinigun) == 0x0002C8, "Member 'AImpactManager::TracerSystemMinigun' has a wrong offset!");
static_assert(offsetof(AImpactManager, ImpactCullDistance) == 0x0002D0, "Member 'AImpactManager::ImpactCullDistance' has a wrong offset!");
static_assert(offsetof(AImpactManager, PoolableGlassClass) == 0x0002D8, "Member 'AImpactManager::PoolableGlassClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, PoolableBloodClass) == 0x0002E0, "Member 'AImpactManager::PoolableBloodClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, BloodMinGap) == 0x0002E8, "Member 'AImpactManager::BloodMinGap' has a wrong offset!");
static_assert(offsetof(AImpactManager, MaxNPCEditsPerTick) == 0x0002F8, "Member 'AImpactManager::MaxNPCEditsPerTick' has a wrong offset!");
static_assert(offsetof(AImpactManager, PhysicsCheckExtents) == 0x000304, "Member 'AImpactManager::PhysicsCheckExtents' has a wrong offset!");
static_assert(offsetof(AImpactManager, ShatterCheckExtents) == 0x000310, "Member 'AImpactManager::ShatterCheckExtents' has a wrong offset!");
static_assert(offsetof(AImpactManager, FoamCheckExtents) == 0x00031C, "Member 'AImpactManager::FoamCheckExtents' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionShake) == 0x000328, "Member 'AImpactManager::ExplosionShake' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionForceFeedback) == 0x000330, "Member 'AImpactManager::ExplosionForceFeedback' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlassForceFeedback) == 0x000338, "Member 'AImpactManager::GlassForceFeedback' has a wrong offset!");
static_assert(offsetof(AImpactManager, GibSystems) == 0x000340, "Member 'AImpactManager::GibSystems' has a wrong offset!");
static_assert(offsetof(AImpactManager, GunShake) == 0x000350, "Member 'AImpactManager::GunShake' has a wrong offset!");
static_assert(offsetof(AImpactManager, PoolableFireClass) == 0x000358, "Member 'AImpactManager::PoolableFireClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, TimeBetweenFlameSpawn) == 0x000360, "Member 'AImpactManager::TimeBetweenFlameSpawn' has a wrong offset!");
static_assert(offsetof(AImpactManager, bIsWaitingForPhysicsTask) == 0x000398, "Member 'AImpactManager::bIsWaitingForPhysicsTask' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlooInfo) == 0x0003A0, "Member 'AImpactManager::GlooInfo' has a wrong offset!");
static_assert(offsetof(AImpactManager, SpawnedWorldsToPhysicsCheck) == 0x0003B0, "Member 'AImpactManager::SpawnedWorldsToPhysicsCheck' has a wrong offset!");
static_assert(offsetof(AImpactManager, PhysicsWorldClass) == 0x000418, "Member 'AImpactManager::PhysicsWorldClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, StickParticle) == 0x000430, "Member 'AImpactManager::StickParticle' has a wrong offset!");
static_assert(offsetof(AImpactManager, LazerLook) == 0x00043C, "Member 'AImpactManager::LazerLook' has a wrong offset!");
static_assert(offsetof(AImpactManager, DestructionDetail) == 0x000458, "Member 'AImpactManager::DestructionDetail' has a wrong offset!");
static_assert(offsetof(AImpactManager, ImpactSoundConcurrencyRules) == 0x000460, "Member 'AImpactManager::ImpactSoundConcurrencyRules' has a wrong offset!");
static_assert(offsetof(AImpactManager, FleshSound) == 0x000468, "Member 'AImpactManager::FleshSound' has a wrong offset!");
static_assert(offsetof(AImpactManager, WhizSound) == 0x000470, "Member 'AImpactManager::WhizSound' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionDecalClass) == 0x000478, "Member 'AImpactManager::ExplosionDecalClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, ImpactSoundChance) == 0x000480, "Member 'AImpactManager::ImpactSoundChance' has a wrong offset!");
static_assert(offsetof(AImpactManager, PaintParticle) == 0x000488, "Member 'AImpactManager::PaintParticle' has a wrong offset!");
static_assert(offsetof(AImpactManager, ImpactSoundAttenuation) == 0x000490, "Member 'AImpactManager::ImpactSoundAttenuation' has a wrong offset!");
static_assert(offsetof(AImpactManager, MinVelocityToStick) == 0x000498, "Member 'AImpactManager::MinVelocityToStick' has a wrong offset!");
static_assert(offsetof(AImpactManager, SlowMoMixModifier) == 0x0004A0, "Member 'AImpactManager::SlowMoMixModifier' has a wrong offset!");
static_assert(offsetof(AImpactManager, PaintRadius) == 0x0004A8, "Member 'AImpactManager::PaintRadius' has a wrong offset!");
static_assert(offsetof(AImpactManager, DummyRoot) == 0x0004B0, "Member 'AImpactManager::DummyRoot' has a wrong offset!");
static_assert(offsetof(AImpactManager, ImpactConfig) == 0x0004B8, "Member 'AImpactManager::ImpactConfig' has a wrong offset!");
static_assert(offsetof(AImpactManager, bIsDebugMode) == 0x000518, "Member 'AImpactManager::bIsDebugMode' has a wrong offset!");
static_assert(offsetof(AImpactManager, MatPropsList) == 0x000520, "Member 'AImpactManager::MatPropsList' has a wrong offset!");
static_assert(offsetof(AImpactManager, SpecialIndices) == 0x000530, "Member 'AImpactManager::SpecialIndices' has a wrong offset!");
static_assert(offsetof(AImpactManager, TestInnerRadius) == 0x000580, "Member 'AImpactManager::TestInnerRadius' has a wrong offset!");
static_assert(offsetof(AImpactManager, RadialForceComp) == 0x000588, "Member 'AImpactManager::RadialForceComp' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionFX) == 0x000590, "Member 'AImpactManager::ExplosionFX' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionFXOverrideSimplified) == 0x000598, "Member 'AImpactManager::ExplosionFXOverrideSimplified' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionFXNiagara) == 0x0005A0, "Member 'AImpactManager::ExplosionFXNiagara' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionFXNiagaraSimplified) == 0x0005A8, "Member 'AImpactManager::ExplosionFXNiagaraSimplified' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionSound) == 0x0005B0, "Member 'AImpactManager::ExplosionSound' has a wrong offset!");
static_assert(offsetof(AImpactManager, TestDirection) == 0x0005B8, "Member 'AImpactManager::TestDirection' has a wrong offset!");
static_assert(offsetof(AImpactManager, ShatterMeshClass) == 0x0005C8, "Member 'AImpactManager::ShatterMeshClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, TestTaper) == 0x0005D0, "Member 'AImpactManager::TestTaper' has a wrong offset!");
static_assert(offsetof(AImpactManager, VoxelMatCollection) == 0x0005D8, "Member 'AImpactManager::VoxelMatCollection' has a wrong offset!");
static_assert(offsetof(AImpactManager, VoxelMatCollectionForPhysics) == 0x0005E0, "Member 'AImpactManager::VoxelMatCollectionForPhysics' has a wrong offset!");
static_assert(offsetof(AImpactManager, VoxelPhysicsSpawner) == 0x0005E8, "Member 'AImpactManager::VoxelPhysicsSpawner' has a wrong offset!");
static_assert(offsetof(AImpactManager, VoxelPhysicsShatterSpawner) == 0x0005F0, "Member 'AImpactManager::VoxelPhysicsShatterSpawner' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlassSpawnerClass) == 0x0005F8, "Member 'AImpactManager::GlassSpawnerClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlassPhysicsSpawner) == 0x000600, "Member 'AImpactManager::GlassPhysicsSpawner' has a wrong offset!");
static_assert(offsetof(AImpactManager, ShearPhysicsSpawner) == 0x000608, "Member 'AImpactManager::ShearPhysicsSpawner' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlassLaunchStrength) == 0x000610, "Member 'AImpactManager::GlassLaunchStrength' has a wrong offset!");
static_assert(offsetof(AImpactManager, ShearLaunchStrength) == 0x000614, "Member 'AImpactManager::ShearLaunchStrength' has a wrong offset!");
static_assert(offsetof(AImpactManager, EmptyWorldGen) == 0x000618, "Member 'AImpactManager::EmptyWorldGen' has a wrong offset!");
static_assert(offsetof(AImpactManager, SpawnedPhysicsWorlds) == 0x000680, "Member 'AImpactManager::SpawnedPhysicsWorlds' has a wrong offset!");
static_assert(offsetof(AImpactManager, SmallExplosionSound) == 0x000690, "Member 'AImpactManager::SmallExplosionSound' has a wrong offset!");
static_assert(offsetof(AImpactManager, NPCExplosionGibRange) == 0x000698, "Member 'AImpactManager::NPCExplosionGibRange' has a wrong offset!");
static_assert(offsetof(AImpactManager, ImpactDamageMap) == 0x0006A0, "Member 'AImpactManager::ImpactDamageMap' has a wrong offset!");
static_assert(offsetof(AImpactManager, JouleMap) == 0x0006F0, "Member 'AImpactManager::JouleMap' has a wrong offset!");
static_assert(offsetof(AImpactManager, HPDmgMap) == 0x000740, "Member 'AImpactManager::HPDmgMap' has a wrong offset!");
static_assert(offsetof(AImpactManager, PhysicsBoxExtension) == 0x000790, "Member 'AImpactManager::PhysicsBoxExtension' has a wrong offset!");
static_assert(offsetof(AImpactManager, PlayerCharacter) == 0x000798, "Member 'AImpactManager::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(AImpactManager, BloodParticle) == 0x0007A0, "Member 'AImpactManager::BloodParticle' has a wrong offset!");
static_assert(offsetof(AImpactManager, BloodParticleSimpleFX) == 0x0007A8, "Member 'AImpactManager::BloodParticleSimpleFX' has a wrong offset!");
static_assert(offsetof(AImpactManager, ArmorParticle) == 0x0007B0, "Member 'AImpactManager::ArmorParticle' has a wrong offset!");
static_assert(offsetof(AImpactManager, BloodClass) == 0x0007B8, "Member 'AImpactManager::BloodClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, DefaultDebrisClass) == 0x0007C0, "Member 'AImpactManager::DefaultDebrisClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, VoxelBloodColor) == 0x0007C8, "Member 'AImpactManager::VoxelBloodColor' has a wrong offset!");
static_assert(offsetof(AImpactManager, bWorldInSlowMo) == 0x0007D9, "Member 'AImpactManager::bWorldInSlowMo' has a wrong offset!");
static_assert(offsetof(AImpactManager, TimeDilationAmount) == 0x0007DC, "Member 'AImpactManager::TimeDilationAmount' has a wrong offset!");
static_assert(offsetof(AImpactManager, Chameleon) == 0x0007E0, "Member 'AImpactManager::Chameleon' has a wrong offset!");
static_assert(offsetof(AImpactManager, KillTraceHitColor) == 0x0007E8, "Member 'AImpactManager::KillTraceHitColor' has a wrong offset!");
static_assert(offsetof(AImpactManager, CloseTraceHitColor) == 0x0007F8, "Member 'AImpactManager::CloseTraceHitColor' has a wrong offset!");
static_assert(offsetof(AImpactManager, MediumTraceHitColor) == 0x000808, "Member 'AImpactManager::MediumTraceHitColor' has a wrong offset!");
static_assert(offsetof(AImpactManager, FarTraceHitColor) == 0x000818, "Member 'AImpactManager::FarTraceHitColor' has a wrong offset!");
static_assert(offsetof(AImpactManager, TYVCGameMode) == 0x000828, "Member 'AImpactManager::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AImpactManager, HealingGlassDecalClass) == 0x000838, "Member 'AImpactManager::HealingGlassDecalClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlassParticle) == 0x000840, "Member 'AImpactManager::GlassParticle' has a wrong offset!");
static_assert(offsetof(AImpactManager, MeltSystem) == 0x000848, "Member 'AImpactManager::MeltSystem' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlassSound) == 0x000850, "Member 'AImpactManager::GlassSound' has a wrong offset!");
static_assert(offsetof(AImpactManager, PaperSound) == 0x000858, "Member 'AImpactManager::PaperSound' has a wrong offset!");
static_assert(offsetof(AImpactManager, PaperParticleSystem) == 0x000860, "Member 'AImpactManager::PaperParticleSystem' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlassEditSizeBullet) == 0x000868, "Member 'AImpactManager::GlassEditSizeBullet' has a wrong offset!");
static_assert(offsetof(AImpactManager, GlassEditSizeEve) == 0x00086C, "Member 'AImpactManager::GlassEditSizeEve' has a wrong offset!");
static_assert(offsetof(AImpactManager, BorderHitParticle) == 0x000870, "Member 'AImpactManager::BorderHitParticle' has a wrong offset!");
static_assert(offsetof(AImpactManager, BorderHitDecal) == 0x000878, "Member 'AImpactManager::BorderHitDecal' has a wrong offset!");
static_assert(offsetof(AImpactManager, FoamWorldClass) == 0x000880, "Member 'AImpactManager::FoamWorldClass' has a wrong offset!");
static_assert(offsetof(AImpactManager, BorderHitDecalSize) == 0x000888, "Member 'AImpactManager::BorderHitDecalSize' has a wrong offset!");
static_assert(offsetof(AImpactManager, BorderImpactMaterialRadius) == 0x000894, "Member 'AImpactManager::BorderImpactMaterialRadius' has a wrong offset!");
static_assert(offsetof(AImpactManager, BorderRepairSpeed) == 0x0008B8, "Member 'AImpactManager::BorderRepairSpeed' has a wrong offset!");
static_assert(offsetof(AImpactManager, BorderRepairMatSpeed) == 0x0008BC, "Member 'AImpactManager::BorderRepairMatSpeed' has a wrong offset!");
static_assert(offsetof(AImpactManager, BloodSplatSize) == 0x0008C0, "Member 'AImpactManager::BloodSplatSize' has a wrong offset!");
static_assert(offsetof(AImpactManager, BulletWoundSize) == 0x0008C4, "Member 'AImpactManager::BulletWoundSize' has a wrong offset!");
static_assert(offsetof(AImpactManager, BulletWoundStrength) == 0x0008C8, "Member 'AImpactManager::BulletWoundStrength' has a wrong offset!");
static_assert(offsetof(AImpactManager, BulletWoundHeight) == 0x0008CC, "Member 'AImpactManager::BulletWoundHeight' has a wrong offset!");
static_assert(offsetof(AImpactManager, BulletWoundDistance) == 0x0008D0, "Member 'AImpactManager::BulletWoundDistance' has a wrong offset!");
static_assert(offsetof(AImpactManager, BulletWoundStep) == 0x0008D4, "Member 'AImpactManager::BulletWoundStep' has a wrong offset!");
static_assert(offsetof(AImpactManager, DebugPenetrationCurve) == 0x000940, "Member 'AImpactManager::DebugPenetrationCurve' has a wrong offset!");
static_assert(offsetof(AImpactManager, CurrentVoxelWorld) == 0x000948, "Member 'AImpactManager::CurrentVoxelWorld' has a wrong offset!");
static_assert(offsetof(AImpactManager, ArmorParticleSimpleFX) == 0x000950, "Member 'AImpactManager::ArmorParticleSimpleFX' has a wrong offset!");
static_assert(offsetof(AImpactManager, BulletImpactStrength) == 0x00095C, "Member 'AImpactManager::BulletImpactStrength' has a wrong offset!");
static_assert(offsetof(AImpactManager, BloodCurve) == 0x000980, "Member 'AImpactManager::BloodCurve' has a wrong offset!");
static_assert(offsetof(AImpactManager, NPCVoxelDamageChance) == 0x000988, "Member 'AImpactManager::NPCVoxelDamageChance' has a wrong offset!");
static_assert(offsetof(AImpactManager, ExplosionCullDistance) == 0x00098C, "Member 'AImpactManager::ExplosionCullDistance' has a wrong offset!");
static_assert(offsetof(AImpactManager, RadiusForNavUpdate) == 0x000990, "Member 'AImpactManager::RadiusForNavUpdate' has a wrong offset!");

// Class ThankYouVeryCool.InteractableInterface
// 0x0000 (0x0028 - 0x0028)
class IInteractableInterface final : public IInterface
{
public:
	class USceneComponent* GetHighlightComponent();
	class FText GetInteractionText();
	bool IsInteractable();
	bool OnHit(EImpactType ImpactType, const struct FHitResult& HitResult, float Dmg);
	void OnLookAt(const struct FVector& LookAtLoc);
	void OnStopLookAt();
	void RequestInteraction(class AActor* Interactor);
	bool ShouldHighlight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableInterface">();
	}
	static class IInteractableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractableInterface>();
	}
};
static_assert(alignof(IInteractableInterface) == 0x000008, "Wrong alignment on IInteractableInterface");
static_assert(sizeof(IInteractableInterface) == 0x000028, "Wrong size on IInteractableInterface");

// Class ThankYouVeryCool.InteractableVoxelBuilder
// 0x0008 (0x0A20 - 0x0A18)
class AInteractableVoxelBuilder final : public AVoxelBuilder2
{
public:
	uint8                                         Pad_A18[0x8];                                      // 0x0A18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableVoxelBuilder">();
	}
	static class AInteractableVoxelBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractableVoxelBuilder>();
	}
};
static_assert(alignof(AInteractableVoxelBuilder) == 0x000008, "Wrong alignment on AInteractableVoxelBuilder");
static_assert(sizeof(AInteractableVoxelBuilder) == 0x000A20, "Wrong size on AInteractableVoxelBuilder");

// Class ThankYouVeryCool.WeaponPickupWidget
// 0x0000 (0x0260 - 0x0260)
class UWeaponPickupWidget : public UUserWidget
{
public:
	void SetupForBackpackRecharge(class USceneComponent* OnComponent);
	void SetupForInteract(class USceneComponent* OnComponent, const class FText& InteractText);
	void SetupForThrow(class AWeaponBase* InWeapon);
	void SetupForWeapon(class AWeaponBase* InWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponPickupWidget">();
	}
	static class UWeaponPickupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponPickupWidget>();
	}
};
static_assert(alignof(UWeaponPickupWidget) == 0x000008, "Wrong alignment on UWeaponPickupWidget");
static_assert(sizeof(UWeaponPickupWidget) == 0x000260, "Wrong size on UWeaponPickupWidget");

// Class ThankYouVeryCool.JumpOpportunityService
// 0x00A8 (0x0118 - 0x0070)
class UJumpOpportunityService final : public UBTService
{
public:
	struct FBlackboardKeySelector                 JumpDestinationKey;                                // 0x0070(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 FoundJumpLocationKey;                              // 0x0098(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FBlackboardKeySelector                 FoundJumpSuccessBoolKey;                           // 0x00C0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         NearTargetRadius;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpCooldownTime;                                  // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredAirTime;                                    // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AirTimeCurve;                                      // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTests;                                          // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinJumpDist;                                       // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JumpOpportunityService">();
	}
	static class UJumpOpportunityService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJumpOpportunityService>();
	}
};
static_assert(alignof(UJumpOpportunityService) == 0x000008, "Wrong alignment on UJumpOpportunityService");
static_assert(sizeof(UJumpOpportunityService) == 0x000118, "Wrong size on UJumpOpportunityService");
static_assert(offsetof(UJumpOpportunityService, JumpDestinationKey) == 0x000070, "Member 'UJumpOpportunityService::JumpDestinationKey' has a wrong offset!");
static_assert(offsetof(UJumpOpportunityService, FoundJumpLocationKey) == 0x000098, "Member 'UJumpOpportunityService::FoundJumpLocationKey' has a wrong offset!");
static_assert(offsetof(UJumpOpportunityService, FoundJumpSuccessBoolKey) == 0x0000C0, "Member 'UJumpOpportunityService::FoundJumpSuccessBoolKey' has a wrong offset!");
static_assert(offsetof(UJumpOpportunityService, NearTargetRadius) == 0x0000E8, "Member 'UJumpOpportunityService::NearTargetRadius' has a wrong offset!");
static_assert(offsetof(UJumpOpportunityService, JumpCooldownTime) == 0x0000F0, "Member 'UJumpOpportunityService::JumpCooldownTime' has a wrong offset!");
static_assert(offsetof(UJumpOpportunityService, DesiredAirTime) == 0x0000F4, "Member 'UJumpOpportunityService::DesiredAirTime' has a wrong offset!");
static_assert(offsetof(UJumpOpportunityService, AirTimeCurve) == 0x0000F8, "Member 'UJumpOpportunityService::AirTimeCurve' has a wrong offset!");
static_assert(offsetof(UJumpOpportunityService, MaxTests) == 0x000100, "Member 'UJumpOpportunityService::MaxTests' has a wrong offset!");
static_assert(offsetof(UJumpOpportunityService, MinJumpDist) == 0x000104, "Member 'UJumpOpportunityService::MinJumpDist' has a wrong offset!");

// Class ThankYouVeryCool.LevelEditorManager
// 0x0700 (0x0920 - 0x0220)
class alignas(0x10) ALevelEditorManager : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PitchOffset;                                       // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              IcePrison;                                         // 0x0230(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              solarpunk;                                         // 0x0258(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Junkie;                                            // 0x0280(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              hotline;                                           // 0x02A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Impact;                                            // 0x02D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              KeepIt;                                            // 0x02F8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              RunningOut;                                        // 0x0320(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              TYVC;                                              // 0x0348(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              AbandonedChurch;                                   // 0x0370(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Cur;                                               // 0x0398(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Blowback;                                          // 0x03C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Giants;                                            // 0x03E8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              Sonata;                                            // 0x0410(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EEditMode NewEditMode)> OnEditorModeChange;                                // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(bool Success)>                 CurrentUploadDel;                                  // 0x0448(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ALevelEditorPawn>           LevelEditorPawnClass;                              // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULevelEditorWidget>         LevelEditorWidgetClass;                            // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelEditorWidget*                     LevelEditorWidget;                                 // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapEnabled;                                      // 0x0470(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AWorldBoundsDisplay>        WorldBoundsClass;                                  // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWorldBoundsDisplay*                    MyWorldBoundsDisplay;                              // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APropVoxelWorld>            CustomPropClass;                                   // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESimState                                     CurrentState;                                      // 0x0498(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x37];                                     // 0x0499(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	class AExponentialHeightFog*                  HeightFogActor;                                    // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATYVCSky*                               SkyActor;                                          // 0x04D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATYVCSky>                   SkyClass;                                          // 0x04E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ARechargeStation>           StationClass;                                      // 0x04E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APropVoxelWorld>            KillerFanClass;                                    // 0x04F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APropVoxelWorld>            HugeKillerFanClass;                                // 0x04F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACampaignTriggerVolume>     TriggerVolumeClass;                                // 0x0500(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACampaignMarker>            CampaignMarkerClass;                               // 0x0508(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACampaignMarker>            EveSpawnClass;                                     // 0x0510(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACampaignMarker*                        SpawnPoint;                                        // 0x0518(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelEditorPawn*                       LevelEditorPawn;                                   // 0x0520(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelBrush*                            VoxelBrush;                                        // 0x0528(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWorkshopChapterData                   CurrentCData;                                      // 0x0530(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x88];                                     // 0x0550(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UArcadeLevelAssetWorkshop*              CurrentLevelAsset;                                 // 0x05D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x10];                                     // 0x05E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, struct FCustomPropData>    PropLibrary;                                       // 0x05F0(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UGameplayTask_StartEditor*              StartEditorTask;                                   // 0x0640(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APropVoxelWorld>            VoxelDoorClass;                                    // 0x0648(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATurret>                    TurretClass;                                       // 0x0650(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayGask_EndArcade*                EndSimTask;                                        // 0x0658(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ResetArcade*              ResetArcadeTask;                                   // 0x0660(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture*>                       LUTList;                                           // 0x0668(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             CurrentLevelScreen;                                // 0x0678(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CurrentPropCatScreen;                              // 0x0680(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTextureCube*>                   SkylightList;                                      // 0x0688(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x06A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APrimaryVoxelWorld*                     PrimaryVoxelWorld;                                 // 0x06A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASkyLight*                              SkyLight;                                          // 0x06B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelAssetActor*                       MagicaActor;                                       // 0x06B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C0[0x10];                                     // 0x06C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelEditorSave*                       CachedSave;                                        // 0x06D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D8[0x4];                                      // 0x06D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelIntBox                           WorldBounds;                                       // 0x06DC(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoxelIntBox                           WorldBorderBounds;                                 // 0x06F4(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoxelIntBox                           BoundsToCheckForEdits;                             // 0x070C(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_724[0xC];                                      // 0x0724(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UVoxelDataAsset*>     PropsMap;                                          // 0x0730(0x0050)(NativeAccessSpecifierPublic)
	TMap<ENPCType, TSubclassOf<class ANPC>>       NPCClassMap;                                       // 0x0780(0x0050)(Edit, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class APropVoxelWorld>            PropWorldClass;                                    // 0x07D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATYVCActor>                 PickupClass;                                       // 0x07D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UVoxelDataAsset*>                Props;                                             // 0x07E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F0[0x10];                                     // 0x07F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEditorLight>               LightClass;                                        // 0x0800(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          WeaponRandomStream;                                // 0x0808(0x0008)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ANPC>>               RandomStandardMap;                                 // 0x0810(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ANPC>>               RandomBackpackMap;                                 // 0x0820(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ANPC>>               RandomHeavyMap;                                    // 0x0830(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_840[0x40];                                     // 0x0840(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTask_ResetNodeToGen*           ResetNodeTask;                                     // 0x0880(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ADirectionalLight>          DirLightClass;                                     // 0x0888(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADirectionalLight*                      DirLight;                                          // 0x0890(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 IndigoEm;                                          // 0x0898(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 OrangeEm;                                          // 0x089C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 RedEm;                                             // 0x08A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 WhiteEm;                                           // 0x08A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BrightRedEm;                                       // 0x08A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8AC[0x54];                                     // 0x08AC(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableNPCSim;                                    // 0x0900(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_901[0x7];                                      // 0x0901(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTasksComponent*                GameplayTasksComponent;                            // 0x0908(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IGameplayTaskOwnerInterface> SelfInterface;                                     // 0x0910(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static void GetFoundProps(TArray<class FString>* OutFound);
	static void GetFoundVox(TArray<class FString>* OutFound);
	static struct FColor MakeColorFromFloat(float R, float G, float B);

	void AddPropToLibrary(const struct FCustomPropData& InProp);
	void AfterNodeReset();
	void ApplyAndClearMask();
	void ConvertLegacyLevels();
	void DeleteSelected();
	void DeleteSelection();
	void DoSpecialAction(EActionType OfType, bool bSimulated);
	void EnsureDirLight(bool bShouldBe, float Strength);
	void EnsureSkyActor(bool bShouldBe, bool bAllowAmbient);
	TArray<EActionType> GetActionsFromID(class FName InID);
	TArray<class FName> GetAlphabeticIDs();
	TArray<class FString> GetAlphabeticPropCategories();
	TArray<struct FGuid> GetAlphabeticPropKeys();
	TArray<struct FGuid> GetAlphabeticPropKeysForCategory(const class FString& CategoryIn);
	class UCustomPropCatSave* GetCatSave(const class FString& ForCat);
	class FString GetCurrentCampaignDirLocal(bool bFull);
	class FString GetCurrentLevelDir(bool bFull);
	bool GetCurrentLevelWorkshopInfo(class FString* OutID);
	TArray<class UCustomCampaign*> GetFoundCampaigns(bool bForConsoles);
	TArray<class UArcadeLevelAssetWorkshop*> GetFoundEditorLevels(bool bForConsoles);
	TArray<EGoalType> GetGoalsFromID(class FName InID);
	TArray<class FName> GetIDsWithActions();
	TArray<class FName> GetIDsWithGoals();
	class UArcadeLevelAssetWorkshop* GetLevelFromCampaign(class UCustomCampaign* Campaign, const class FString& InLevelName, bool bGetSource);
	TArray<class UArcadeLevelAssetWorkshop*> GetLocalLevelAssets();
	TArray<class FString> GetPropCat(const class FString& inString);
	class UTexture2D* GetScreenshotFromCampaign(class UCustomCampaign* Campaign, const class FString& InLevelName);
	struct FTransform GetSpawnTransform(bool bYawOnly);
	TArray<class UCustomCampaign*> GetWorkshopCampaignAssets();
	TArray<class UArcadeLevelAssetWorkshop*> GetWorkshopLevelAssets();
	bool IsLevelNameValid(const class FString& ToCheck, class FText* OutMsg);
	void LoadFromEditorAndApply();
	class UCustomPropCatSave* MakeCatSave(const class FString& ForCat, const struct FPropCatUploadInfo& InInfo);
	void NotifyPostLoad();
	void OpenWorkshopFor(const class FString& ID);
	void ReadyVoxProps();
	void Redo();
	void RefreshPreviewProp(class APropVoxelWorld* ToRefresh);
	void ReloadVox();
	void RemovePropFromLibrary(const struct FGuid& ForGUID);
	void RequestMove(bool bShouldCut);
	void RotateSelection(bool Counter);
	bool SaveCustomCampaign(const struct FCustomCampaignStruct& InCampaign, const class FString& SlotName);
	bool SaveEditor(bool bCacheOnly);
	void SetAmbientLight(float InStrength, float SimpleMod, float InDirLight);
	void SetBorder(int32 Index_0, const struct FVoxelIntBox& Dims, bool bReloadWorld, bool bHasSky);
	void SetBorderViz(bool bViz);
	void SetCurrentLevelWorkshopInfo(const class FString& InID);
	bool SetDescription(const class FText& InDescription);
	bool SetDisplayName(const class FText& DisplayName);
	void SetEditMode(EEditMode InMode);
	void SetEditType(EEditType InType);
	void SetFogEnabled(bool bEnabled);
	void SetLUT(int32 LUTIndex, float LUTStrength);
	void SetMaskActive(bool bStatus);
	void SetMaterialIndex(int32 InIndex);
	void SetNoFriction(bool bNo);
	void SetShouldSnap(bool bShouldSnap);
	void SetSkylightTexture(int32 TextureIndex);
	void SetSkyTime(float InTime);
	void SetSpawnPoint();
	void SetupWorldBoundsDisplay(const struct FVoxelIntBox& InBounds);
	bool SetWorkshopAuthor(const class FText& Author);
	bool SetWorkshopName(const class FText& DisplayName);
	void SimulationLeft();
	void SpawnAsEditor();
	void SpawnAsEve();
	void SpawnCampaignMarker(TSubclassOf<class ACampaignMarker> MarkerClass);
	void SpawnChargeStation(TSubclassOf<class ARechargeStation> InClass);
	class APropVoxelWorld* SpawnCustomPropFromData(const struct FCustomPropData& InData, const struct FTransform& AtTransform);
	void SpawnDoor();
	void SpawnGenericProp(TSubclassOf<class APropVoxelWorld> ClassToSpawn);
	void SpawnGlass(TSubclassOf<class AGlassVoxelWorld> GlassClass);
	void SpawnGun(TSubclassOf<class AWeaponBase> WeaponClass);
	void SpawnHugeKillerFan();
	void SpawnKillerFan();
	void SpawnLight();
	void SpawnMech(TSubclassOf<class AMech> MechClass);
	void SpawnNPC(ENPCType OfType);
	void SpawnPickup();
	void SpawnProp(int32 Index_0);
	void SpawnTriggerVolume();
	class ATurret* SpawnTurret();
	void SpawnVoid(TSubclassOf<class ARechargeStation> VoidClass);
	void SpawnVoxProp(const class FString& PropName);
	void StampPropToWorld(class APropVoxelWorld* InProp);
	void TickSlice();
	void ToggleBorderViz();
	void ToggleCubicMode();
	void ToggleFog();
	void ToggleGrid();
	void ToggleVolumesViz();
	void Undo();
	void UploadCampaignToSteam(const struct FCustomCampaignStruct& ToUpload, TDelegate<void(bool Success)> WhenDone);
	void UploadPropToSteam(const class FString& CatName, const TArray<struct FCustomPropData>& ToUpload, const struct FPropCatUploadInfo& InInfo, TDelegate<void(bool Success)> WhenDone);
	void UploadToSteam(TDelegate<void(bool Success)> WhenDone);
	void UserRequestedAttachment(class AActor* ToAttach, class AActor* ToAttachTo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelEditorManager">();
	}
	static class ALevelEditorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelEditorManager>();
	}
};
static_assert(alignof(ALevelEditorManager) == 0x000010, "Wrong alignment on ALevelEditorManager");
static_assert(sizeof(ALevelEditorManager) == 0x000920, "Wrong size on ALevelEditorManager");
static_assert(offsetof(ALevelEditorManager, PitchOffset) == 0x000228, "Member 'ALevelEditorManager::PitchOffset' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, IcePrison) == 0x000230, "Member 'ALevelEditorManager::IcePrison' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, solarpunk) == 0x000258, "Member 'ALevelEditorManager::solarpunk' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, Junkie) == 0x000280, "Member 'ALevelEditorManager::Junkie' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, hotline) == 0x0002A8, "Member 'ALevelEditorManager::hotline' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, Impact) == 0x0002D0, "Member 'ALevelEditorManager::Impact' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, KeepIt) == 0x0002F8, "Member 'ALevelEditorManager::KeepIt' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, RunningOut) == 0x000320, "Member 'ALevelEditorManager::RunningOut' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, TYVC) == 0x000348, "Member 'ALevelEditorManager::TYVC' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, AbandonedChurch) == 0x000370, "Member 'ALevelEditorManager::AbandonedChurch' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, Cur) == 0x000398, "Member 'ALevelEditorManager::Cur' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, Blowback) == 0x0003C0, "Member 'ALevelEditorManager::Blowback' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, Giants) == 0x0003E8, "Member 'ALevelEditorManager::Giants' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, Sonata) == 0x000410, "Member 'ALevelEditorManager::Sonata' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, OnEditorModeChange) == 0x000438, "Member 'ALevelEditorManager::OnEditorModeChange' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CurrentUploadDel) == 0x000448, "Member 'ALevelEditorManager::CurrentUploadDel' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, LevelEditorPawnClass) == 0x000458, "Member 'ALevelEditorManager::LevelEditorPawnClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, LevelEditorWidgetClass) == 0x000460, "Member 'ALevelEditorManager::LevelEditorWidgetClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, LevelEditorWidget) == 0x000468, "Member 'ALevelEditorManager::LevelEditorWidget' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, bSnapEnabled) == 0x000470, "Member 'ALevelEditorManager::bSnapEnabled' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, WorldBoundsClass) == 0x000478, "Member 'ALevelEditorManager::WorldBoundsClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, MyWorldBoundsDisplay) == 0x000480, "Member 'ALevelEditorManager::MyWorldBoundsDisplay' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CustomPropClass) == 0x000490, "Member 'ALevelEditorManager::CustomPropClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CurrentState) == 0x000498, "Member 'ALevelEditorManager::CurrentState' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, HeightFogActor) == 0x0004D0, "Member 'ALevelEditorManager::HeightFogActor' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, SkyActor) == 0x0004D8, "Member 'ALevelEditorManager::SkyActor' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, SkyClass) == 0x0004E0, "Member 'ALevelEditorManager::SkyClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, StationClass) == 0x0004E8, "Member 'ALevelEditorManager::StationClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, KillerFanClass) == 0x0004F0, "Member 'ALevelEditorManager::KillerFanClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, HugeKillerFanClass) == 0x0004F8, "Member 'ALevelEditorManager::HugeKillerFanClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, TriggerVolumeClass) == 0x000500, "Member 'ALevelEditorManager::TriggerVolumeClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CampaignMarkerClass) == 0x000508, "Member 'ALevelEditorManager::CampaignMarkerClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, EveSpawnClass) == 0x000510, "Member 'ALevelEditorManager::EveSpawnClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, SpawnPoint) == 0x000518, "Member 'ALevelEditorManager::SpawnPoint' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, LevelEditorPawn) == 0x000520, "Member 'ALevelEditorManager::LevelEditorPawn' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, VoxelBrush) == 0x000528, "Member 'ALevelEditorManager::VoxelBrush' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CurrentCData) == 0x000530, "Member 'ALevelEditorManager::CurrentCData' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CurrentLevelAsset) == 0x0005D8, "Member 'ALevelEditorManager::CurrentLevelAsset' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, PropLibrary) == 0x0005F0, "Member 'ALevelEditorManager::PropLibrary' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, StartEditorTask) == 0x000640, "Member 'ALevelEditorManager::StartEditorTask' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, VoxelDoorClass) == 0x000648, "Member 'ALevelEditorManager::VoxelDoorClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, TurretClass) == 0x000650, "Member 'ALevelEditorManager::TurretClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, EndSimTask) == 0x000658, "Member 'ALevelEditorManager::EndSimTask' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, ResetArcadeTask) == 0x000660, "Member 'ALevelEditorManager::ResetArcadeTask' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, LUTList) == 0x000668, "Member 'ALevelEditorManager::LUTList' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CurrentLevelScreen) == 0x000678, "Member 'ALevelEditorManager::CurrentLevelScreen' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CurrentPropCatScreen) == 0x000680, "Member 'ALevelEditorManager::CurrentPropCatScreen' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, SkylightList) == 0x000688, "Member 'ALevelEditorManager::SkylightList' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, TYVCGameMode) == 0x0006A0, "Member 'ALevelEditorManager::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, PrimaryVoxelWorld) == 0x0006A8, "Member 'ALevelEditorManager::PrimaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, SkyLight) == 0x0006B0, "Member 'ALevelEditorManager::SkyLight' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, MagicaActor) == 0x0006B8, "Member 'ALevelEditorManager::MagicaActor' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, CachedSave) == 0x0006D0, "Member 'ALevelEditorManager::CachedSave' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, WorldBounds) == 0x0006DC, "Member 'ALevelEditorManager::WorldBounds' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, WorldBorderBounds) == 0x0006F4, "Member 'ALevelEditorManager::WorldBorderBounds' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, BoundsToCheckForEdits) == 0x00070C, "Member 'ALevelEditorManager::BoundsToCheckForEdits' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, PropsMap) == 0x000730, "Member 'ALevelEditorManager::PropsMap' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, NPCClassMap) == 0x000780, "Member 'ALevelEditorManager::NPCClassMap' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, PropWorldClass) == 0x0007D0, "Member 'ALevelEditorManager::PropWorldClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, PickupClass) == 0x0007D8, "Member 'ALevelEditorManager::PickupClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, Props) == 0x0007E0, "Member 'ALevelEditorManager::Props' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, LightClass) == 0x000800, "Member 'ALevelEditorManager::LightClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, WeaponRandomStream) == 0x000808, "Member 'ALevelEditorManager::WeaponRandomStream' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, RandomStandardMap) == 0x000810, "Member 'ALevelEditorManager::RandomStandardMap' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, RandomBackpackMap) == 0x000820, "Member 'ALevelEditorManager::RandomBackpackMap' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, RandomHeavyMap) == 0x000830, "Member 'ALevelEditorManager::RandomHeavyMap' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, ResetNodeTask) == 0x000880, "Member 'ALevelEditorManager::ResetNodeTask' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, DirLightClass) == 0x000888, "Member 'ALevelEditorManager::DirLightClass' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, DirLight) == 0x000890, "Member 'ALevelEditorManager::DirLight' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, IndigoEm) == 0x000898, "Member 'ALevelEditorManager::IndigoEm' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, OrangeEm) == 0x00089C, "Member 'ALevelEditorManager::OrangeEm' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, RedEm) == 0x0008A0, "Member 'ALevelEditorManager::RedEm' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, WhiteEm) == 0x0008A4, "Member 'ALevelEditorManager::WhiteEm' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, BrightRedEm) == 0x0008A8, "Member 'ALevelEditorManager::BrightRedEm' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, bDisableNPCSim) == 0x000900, "Member 'ALevelEditorManager::bDisableNPCSim' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, GameplayTasksComponent) == 0x000908, "Member 'ALevelEditorManager::GameplayTasksComponent' has a wrong offset!");
static_assert(offsetof(ALevelEditorManager, SelfInterface) == 0x000910, "Member 'ALevelEditorManager::SelfInterface' has a wrong offset!");

// Class ThankYouVeryCool.LevelEditorPawn
// 0x08A0 (0x0CD0 - 0x0430)
class ALevelEditorPawn : public ATransformerPawn
{
public:
	uint8                                         Pad_430[0x1B0];                                    // 0x0430(0x01B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       FirstPersonCamera;                                 // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        CursorComp;                                        // 0x05F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   RectangleSelectComp;                               // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_600[0x8];                                      // 0x0600(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SelectedActor;                                     // 0x0608(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x3];                                      // 0x0610(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ESelectType                                   CurrentSelectType;                                 // 0x0613(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_614[0x4];                                      // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneCaptureComponent2D*               ScreenshotComp;                                    // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ScreenShotAlphaMat;                                // 0x0620(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ScreenShotAlphaMatDyn;                             // 0x0628(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 ScreenShotAlphaTarget;                             // 0x0630(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_638[0x2D4];                                    // 0x0638(0x02D4)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CylinderTest;                                      // 0x090C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_918[0x10];                                     // 0x0918(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   RectangleSelectGrabPoint;                          // 0x0928(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RectangleSelectGrabPointMin;                       // 0x0930(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   RectangleSelectGrabPointCenter;                    // 0x0938(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_940[0x40];                                     // 0x0940(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateBoxRate;                                     // 0x0980(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_984[0x4C];                                     // 0x0984(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelEditorManager*                    EditorManager;                                     // 0x09D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D8[0x20];                                     // 0x09D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        CompSelectedLastFrame;                             // 0x09F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A00[0x30];                                     // 0x0A00(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineSnapDegrees;                                   // 0x0A30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A34[0xD];                                      // 0x0A34(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLineAsStairs;                                     // 0x0A41(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A42[0x19E];                                    // 0x0A42(0x019E)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEditHistory>                   UndoStack;                                         // 0x0BE0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEditHistory>                   RedoStack;                                         // 0x0BF0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FEditHistory                           CurrentMask;                                       // 0x0C00(0x00C0)(NativeAccessSpecifierPublic)
	bool                                          bIsMasking;                                        // 0x0CC0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC1[0xF];                                      // 0x0CC1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConvertSelectionToProp(const class FString& InName);
	void CopyDown();
	void CopyUp();
	EEditMode GetCurrentEditMode();
	EEditType GetCurrentEditType();
	class UTexture2D* GetScreenshot();
	class UTexture2D* GetScreenshotForPropCat(const class FString& CatName);
	class UTexture2D* LoadScreenshotForPropCat(const class FString& CatName);
	void MoveWithCameraDown();
	void MoveWithCameraUp();
	void PausePressed();
	void QuickPickPressed();
	void Redo();
	void RequestRotateMode();
	void RequestScaleMode();
	void RequestTranslateMode();
	void RightClickDown();
	void RightClickUp();
	void TickCircle();
	void TickVoxelMove();
	void TriggerDownMouse();
	void TriggerUpMouse();
	void Undo();
	void UpdateBoxEdit();
	void UpdateFaceEdit(EFaceDirection ForceDirection);
	void UpdateLineEdit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelEditorPawn">();
	}
	static class ALevelEditorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelEditorPawn>();
	}
};
static_assert(alignof(ALevelEditorPawn) == 0x000010, "Wrong alignment on ALevelEditorPawn");
static_assert(sizeof(ALevelEditorPawn) == 0x000CD0, "Wrong size on ALevelEditorPawn");
static_assert(offsetof(ALevelEditorPawn, FirstPersonCamera) == 0x0005E0, "Member 'ALevelEditorPawn::FirstPersonCamera' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, CursorComp) == 0x0005F0, "Member 'ALevelEditorPawn::CursorComp' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, RectangleSelectComp) == 0x0005F8, "Member 'ALevelEditorPawn::RectangleSelectComp' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, SelectedActor) == 0x000608, "Member 'ALevelEditorPawn::SelectedActor' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, CurrentSelectType) == 0x000613, "Member 'ALevelEditorPawn::CurrentSelectType' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, ScreenshotComp) == 0x000618, "Member 'ALevelEditorPawn::ScreenshotComp' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, ScreenShotAlphaMat) == 0x000620, "Member 'ALevelEditorPawn::ScreenShotAlphaMat' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, ScreenShotAlphaMatDyn) == 0x000628, "Member 'ALevelEditorPawn::ScreenShotAlphaMatDyn' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, ScreenShotAlphaTarget) == 0x000630, "Member 'ALevelEditorPawn::ScreenShotAlphaTarget' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, CylinderTest) == 0x00090C, "Member 'ALevelEditorPawn::CylinderTest' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, RectangleSelectGrabPoint) == 0x000928, "Member 'ALevelEditorPawn::RectangleSelectGrabPoint' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, RectangleSelectGrabPointMin) == 0x000930, "Member 'ALevelEditorPawn::RectangleSelectGrabPointMin' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, RectangleSelectGrabPointCenter) == 0x000938, "Member 'ALevelEditorPawn::RectangleSelectGrabPointCenter' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, UpdateBoxRate) == 0x000980, "Member 'ALevelEditorPawn::UpdateBoxRate' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, EditorManager) == 0x0009D0, "Member 'ALevelEditorPawn::EditorManager' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, CompSelectedLastFrame) == 0x0009F8, "Member 'ALevelEditorPawn::CompSelectedLastFrame' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, LineSnapDegrees) == 0x000A30, "Member 'ALevelEditorPawn::LineSnapDegrees' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, bLineAsStairs) == 0x000A41, "Member 'ALevelEditorPawn::bLineAsStairs' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, UndoStack) == 0x000BE0, "Member 'ALevelEditorPawn::UndoStack' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, RedoStack) == 0x000BF0, "Member 'ALevelEditorPawn::RedoStack' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, CurrentMask) == 0x000C00, "Member 'ALevelEditorPawn::CurrentMask' has a wrong offset!");
static_assert(offsetof(ALevelEditorPawn, bIsMasking) == 0x000CC0, "Member 'ALevelEditorPawn::bIsMasking' has a wrong offset!");

// Class ThankYouVeryCool.LevelEditorSave
// 0x00E0 (0x0108 - 0x0028)
class ULevelEditorSave final : public USaveGame
{
public:
	int32                                         LUTIndex;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LUTStrength;                                       // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BorderIndex;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmbientStength;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEditorActorSave>               ActorSaves;                                        // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVoxelCompressedWorldSave              VoxelSave;                                         // 0x0048(0x0020)(NativeAccessSpecifierPublic)
	int32                                         SaveDepth;                                         // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVoxelIntBox                           WorldBounds;                                       // 0x006C(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkylightIndex;                                     // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFog;                                        // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 SerializedScreenshot;                              // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseSky;                                           // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkyTime;                                           // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGuid, struct FCustomPropData>    CustomProps;                                       // 0x00A8(0x0050)(NativeAccessSpecifierPublic)
	float                                         SimpleAmbientMod;                                  // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirLightStrength;                                  // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSkyAndAmbient;                                 // 0x0100(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoFriction;                                       // 0x0101(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelEditorSave">();
	}
	static class ULevelEditorSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelEditorSave>();
	}
};
static_assert(alignof(ULevelEditorSave) == 0x000008, "Wrong alignment on ULevelEditorSave");
static_assert(sizeof(ULevelEditorSave) == 0x000108, "Wrong size on ULevelEditorSave");
static_assert(offsetof(ULevelEditorSave, LUTIndex) == 0x000028, "Member 'ULevelEditorSave::LUTIndex' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, LUTStrength) == 0x00002C, "Member 'ULevelEditorSave::LUTStrength' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, BorderIndex) == 0x000030, "Member 'ULevelEditorSave::BorderIndex' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, AmbientStength) == 0x000034, "Member 'ULevelEditorSave::AmbientStength' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, ActorSaves) == 0x000038, "Member 'ULevelEditorSave::ActorSaves' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, VoxelSave) == 0x000048, "Member 'ULevelEditorSave::VoxelSave' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, SaveDepth) == 0x000068, "Member 'ULevelEditorSave::SaveDepth' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, WorldBounds) == 0x00006C, "Member 'ULevelEditorSave::WorldBounds' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, SkylightIndex) == 0x000084, "Member 'ULevelEditorSave::SkylightIndex' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, bEnableFog) == 0x000088, "Member 'ULevelEditorSave::bEnableFog' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, SerializedScreenshot) == 0x000090, "Member 'ULevelEditorSave::SerializedScreenshot' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, bUseSky) == 0x0000A0, "Member 'ULevelEditorSave::bUseSky' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, SkyTime) == 0x0000A4, "Member 'ULevelEditorSave::SkyTime' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, CustomProps) == 0x0000A8, "Member 'ULevelEditorSave::CustomProps' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, SimpleAmbientMod) == 0x0000F8, "Member 'ULevelEditorSave::SimpleAmbientMod' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, DirLightStrength) == 0x0000FC, "Member 'ULevelEditorSave::DirLightStrength' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, bUseSkyAndAmbient) == 0x000100, "Member 'ULevelEditorSave::bUseSkyAndAmbient' has a wrong offset!");
static_assert(offsetof(ULevelEditorSave, bNoFriction) == 0x000101, "Member 'ULevelEditorSave::bNoFriction' has a wrong offset!");

// Class ThankYouVeryCool.LevelAssetSave
// 0x0010 (0x0038 - 0x0028)
class ULevelAssetSave final : public USaveGame
{
public:
	TArray<uint8>                                 AssetData;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAssetSave">();
	}
	static class ULevelAssetSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelAssetSave>();
	}
};
static_assert(alignof(ULevelAssetSave) == 0x000008, "Wrong alignment on ULevelAssetSave");
static_assert(sizeof(ULevelAssetSave) == 0x000038, "Wrong size on ULevelAssetSave");
static_assert(offsetof(ULevelAssetSave, AssetData) == 0x000028, "Member 'ULevelAssetSave::AssetData' has a wrong offset!");

// Class ThankYouVeryCool.CustomPropSave
// 0x0090 (0x00B8 - 0x0028)
class UCustomPropSave final : public USaveGame
{
public:
	struct FCustomPropData                        MyData;                                            // 0x0028(0x0090)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPropSave">();
	}
	static class UCustomPropSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPropSave>();
	}
};
static_assert(alignof(UCustomPropSave) == 0x000008, "Wrong alignment on UCustomPropSave");
static_assert(sizeof(UCustomPropSave) == 0x0000B8, "Wrong size on UCustomPropSave");
static_assert(offsetof(UCustomPropSave, MyData) == 0x000028, "Member 'UCustomPropSave::MyData' has a wrong offset!");

// Class ThankYouVeryCool.CustomPropCatSave
// 0x0030 (0x0058 - 0x0028)
class UCustomPropCatSave final : public USaveGame
{
public:
	struct FPropCatUploadInfo                     UploadInfo;                                        // 0x0028(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomPropCatSave">();
	}
	static class UCustomPropCatSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomPropCatSave>();
	}
};
static_assert(alignof(UCustomPropCatSave) == 0x000008, "Wrong alignment on UCustomPropCatSave");
static_assert(sizeof(UCustomPropCatSave) == 0x000058, "Wrong size on UCustomPropCatSave");
static_assert(offsetof(UCustomPropCatSave, UploadInfo) == 0x000028, "Member 'UCustomPropCatSave::UploadInfo' has a wrong offset!");

// Class ThankYouVeryCool.CustomCampaign
// 0x0098 (0x00C0 - 0x0028)
class UCustomCampaign final : public USaveGame
{
public:
	struct FCustomCampaignStruct                  CampaignInfo;                                      // 0x0028(0x0088)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	class FString                                 LocalPath;                                         // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomCampaign">();
	}
	static class UCustomCampaign* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomCampaign>();
	}
};
static_assert(alignof(UCustomCampaign) == 0x000008, "Wrong alignment on UCustomCampaign");
static_assert(sizeof(UCustomCampaign) == 0x0000C0, "Wrong size on UCustomCampaign");
static_assert(offsetof(UCustomCampaign, CampaignInfo) == 0x000028, "Member 'UCustomCampaign::CampaignInfo' has a wrong offset!");
static_assert(offsetof(UCustomCampaign, LocalPath) == 0x0000B0, "Member 'UCustomCampaign::LocalPath' has a wrong offset!");

// Class ThankYouVeryCool.LevelEditorWidget
// 0x0000 (0x0260 - 0x0260)
class ULevelEditorWidget : public UUserWidget
{
public:
	void DisplayPropertiesFor(class AActor* ForActor);
	void DisplaySavedValues(class ULevelEditorSave* SaveInfo);
	void DisplayToolDimensions(const struct FIntVector& InDims);
	struct FWorkshopChapterData GetChapterData();
	void GetSimSettings(bool* bEnableAI, bool* bSpawnAtCamera);
	void HideToolDimensions();
	void HotKeyModePressed(EEditMode InMode);
	void HotKeyTypePressed(EEditType InType);
	void RefreshPropLibrary();
	void RefreshWorkshopTab();
	void SetAsDefault();
	void SetSelectedMaterial(int32 Mat);
	void SetWorldSizeDisplay(const struct FVoxelIntBox& InValue);
	void ShowSelectControls(ESelectStage InStage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelEditorWidget">();
	}
	static class ULevelEditorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelEditorWidget>();
	}
};
static_assert(alignof(ULevelEditorWidget) == 0x000008, "Wrong alignment on ULevelEditorWidget");
static_assert(sizeof(ULevelEditorWidget) == 0x000260, "Wrong size on ULevelEditorWidget");

// Class ThankYouVeryCool.Lift
// 0x00B8 (0x0328 - 0x0270)
class ALift final : public ATYVCActor
{
public:
	bool                                          bStartAtTop;                                       // 0x0270(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        DummyRoot;                                         // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELiftState                                    LiftState;                                         // 0x0280(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AVoxelBuilder2*                         Builder;                                           // 0x0288(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATYVCInteractableVoxelWorld*            BottomButton;                                      // 0x0290(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATYVCInteractableVoxelWorld*            TopButton;                                         // 0x0298(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATYVCInteractableVoxelWorld*            LiftButton;                                        // 0x02A0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATYVCVoxelWorld*                        Lift;                                              // 0x02A8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlatformDimensions;                                // 0x02B0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ButtonDimensions;                                  // 0x02BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TravelHeight;                                      // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FrameMaterial;                                     // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LiftMaterial;                                      // 0x02CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ButtonMaterial;                                    // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LiftSpeed;                                         // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                PromptClass;                                       // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x28];                                     // 0x02E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             StartSound;                                        // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             StopSound;                                         // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PressedSound;                                      // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        LoopAudioComp;                                     // 0x0320(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Build();
	void CleanUp();
	void OnBottomPressed();
	void OnLiftPressed();
	void OnTopPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Lift">();
	}
	static class ALift* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALift>();
	}
};
static_assert(alignof(ALift) == 0x000008, "Wrong alignment on ALift");
static_assert(sizeof(ALift) == 0x000328, "Wrong size on ALift");
static_assert(offsetof(ALift, bStartAtTop) == 0x000270, "Member 'ALift::bStartAtTop' has a wrong offset!");
static_assert(offsetof(ALift, DummyRoot) == 0x000278, "Member 'ALift::DummyRoot' has a wrong offset!");
static_assert(offsetof(ALift, LiftState) == 0x000280, "Member 'ALift::LiftState' has a wrong offset!");
static_assert(offsetof(ALift, Builder) == 0x000288, "Member 'ALift::Builder' has a wrong offset!");
static_assert(offsetof(ALift, BottomButton) == 0x000290, "Member 'ALift::BottomButton' has a wrong offset!");
static_assert(offsetof(ALift, TopButton) == 0x000298, "Member 'ALift::TopButton' has a wrong offset!");
static_assert(offsetof(ALift, LiftButton) == 0x0002A0, "Member 'ALift::LiftButton' has a wrong offset!");
static_assert(offsetof(ALift, Lift) == 0x0002A8, "Member 'ALift::Lift' has a wrong offset!");
static_assert(offsetof(ALift, PlatformDimensions) == 0x0002B0, "Member 'ALift::PlatformDimensions' has a wrong offset!");
static_assert(offsetof(ALift, ButtonDimensions) == 0x0002BC, "Member 'ALift::ButtonDimensions' has a wrong offset!");
static_assert(offsetof(ALift, TravelHeight) == 0x0002C4, "Member 'ALift::TravelHeight' has a wrong offset!");
static_assert(offsetof(ALift, FrameMaterial) == 0x0002C8, "Member 'ALift::FrameMaterial' has a wrong offset!");
static_assert(offsetof(ALift, LiftMaterial) == 0x0002CC, "Member 'ALift::LiftMaterial' has a wrong offset!");
static_assert(offsetof(ALift, ButtonMaterial) == 0x0002D0, "Member 'ALift::ButtonMaterial' has a wrong offset!");
static_assert(offsetof(ALift, LiftSpeed) == 0x0002D4, "Member 'ALift::LiftSpeed' has a wrong offset!");
static_assert(offsetof(ALift, PromptClass) == 0x0002D8, "Member 'ALift::PromptClass' has a wrong offset!");
static_assert(offsetof(ALift, StartSound) == 0x000308, "Member 'ALift::StartSound' has a wrong offset!");
static_assert(offsetof(ALift, StopSound) == 0x000310, "Member 'ALift::StopSound' has a wrong offset!");
static_assert(offsetof(ALift, PressedSound) == 0x000318, "Member 'ALift::PressedSound' has a wrong offset!");
static_assert(offsetof(ALift, LoopAudioComp) == 0x000320, "Member 'ALift::LoopAudioComp' has a wrong offset!");

// Class ThankYouVeryCool.LiftBuilder
// 0x0000 (0x0A18 - 0x0A18)
class ALiftBuilder final : public AVoxelBuilder2
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LiftBuilder">();
	}
	static class ALiftBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALiftBuilder>();
	}
};
static_assert(alignof(ALiftBuilder) == 0x000008, "Wrong alignment on ALiftBuilder");
static_assert(sizeof(ALiftBuilder) == 0x000A18, "Wrong size on ALiftBuilder");

// Class ThankYouVeryCool.LuckDisplay
// 0x0000 (0x0260 - 0x0260)
class ULuckDisplay : public UUserWidget
{
public:
	void Reset(int32 MaxAmount);
	void SetLuck(int32 Amount, bool bRestore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuckDisplay">();
	}
	static class ULuckDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuckDisplay>();
	}
};
static_assert(alignof(ULuckDisplay) == 0x000008, "Wrong alignment on ULuckDisplay");
static_assert(sizeof(ULuckDisplay) == 0x000260, "Wrong size on ULuckDisplay");

// Class ThankYouVeryCool.VoxelBrush
// 0x0020 (0x0240 - 0x0220)
class AVoxelBrush final : public AActor
{
public:
	class AVoxelWorld*                            PrimaryVoxelWorld;                                 // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            SecondaryVoxelWorld;                               // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            TertiaryVoxelWorld;                                // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            QuaternaryVoxelWorld;                              // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBrush">();
	}
	static class AVoxelBrush* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelBrush>();
	}
};
static_assert(alignof(AVoxelBrush) == 0x000008, "Wrong alignment on AVoxelBrush");
static_assert(sizeof(AVoxelBrush) == 0x000240, "Wrong size on AVoxelBrush");
static_assert(offsetof(AVoxelBrush, PrimaryVoxelWorld) == 0x000220, "Member 'AVoxelBrush::PrimaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBrush, SecondaryVoxelWorld) == 0x000228, "Member 'AVoxelBrush::SecondaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBrush, TertiaryVoxelWorld) == 0x000230, "Member 'AVoxelBrush::TertiaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelBrush, QuaternaryVoxelWorld) == 0x000238, "Member 'AVoxelBrush::QuaternaryVoxelWorld' has a wrong offset!");

// Class ThankYouVeryCool.LuosProjectile
// 0x0010 (0x0230 - 0x0220)
class ALuosProjectile : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AArmCannon*                             MyArmCannon;                                       // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OverlappedSomething(class AActor* Overlapped, const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuosProjectile">();
	}
	static class ALuosProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALuosProjectile>();
	}
};
static_assert(alignof(ALuosProjectile) == 0x000008, "Wrong alignment on ALuosProjectile");
static_assert(sizeof(ALuosProjectile) == 0x000230, "Wrong size on ALuosProjectile");
static_assert(offsetof(ALuosProjectile, MyArmCannon) == 0x000228, "Member 'ALuosProjectile::MyArmCannon' has a wrong offset!");

// Class ThankYouVeryCool.MaterialImpactLogic
// 0x0020 (0x00D0 - 0x00B0)
class UMaterialImpactLogic final : public UActorComponent
{
public:
	TArray<uint8>                                 MaterialIndices;                                   // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FString                                 MaterialNameString;                                // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialImpactLogic">();
	}
	static class UMaterialImpactLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialImpactLogic>();
	}
};
static_assert(alignof(UMaterialImpactLogic) == 0x000008, "Wrong alignment on UMaterialImpactLogic");
static_assert(sizeof(UMaterialImpactLogic) == 0x0000D0, "Wrong size on UMaterialImpactLogic");
static_assert(offsetof(UMaterialImpactLogic, MaterialIndices) == 0x0000B0, "Member 'UMaterialImpactLogic::MaterialIndices' has a wrong offset!");
static_assert(offsetof(UMaterialImpactLogic, MaterialNameString) == 0x0000C0, "Member 'UMaterialImpactLogic::MaterialNameString' has a wrong offset!");

// Class ThankYouVeryCool.Mech
// 0x00C0 (0x0580 - 0x04C0)
class AMech : public ACharacter
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShieldActive;                                     // 0x04C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallCheckDistance;                                 // 0x04D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenWallTests;                              // 0x04D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D8[0x10];                                     // 0x04D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        SparkParticle;                                     // 0x04E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponRateOfFire;                                  // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AM203_Round>                RocketActorClass;                                  // 0x04F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InterpedFocus;                                     // 0x0500(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                InterpedFocusPoint;                                // 0x050C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x4];                                      // 0x0518(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusSpeed;                                        // 0x051C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMechController*                        MyController;                                      // 0x0520(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_528[0x8];                                      // 0x0528(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             ShootSound;                                        // 0x0530(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShootCone;                                         // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        MuzzleFlash;                                       // 0x0540(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDormant;                                        // 0x0549(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54A[0x6];                                      // 0x054A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           WakeUpAnim;                                        // 0x0550(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ShutdownAnim;                                      // 0x0558(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookatSpeed;                                       // 0x0568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementSpeed;                                     // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_570[0x4];                                      // 0x0570(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MyHP;                                              // 0x0574(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AfterShutdown();
	void AfterWakeUp();
	void DoDestructionGraph(const struct FVector& WorldLocation, class AVoxelWorld* OnWorld);
	void DoHitLogic(const struct FHitResult& HitResult);
	void DoWallTest();
	struct FRotator GetInterpolatedLookAt(const struct FVector& GoalLookAt, float DeltaTime);
	struct FTransform GetShootOrigin();
	void LevelReady();
	void MakeDead();
	void NotifyMechHit(const struct FHitResult& HitResult, int32 Dmg);
	void SeenPlayer();
	void SetShieldActive(bool bActive, bool bInstant);
	void SetSpeed(float InSpeed);
	void Shoot();
	void ShutDown();
	void WakeUp();
	void WokenUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mech">();
	}
	static class AMech* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMech>();
	}
};
static_assert(alignof(AMech) == 0x000010, "Wrong alignment on AMech");
static_assert(sizeof(AMech) == 0x000580, "Wrong size on AMech");
static_assert(offsetof(AMech, bShieldActive) == 0x0004C0, "Member 'AMech::bShieldActive' has a wrong offset!");
static_assert(offsetof(AMech, TYVCGameMode) == 0x0004C8, "Member 'AMech::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AMech, WallCheckDistance) == 0x0004D0, "Member 'AMech::WallCheckDistance' has a wrong offset!");
static_assert(offsetof(AMech, TimeBetweenWallTests) == 0x0004D4, "Member 'AMech::TimeBetweenWallTests' has a wrong offset!");
static_assert(offsetof(AMech, SparkParticle) == 0x0004E8, "Member 'AMech::SparkParticle' has a wrong offset!");
static_assert(offsetof(AMech, WeaponRateOfFire) == 0x0004F0, "Member 'AMech::WeaponRateOfFire' has a wrong offset!");
static_assert(offsetof(AMech, RocketActorClass) == 0x0004F8, "Member 'AMech::RocketActorClass' has a wrong offset!");
static_assert(offsetof(AMech, InterpedFocus) == 0x000500, "Member 'AMech::InterpedFocus' has a wrong offset!");
static_assert(offsetof(AMech, InterpedFocusPoint) == 0x00050C, "Member 'AMech::InterpedFocusPoint' has a wrong offset!");
static_assert(offsetof(AMech, FocusSpeed) == 0x00051C, "Member 'AMech::FocusSpeed' has a wrong offset!");
static_assert(offsetof(AMech, MyController) == 0x000520, "Member 'AMech::MyController' has a wrong offset!");
static_assert(offsetof(AMech, ShootSound) == 0x000530, "Member 'AMech::ShootSound' has a wrong offset!");
static_assert(offsetof(AMech, ShootCone) == 0x000538, "Member 'AMech::ShootCone' has a wrong offset!");
static_assert(offsetof(AMech, MuzzleFlash) == 0x000540, "Member 'AMech::MuzzleFlash' has a wrong offset!");
static_assert(offsetof(AMech, bIsDead) == 0x000548, "Member 'AMech::bIsDead' has a wrong offset!");
static_assert(offsetof(AMech, bIsDormant) == 0x000549, "Member 'AMech::bIsDormant' has a wrong offset!");
static_assert(offsetof(AMech, WakeUpAnim) == 0x000550, "Member 'AMech::WakeUpAnim' has a wrong offset!");
static_assert(offsetof(AMech, ShutdownAnim) == 0x000558, "Member 'AMech::ShutdownAnim' has a wrong offset!");
static_assert(offsetof(AMech, LookatSpeed) == 0x000568, "Member 'AMech::LookatSpeed' has a wrong offset!");
static_assert(offsetof(AMech, MovementSpeed) == 0x00056C, "Member 'AMech::MovementSpeed' has a wrong offset!");
static_assert(offsetof(AMech, MyHP) == 0x000574, "Member 'AMech::MyHP' has a wrong offset!");

// Class ThankYouVeryCool.MechController
// 0x0020 (0x0348 - 0x0328)
class AMechController : public AAIController
{
public:
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          MyBT;                                              // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InterpedRotation;                                  // 0x0338(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationSpeed;                                     // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateTargetPerception(class AActor* Actor, const struct FAIStimulus& Stimulus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MechController">();
	}
	static class AMechController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMechController>();
	}
};
static_assert(alignof(AMechController) == 0x000008, "Wrong alignment on AMechController");
static_assert(sizeof(AMechController) == 0x000348, "Wrong size on AMechController");
static_assert(offsetof(AMechController, TYVCGameMode) == 0x000328, "Member 'AMechController::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AMechController, MyBT) == 0x000330, "Member 'AMechController::MyBT' has a wrong offset!");
static_assert(offsetof(AMechController, InterpedRotation) == 0x000338, "Member 'AMechController::InterpedRotation' has a wrong offset!");
static_assert(offsetof(AMechController, RotationSpeed) == 0x000344, "Member 'AMechController::RotationSpeed' has a wrong offset!");

// Class ThankYouVeryCool.MenuPawn
// 0x0018 (0x02C0 - 0x02A8)
class AMenuPawn : public ADefaultPawn
{
public:
	class UCameraComponent*                       CameraComp;                                        // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LerpTransform(const struct FTransform& Transform);
	void OnCloseToPlayer();
	void OnTransformComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPawn">();
	}
	static class AMenuPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuPawn>();
	}
};
static_assert(alignof(AMenuPawn) == 0x000008, "Wrong alignment on AMenuPawn");
static_assert(sizeof(AMenuPawn) == 0x0002C0, "Wrong size on AMenuPawn");
static_assert(offsetof(AMenuPawn, CameraComp) == 0x0002A8, "Member 'AMenuPawn::CameraComp' has a wrong offset!");
static_assert(offsetof(AMenuPawn, TYVCGameMode) == 0x0002B0, "Member 'AMenuPawn::TYVCGameMode' has a wrong offset!");

// Class ThankYouVeryCool.MoveTo_ExposedFilter
// 0x0000 (0x00B0 - 0x00B0)
class UMoveTo_ExposedFilter final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveTo_ExposedFilter">();
	}
	static class UMoveTo_ExposedFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveTo_ExposedFilter>();
	}
};
static_assert(alignof(UMoveTo_ExposedFilter) == 0x000008, "Wrong alignment on UMoveTo_ExposedFilter");
static_assert(sizeof(UMoveTo_ExposedFilter) == 0x0000B0, "Wrong size on UMoveTo_ExposedFilter");

// Class ThankYouVeryCool.MusicPlayer
// 0x0110 (0x0330 - 0x0220)
class AMusicPlayer : public AActor
{
public:
	float                                         BPitchMod;                                         // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class URuntimeAudioImporterLibrary*           CurrentUserRuntime;                                // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        MusicComp;                                         // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x30];                                     // 0x0238(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class USoundBase>>      ArcadeTracks;                                      // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bForceTrack;                                       // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              TrackToForce;                                      // 0x0280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundSubmixBase*                       PauseSubmix;                                       // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              PauseMix;                                          // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class USoundBase>, class FText> OST;                                               // 0x0298(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USoundBase>>      EditorOST;                                         // 0x02E8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioAnalysisToolsLibrary*             AudioAnalysisTools;                                // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x4];                                      // 0x0320(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BeatIndex;                                         // 0x0324(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x4];                                      // 0x0328(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinBeatTime;                                       // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CacheTrack(const TSoftObjectPtr<class USoundBase>& ToCache);
	void CustomTrackLoaded(class URuntimeAudioImporterLibrary* Importer, class UImportedSoundWave* ImportedSoundWave, ERuntimeImportStatus Status);
	void FadeTrack(TSoftObjectPtr<class USoundBase> WhiteList, float Time);
	class FText GetCurrentTrackTitle();
	int32 GetCustomTrackCount();
	void GetCustomTrackPath(class FString* OutPath);
	void GetPCMData(const TArray<float>& PCMData);
	class FText GetTitleOfTrack(TSoftObjectPtr<class USoundBase> track);
	bool IsAnyTrackPlaying();
	bool IsAnyTrackPlayingBesidesTitle();
	bool IsTrackPlaying(TSoftObjectPtr<class USoundBase> ToCheck);
	void OnPaused(bool bPaused);
	void OpenMusicPath();
	void PlayIfNotPlaying(TSoftObjectPtr<class USoundBase> ToPlay);
	void PlayRandomEditorTrack();
	void PlayRandomGameplayTrack();
	void PlayRandomUserTrack();
	void PlayTrack(TSoftObjectPtr<class USoundBase> InTrack, bool bDontStoreAsLast, bool bIsCustom);
	void StopTrack(TSoftObjectPtr<class USoundBase> WhiteList, bool bInstant, float FadeOutTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicPlayer">();
	}
	static class AMusicPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMusicPlayer>();
	}
};
static_assert(alignof(AMusicPlayer) == 0x000008, "Wrong alignment on AMusicPlayer");
static_assert(sizeof(AMusicPlayer) == 0x000330, "Wrong size on AMusicPlayer");
static_assert(offsetof(AMusicPlayer, BPitchMod) == 0x000220, "Member 'AMusicPlayer::BPitchMod' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, CurrentUserRuntime) == 0x000228, "Member 'AMusicPlayer::CurrentUserRuntime' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, MusicComp) == 0x000230, "Member 'AMusicPlayer::MusicComp' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, ArcadeTracks) == 0x000268, "Member 'AMusicPlayer::ArcadeTracks' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, bForceTrack) == 0x000278, "Member 'AMusicPlayer::bForceTrack' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, TrackToForce) == 0x000280, "Member 'AMusicPlayer::TrackToForce' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, PauseSubmix) == 0x000288, "Member 'AMusicPlayer::PauseSubmix' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, PauseMix) == 0x000290, "Member 'AMusicPlayer::PauseMix' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, OST) == 0x000298, "Member 'AMusicPlayer::OST' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, EditorOST) == 0x0002E8, "Member 'AMusicPlayer::EditorOST' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, TYVCGameMode) == 0x0002F8, "Member 'AMusicPlayer::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, AudioAnalysisTools) == 0x000318, "Member 'AMusicPlayer::AudioAnalysisTools' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, BeatIndex) == 0x000324, "Member 'AMusicPlayer::BeatIndex' has a wrong offset!");
static_assert(offsetof(AMusicPlayer, MinBeatTime) == 0x00032C, "Member 'AMusicPlayer::MinBeatTime' has a wrong offset!");

// Class ThankYouVeryCool.NavLinkProxy_Jump
// 0x0008 (0x0278 - 0x0270)
class ANavLinkProxy_Jump final : public ANavLinkProxy
{
public:
	float                                         JumpDuration;                                      // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveSmartLinkReached_Internal(class AActor* Agent, const struct FVector& Destination);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy_Jump">();
	}
	static class ANavLinkProxy_Jump* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy_Jump>();
	}
};
static_assert(alignof(ANavLinkProxy_Jump) == 0x000008, "Wrong alignment on ANavLinkProxy_Jump");
static_assert(sizeof(ANavLinkProxy_Jump) == 0x000278, "Wrong size on ANavLinkProxy_Jump");
static_assert(offsetof(ANavLinkProxy_Jump, JumpDuration) == 0x000270, "Member 'ANavLinkProxy_Jump::JumpDuration' has a wrong offset!");

// Class ThankYouVeryCool.NdocRingWidget
// 0x0000 (0x0260 - 0x0260)
class UNdocRingWidget : public UUserWidget
{
public:
	void CloseOuterAnimation();
	void StartOuterAnimation();
	void UpdateInnerRing(float UpdateAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NdocRingWidget">();
	}
	static class UNdocRingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNdocRingWidget>();
	}
};
static_assert(alignof(UNdocRingWidget) == 0x000008, "Wrong alignment on UNdocRingWidget");
static_assert(sizeof(UNdocRingWidget) == 0x000260, "Wrong size on UNdocRingWidget");

// Class ThankYouVeryCool.NodeMonitor
// 0x0038 (0x0258 - 0x0220)
class ANodeMonitor final : public AActor
{
public:
	class USphereComponent*                       SphereViz;                                         // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MyNodeName;                                        // 0x022C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACampaignManager*                       MyCampaignManager;                                 // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            OuterWorld;                                        // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Player;                                            // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NodeMonitor">();
	}
	static class ANodeMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANodeMonitor>();
	}
};
static_assert(alignof(ANodeMonitor) == 0x000008, "Wrong alignment on ANodeMonitor");
static_assert(sizeof(ANodeMonitor) == 0x000258, "Wrong size on ANodeMonitor");
static_assert(offsetof(ANodeMonitor, SphereViz) == 0x000220, "Member 'ANodeMonitor::SphereViz' has a wrong offset!");
static_assert(offsetof(ANodeMonitor, Radius) == 0x000228, "Member 'ANodeMonitor::Radius' has a wrong offset!");
static_assert(offsetof(ANodeMonitor, MyNodeName) == 0x00022C, "Member 'ANodeMonitor::MyNodeName' has a wrong offset!");
static_assert(offsetof(ANodeMonitor, MyCampaignManager) == 0x000238, "Member 'ANodeMonitor::MyCampaignManager' has a wrong offset!");
static_assert(offsetof(ANodeMonitor, OuterWorld) == 0x000240, "Member 'ANodeMonitor::OuterWorld' has a wrong offset!");
static_assert(offsetof(ANodeMonitor, Player) == 0x000248, "Member 'ANodeMonitor::Player' has a wrong offset!");

// Class ThankYouVeryCool.NPC
// 0x0690 (0x0EC0 - 0x0830)
class ANPC : public AALSBaseCharacter
{
public:
	uint8                                         Pad_828[0x10];                                     // 0x0828(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxKnockback;                                      // 0x0838(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointsToGiveOnDeath;                               // 0x083C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_840[0x1];                                      // 0x0840(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bJumperOverride;                                   // 0x0841(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCType                                      MyType;                                            // 0x0842(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_843[0xD];                                      // 0x0843(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSuperShield;                                      // 0x0850(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_851[0x7];                                      // 0x0851(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACampaignMarker*                        MySpawnMarker;                                     // 0x0858(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_860[0x18];                                     // 0x0860(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsAsset*                          DeadPhysicsAsset;                                  // 0x0878(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsAsset*                          LivingPhysicsAsset;                                // 0x0880(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceSqToNavWalk;                               // 0x0888(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88C[0xC];                                      // 0x088C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KnockdownZBoost;                                   // 0x0898(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89C[0x14];                                     // 0x089C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        HitThrownSystem;                                   // 0x08B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToBeKnockedDown;                               // 0x08B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8BC[0x4];                                      // 0x08BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JetpackExplosionCooldown;                          // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C4[0x4];                                      // 0x08C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpeedForRagdollHit;                             // 0x08C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8CC[0xC];                                      // 0x08CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollCooldownTime;                               // 0x08D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DieOnFallVelocity;                                 // 0x08DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E0[0x8];                                      // 0x08E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        GibParticleSystem;                                 // 0x08E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DecorativeHead;                                    // 0x08F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  NPCUID;                                            // 0x08F8(0x0010)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PunchAnim;                                         // 0x0908(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_910[0x2];                                      // 0x0910(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSleeping;                                       // 0x0912(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_913[0x5];                                      // 0x0913(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        TorchSystem;                                       // 0x0918(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       TorchComps;                                        // 0x0920(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	ETutorialType                                 TutorialType;                                      // 0x0930(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_931[0x7];                                      // 0x0931(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATutorialPickup*                        MyTutorialPickup;                                  // 0x0938(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_940[0x8];                                      // 0x0940(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponBase*                            WeaponToGrab;                                      // 0x0948(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArmored;                                        // 0x0950(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_951[0x3];                                      // 0x0951(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NextArmorThreshold;                                // 0x0954(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         UnattachedArmors;                                  // 0x0958(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         ArmorThresholds;                                   // 0x0968(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96C[0x4];                                      // 0x096C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBackpack*                              BackpackComponent;                                 // 0x0970(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBackpackTroop;                                    // 0x0978(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSniper;                                         // 0x0979(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJetpack;                                        // 0x097A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsZombie;                                         // 0x097B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSpecialist;                                     // 0x097C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMinigun;                                        // 0x097D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCloaker;                                        // 0x097E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRocket;                                         // 0x097F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               SniperLaserComponent;                              // 0x0980(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               JetBlast1;                                         // 0x0988(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               JetBlast2;                                         // 0x0990(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JetpackDeathThrust;                                // 0x0998(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JetPackDeathTimeMax;                               // 0x099C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A0[0x4];                                      // 0x09A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSSOnly;                                           // 0x09A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A5[0x3];                                      // 0x09A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         ArmorSkeletalComponents;                           // 0x09A8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B8[0x68];                                     // 0x09B8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TestVal;                                           // 0x0A20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A24[0x14];                                     // 0x0A24(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AimRoot;                                           // 0x0A38(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        VirtualBarrel;                                     // 0x0A40(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunnedMovementSpeed;                              // 0x0A48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4C[0x10];                                     // 0x0A4C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LaserSpeed;                                        // 0x0A5C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A60[0x4];                                      // 0x0A60(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleedStunnedMovementSpeed;                        // 0x0A64(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverMovementSpeed;                                // 0x0A68(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverMovementTotalDistance;                        // 0x0A6C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A70[0x14];                                     // 0x0A70(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OnHitPreserveMovementFactor;                       // 0x0A84(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShieldUnit;                                       // 0x0A88(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A89[0x3];                                      // 0x0A89(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShieldHP;                                          // 0x0A8C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ShieldDynMat;                                      // 0x0A90(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ShieldComponent;                                   // 0x0A98(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA0[0x8];                                      // 0x0AA0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 CanisterComponent;                                 // 0x0AA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimSpeed;                                          // 0x0AB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB4[0x4];                                      // 0x0AB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TYVCRotationRate;                                  // 0x0AB8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackTolerance;                                     // 0x0ABC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPhysicalAnimationData                 PAnimData;                                         // 0x0AC0(0x0024)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OnHitRadius;                                       // 0x0AE4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE8[0xC];                                      // 0x0AE8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinAccuracy;                                       // 0x0AF4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccuracy;                                       // 0x0AF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSightTimeNormal;                                // 0x0AFC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSightTimeHard;                                  // 0x0B00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LifeLightParamName;                                // 0x0B04(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0C[0x4];                                      // 0x0B0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               LifeLightMat;                                      // 0x0B10(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               BodyMat;                                           // 0x0B18(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     UncloakedBody;                                     // 0x0B20(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      UncloakedHead;                                     // 0x0B28(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     InvulnJetpackMat;                                  // 0x0B30(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentlyCloaked;                               // 0x0B38(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B39[0x3];                                      // 0x0B39(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoveryTime;                                      // 0x0B3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B40[0x10];                                     // 0x0B40(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            HitRecoverFloat;                                   // 0x0B50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B58[0x98];                                     // 0x0B58(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             DeathSound;                                        // 0x0BF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USphereComponent*                       HeadshotComp;                                      // 0x0BF8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetZOffset;                                     // 0x0C00(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C04[0x1C];                                     // 0x0C04(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UNPCAnimInstance*                       NPCAnimInstance;                                   // 0x0C20(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0C28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HP;                                                // 0x0C30(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartingHP;                                        // 0x0C34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInCover;                                          // 0x0C38(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldLean;                                       // 0x0C39(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C3A[0x2];                                      // 0x0C3A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LeanDirection;                                     // 0x0C3C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C40[0x8];                                      // 0x0C40(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunDuration;                                      // 0x0C48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StunDurationMelee;                                 // 0x0C4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StunAnimMeleeSpeed;                                // 0x0C50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C54[0xC];                                      // 0x0C54(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LooseProfileName;                                  // 0x0C60(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FirmProfileName;                                   // 0x0C68(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ShotInArmsMontage;                                 // 0x0C70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           HeadBones;                                         // 0x0C78(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           TorsoBones;                                        // 0x0C88(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           LeftArmBones;                                      // 0x0C98(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           RightArmBones;                                     // 0x0CA8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           LeftLegBones;                                      // 0x0CB8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           RightLegBones;                                     // 0x0CC8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EBoneGroup, class FName>                 BoneToSimulatePerGroup;                            // 0x0CD8(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AWeaponBase>                StartingWeapon;                                    // 0x0D28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AWeaponBase>                StartingSideArm;                                   // 0x0D30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HolsterSocket;                                     // 0x0D38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeaponBase*                            HeldWeapon;                                        // 0x0D40(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeaponBase*                            HolsteredWeapon;                                   // 0x0D48(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeaponBase*                            StartingWeaponPtr;                                 // 0x0D50(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeaponBase*                            StartingSidearmPtr;                                // 0x0D58(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldShoot;                                      // 0x0D60(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D61[0x3F];                                     // 0x0D61(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	ELeanState                                    LeanState;                                         // 0x0DA0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA1[0x7];                                      // 0x0DA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       DetectUnderFireSphere;                             // 0x0DA8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       BackpackChargeSphere;                              // 0x0DB0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DB8[0x4];                                      // 0x0DB8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilReductionRate;                               // 0x0DBC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerCharacter*                       PlayerActor;                                       // 0x0DC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DrawSidearmMontage;                                // 0x0DC8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD0[0x30];                                     // 0x0DD0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EWeaponPosition                               WeaponPosition;                                    // 0x0E00(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E01[0x7];                                      // 0x0E01(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AWeaponBase>>        StartingWeaponPool;                                // 0x0E08(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AWeaponBase>>        StartingSideArmPool;                               // 0x0E18(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   EventOnDeath;                                      // 0x0E28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpeechComponent*                       SpeechComponent;                                   // 0x0E30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USpeechComponent>           SpeechComponentClass;                              // 0x0E38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SpeechDebugLine;                                   // 0x0E40(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E50[0x20];                                     // 0x0E50(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    StimSourceComp;                                    // 0x0E70(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0E78(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E79[0x17];                                     // 0x0E79(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class ANPCController*                         MyController;                                      // 0x0E90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E98[0x10];                                     // 0x0E98(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ANPC*                                   StashedResponder;                                  // 0x0EA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB0[0x10];                                     // 0x0EB0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyHitForce(const struct FVector& Impulse, class FName BoneName, const struct FVector& Location);
	void CapsuleHit(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& SweepResult);
	void CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void Detonate(bool bGivePlayerCredit);
	void DisableCloak();
	void EndStun();
	void EquipPumpkin();
	void EquipSidearm();
	void EquipXMas();
	void FireSayCallback();
	void ForceSetFocus(class AActor* ActorToFocus);
	float GetRecoil();
	class ASquad* GetSquad();
	void GetupFromKnockdown();
	bool Gib(bool bGivePlayerCredit, bool bForce, const struct FVector& WorldDir);
	void GrabAnimationAtGrabPoint();
	void GrabSidearm();
	void GrabWeaponOnGround(class AWeaponBase* Weapon);
	bool HasSidearm();
	void HitReactionOver(class UAnimMontage* AnimMontage, bool bInterrupted, class FName EffetedBoneName);
	bool IsArmed();
	void LevelReady();
	void LevelUnload();
	void NotifyBlendedOutOfStumble();
	void NotifyBPDead();
	bool NotifyBPTargetSighted(bool bSighted);
	void NotifyRagdollALS();
	void NotifyUnragdollALS();
	void OnBackpackOverlapBegin(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnJetpackCrash(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& SweepResult);
	void PreLevelReady();
	bool ReactToBulletHit(const struct FHitResult& HitResult, float Joules, float HPdmg, EImpactType ImpactType, bool* bHitArmor, bool* bShouldContinue);
	void RequestResponse();
	void Say(class FName Line, bool bOverrideTimer);
	void SayWithCallback(const TArray<class FName>& Line, const TDelegate<void(bool bWasInterrupted)>& Callback, bool bOverrideTimer);
	void SayWithResponse(const TArray<class FName>& MyLine, class ANPC* Responder, const TArray<class FName>& ResponderLine, bool bOverrideTimer);
	void SetBackpackLights(bool bViz);
	void SetCloakActive(bool bShouldBeActive, bool bShouldAnimate);
	void SetLean(ELeanState NewLean);
	void SetWeaponPosition(EWeaponPosition NewPosition);
	bool ShootAtFocalPoint(int32* OutPoints, bool bCanBeKillingShot);
	void SpawnGibFX(const struct FVector& WorldDir);
	void UpdateCoverState(ECoverState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPC">();
	}
	static class ANPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPC>();
	}
};
static_assert(alignof(ANPC) == 0x000010, "Wrong alignment on ANPC");
static_assert(sizeof(ANPC) == 0x000EC0, "Wrong size on ANPC");
static_assert(offsetof(ANPC, MaxKnockback) == 0x000838, "Member 'ANPC::MaxKnockback' has a wrong offset!");
static_assert(offsetof(ANPC, PointsToGiveOnDeath) == 0x00083C, "Member 'ANPC::PointsToGiveOnDeath' has a wrong offset!");
static_assert(offsetof(ANPC, bJumperOverride) == 0x000841, "Member 'ANPC::bJumperOverride' has a wrong offset!");
static_assert(offsetof(ANPC, MyType) == 0x000842, "Member 'ANPC::MyType' has a wrong offset!");
static_assert(offsetof(ANPC, bSuperShield) == 0x000850, "Member 'ANPC::bSuperShield' has a wrong offset!");
static_assert(offsetof(ANPC, MySpawnMarker) == 0x000858, "Member 'ANPC::MySpawnMarker' has a wrong offset!");
static_assert(offsetof(ANPC, DeadPhysicsAsset) == 0x000878, "Member 'ANPC::DeadPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ANPC, LivingPhysicsAsset) == 0x000880, "Member 'ANPC::LivingPhysicsAsset' has a wrong offset!");
static_assert(offsetof(ANPC, DistanceSqToNavWalk) == 0x000888, "Member 'ANPC::DistanceSqToNavWalk' has a wrong offset!");
static_assert(offsetof(ANPC, KnockdownZBoost) == 0x000898, "Member 'ANPC::KnockdownZBoost' has a wrong offset!");
static_assert(offsetof(ANPC, HitThrownSystem) == 0x0008B0, "Member 'ANPC::HitThrownSystem' has a wrong offset!");
static_assert(offsetof(ANPC, TimeToBeKnockedDown) == 0x0008B8, "Member 'ANPC::TimeToBeKnockedDown' has a wrong offset!");
static_assert(offsetof(ANPC, JetpackExplosionCooldown) == 0x0008C0, "Member 'ANPC::JetpackExplosionCooldown' has a wrong offset!");
static_assert(offsetof(ANPC, MinSpeedForRagdollHit) == 0x0008C8, "Member 'ANPC::MinSpeedForRagdollHit' has a wrong offset!");
static_assert(offsetof(ANPC, RagdollCooldownTime) == 0x0008D8, "Member 'ANPC::RagdollCooldownTime' has a wrong offset!");
static_assert(offsetof(ANPC, DieOnFallVelocity) == 0x0008DC, "Member 'ANPC::DieOnFallVelocity' has a wrong offset!");
static_assert(offsetof(ANPC, GibParticleSystem) == 0x0008E8, "Member 'ANPC::GibParticleSystem' has a wrong offset!");
static_assert(offsetof(ANPC, DecorativeHead) == 0x0008F0, "Member 'ANPC::DecorativeHead' has a wrong offset!");
static_assert(offsetof(ANPC, NPCUID) == 0x0008F8, "Member 'ANPC::NPCUID' has a wrong offset!");
static_assert(offsetof(ANPC, PunchAnim) == 0x000908, "Member 'ANPC::PunchAnim' has a wrong offset!");
static_assert(offsetof(ANPC, bIsSleeping) == 0x000912, "Member 'ANPC::bIsSleeping' has a wrong offset!");
static_assert(offsetof(ANPC, TorchSystem) == 0x000918, "Member 'ANPC::TorchSystem' has a wrong offset!");
static_assert(offsetof(ANPC, TorchComps) == 0x000920, "Member 'ANPC::TorchComps' has a wrong offset!");
static_assert(offsetof(ANPC, TutorialType) == 0x000930, "Member 'ANPC::TutorialType' has a wrong offset!");
static_assert(offsetof(ANPC, MyTutorialPickup) == 0x000938, "Member 'ANPC::MyTutorialPickup' has a wrong offset!");
static_assert(offsetof(ANPC, WeaponToGrab) == 0x000948, "Member 'ANPC::WeaponToGrab' has a wrong offset!");
static_assert(offsetof(ANPC, bIsArmored) == 0x000950, "Member 'ANPC::bIsArmored' has a wrong offset!");
static_assert(offsetof(ANPC, NextArmorThreshold) == 0x000954, "Member 'ANPC::NextArmorThreshold' has a wrong offset!");
static_assert(offsetof(ANPC, UnattachedArmors) == 0x000958, "Member 'ANPC::UnattachedArmors' has a wrong offset!");
static_assert(offsetof(ANPC, ArmorThresholds) == 0x000968, "Member 'ANPC::ArmorThresholds' has a wrong offset!");
static_assert(offsetof(ANPC, BackpackComponent) == 0x000970, "Member 'ANPC::BackpackComponent' has a wrong offset!");
static_assert(offsetof(ANPC, bBackpackTroop) == 0x000978, "Member 'ANPC::bBackpackTroop' has a wrong offset!");
static_assert(offsetof(ANPC, bIsSniper) == 0x000979, "Member 'ANPC::bIsSniper' has a wrong offset!");
static_assert(offsetof(ANPC, bIsJetpack) == 0x00097A, "Member 'ANPC::bIsJetpack' has a wrong offset!");
static_assert(offsetof(ANPC, bIsZombie) == 0x00097B, "Member 'ANPC::bIsZombie' has a wrong offset!");
static_assert(offsetof(ANPC, bIsSpecialist) == 0x00097C, "Member 'ANPC::bIsSpecialist' has a wrong offset!");
static_assert(offsetof(ANPC, bIsMinigun) == 0x00097D, "Member 'ANPC::bIsMinigun' has a wrong offset!");
static_assert(offsetof(ANPC, bIsCloaker) == 0x00097E, "Member 'ANPC::bIsCloaker' has a wrong offset!");
static_assert(offsetof(ANPC, bIsRocket) == 0x00097F, "Member 'ANPC::bIsRocket' has a wrong offset!");
static_assert(offsetof(ANPC, SniperLaserComponent) == 0x000980, "Member 'ANPC::SniperLaserComponent' has a wrong offset!");
static_assert(offsetof(ANPC, JetBlast1) == 0x000988, "Member 'ANPC::JetBlast1' has a wrong offset!");
static_assert(offsetof(ANPC, JetBlast2) == 0x000990, "Member 'ANPC::JetBlast2' has a wrong offset!");
static_assert(offsetof(ANPC, JetpackDeathThrust) == 0x000998, "Member 'ANPC::JetpackDeathThrust' has a wrong offset!");
static_assert(offsetof(ANPC, JetPackDeathTimeMax) == 0x00099C, "Member 'ANPC::JetPackDeathTimeMax' has a wrong offset!");
static_assert(offsetof(ANPC, bSSOnly) == 0x0009A4, "Member 'ANPC::bSSOnly' has a wrong offset!");
static_assert(offsetof(ANPC, ArmorSkeletalComponents) == 0x0009A8, "Member 'ANPC::ArmorSkeletalComponents' has a wrong offset!");
static_assert(offsetof(ANPC, TestVal) == 0x000A20, "Member 'ANPC::TestVal' has a wrong offset!");
static_assert(offsetof(ANPC, AimRoot) == 0x000A38, "Member 'ANPC::AimRoot' has a wrong offset!");
static_assert(offsetof(ANPC, VirtualBarrel) == 0x000A40, "Member 'ANPC::VirtualBarrel' has a wrong offset!");
static_assert(offsetof(ANPC, StunnedMovementSpeed) == 0x000A48, "Member 'ANPC::StunnedMovementSpeed' has a wrong offset!");
static_assert(offsetof(ANPC, LaserSpeed) == 0x000A5C, "Member 'ANPC::LaserSpeed' has a wrong offset!");
static_assert(offsetof(ANPC, MeleedStunnedMovementSpeed) == 0x000A64, "Member 'ANPC::MeleedStunnedMovementSpeed' has a wrong offset!");
static_assert(offsetof(ANPC, CoverMovementSpeed) == 0x000A68, "Member 'ANPC::CoverMovementSpeed' has a wrong offset!");
static_assert(offsetof(ANPC, CoverMovementTotalDistance) == 0x000A6C, "Member 'ANPC::CoverMovementTotalDistance' has a wrong offset!");
static_assert(offsetof(ANPC, OnHitPreserveMovementFactor) == 0x000A84, "Member 'ANPC::OnHitPreserveMovementFactor' has a wrong offset!");
static_assert(offsetof(ANPC, bShieldUnit) == 0x000A88, "Member 'ANPC::bShieldUnit' has a wrong offset!");
static_assert(offsetof(ANPC, ShieldHP) == 0x000A8C, "Member 'ANPC::ShieldHP' has a wrong offset!");
static_assert(offsetof(ANPC, ShieldDynMat) == 0x000A90, "Member 'ANPC::ShieldDynMat' has a wrong offset!");
static_assert(offsetof(ANPC, ShieldComponent) == 0x000A98, "Member 'ANPC::ShieldComponent' has a wrong offset!");
static_assert(offsetof(ANPC, CanisterComponent) == 0x000AA8, "Member 'ANPC::CanisterComponent' has a wrong offset!");
static_assert(offsetof(ANPC, AimSpeed) == 0x000AB0, "Member 'ANPC::AimSpeed' has a wrong offset!");
static_assert(offsetof(ANPC, TYVCRotationRate) == 0x000AB8, "Member 'ANPC::TYVCRotationRate' has a wrong offset!");
static_assert(offsetof(ANPC, BackTolerance) == 0x000ABC, "Member 'ANPC::BackTolerance' has a wrong offset!");
static_assert(offsetof(ANPC, PAnimData) == 0x000AC0, "Member 'ANPC::PAnimData' has a wrong offset!");
static_assert(offsetof(ANPC, OnHitRadius) == 0x000AE4, "Member 'ANPC::OnHitRadius' has a wrong offset!");
static_assert(offsetof(ANPC, MinAccuracy) == 0x000AF4, "Member 'ANPC::MinAccuracy' has a wrong offset!");
static_assert(offsetof(ANPC, MaxAccuracy) == 0x000AF8, "Member 'ANPC::MaxAccuracy' has a wrong offset!");
static_assert(offsetof(ANPC, MaxSightTimeNormal) == 0x000AFC, "Member 'ANPC::MaxSightTimeNormal' has a wrong offset!");
static_assert(offsetof(ANPC, MaxSightTimeHard) == 0x000B00, "Member 'ANPC::MaxSightTimeHard' has a wrong offset!");
static_assert(offsetof(ANPC, LifeLightParamName) == 0x000B04, "Member 'ANPC::LifeLightParamName' has a wrong offset!");
static_assert(offsetof(ANPC, LifeLightMat) == 0x000B10, "Member 'ANPC::LifeLightMat' has a wrong offset!");
static_assert(offsetof(ANPC, BodyMat) == 0x000B18, "Member 'ANPC::BodyMat' has a wrong offset!");
static_assert(offsetof(ANPC, UncloakedBody) == 0x000B20, "Member 'ANPC::UncloakedBody' has a wrong offset!");
static_assert(offsetof(ANPC, UncloakedHead) == 0x000B28, "Member 'ANPC::UncloakedHead' has a wrong offset!");
static_assert(offsetof(ANPC, InvulnJetpackMat) == 0x000B30, "Member 'ANPC::InvulnJetpackMat' has a wrong offset!");
static_assert(offsetof(ANPC, bIsCurrentlyCloaked) == 0x000B38, "Member 'ANPC::bIsCurrentlyCloaked' has a wrong offset!");
static_assert(offsetof(ANPC, RecoveryTime) == 0x000B3C, "Member 'ANPC::RecoveryTime' has a wrong offset!");
static_assert(offsetof(ANPC, HitRecoverFloat) == 0x000B50, "Member 'ANPC::HitRecoverFloat' has a wrong offset!");
static_assert(offsetof(ANPC, DeathSound) == 0x000BF0, "Member 'ANPC::DeathSound' has a wrong offset!");
static_assert(offsetof(ANPC, HeadshotComp) == 0x000BF8, "Member 'ANPC::HeadshotComp' has a wrong offset!");
static_assert(offsetof(ANPC, TargetZOffset) == 0x000C00, "Member 'ANPC::TargetZOffset' has a wrong offset!");
static_assert(offsetof(ANPC, NPCAnimInstance) == 0x000C20, "Member 'ANPC::NPCAnimInstance' has a wrong offset!");
static_assert(offsetof(ANPC, TYVCGameMode) == 0x000C28, "Member 'ANPC::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ANPC, HP) == 0x000C30, "Member 'ANPC::HP' has a wrong offset!");
static_assert(offsetof(ANPC, StartingHP) == 0x000C34, "Member 'ANPC::StartingHP' has a wrong offset!");
static_assert(offsetof(ANPC, bInCover) == 0x000C38, "Member 'ANPC::bInCover' has a wrong offset!");
static_assert(offsetof(ANPC, bShouldLean) == 0x000C39, "Member 'ANPC::bShouldLean' has a wrong offset!");
static_assert(offsetof(ANPC, LeanDirection) == 0x000C3C, "Member 'ANPC::LeanDirection' has a wrong offset!");
static_assert(offsetof(ANPC, StunDuration) == 0x000C48, "Member 'ANPC::StunDuration' has a wrong offset!");
static_assert(offsetof(ANPC, StunDurationMelee) == 0x000C4C, "Member 'ANPC::StunDurationMelee' has a wrong offset!");
static_assert(offsetof(ANPC, StunAnimMeleeSpeed) == 0x000C50, "Member 'ANPC::StunAnimMeleeSpeed' has a wrong offset!");
static_assert(offsetof(ANPC, LooseProfileName) == 0x000C60, "Member 'ANPC::LooseProfileName' has a wrong offset!");
static_assert(offsetof(ANPC, FirmProfileName) == 0x000C68, "Member 'ANPC::FirmProfileName' has a wrong offset!");
static_assert(offsetof(ANPC, ShotInArmsMontage) == 0x000C70, "Member 'ANPC::ShotInArmsMontage' has a wrong offset!");
static_assert(offsetof(ANPC, HeadBones) == 0x000C78, "Member 'ANPC::HeadBones' has a wrong offset!");
static_assert(offsetof(ANPC, TorsoBones) == 0x000C88, "Member 'ANPC::TorsoBones' has a wrong offset!");
static_assert(offsetof(ANPC, LeftArmBones) == 0x000C98, "Member 'ANPC::LeftArmBones' has a wrong offset!");
static_assert(offsetof(ANPC, RightArmBones) == 0x000CA8, "Member 'ANPC::RightArmBones' has a wrong offset!");
static_assert(offsetof(ANPC, LeftLegBones) == 0x000CB8, "Member 'ANPC::LeftLegBones' has a wrong offset!");
static_assert(offsetof(ANPC, RightLegBones) == 0x000CC8, "Member 'ANPC::RightLegBones' has a wrong offset!");
static_assert(offsetof(ANPC, BoneToSimulatePerGroup) == 0x000CD8, "Member 'ANPC::BoneToSimulatePerGroup' has a wrong offset!");
static_assert(offsetof(ANPC, StartingWeapon) == 0x000D28, "Member 'ANPC::StartingWeapon' has a wrong offset!");
static_assert(offsetof(ANPC, StartingSideArm) == 0x000D30, "Member 'ANPC::StartingSideArm' has a wrong offset!");
static_assert(offsetof(ANPC, HolsterSocket) == 0x000D38, "Member 'ANPC::HolsterSocket' has a wrong offset!");
static_assert(offsetof(ANPC, HeldWeapon) == 0x000D40, "Member 'ANPC::HeldWeapon' has a wrong offset!");
static_assert(offsetof(ANPC, HolsteredWeapon) == 0x000D48, "Member 'ANPC::HolsteredWeapon' has a wrong offset!");
static_assert(offsetof(ANPC, StartingWeaponPtr) == 0x000D50, "Member 'ANPC::StartingWeaponPtr' has a wrong offset!");
static_assert(offsetof(ANPC, StartingSidearmPtr) == 0x000D58, "Member 'ANPC::StartingSidearmPtr' has a wrong offset!");
static_assert(offsetof(ANPC, bShouldShoot) == 0x000D60, "Member 'ANPC::bShouldShoot' has a wrong offset!");
static_assert(offsetof(ANPC, LeanState) == 0x000DA0, "Member 'ANPC::LeanState' has a wrong offset!");
static_assert(offsetof(ANPC, DetectUnderFireSphere) == 0x000DA8, "Member 'ANPC::DetectUnderFireSphere' has a wrong offset!");
static_assert(offsetof(ANPC, BackpackChargeSphere) == 0x000DB0, "Member 'ANPC::BackpackChargeSphere' has a wrong offset!");
static_assert(offsetof(ANPC, RecoilReductionRate) == 0x000DBC, "Member 'ANPC::RecoilReductionRate' has a wrong offset!");
static_assert(offsetof(ANPC, PlayerActor) == 0x000DC0, "Member 'ANPC::PlayerActor' has a wrong offset!");
static_assert(offsetof(ANPC, DrawSidearmMontage) == 0x000DC8, "Member 'ANPC::DrawSidearmMontage' has a wrong offset!");
static_assert(offsetof(ANPC, WeaponPosition) == 0x000E00, "Member 'ANPC::WeaponPosition' has a wrong offset!");
static_assert(offsetof(ANPC, StartingWeaponPool) == 0x000E08, "Member 'ANPC::StartingWeaponPool' has a wrong offset!");
static_assert(offsetof(ANPC, StartingSideArmPool) == 0x000E18, "Member 'ANPC::StartingSideArmPool' has a wrong offset!");
static_assert(offsetof(ANPC, EventOnDeath) == 0x000E28, "Member 'ANPC::EventOnDeath' has a wrong offset!");
static_assert(offsetof(ANPC, SpeechComponent) == 0x000E30, "Member 'ANPC::SpeechComponent' has a wrong offset!");
static_assert(offsetof(ANPC, SpeechComponentClass) == 0x000E38, "Member 'ANPC::SpeechComponentClass' has a wrong offset!");
static_assert(offsetof(ANPC, SpeechDebugLine) == 0x000E40, "Member 'ANPC::SpeechDebugLine' has a wrong offset!");
static_assert(offsetof(ANPC, StimSourceComp) == 0x000E70, "Member 'ANPC::StimSourceComp' has a wrong offset!");
static_assert(offsetof(ANPC, bIsDead) == 0x000E78, "Member 'ANPC::bIsDead' has a wrong offset!");
static_assert(offsetof(ANPC, MyController) == 0x000E90, "Member 'ANPC::MyController' has a wrong offset!");
static_assert(offsetof(ANPC, StashedResponder) == 0x000EA8, "Member 'ANPC::StashedResponder' has a wrong offset!");

// Class ThankYouVeryCool.NPCAnimInstance
// 0x0430 (0x0AC0 - 0x0690)
class UNPCAnimInstance : public UALSCharacterAnimInstance
{
public:
	float                                         FeetTooCloseThreshold;                             // 0x0688(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         FootSolverMaxAttempts;                             // 0x068C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68D[0x8B];                                     // 0x068D(0x008B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FeetInterpolationSpeed;                            // 0x0718(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FeetInterpolationSpeedSloMo;                       // 0x071C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_720[0x10];                                     // 0x0720(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PelvisRotationOffset;                              // 0x0730(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         FutureVelocityMinSize;                             // 0x073C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FutureVelocityMaxSize;                             // 0x0740(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_744[0x4];                                      // 0x0744(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FootRaiseCurve;                                    // 0x0748(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PelvisInterpSpeed;                                 // 0x0750(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpringStiffness;                                   // 0x0754(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpringDampening;                                   // 0x0758(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_75C[0x30];                                     // 0x075C(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringDistance;                                    // 0x078C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_790[0x10];                                     // 0x0790(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NeutralThighDistance;                              // 0x07A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInCover;                                          // 0x07A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A5[0x3];                                      // 0x07A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LeanDirection;                                     // 0x07A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCoverIsCrouched;                                  // 0x07AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7AD[0x3];                                      // 0x07AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StunSpeed;                                         // 0x07B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCGripType                                  WeaponGripTypeC;                                   // 0x07B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDoLeftGripIK;                               // 0x07B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStaggering;                                     // 0x07B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAnimStaggering;                             // 0x07B7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPoseSnapshot                          LeaveStunSnapshot;                                 // 0x07B8(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FPoseSnapshot                          RagdollPoseSnapshot;                               // 0x07F0(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bShouldBeInRagdollSnapshot;                        // 0x0828(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_829[0x3];                                      // 0x0829(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitAngleWorld;                                     // 0x082C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitAngleLocal;                                     // 0x0830(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHoldingShield;                                  // 0x0834(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReloading;                                        // 0x0835(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_836[0x22];                                     // 0x0836(0x0022)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftVBAdjust;                                      // 0x0858(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FocusWorldPosition;                                // 0x085C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightVBAdjust;                                     // 0x0868(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               GoalPelvisWorldRotation;                           // 0x086C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               InterpPelvisWorldRotation;                         // 0x0878(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LeftRightOffsetFactor;                             // 0x0884(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisYawLimit;                                    // 0x0888(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermediateStepSize;                              // 0x088C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReactingToHit;                                    // 0x0890(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_891[0x3];                                      // 0x0891(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeftFootLocalInterpolatedLocation;                 // 0x0894(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightFootLocalInterpolatedLocation;                // 0x08A0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MassPredictionTime;                                // 0x08AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BalanceThreshold;                                  // 0x08B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeadC;                                          // 0x08B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLean;                                       // 0x08B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B6[0x2];                                      // 0x08B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FeetZOffset;                                       // 0x08B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FootIKRootBone;                                    // 0x08C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8CC[0x4];                                      // 0x08CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANPC*                                   NPC;                                               // 0x08D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoverPlayRate;                                     // 0x08D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HeadScale;                                         // 0x08DC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x28];                                     // 0x08E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumMoveAmount;                                 // 0x0910(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_914[0x3C];                                     // 0x0914(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PelvisOffset;                                      // 0x0950(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisMaxOffsetSize;                               // 0x095C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_960[0x98];                                     // 0x0960(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightedFootThreshold;                             // 0x09F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenFootMovements;                          // 0x09FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A00[0x44];                                     // 0x0A00(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootLandTolerance;                                 // 0x0A44(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFootMoveTime;                                   // 0x0A48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotTooFarDistance;                                // 0x0A4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FootMaxDistanceFromThigh;                          // 0x0A50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStepDistance;                                   // 0x0A54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A58[0x18];                                     // 0x0A58(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementDistanceLiftMultiplier;                    // 0x0A70(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A74[0xC];                                      // 0x0A74(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHandEffector;                                  // 0x0A80(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AO_Pitch;                                          // 0x0AB0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AO_Yaw;                                            // 0x0AB4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AB8[0x8];                                      // 0x0AB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCAnimInstance">();
	}
	static class UNPCAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNPCAnimInstance>();
	}
};
static_assert(alignof(UNPCAnimInstance) == 0x000010, "Wrong alignment on UNPCAnimInstance");
static_assert(sizeof(UNPCAnimInstance) == 0x000AC0, "Wrong size on UNPCAnimInstance");
static_assert(offsetof(UNPCAnimInstance, FeetTooCloseThreshold) == 0x000688, "Member 'UNPCAnimInstance::FeetTooCloseThreshold' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FootSolverMaxAttempts) == 0x00068C, "Member 'UNPCAnimInstance::FootSolverMaxAttempts' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FeetInterpolationSpeed) == 0x000718, "Member 'UNPCAnimInstance::FeetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FeetInterpolationSpeedSloMo) == 0x00071C, "Member 'UNPCAnimInstance::FeetInterpolationSpeedSloMo' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, PelvisRotationOffset) == 0x000730, "Member 'UNPCAnimInstance::PelvisRotationOffset' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FutureVelocityMinSize) == 0x00073C, "Member 'UNPCAnimInstance::FutureVelocityMinSize' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FutureVelocityMaxSize) == 0x000740, "Member 'UNPCAnimInstance::FutureVelocityMaxSize' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FootRaiseCurve) == 0x000748, "Member 'UNPCAnimInstance::FootRaiseCurve' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, PelvisInterpSpeed) == 0x000750, "Member 'UNPCAnimInstance::PelvisInterpSpeed' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, SpringStiffness) == 0x000754, "Member 'UNPCAnimInstance::SpringStiffness' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, SpringDampening) == 0x000758, "Member 'UNPCAnimInstance::SpringDampening' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, SpringDistance) == 0x00078C, "Member 'UNPCAnimInstance::SpringDistance' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, NeutralThighDistance) == 0x0007A0, "Member 'UNPCAnimInstance::NeutralThighDistance' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bInCover) == 0x0007A4, "Member 'UNPCAnimInstance::bInCover' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, LeanDirection) == 0x0007A8, "Member 'UNPCAnimInstance::LeanDirection' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bCoverIsCrouched) == 0x0007AC, "Member 'UNPCAnimInstance::bCoverIsCrouched' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, StunSpeed) == 0x0007B0, "Member 'UNPCAnimInstance::StunSpeed' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, WeaponGripTypeC) == 0x0007B4, "Member 'UNPCAnimInstance::WeaponGripTypeC' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bShouldDoLeftGripIK) == 0x0007B5, "Member 'UNPCAnimInstance::bShouldDoLeftGripIK' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bIsStaggering) == 0x0007B6, "Member 'UNPCAnimInstance::bIsStaggering' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bShouldAnimStaggering) == 0x0007B7, "Member 'UNPCAnimInstance::bShouldAnimStaggering' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, LeaveStunSnapshot) == 0x0007B8, "Member 'UNPCAnimInstance::LeaveStunSnapshot' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, RagdollPoseSnapshot) == 0x0007F0, "Member 'UNPCAnimInstance::RagdollPoseSnapshot' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bShouldBeInRagdollSnapshot) == 0x000828, "Member 'UNPCAnimInstance::bShouldBeInRagdollSnapshot' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, HitAngleWorld) == 0x00082C, "Member 'UNPCAnimInstance::HitAngleWorld' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, HitAngleLocal) == 0x000830, "Member 'UNPCAnimInstance::HitAngleLocal' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bIsHoldingShield) == 0x000834, "Member 'UNPCAnimInstance::bIsHoldingShield' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bReloading) == 0x000835, "Member 'UNPCAnimInstance::bReloading' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, LeftVBAdjust) == 0x000858, "Member 'UNPCAnimInstance::LeftVBAdjust' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FocusWorldPosition) == 0x00085C, "Member 'UNPCAnimInstance::FocusWorldPosition' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, RightVBAdjust) == 0x000868, "Member 'UNPCAnimInstance::RightVBAdjust' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, GoalPelvisWorldRotation) == 0x00086C, "Member 'UNPCAnimInstance::GoalPelvisWorldRotation' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, InterpPelvisWorldRotation) == 0x000878, "Member 'UNPCAnimInstance::InterpPelvisWorldRotation' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, LeftRightOffsetFactor) == 0x000884, "Member 'UNPCAnimInstance::LeftRightOffsetFactor' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, PelvisYawLimit) == 0x000888, "Member 'UNPCAnimInstance::PelvisYawLimit' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, IntermediateStepSize) == 0x00088C, "Member 'UNPCAnimInstance::IntermediateStepSize' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bReactingToHit) == 0x000890, "Member 'UNPCAnimInstance::bReactingToHit' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, LeftFootLocalInterpolatedLocation) == 0x000894, "Member 'UNPCAnimInstance::LeftFootLocalInterpolatedLocation' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, RightFootLocalInterpolatedLocation) == 0x0008A0, "Member 'UNPCAnimInstance::RightFootLocalInterpolatedLocation' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, MassPredictionTime) == 0x0008AC, "Member 'UNPCAnimInstance::MassPredictionTime' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, BalanceThreshold) == 0x0008B0, "Member 'UNPCAnimInstance::BalanceThreshold' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bIsDeadC) == 0x0008B4, "Member 'UNPCAnimInstance::bIsDeadC' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, bShouldLean) == 0x0008B5, "Member 'UNPCAnimInstance::bShouldLean' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FeetZOffset) == 0x0008B8, "Member 'UNPCAnimInstance::FeetZOffset' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FootIKRootBone) == 0x0008C4, "Member 'UNPCAnimInstance::FootIKRootBone' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, NPC) == 0x0008D0, "Member 'UNPCAnimInstance::NPC' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, CoverPlayRate) == 0x0008D8, "Member 'UNPCAnimInstance::CoverPlayRate' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, HeadScale) == 0x0008DC, "Member 'UNPCAnimInstance::HeadScale' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, MinimumMoveAmount) == 0x000910, "Member 'UNPCAnimInstance::MinimumMoveAmount' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, PelvisOffset) == 0x000950, "Member 'UNPCAnimInstance::PelvisOffset' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, PelvisMaxOffsetSize) == 0x00095C, "Member 'UNPCAnimInstance::PelvisMaxOffsetSize' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, WeightedFootThreshold) == 0x0009F8, "Member 'UNPCAnimInstance::WeightedFootThreshold' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, TimeBetweenFootMovements) == 0x0009FC, "Member 'UNPCAnimInstance::TimeBetweenFootMovements' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FootLandTolerance) == 0x000A44, "Member 'UNPCAnimInstance::FootLandTolerance' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, MinFootMoveTime) == 0x000A48, "Member 'UNPCAnimInstance::MinFootMoveTime' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, SpotTooFarDistance) == 0x000A4C, "Member 'UNPCAnimInstance::SpotTooFarDistance' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, FootMaxDistanceFromThigh) == 0x000A50, "Member 'UNPCAnimInstance::FootMaxDistanceFromThigh' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, MaxStepDistance) == 0x000A54, "Member 'UNPCAnimInstance::MaxStepDistance' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, MovementDistanceLiftMultiplier) == 0x000A70, "Member 'UNPCAnimInstance::MovementDistanceLiftMultiplier' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, LeftHandEffector) == 0x000A80, "Member 'UNPCAnimInstance::LeftHandEffector' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, AO_Pitch) == 0x000AB0, "Member 'UNPCAnimInstance::AO_Pitch' has a wrong offset!");
static_assert(offsetof(UNPCAnimInstance, AO_Yaw) == 0x000AB4, "Member 'UNPCAnimInstance::AO_Yaw' has a wrong offset!");

// Class ThankYouVeryCool.NPCController
// 0x0168 (0x0490 - 0x0328)
class ANPCController : public AAIController
{
public:
	uint8                                         Pad_328[0x14];                                     // 0x0328(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SightRangeSniper;                                  // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UsualSightRange;                                   // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SightShutoffSquared;                               // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x4];                                      // 0x0348(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceToUnleash;                                 // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceToUnleashZBounds;                          // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIdleOverride;                                     // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESituationContext>                     SitRep;                                            // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class FName                                   CanReloadKey;                                      // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CanShootKey;                                       // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnknownNoiseLocationKey;                           // 0x0378(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   bRecentlyHearUnknownNoiseKey;                      // 0x0380(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x4];                                      // 0x0388(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentTargetKey;                                  // 0x038C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        TargetSC;                                          // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0xC];                                      // 0x03A0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimSpeed;                                          // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPC*                                   MyNPC;                                             // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0xC];                                      // 0x03B8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DynamicTreeTag;                                    // 0x03C4(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrder*                                 CurrentOrder;                                      // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x03E0(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AWeaponBase*                            HeldWeapon;                                        // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASquad*                                 MySquad;                                           // 0x0420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNPCAnimInstance*                       AnimInst;                                          // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBackpackAnimInstance*                  BackpackAnimInst;                                  // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerPositionModel*                   SquadPlayerPosModel;                               // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x4];                                      // 0x0440(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnderFireMaxCooldown;                              // 0x0444(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x10];                                     // 0x0448(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          MainBT;                                            // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAISenseConfig_Sight*                   SightSense;                                        // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnteredVisionDelay;                                // 0x0478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAISenseConfig_Hearing*                 HearingSense;                                      // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CanSeeActor(const class AActor* Actor);
	void EnteredVisionDelayReached();
	class ANPC* GetNPC();
	class ASquad* GetSquad();
	void InjectTree(class UBehaviorTree* Order, const struct FGameplayTag& OrderTag);
	bool IsPassive();
	void Releash();
	void UpdatedPerception(const TArray<class AActor*>& Actors);
	void UpdateTargetPerception(class AActor* Actor, const struct FAIStimulus& Stimulus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPCController">();
	}
	static class ANPCController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPCController>();
	}
};
static_assert(alignof(ANPCController) == 0x000010, "Wrong alignment on ANPCController");
static_assert(sizeof(ANPCController) == 0x000490, "Wrong size on ANPCController");
static_assert(offsetof(ANPCController, SightRangeSniper) == 0x00033C, "Member 'ANPCController::SightRangeSniper' has a wrong offset!");
static_assert(offsetof(ANPCController, UsualSightRange) == 0x000340, "Member 'ANPCController::UsualSightRange' has a wrong offset!");
static_assert(offsetof(ANPCController, SightShutoffSquared) == 0x000344, "Member 'ANPCController::SightShutoffSquared' has a wrong offset!");
static_assert(offsetof(ANPCController, DistanceToUnleash) == 0x00034C, "Member 'ANPCController::DistanceToUnleash' has a wrong offset!");
static_assert(offsetof(ANPCController, DistanceToUnleashZBounds) == 0x000350, "Member 'ANPCController::DistanceToUnleashZBounds' has a wrong offset!");
static_assert(offsetof(ANPCController, bIdleOverride) == 0x000354, "Member 'ANPCController::bIdleOverride' has a wrong offset!");
static_assert(offsetof(ANPCController, SitRep) == 0x000358, "Member 'ANPCController::SitRep' has a wrong offset!");
static_assert(offsetof(ANPCController, CanReloadKey) == 0x000368, "Member 'ANPCController::CanReloadKey' has a wrong offset!");
static_assert(offsetof(ANPCController, CanShootKey) == 0x000370, "Member 'ANPCController::CanShootKey' has a wrong offset!");
static_assert(offsetof(ANPCController, UnknownNoiseLocationKey) == 0x000378, "Member 'ANPCController::UnknownNoiseLocationKey' has a wrong offset!");
static_assert(offsetof(ANPCController, bRecentlyHearUnknownNoiseKey) == 0x000380, "Member 'ANPCController::bRecentlyHearUnknownNoiseKey' has a wrong offset!");
static_assert(offsetof(ANPCController, CurrentTargetKey) == 0x00038C, "Member 'ANPCController::CurrentTargetKey' has a wrong offset!");
static_assert(offsetof(ANPCController, TargetSC) == 0x000398, "Member 'ANPCController::TargetSC' has a wrong offset!");
static_assert(offsetof(ANPCController, AimSpeed) == 0x0003AC, "Member 'ANPCController::AimSpeed' has a wrong offset!");
static_assert(offsetof(ANPCController, MyNPC) == 0x0003B0, "Member 'ANPCController::MyNPC' has a wrong offset!");
static_assert(offsetof(ANPCController, DynamicTreeTag) == 0x0003C4, "Member 'ANPCController::DynamicTreeTag' has a wrong offset!");
static_assert(offsetof(ANPCController, CurrentOrder) == 0x0003D0, "Member 'ANPCController::CurrentOrder' has a wrong offset!");
static_assert(offsetof(ANPCController, SpawnTransform) == 0x0003E0, "Member 'ANPCController::SpawnTransform' has a wrong offset!");
static_assert(offsetof(ANPCController, HeldWeapon) == 0x000410, "Member 'ANPCController::HeldWeapon' has a wrong offset!");
static_assert(offsetof(ANPCController, MySquad) == 0x000420, "Member 'ANPCController::MySquad' has a wrong offset!");
static_assert(offsetof(ANPCController, AnimInst) == 0x000428, "Member 'ANPCController::AnimInst' has a wrong offset!");
static_assert(offsetof(ANPCController, BackpackAnimInst) == 0x000430, "Member 'ANPCController::BackpackAnimInst' has a wrong offset!");
static_assert(offsetof(ANPCController, SquadPlayerPosModel) == 0x000438, "Member 'ANPCController::SquadPlayerPosModel' has a wrong offset!");
static_assert(offsetof(ANPCController, UnderFireMaxCooldown) == 0x000444, "Member 'ANPCController::UnderFireMaxCooldown' has a wrong offset!");
static_assert(offsetof(ANPCController, PlayerCharacter) == 0x000458, "Member 'ANPCController::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(ANPCController, MainBT) == 0x000460, "Member 'ANPCController::MainBT' has a wrong offset!");
static_assert(offsetof(ANPCController, SightSense) == 0x000468, "Member 'ANPCController::SightSense' has a wrong offset!");
static_assert(offsetof(ANPCController, EnteredVisionDelay) == 0x000478, "Member 'ANPCController::EnteredVisionDelay' has a wrong offset!");
static_assert(offsetof(ANPCController, HearingSense) == 0x000480, "Member 'ANPCController::HearingSense' has a wrong offset!");
static_assert(offsetof(ANPCController, TYVCGameMode) == 0x000488, "Member 'ANPCController::TYVCGameMode' has a wrong offset!");

// Class ThankYouVeryCool.OverclockWidget
// 0x0000 (0x0260 - 0x0260)
class UOverclockWidget : public UUserWidget
{
public:
	void SetOverclockPercent(float InPercent);
	void SetupForCampaign();
	void SetupForHunt();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverclockWidget">();
	}
	static class UOverclockWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverclockWidget>();
	}
};
static_assert(alignof(UOverclockWidget) == 0x000008, "Wrong alignment on UOverclockWidget");
static_assert(sizeof(UOverclockWidget) == 0x000260, "Wrong size on UOverclockWidget");

// Class ThankYouVeryCool.OverworldManager
// 0x0018 (0x0238 - 0x0220)
class AOverworldManager final : public AActor
{
public:
	class AVoxelWorld*                            ArcticOverworld;                                   // 0x0220(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 FakeSky;                                           // 0x0228(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            FakeWorld;                                         // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverworldManager">();
	}
	static class AOverworldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOverworldManager>();
	}
};
static_assert(alignof(AOverworldManager) == 0x000008, "Wrong alignment on AOverworldManager");
static_assert(sizeof(AOverworldManager) == 0x000238, "Wrong size on AOverworldManager");
static_assert(offsetof(AOverworldManager, ArcticOverworld) == 0x000220, "Member 'AOverworldManager::ArcticOverworld' has a wrong offset!");
static_assert(offsetof(AOverworldManager, FakeSky) == 0x000228, "Member 'AOverworldManager::FakeSky' has a wrong offset!");
static_assert(offsetof(AOverworldManager, FakeWorld) == 0x000230, "Member 'AOverworldManager::FakeWorld' has a wrong offset!");

// Class ThankYouVeryCool.PickupWidget
// 0x0000 (0x0260 - 0x0260)
class UPickupWidget : public UUserWidget
{
public:
	void OverrideText(const class FString& inString);
	void SetMode(bool bController, bool bShowThrow);
	void ShowPrompt(bool bShouldShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupWidget">();
	}
	static class UPickupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickupWidget>();
	}
};
static_assert(alignof(UPickupWidget) == 0x000008, "Wrong alignment on UPickupWidget");
static_assert(sizeof(UPickupWidget) == 0x000260, "Wrong size on UPickupWidget");

// Class ThankYouVeryCool.PlayerCharacter
// 0x19C0 (0x21F0 - 0x0830)
class APlayerCharacter : public AALSBaseCharacter
{
public:
	uint8                                         Pad_828[0x10];                                     // 0x0828(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EGyroSpace                                    MyGyroSpace;                                       // 0x0838(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_839[0x27];                                     // 0x0839(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PreviewTransform;                                  // 0x0860(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FanForceThreshold;                                 // 0x0890(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_894[0x4];                                      // 0x0894(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FanBrake;                                          // 0x0898(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89C[0xC];                                      // 0x089C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallRunSpeed;                                      // 0x08A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LikeWaterSpeed;                                    // 0x08AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentFanStrength;                                // 0x08B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostFanBoost;                                      // 0x08B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B8[0x4];                                      // 0x08B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FanUpwardsForce;                                   // 0x08BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FanTerminalV;                                      // 0x08C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponReady;                                      // 0x08C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C5[0x7];                                      // 0x08C5(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KickSlideStartSpeed;                               // 0x08CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRidingSomething;                                  // 0x08D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D1[0xF];                                      // 0x08D1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallRunDotThreshold;                               // 0x08E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallRunCooldownTime;                               // 0x08E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x10];                                     // 0x08E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLocoStateDebug;                                   // 0x08F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F9[0x67];                                     // 0x08F9(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GraphOffset;                                       // 0x0960(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GraphSize;                                         // 0x096C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbUpwardsForce;                                 // 0x0974(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseAmplitude;                                    // 0x0978(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_97C[0x4];                                      // 0x097C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoiseTimeMulti;                                    // 0x0980(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoiseRate;                                         // 0x0984(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerAction                                 LastRequestedAction;                               // 0x0988(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_989[0x7];                                      // 0x0989(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCoyoteTime;                                     // 0x0990(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_994[0x4];                                      // 0x0994(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastActionThreshold;                               // 0x0998(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99C[0x14];                                     // 0x099C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             PickupSwoop;                                       // 0x09B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PickupImpact;                                      // 0x09B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ReloadWeaponSound;                                 // 0x09C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANPC*                                   KickAutoAimTarget;                                 // 0x09C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               KickAutoAimStart;                                  // 0x09D0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9DC[0xC];                                      // 0x09DC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ClimbingObject;                                    // 0x09E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickAutoAimSize;                                   // 0x09F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F4[0x4];                                      // 0x09F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AArmCannon>                 ArmCannonClass;                                    // 0x09F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AArmCannon*                             ArmCannon;                                         // 0x0A00(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ClimbUpCurve;                                      // 0x0A08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ClimbForwardCurve;                                 // 0x0A10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A18[0x130];                                    // 0x0A18(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KickImpulse;                                       // 0x0B48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4C[0x4];                                      // 0x0B4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDotForAutoAim;                                  // 0x0B50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistForAutoAim;                                 // 0x0B54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B58[0x8];                                      // 0x0B58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToFreeze;                                      // 0x0B60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B64[0x4];                                      // 0x0B64(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 AATarget;                                          // 0x0B68(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayHUD*                           EveHUD;                                            // 0x0B70(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B78[0x4];                                      // 0x0B78(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingStuntMinSpeed;                              // 0x0B7C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingStuntMinSpeed;                               // 0x0B80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B84[0x14];                                     // 0x0B84(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ClassicCameraPosition;                             // 0x0B98(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA0[0xC];                                      // 0x0BA0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SlideMomentumVec;                                  // 0x0BAC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingSpeed;                                      // 0x0BB8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandingBrakeFrictionFactor;                       // 0x0BBC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandingBrakeDecelerationWalking;                  // 0x0BC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandingAccel;                                     // 0x0BC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC8[0x4];                                      // 0x0BC8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlideKickMinPitch;                                 // 0x0BCC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD0[0x4];                                      // 0x0BD0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AltnernateGripInterpTime;                          // 0x0BD4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD8[0x4];                                      // 0x0BD8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DiveOffset;                                        // 0x0BDC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE8[0x4];                                      // 0x0BE8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProneOffset;                                       // 0x0BEC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF8[0x10];                                     // 0x0BF8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        TestStandOffsets;                                  // 0x0C08(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C18[0x44];                                     // 0x0C18(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlipLandTotalTime;                                 // 0x0C5C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C60[0x4];                                      // 0x0C60(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BobReturnSpeed;                                    // 0x0C64(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C68[0x10];                                     // 0x0C68(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallRunCameraCenteringSpeed;                       // 0x0C78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallRunPlayerWantsWallThreshold;                   // 0x0C7C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallRunCheckSphereSize;                            // 0x0C80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C84[0xC];                                      // 0x0C84(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DropKickSpeed;                                     // 0x0C90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C94[0x4];                                      // 0x0C94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisableAirControlTime;                             // 0x0C98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlowMoPerKill;                                     // 0x0C9C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA0[0x1C];                                     // 0x0CA0(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DropKickZ;                                         // 0x0CBC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponRoll;                                        // 0x0CC0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSloMoMeter;                                 // 0x0CC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentMultiMeter;                                 // 0x0CC8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidePelvisTilt;                                   // 0x0CCC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FuckingTestFuck;                                   // 0x0CD0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ArcadeMultiBurnRate;                               // 0x0CDC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE0[0x8];                                      // 0x0CE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             WindSound;                                         // 0x0CE8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        WindSoundComp;                                     // 0x0CF0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             LowHealthSound;                                    // 0x0CF8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MultiplierDrainSound;                              // 0x0D00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentMultiplierMeter;                            // 0x0D08(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0C[0x4];                                      // 0x0D0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DecayChart;                                        // 0x0D10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierBurnRate;                                // 0x0D18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SloMoBurnRate;                                     // 0x0D1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetWeaponRoll;                                  // 0x0D20(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopSlideThreshold;                                // 0x0D24(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyViz                                      CurrentBodyViz;                                    // 0x0D28(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D29[0x17];                                     // 0x0D29(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyFadeSpeed;                                     // 0x0D40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteepnessMultiplier;                               // 0x0D44(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpwardsSlopeModifier;                              // 0x0D48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4C[0x4];                                      // 0x0D4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DropKickZCurve;                                    // 0x0D50(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SlideKickJumpMultiplier;                           // 0x0D58(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideKickFriction;                                 // 0x0D60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideKickFrictionBrake;                            // 0x0D64(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CeilingAvoidanceSpeed;                             // 0x0D68(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CeilingCheckDistance;                              // 0x0D6C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DropKickPitchYOffset;                              // 0x0D70(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetWeaponRollSpeed;                             // 0x0D78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7C[0x4];                                      // 0x0D7C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DropKickTotalAlpha;                                // 0x0D80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D84[0x4];                                      // 0x0D84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshSocket*                    CurrentLeftHandSocket;                             // 0x0D88(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 CurrentLeftHandSocketOwner;                        // 0x0D90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D98[0x1C];                                     // 0x0D98(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CameraBodyDistance;                                // 0x0DB4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC0[0x71];                                     // 0x0DC0(0x0071)(Fixing Size After Last Property [ Dumper-7 ])
	ECameraMode                                   StartingCameraMode;                                // 0x0E31(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E32[0x16];                                     // 0x0E32(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           PunchMontage;                                      // 0x0E48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedIdleSequence;                               // 0x0E50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          UnarmedWalkingSequence;                            // 0x0E58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               UnarmedBaseRotation;                               // 0x0E60(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6C[0x58];                                     // 0x0E6C(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PunchSphereSize;                                   // 0x0EC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Spine3BaseRotation;                                // 0x0EC8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PunchDistance;                                     // 0x0ED4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickApexHold;                                      // 0x0ED8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EDC[0x15];                                     // 0x0EDC(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSynty;                                          // 0x0EF1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF2[0x6];                                      // 0x0EF2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponReadyPersist;                                // 0x0EF8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EFC[0x30];                                     // 0x0EFC(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingLateralFriction;                            // 0x0F2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingStepHeight;                                 // 0x0F30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingStepHeight;                                 // 0x0F34(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DivingStepHeight;                                  // 0x0F38(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingStepHeight;                                 // 0x0F3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F40[0x20];                                     // 0x0F40(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformTest;                                     // 0x0F60(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              SocketAdjust;                                      // 0x0F90(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWallRunning;                                    // 0x0F98(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F99[0x7];                                      // 0x0F99(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             DiveSound;                                         // 0x0FA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ClimbSound;                                        // 0x0FA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPadding;                                     // 0x0FB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB4[0x4];                                      // 0x0FB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             PunchHitWallSound;                                 // 0x0FB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PunchHitBodySound;                                 // 0x0FC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             KickHitWallSound;                                  // 0x0FC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             KickHitBodySound;                                  // 0x0FD0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DiveLandSound;                                     // 0x0FD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SwingSound;                                        // 0x0FE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE8[0x8];                                      // 0x0FE8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             HitByThrownSound;                                  // 0x0FF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ThrowSound;                                        // 0x0FF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PickupSound;                                       // 0x1000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1008[0xC];                                     // 0x1008(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BarrelLookAtRot;                                   // 0x1014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         KickDistance;                                      // 0x1020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickDistanceAutomatic;                             // 0x1024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Adjustment;                                        // 0x1028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1034[0x10];                                    // 0x1034(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlideKickMinTime;                                  // 0x1044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideStuntModeMinSpeed;                            // 0x1048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallRunStuntModeMinSpeed;                          // 0x104C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1050[0x4];                                     // 0x1050(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpHeight;                                        // 0x1054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1058[0xC];                                     // 0x1058(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallKillThreshold;                                 // 0x1064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationLastFrame;                                 // 0x1068(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickSlideMinSpeed;                                 // 0x1074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpHeightSlideBoost;                              // 0x1078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSpeed;                                      // 0x107C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentSpeedXY;                                    // 0x1080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1084[0x8];                                     // 0x1084(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SteepnessSlideLaunchThreshold;                     // 0x108C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentVelocity;                                   // 0x1090(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingFrictionNoStunt;                            // 0x109C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A0[0xC];                                     // 0x10A0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CurrentVelocityForTrailer;                         // 0x10AC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInTrailer;                                      // 0x10B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B9[0x3];                                     // 0x10B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlopeCheckDistance;                                // 0x10BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandingWalkableFloorAngle;                        // 0x10C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlidingWalkableFloorAngle;                         // 0x10C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C8[0x1C];                                    // 0x10C8(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightHandSwapSpeed;                                // 0x10E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10E8[0x20];                                    // 0x10E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimAdjustRate;                                     // 0x1108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimAdjustInterpSpeed;                              // 0x110C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1110[0x8];                                     // 0x1110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageForCam;                                     // 0x1118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1120[0x10];                                    // 0x1120(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        SlideAudioComp;                                    // 0x1130(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1138[0x4];                                     // 0x1138(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CrosshairMinSpread;                                // 0x113C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairMaxSpread;                                // 0x1140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairLerpSpeed;                                // 0x1144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairCurrentSpread;                            // 0x1148(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114C[0x4];                                     // 0x114C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USpreadingCrosshair>        CrosshairClass;                                    // 0x1150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ULuckDisplay>               LuckDisplayClass;                                  // 0x1158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1160[0x10];                                    // 0x1160(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LuckThresholdGracePeriod;                          // 0x1170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LuckThresholdGracePeriodTempered;                  // 0x1174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1178[0x8];                                     // 0x1178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             GruntCue;                                          // 0x1180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             HitENemyCue;                                       // 0x1188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            LuckThresholdsCurve;                               // 0x1190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            WeaponRollCurve;                                   // 0x1198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A0[0x8];                                     // 0x11A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxLuckV2;                                         // 0x11A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11AC[0xC];                                     // 0x11AC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InStuntDilation;                                   // 0x11B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultDilation;                                   // 0x11BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReducedDilation;                                   // 0x11C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyYawRotateSpeedSlow;                            // 0x11C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyYawRotateSpeedFast;                            // 0x11C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightHandInterpSpeed;                              // 0x11CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OnDeathExplosionRadius;                            // 0x11D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D4[0xC];                                     // 0x11D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RightHandGripRange;                                // 0x11E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightHandRangeSpeed;                               // 0x11E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LightFallThreshold;                                // 0x11E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeavyFallThreshold;                                // 0x11EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             HeavyFallSound;                                    // 0x11F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RightHandGripLocation;                             // 0x11F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RightShoulderLocation;                             // 0x1200(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        LeftShoulderLocation;                              // 0x1208(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeftShoulderSlideLocation;                         // 0x1210(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeftShoulderBaseLocation;                          // 0x121C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RightShoulderLocationStabilized;                   // 0x1228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShoulderStabilizationThreshold;                    // 0x1230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1234[0x4];                                     // 0x1234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USpringArmComponent*                    HeadSpringArm;                                     // 0x1238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    StuntThirdPersonSpringArm;                         // 0x1240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    RightHandSpringArm;                                // 0x1248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       StuntThirdPersonCam;                               // 0x1250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      PhysicsCollisionCapsule;                           // 0x1258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalAnimationComponent*            PhysAnimComp;                                      // 0x1260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DiveBodyNameLeftLeg;                               // 0x1268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DiveBodyNameRightLeg;                              // 0x1270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DiveBoneNameLeftLeg;                               // 0x1278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DiveBoneNameRightLeg;                              // 0x1280(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DiveProfileName;                                   // 0x1288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftArmBone1Name;                                  // 0x1290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftArmBone2Name;                                  // 0x1298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12A0[0x78];                                    // 0x12A0(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x1318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           KickMontage;                                       // 0x1320(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WallRunStartLeftMontage;                           // 0x1328(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           WallRunStartRightMontage;                          // 0x1330(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ThrowMontage;                                      // 0x1338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ThrowMontageProne;                                 // 0x1340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DropMontage;                                       // 0x1348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DeathMontage;                                      // 0x1350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        ActorDirectionArrow;                               // 0x1358(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        HandsDirectionArrow;                               // 0x1360(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuatSlerpSpeed;                                    // 0x1368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_136C[0x24];                                    // 0x136C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       FirstPersonCamera;                                 // 0x1390(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       DebugCamera;                                       // 0x1398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    DebugSpringArm;                                    // 0x13A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyTrackCameraSpeed;                              // 0x13A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PickupReach;                                       // 0x13AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PickupReachDefault;                                // 0x13B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KickReach;                                         // 0x13B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoStandMaxTimer;                                 // 0x13B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13BC[0xC];                                     // 0x13BC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelSimpleInvokerComponent*           VoxelInvokerComponent;                             // 0x13C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 Hands;                                             // 0x13D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    StimSourceComp;                                    // 0x13D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E0[0x2];                                     // 0x13E0(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ECardinalDirection                            MyCardinalDirection;                               // 0x13E2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13E3[0x5];                                     // 0x13E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                CurrentlyLookedAtInteractable;                     // 0x13E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeaponBase*                            CurrentlyEquippedWeapon;                           // 0x13F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeaponBase*                            MyAkimboWeapon;                                    // 0x13F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AWeaponBase*                            PickingUpWeapon;                                   // 0x1400(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1408[0x38];                                    // 0x1408(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlideKickSweepOffset;                              // 0x1440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideKickSweepSize;                                // 0x1444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveSweepRadius;                                   // 0x1448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveSweepHalfHeight;                               // 0x144C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1450[0x4];                                     // 0x1450(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PickupTime;                                        // 0x1454(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1458[0x8];                                     // 0x1458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponBase*                            HolsteredWeapon;                                   // 0x1460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1468[0x8];                                     // 0x1468(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiveZVector;                                       // 0x1470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallKickZVector;                                   // 0x1474(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallKickVelocity;                                  // 0x1478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_147C[0x4];                                     // 0x147C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           DivePitchVelocityCurve;                            // 0x1480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            WallJumpPitchZVector;                              // 0x1488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveVelocityMultiplier;                            // 0x1490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunJumpZVector;                                // 0x1494(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunJumpMaxDiff;                                // 0x1498(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunJumpVelocityMultiplier;                     // 0x149C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunPushOffVelocityMultiplier;                  // 0x14A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CameraStandingPosition;                            // 0x14A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CameraPronePosition;                               // 0x14B0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14BC[0x4];                                     // 0x14BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WallRunBoostCurve;                                 // 0x14C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_14C8[0x34];                                    // 0x14C8(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallRunYawChangeMax;                               // 0x14FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceBetweenNormalSamples;                      // 0x1500(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunFailedLeniancyTime;                         // 0x1504(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1508[0x4];                                     // 0x1508(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredCrouchCamHeight;                            // 0x150C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredSlideCamHeight;                             // 0x1510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetCrouchCamHeight;                             // 0x1514(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchCamInterpSpeed;                              // 0x1518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideCamInterpSpeed;                               // 0x151C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideSteepnessClamp;                               // 0x1520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1524[0x4];                                     // 0x1524(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            WallRunLaunchCameraInfluence;                      // 0x1528(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunGravityScale;                               // 0x1530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NormalGravityScale;                                // 0x1534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunMaxTime;                                    // 0x1538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerToWallDistance;                              // 0x153C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerToWallDistanceDuringRun;                     // 0x1540(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunPushIntoWallForce;                          // 0x1544(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SlideKickPushIntoFloorForce;                       // 0x1548(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunFallingFriction;                            // 0x154C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1550[0x4];                                     // 0x1550(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallRunAimLerpTime;                                // 0x1554(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            WallRunSpeedCurve;                                 // 0x1558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CamWeaponSwayMaxPitch;                             // 0x1560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CamWeaponSwayMaxYaw;                               // 0x1564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinCamMovementForSway;                             // 0x1568(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CamWeaponSwaySpeed;                                // 0x156C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCamWeaponSwayPitch;                         // 0x1570(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCamWeaponSwayYaw;                           // 0x1574(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            WeaponRollCurveV2;                                 // 0x1578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            PitchOverrideCurve;                                // 0x1580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           WeaponRollAdjustCurve;                             // 0x1588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           PitchLimitCurve;                                   // 0x1590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           PitchAimCurve;                                     // 0x1598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingPitchMax;                                  // 0x15A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingPitchMin;                                  // 0x15A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeaponClippingDistance;                            // 0x15A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadePitchThreshold;                                // 0x15AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15B0[0x8];                                     // 0x15B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldTimeForKickSlide;                              // 0x15B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClimbCapZ;                                         // 0x15BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClimbCapFwd;                                       // 0x15C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PostClimbLaunch;                                   // 0x15C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AChameleon*                             Chameleon;                                         // 0x15C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HitsToWallRun;                                     // 0x15D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunLaunchMinOffset;                            // 0x15D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15D8[0x4];                                     // 0x15D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlowMoPlaybackSpeed;                               // 0x15DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentAnimPlaybackSpeed;                          // 0x15E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15E4[0x4];                                     // 0x15E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultAirControl;                                 // 0x15E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15EC[0x4];                                     // 0x15EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             EdgeBoostSfx;                                      // 0x15F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleLerpSpeed;                                  // 0x15F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgeBoostDetectionWindow;                          // 0x15FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgeBoostUseWindow;                                // 0x1600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1604[0x20];                                    // 0x1604(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StandingCapsuleScale;                              // 0x1624(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraLerpSpeed;                                   // 0x1628(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_162C[0x4];                                     // 0x162C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HandsLerpSpeed;                                    // 0x1630(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HandsRotLerpSpeed;                                 // 0x1634(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1638[0x44];                                    // 0x1638(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RollingCapsuleSize;                                // 0x167C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingHalfHeight;                                // 0x1684(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CamMoveToHeadSpeed;                                // 0x1688(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_168C[0x4];                                     // 0x168C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ProneToStandMontageOnBelly;                        // 0x1690(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           ProneToStandMontageOnBack;                         // 0x1698(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           ProneToStandCurveOnBack;                           // 0x16A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           ProneToStandCurveOnBelly;                          // 0x16A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           StartSlideKickCurve;                               // 0x16B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           LeaveSlideKickCurve;                               // 0x16B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C0[0xC];                                     // 0x16C0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BodyRollOffset;                                    // 0x16CC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraSwapTolerance;                               // 0x16D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16DC[0x34];                                    // 0x16DC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyOffsetSpeed;                                   // 0x1710(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProneHalfHeight;                                   // 0x1714(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProneForwardsSpeed;                                // 0x1718(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProneRollSpeed;                                    // 0x171C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingSpeed;                                     // 0x1720(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StandingSpeedReduced;                              // 0x1724(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DiveMontage;                                       // 0x1728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RollMontageForward;                                // 0x1730(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RollMontageRight;                                  // 0x1738(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RollMontageBack;                                   // 0x1740(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RollMontageLeft;                                   // 0x1748(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiveSlidingTime;                                   // 0x1750(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1754[0x4];                                     // 0x1754(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            StandFromProneCurve;                               // 0x1758(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ProneFromStandCurve;                               // 0x1760(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            StuntEndGraceCurve;                                // 0x1768(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            OnDeathCameraSwivelCurve;                          // 0x1770(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            OnWallRunCameraCurve;                              // 0x1778(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            WallRunZAndReleaseCurve;                           // 0x1780(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       WeaponPickupWidgetComp;                            // 0x1788(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponPickupWidget*                    WeaponPickupWidgetCompWidget;                      // 0x1790(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1798[0x3A0];                                   // 0x1798(0x03A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            KickSlideVelocityCurve;                            // 0x1B38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DefaultCollisionDistance;                          // 0x1B40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B44[0x4];                                     // 0x1B44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionImminentSphereRadius;                     // 0x1B48(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B4C[0xC];                                     // 0x1B4C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsHitThisSlide;                                // 0x1B58(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         ActorsHitThisDive;                                 // 0x1B68(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UCurveVector*                           CurrentCamCurve;                                   // 0x1B78(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B80[0x4];                                     // 0x1B80(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlideKickYawOffset;                                // 0x1B84(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B88[0x8];                                     // 0x1B88(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CamAttachToHeadSocketInterpSpeed;                  // 0x1B90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B94[0x4];                                     // 0x1B94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallRunTargetCameraRoll;                           // 0x1B98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallRunCameraRollSpeed;                            // 0x1B9C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartingLuck;                                      // 0x1BA0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LuckRestoreSpeed;                                  // 0x1BA4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BA8[0x4];                                     // 0x1BA8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraTiltSpeedDive;                               // 0x1BAC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                AkimboOffset;                                      // 0x1BB0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BBC[0x4];                                     // 0x1BBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTYVCAnimInstance*                      HandsAnimInstance;                                 // 0x1BC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTYVCAnimInstance_Post*                 AnimInstance_Post;                                 // 0x1BC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTYVCAnimInstance*                      ShadowAnimInstance;                                // 0x1BD0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTYVCAnimInstance_Post*                 ShadowAnimInstance_Post;                           // 0x1BD8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1BE0[0x80];                                    // 0x1BE0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   RotationRateKey;                                   // 0x1C60(0x0018)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKey                                   AccelerationGyroKey;                               // 0x1C78(0x0018)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GyroDebugSensitivity;                              // 0x1C90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C94[0x34];                                    // 0x1C94(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             PlayerHitSound;                                    // 0x1CC8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       HeadTarget3;                                       // 0x1CD0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       TorsoTarget3;                                      // 0x1CD8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       LeftArmTarget3;                                    // 0x1CE0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       RightArmTarget3;                                   // 0x1CE8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       LegsTarget3;                                       // 0x1CF0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CF8[0x8];                                     // 0x1CF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        OnDiveLandCameraShake;                             // 0x1D00(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        OnJumpLandCameraShake;                             // 0x1D08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        OnJumpLandCameraShakeHeavy;                        // 0x1D10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        ShockwaveSystem;                                   // 0x1D18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        OnJumpCameraShake;                                 // 0x1D20(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        OnDiveCameraShake;                                 // 0x1D28(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        OnKickLandCameraShake;                             // 0x1D30(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        OnKickCameraShake;                                 // 0x1D38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UMatineeCameraShake>        OnSpendLuckCameraShake;                            // 0x1D40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       ActiveCam;                                         // 0x1D48(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugSpendLuckAmount;                              // 0x1D50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D54[0xC];                                     // 0x1D54(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AkimboFire;                                        // 0x1D60(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D68[0x8];                                     // 0x1D68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LevelStartTransform;                               // 0x1D70(0x0030)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DA0[0x8];                                     // 0x1DA0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponBase*                            CurrentlyLookedAtWeapon;                           // 0x1DA8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DB0[0x30];                                    // 0x1DB0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimSpeed;                                          // 0x1DE0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CouchCamHideBodyThreshold;                         // 0x1DE4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SeethroughMat;                                     // 0x1DE8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DefaultSkin;                                       // 0x1DF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DefaultHair;                                       // 0x1DF8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E00[0x10];                                    // 0x1E00(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATrailerPawn>               TrailerPawnClass;                                  // 0x1E10(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E18[0x8];                                     // 0x1E18(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAdamCrosshair*                         Crosshair;                                         // 0x1E20(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WholeOffsetTest;                                   // 0x1E28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToRecoverLowLuck;                              // 0x1E2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E30[0x10];                                    // 0x1E30(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               InitialRotationUnarmed;                            // 0x1E40(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4C[0x50];                                    // 0x1E4C(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToLerpRightSideUp;                             // 0x1E9C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpectedDiveTravelAtApex;                          // 0x1EA0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EA4[0x10];                                    // 0x1EA4(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HideBodyPosition;                                  // 0x1EB4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideBodyCompletionTime;                            // 0x1EC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC4[0x28];                                    // 0x1EC4(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KickPitchLimit;                                    // 0x1EEC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EF0[0x10];                                    // 0x1EF0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTYVCAnimInstance*                      AnimInstance;                                      // 0x1F00(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DebugMontage;                                      // 0x1F08(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraMode                                   DebugCameraMode;                                   // 0x1F10(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F11[0x7];                                     // 0x1F11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GunAvoidWallThreshold;                             // 0x1F18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1C[0x4];                                     // 0x1F1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AmountToMoveGunToAvoid;                            // 0x1F20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneCapsuleScale;                                 // 0x1F24(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ThrowForce;                                        // 0x1F28(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ThrowOrigin;                                       // 0x1F30(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ThrowAdjust;                                       // 0x1F38(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F44[0x4];                                     // 0x1F44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class USphereComponent>> SphereCompList;                                    // 0x1F48(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                DiveAndProneCameraOffset;                          // 0x1F58(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F64[0xC];                                     // 0x1F64(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               HandsDynMatJacket;                                 // 0x1F70(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               HandsDynMatPants;                                  // 0x1F78(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               HandsDynMatSkin;                                   // 0x1F80(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BodyFacingRange;                                   // 0x1F88(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8C[0x4];                                     // 0x1F8C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ShoulderOffset;                                    // 0x1F90(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdjustedShoulderOffset;                            // 0x1F9C(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderOffsetYMin;                                // 0x1FA8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FAC[0x4];                                     // 0x1FAC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShoulderOffsetYMax;                                // 0x1FB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderOffsetAdjustmentRatio;                     // 0x1FB4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FB8[0xC];                                     // 0x1FB8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponYawOffsetMin;                                // 0x1FC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponYawOffsetMax;                                // 0x1FC8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderStiffness;                                 // 0x1FCC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderDampingFactor;                             // 0x1FD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteShoulder;                                 // 0x1FD4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD5[0x3];                                     // 0x1FD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             ChargedWallRunSound;                               // 0x1FD8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SuperWallRunSound;                                 // 0x1FE0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   WallRunForceFeedback;                              // 0x1FE8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   MeleeHitForceFeedback;                             // 0x1FF0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF8[0x8];                                     // 0x1FF8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoStaggeredAkimboDelay;                          // 0x2000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2004[0x4];                                     // 0x2004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbSoundCooldown;                                // 0x2008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_200C[0xC];                                     // 0x200C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             MediumLanding;                                     // 0x2018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Dead;                                              // 0x2020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2028[0x10];                                    // 0x2028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           PickupAnim;                                        // 0x2038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RestingFOV;                                        // 0x2040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideFOVOffset;                                    // 0x2044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2048[0x18];                                    // 0x2048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           KickSlideMontage;                                  // 0x2060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           KickSlideMontageStart;                             // 0x2068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           KickSlideMontageLoop;                              // 0x2070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           KickSlideMontageStand;                             // 0x2078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlideDuration;                                     // 0x2080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HideHeadName;                                      // 0x2084(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208C[0xC];                                     // 0x208C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CannonYawOffset;                                   // 0x2098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityToLeaveSlide;                              // 0x209C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityToEndSlide;                                // 0x20A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingFrictionFactorSlide;                       // 0x20A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingDecelSlide;                                // 0x20A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingFrictionFactorKickSlide;                   // 0x20AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingDecelKickSlide;                            // 0x20B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B4[0x8];                                     // 0x20B4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbForwardDistance;                              // 0x20BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClimbUpCheckDistance;                              // 0x20C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C4[0x2C];                                    // 0x20C4(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClimbSpeed;                                        // 0x20F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F4[0x10];                                    // 0x20F4(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyXOffset;                                       // 0x2104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        LowHealthLoop;                                     // 0x2108(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             QueueActionSound;                                  // 0x2110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2118[0x8];                                     // 0x2118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyXOffsetCrouched;                               // 0x2120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2124[0x2];                                     // 0x2124(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bGoProHead;                                        // 0x2126(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2127[0x1];                                     // 0x2127(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CapsuleScaleCurveProne;                            // 0x2128(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CapsuleScaleCurveKickSlide;                        // 0x2130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2138[0x9C];                                    // 0x2138(0x009C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         XOffsetLerpSpeed;                                  // 0x21D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D8[0x8];                                     // 0x21D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StandValidityOverflow;                             // 0x21E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E4[0xC];                                     // 0x21E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void GetActionInfo(EPlayerAction ForAction, bool bForController, class FName* OutName, bool* OutIsAxis);

	void AllowInstantAcceleration(float Time);
	void AtWeaponGrabPoint();
	void CancelFanWinddown();
	void CancelFanWindUp();
	void CannonSelectGamepadPressed();
	void CannonSelectGamepadReleased();
	void CannonSelectMKBPressed();
	void CannonSelectMKBReleased();
	void CannonSelectPressedImp();
	void CannonSelectReleasedImp();
	void CapsuleHit(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& SweepResult);
	void CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void DebugAIGoToPressed();
	void DebugCameraPressed();
	void DebugInvisiblePlayer();
	void DebugSpendLuckPressed();
	void DisableAirControl(float Time);
	void Dive();
	void DiveController();
	void DiveImp();
	void DiveReleased();
	void DiveReleasedController();
	void DoKickAutoAim();
	void DoLeftShoulderSlide(bool bInSlide, bool bInstant);
	void DrawFinished();
	void DropWeapon();
	void DropWeaponPressed();
	void EndSlide();
	bool EnsureStandValid();
	void EnterPressed();
	void EnterSlowMo();
	void FanWinddownComplete();
	void FinishCapsuleLerp();
	void FinishClimbForward();
	void FinishClimbUp();
	void FinishDeathCameraSwivel();
	void FinishedKickAnim(class UAnimMontage* AnimMontage, bool bInterrupted);
	void FinishedProneFromStand();
	void FinishedPunch(class UAnimMontage* AnimMontage, bool bInterrupted);
	void FinishedStandingFromProne();
	void FinishedUncrouching();
	void FinishKickSlide(bool bToCrouch);
	void FinishOnWallRunCameraCurve();
	void FireWeapon();
	void FlashlightGamepadPressed();
	void FlashlightKBPressed();
	void ForceEquip(class AWeaponBase* ToEquip);
	void ForceUpdateOverlaps();
	void ForwardPressed();
	void ForwardReleased();
	class AWeaponBase* GetEquippedWeapon();
	class UCameraComponent* GetFirstPersonCamera();
	bool GetIsDead();
	bool GetIsInDamageCooldown();
	bool GetIsReady();
	EMovementMode GetMovementMode();
	void HideDamage();
	void HolsterFinished();
	bool IsInStunt();
	void JumpPressedController();
	void JumpReleasedController();
	void KickPressed();
	void KickPressedController();
	void KickReleased();
	void KickReleasedController();
	void KickSlidePressedController();
	void KickSlidePressedImp();
	void KickSlidePressedKB();
	void KickSlideReleasedController();
	void KickSlideReleasedImp();
	void KickSlideReleasedKB();
	void LeaveDivePoseSnapshot();
	void LeaveRollPoseSnapshot();
	void LeaveSlowMo();
	void LerpRightShoulderTo(const struct FVector& ToLerpTo);
	void LevelReady();
	void LoadJacket(class FName InJacket);
	void LookUp(float AxisValue);
	void LookUpController(float AxisValue);
	void LookUpImp(float AxisValue);
	void MoveKickSlide(float Velocity);
	void NotifyArmCannonChargeAnimOver();
	void NotifyArmCannonMinCharge();
	void NotifyDoorKicked();
	void NotifyFanStatus(bool bFanStatus, const struct FVector& InFanLocation, const struct FVector& InFanVector, float FanLength);
	void NotifyFinishedUncrouch();
	void OnDebugMontageComplete(class UAnimMontage* AnimMontage, bool bInterrupted);
	void OnGetUpFinished(class UAnimMontage* AnimMontage, bool bInterrupted);
	void OnKickApex();
	void OnKickHeld();
	void OnKickHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnKickHitOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnProneDebugPressed();
	void OnPunchApex();
	void OnPunchApexArmCannon();
	void OnRollFinished(class UAnimMontage* AnimMontage, bool bInterrupted);
	void OnRollInterrupted(class UAnimMontage* AnimMontage, bool bInterrupted);
	void OnSlideKickSliding();
	void OnSlideKickStanding();
	void OnWallRunTimeOut();
	void PassedThroughChargeBox();
	void PauseDeath();
	void PausePressedDev();
	void PausePressedGamepad();
	void PausePressedKB();
	void PickupCallPressedController();
	void PickupCallPressedImp();
	void PickupCallPressedKeyboard();
	void PickupLookedAtWeapon();
	void PickupLookedAtWeaponController();
	void PickupLookedAtWeaponImp(bool bForced);
	void PlayDebugMontage();
	void PlayerRequestLevelReset();
	void PlayerRequestLevelResetGamepad();
	void ProcessForwardInput(float AxisValue);
	void ProcessForwardInputController(float AxisValue);
	void ProcessForwardInputImp(float AxisValue);
	void ProcessGyroAcceleration(const struct FVector& AxisValue);
	void ProcessGyroRotationRate(const struct FVector& AxisValue);
	void ProcessRightInput(float AxisValue);
	void ProcessRightInputController(float AxisValue);
	void ProcessRightInputImp(float AxisValue);
	void ReactToSlowMoChange(bool bNewStatus);
	void ReleasePickupLookedAtWeapon();
	void ReloadPressed();
	void SetControllerLookSensitivity(float InSens);
	void SetGamepadAcceleration(bool bAccel);
	void SetLeftArmNoise(bool bShouldNoise);
	void SetLookSpeedBP(float InSpeed);
	void SetTerminalVelocity(float InV);
	void SetupDecorativeGun();
	void SetWallRunningViz(bool bIsActive);
	void ShootCannonGamepadPressed();
	void ShootCannonGamepadReleased();
	void ShootCannonMKBPressed();
	void ShootCannonMKBReleased();
	void ShootCannonPressedImp();
	void ShootCannonReleasedImp();
	void ShowDamage(const struct FVector& DamageOrigin);
	void ShowWeaponPickupUI(class AWeaponBase* Weapon);
	void SlowMoPressedController();
	void SlowMoPressedMouse();
	void SlowMoReleasedController();
	void SlowMoReleasedMouse();
	void SmoothControllerAxis(float Xin, float Yin, float* Xout, float* Yout, bool bForTurning);
	bool SpendLuck(int32 Amount, const struct FVector& HitDir, const struct FVector& HitOrigin);
	void StandFromProneStep2();
	void StopWallRunning();
	void SwapWeapon();
	void ThrowWeaponPressed();
	void ThrowWeaponPressedController();
	void TickCapsuleLerp(float Value);
	void TickClimbForward(float Value);
	void TickClimbUp(float Value);
	void ToggleRunPressed();
	void ToggleSlowMo();
	void TriggerDownController();
	void TriggerDownMouse();
	void TriggerUpController();
	void TriggerUpMouse();
	void Turn(float AxisValue);
	void TurnController(float AxisValue);
	void TurnImp(float AxisValue);
	void UpdateAimAdjustDelta();
	void UpdateDeathCameraSwivel();
	void UpdateOnWallRunCameraCurve();
	void UpdateProneFromStand();
	void UpdateStandFromProne();
	void UpdateTriggerPull(float AxisValue);
	void UpdateTriggerPullController(float AxisValue);
	void UpdateWallRunZAndReleaseCurve();
	void WallRunCoolDownOver();
	void WindDownFan();
	void WindUpFan();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacter">();
	}
	static class APlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerCharacter>();
	}
};
static_assert(alignof(APlayerCharacter) == 0x000010, "Wrong alignment on APlayerCharacter");
static_assert(sizeof(APlayerCharacter) == 0x0021F0, "Wrong size on APlayerCharacter");
static_assert(offsetof(APlayerCharacter, MyGyroSpace) == 0x000838, "Member 'APlayerCharacter::MyGyroSpace' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PreviewTransform) == 0x000860, "Member 'APlayerCharacter::PreviewTransform' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FanForceThreshold) == 0x000890, "Member 'APlayerCharacter::FanForceThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FanBrake) == 0x000898, "Member 'APlayerCharacter::FanBrake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunSpeed) == 0x0008A8, "Member 'APlayerCharacter::WallRunSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LikeWaterSpeed) == 0x0008AC, "Member 'APlayerCharacter::LikeWaterSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentFanStrength) == 0x0008B0, "Member 'APlayerCharacter::CurrentFanStrength' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PostFanBoost) == 0x0008B4, "Member 'APlayerCharacter::PostFanBoost' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FanUpwardsForce) == 0x0008BC, "Member 'APlayerCharacter::FanUpwardsForce' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FanTerminalV) == 0x0008C0, "Member 'APlayerCharacter::FanTerminalV' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bWeaponReady) == 0x0008C4, "Member 'APlayerCharacter::bWeaponReady' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickSlideStartSpeed) == 0x0008CC, "Member 'APlayerCharacter::KickSlideStartSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bRidingSomething) == 0x0008D0, "Member 'APlayerCharacter::bRidingSomething' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunDotThreshold) == 0x0008E0, "Member 'APlayerCharacter::WallRunDotThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunCooldownTime) == 0x0008E4, "Member 'APlayerCharacter::WallRunCooldownTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bLocoStateDebug) == 0x0008F8, "Member 'APlayerCharacter::bLocoStateDebug' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GraphOffset) == 0x000960, "Member 'APlayerCharacter::GraphOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GraphSize) == 0x00096C, "Member 'APlayerCharacter::GraphSize' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbUpwardsForce) == 0x000974, "Member 'APlayerCharacter::ClimbUpwardsForce' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, NoiseAmplitude) == 0x000978, "Member 'APlayerCharacter::NoiseAmplitude' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, NoiseTimeMulti) == 0x000980, "Member 'APlayerCharacter::NoiseTimeMulti' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, NoiseRate) == 0x000984, "Member 'APlayerCharacter::NoiseRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastRequestedAction) == 0x000988, "Member 'APlayerCharacter::LastRequestedAction' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxCoyoteTime) == 0x000990, "Member 'APlayerCharacter::MaxCoyoteTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LastActionThreshold) == 0x000998, "Member 'APlayerCharacter::LastActionThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PickupSwoop) == 0x0009B0, "Member 'APlayerCharacter::PickupSwoop' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PickupImpact) == 0x0009B8, "Member 'APlayerCharacter::PickupImpact' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ReloadWeaponSound) == 0x0009C0, "Member 'APlayerCharacter::ReloadWeaponSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickAutoAimTarget) == 0x0009C8, "Member 'APlayerCharacter::KickAutoAimTarget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickAutoAimStart) == 0x0009D0, "Member 'APlayerCharacter::KickAutoAimStart' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbingObject) == 0x0009E8, "Member 'APlayerCharacter::ClimbingObject' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickAutoAimSize) == 0x0009F0, "Member 'APlayerCharacter::KickAutoAimSize' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ArmCannonClass) == 0x0009F8, "Member 'APlayerCharacter::ArmCannonClass' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ArmCannon) == 0x000A00, "Member 'APlayerCharacter::ArmCannon' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbUpCurve) == 0x000A08, "Member 'APlayerCharacter::ClimbUpCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbForwardCurve) == 0x000A10, "Member 'APlayerCharacter::ClimbForwardCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickImpulse) == 0x000B48, "Member 'APlayerCharacter::KickImpulse' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MinDotForAutoAim) == 0x000B50, "Member 'APlayerCharacter::MinDotForAutoAim' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxDistForAutoAim) == 0x000B54, "Member 'APlayerCharacter::MaxDistForAutoAim' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TimeToFreeze) == 0x000B60, "Member 'APlayerCharacter::TimeToFreeze' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AATarget) == 0x000B68, "Member 'APlayerCharacter::AATarget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, EveHUD) == 0x000B70, "Member 'APlayerCharacter::EveHUD' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FallingStuntMinSpeed) == 0x000B7C, "Member 'APlayerCharacter::FallingStuntMinSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FlyingStuntMinSpeed) == 0x000B80, "Member 'APlayerCharacter::FlyingStuntMinSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClassicCameraPosition) == 0x000B98, "Member 'APlayerCharacter::ClassicCameraPosition' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideMomentumVec) == 0x000BAC, "Member 'APlayerCharacter::SlideMomentumVec' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlidingSpeed) == 0x000BB8, "Member 'APlayerCharacter::SlidingSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingBrakeFrictionFactor) == 0x000BBC, "Member 'APlayerCharacter::StandingBrakeFrictionFactor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingBrakeDecelerationWalking) == 0x000BC0, "Member 'APlayerCharacter::StandingBrakeDecelerationWalking' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingAccel) == 0x000BC4, "Member 'APlayerCharacter::StandingAccel' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickMinPitch) == 0x000BCC, "Member 'APlayerCharacter::SlideKickMinPitch' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AltnernateGripInterpTime) == 0x000BD4, "Member 'APlayerCharacter::AltnernateGripInterpTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveOffset) == 0x000BDC, "Member 'APlayerCharacter::DiveOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneOffset) == 0x000BEC, "Member 'APlayerCharacter::ProneOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TestStandOffsets) == 0x000C08, "Member 'APlayerCharacter::TestStandOffsets' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FlipLandTotalTime) == 0x000C5C, "Member 'APlayerCharacter::FlipLandTotalTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BobReturnSpeed) == 0x000C64, "Member 'APlayerCharacter::BobReturnSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunCameraCenteringSpeed) == 0x000C78, "Member 'APlayerCharacter::WallRunCameraCenteringSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunPlayerWantsWallThreshold) == 0x000C7C, "Member 'APlayerCharacter::WallRunPlayerWantsWallThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunCheckSphereSize) == 0x000C80, "Member 'APlayerCharacter::WallRunCheckSphereSize' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DropKickSpeed) == 0x000C90, "Member 'APlayerCharacter::DropKickSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DisableAirControlTime) == 0x000C98, "Member 'APlayerCharacter::DisableAirControlTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlowMoPerKill) == 0x000C9C, "Member 'APlayerCharacter::SlowMoPerKill' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DropKickZ) == 0x000CBC, "Member 'APlayerCharacter::DropKickZ' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponRoll) == 0x000CC0, "Member 'APlayerCharacter::WeaponRoll' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentSloMoMeter) == 0x000CC4, "Member 'APlayerCharacter::CurrentSloMoMeter' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentMultiMeter) == 0x000CC8, "Member 'APlayerCharacter::CurrentMultiMeter' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlidePelvisTilt) == 0x000CCC, "Member 'APlayerCharacter::SlidePelvisTilt' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FuckingTestFuck) == 0x000CD0, "Member 'APlayerCharacter::FuckingTestFuck' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ArcadeMultiBurnRate) == 0x000CDC, "Member 'APlayerCharacter::ArcadeMultiBurnRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WindSound) == 0x000CE8, "Member 'APlayerCharacter::WindSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WindSoundComp) == 0x000CF0, "Member 'APlayerCharacter::WindSoundComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LowHealthSound) == 0x000CF8, "Member 'APlayerCharacter::LowHealthSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MultiplierDrainSound) == 0x000D00, "Member 'APlayerCharacter::MultiplierDrainSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentMultiplierMeter) == 0x000D08, "Member 'APlayerCharacter::CurrentMultiplierMeter' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DecayChart) == 0x000D10, "Member 'APlayerCharacter::DecayChart' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MultiplierBurnRate) == 0x000D18, "Member 'APlayerCharacter::MultiplierBurnRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SloMoBurnRate) == 0x000D1C, "Member 'APlayerCharacter::SloMoBurnRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TargetWeaponRoll) == 0x000D20, "Member 'APlayerCharacter::TargetWeaponRoll' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StopSlideThreshold) == 0x000D24, "Member 'APlayerCharacter::StopSlideThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentBodyViz) == 0x000D28, "Member 'APlayerCharacter::CurrentBodyViz' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyFadeSpeed) == 0x000D40, "Member 'APlayerCharacter::BodyFadeSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SteepnessMultiplier) == 0x000D44, "Member 'APlayerCharacter::SteepnessMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, UpwardsSlopeModifier) == 0x000D48, "Member 'APlayerCharacter::UpwardsSlopeModifier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DropKickZCurve) == 0x000D50, "Member 'APlayerCharacter::DropKickZCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickJumpMultiplier) == 0x000D58, "Member 'APlayerCharacter::SlideKickJumpMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickFriction) == 0x000D60, "Member 'APlayerCharacter::SlideKickFriction' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickFrictionBrake) == 0x000D64, "Member 'APlayerCharacter::SlideKickFrictionBrake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CeilingAvoidanceSpeed) == 0x000D68, "Member 'APlayerCharacter::CeilingAvoidanceSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CeilingCheckDistance) == 0x000D6C, "Member 'APlayerCharacter::CeilingCheckDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DropKickPitchYOffset) == 0x000D70, "Member 'APlayerCharacter::DropKickPitchYOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TargetWeaponRollSpeed) == 0x000D78, "Member 'APlayerCharacter::TargetWeaponRollSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DropKickTotalAlpha) == 0x000D80, "Member 'APlayerCharacter::DropKickTotalAlpha' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentLeftHandSocket) == 0x000D88, "Member 'APlayerCharacter::CurrentLeftHandSocket' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentLeftHandSocketOwner) == 0x000D90, "Member 'APlayerCharacter::CurrentLeftHandSocketOwner' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraBodyDistance) == 0x000DB4, "Member 'APlayerCharacter::CameraBodyDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StartingCameraMode) == 0x000E31, "Member 'APlayerCharacter::StartingCameraMode' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PunchMontage) == 0x000E48, "Member 'APlayerCharacter::PunchMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, UnarmedIdleSequence) == 0x000E50, "Member 'APlayerCharacter::UnarmedIdleSequence' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, UnarmedWalkingSequence) == 0x000E58, "Member 'APlayerCharacter::UnarmedWalkingSequence' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, UnarmedBaseRotation) == 0x000E60, "Member 'APlayerCharacter::UnarmedBaseRotation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PunchSphereSize) == 0x000EC4, "Member 'APlayerCharacter::PunchSphereSize' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Spine3BaseRotation) == 0x000EC8, "Member 'APlayerCharacter::Spine3BaseRotation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PunchDistance) == 0x000ED4, "Member 'APlayerCharacter::PunchDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickApexHold) == 0x000ED8, "Member 'APlayerCharacter::KickApexHold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsSynty) == 0x000EF1, "Member 'APlayerCharacter::bIsSynty' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponReadyPersist) == 0x000EF8, "Member 'APlayerCharacter::WeaponReadyPersist' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FallingLateralFriction) == 0x000F2C, "Member 'APlayerCharacter::FallingLateralFriction' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WalkingStepHeight) == 0x000F30, "Member 'APlayerCharacter::WalkingStepHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FallingStepHeight) == 0x000F34, "Member 'APlayerCharacter::FallingStepHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DivingStepHeight) == 0x000F38, "Member 'APlayerCharacter::DivingStepHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlidingStepHeight) == 0x000F3C, "Member 'APlayerCharacter::SlidingStepHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TransformTest) == 0x000F60, "Member 'APlayerCharacter::TransformTest' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SocketAdjust) == 0x000F90, "Member 'APlayerCharacter::SocketAdjust' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsWallRunning) == 0x000F98, "Member 'APlayerCharacter::bIsWallRunning' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveSound) == 0x000FA0, "Member 'APlayerCharacter::DiveSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbSound) == 0x000FA8, "Member 'APlayerCharacter::ClimbSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraPadding) == 0x000FB0, "Member 'APlayerCharacter::CameraPadding' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PunchHitWallSound) == 0x000FB8, "Member 'APlayerCharacter::PunchHitWallSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PunchHitBodySound) == 0x000FC0, "Member 'APlayerCharacter::PunchHitBodySound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickHitWallSound) == 0x000FC8, "Member 'APlayerCharacter::KickHitWallSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickHitBodySound) == 0x000FD0, "Member 'APlayerCharacter::KickHitBodySound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveLandSound) == 0x000FD8, "Member 'APlayerCharacter::DiveLandSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SwingSound) == 0x000FE0, "Member 'APlayerCharacter::SwingSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitByThrownSound) == 0x000FF0, "Member 'APlayerCharacter::HitByThrownSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThrowSound) == 0x000FF8, "Member 'APlayerCharacter::ThrowSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PickupSound) == 0x001000, "Member 'APlayerCharacter::PickupSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BarrelLookAtRot) == 0x001014, "Member 'APlayerCharacter::BarrelLookAtRot' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickDistance) == 0x001020, "Member 'APlayerCharacter::KickDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickDistanceAutomatic) == 0x001024, "Member 'APlayerCharacter::KickDistanceAutomatic' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Adjustment) == 0x001028, "Member 'APlayerCharacter::Adjustment' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickMinTime) == 0x001044, "Member 'APlayerCharacter::SlideKickMinTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideStuntModeMinSpeed) == 0x001048, "Member 'APlayerCharacter::SlideStuntModeMinSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunStuntModeMinSpeed) == 0x00104C, "Member 'APlayerCharacter::WallRunStuntModeMinSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, JumpHeight) == 0x001054, "Member 'APlayerCharacter::JumpHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FallKillThreshold) == 0x001064, "Member 'APlayerCharacter::FallKillThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LocationLastFrame) == 0x001068, "Member 'APlayerCharacter::LocationLastFrame' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickSlideMinSpeed) == 0x001074, "Member 'APlayerCharacter::KickSlideMinSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, JumpHeightSlideBoost) == 0x001078, "Member 'APlayerCharacter::JumpHeightSlideBoost' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentSpeed) == 0x00107C, "Member 'APlayerCharacter::CurrentSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentSpeedXY) == 0x001080, "Member 'APlayerCharacter::CurrentSpeedXY' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SteepnessSlideLaunchThreshold) == 0x00108C, "Member 'APlayerCharacter::SteepnessSlideLaunchThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentVelocity) == 0x001090, "Member 'APlayerCharacter::CurrentVelocity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FallingFrictionNoStunt) == 0x00109C, "Member 'APlayerCharacter::FallingFrictionNoStunt' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentVelocityForTrailer) == 0x0010AC, "Member 'APlayerCharacter::CurrentVelocityForTrailer' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bIsInTrailer) == 0x0010B8, "Member 'APlayerCharacter::bIsInTrailer' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlopeCheckDistance) == 0x0010BC, "Member 'APlayerCharacter::SlopeCheckDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingWalkableFloorAngle) == 0x0010C0, "Member 'APlayerCharacter::StandingWalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlidingWalkableFloorAngle) == 0x0010C4, "Member 'APlayerCharacter::SlidingWalkableFloorAngle' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightHandSwapSpeed) == 0x0010E4, "Member 'APlayerCharacter::RightHandSwapSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AimAdjustRate) == 0x001108, "Member 'APlayerCharacter::AimAdjustRate' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AimAdjustInterpSpeed) == 0x00110C, "Member 'APlayerCharacter::AimAdjustInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MontageForCam) == 0x001118, "Member 'APlayerCharacter::MontageForCam' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideAudioComp) == 0x001130, "Member 'APlayerCharacter::SlideAudioComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CrosshairMinSpread) == 0x00113C, "Member 'APlayerCharacter::CrosshairMinSpread' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CrosshairMaxSpread) == 0x001140, "Member 'APlayerCharacter::CrosshairMaxSpread' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CrosshairLerpSpeed) == 0x001144, "Member 'APlayerCharacter::CrosshairLerpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CrosshairCurrentSpread) == 0x001148, "Member 'APlayerCharacter::CrosshairCurrentSpread' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CrosshairClass) == 0x001150, "Member 'APlayerCharacter::CrosshairClass' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LuckDisplayClass) == 0x001158, "Member 'APlayerCharacter::LuckDisplayClass' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LuckThresholdGracePeriod) == 0x001170, "Member 'APlayerCharacter::LuckThresholdGracePeriod' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LuckThresholdGracePeriodTempered) == 0x001174, "Member 'APlayerCharacter::LuckThresholdGracePeriodTempered' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GruntCue) == 0x001180, "Member 'APlayerCharacter::GruntCue' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitENemyCue) == 0x001188, "Member 'APlayerCharacter::HitENemyCue' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LuckThresholdsCurve) == 0x001190, "Member 'APlayerCharacter::LuckThresholdsCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponRollCurve) == 0x001198, "Member 'APlayerCharacter::WeaponRollCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MaxLuckV2) == 0x0011A8, "Member 'APlayerCharacter::MaxLuckV2' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InStuntDilation) == 0x0011B8, "Member 'APlayerCharacter::InStuntDilation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultDilation) == 0x0011BC, "Member 'APlayerCharacter::DefaultDilation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ReducedDilation) == 0x0011C0, "Member 'APlayerCharacter::ReducedDilation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyYawRotateSpeedSlow) == 0x0011C4, "Member 'APlayerCharacter::BodyYawRotateSpeedSlow' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyYawRotateSpeedFast) == 0x0011C8, "Member 'APlayerCharacter::BodyYawRotateSpeedFast' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightHandInterpSpeed) == 0x0011CC, "Member 'APlayerCharacter::RightHandInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnDeathExplosionRadius) == 0x0011D0, "Member 'APlayerCharacter::OnDeathExplosionRadius' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightHandGripRange) == 0x0011E0, "Member 'APlayerCharacter::RightHandGripRange' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightHandRangeSpeed) == 0x0011E4, "Member 'APlayerCharacter::RightHandRangeSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LightFallThreshold) == 0x0011E8, "Member 'APlayerCharacter::LightFallThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeavyFallThreshold) == 0x0011EC, "Member 'APlayerCharacter::HeavyFallThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeavyFallSound) == 0x0011F0, "Member 'APlayerCharacter::HeavyFallSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightHandGripLocation) == 0x0011F8, "Member 'APlayerCharacter::RightHandGripLocation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightShoulderLocation) == 0x001200, "Member 'APlayerCharacter::RightShoulderLocation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftShoulderLocation) == 0x001208, "Member 'APlayerCharacter::LeftShoulderLocation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftShoulderSlideLocation) == 0x001210, "Member 'APlayerCharacter::LeftShoulderSlideLocation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftShoulderBaseLocation) == 0x00121C, "Member 'APlayerCharacter::LeftShoulderBaseLocation' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightShoulderLocationStabilized) == 0x001228, "Member 'APlayerCharacter::RightShoulderLocationStabilized' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShoulderStabilizationThreshold) == 0x001230, "Member 'APlayerCharacter::ShoulderStabilizationThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeadSpringArm) == 0x001238, "Member 'APlayerCharacter::HeadSpringArm' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StuntThirdPersonSpringArm) == 0x001240, "Member 'APlayerCharacter::StuntThirdPersonSpringArm' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightHandSpringArm) == 0x001248, "Member 'APlayerCharacter::RightHandSpringArm' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StuntThirdPersonCam) == 0x001250, "Member 'APlayerCharacter::StuntThirdPersonCam' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PhysicsCollisionCapsule) == 0x001258, "Member 'APlayerCharacter::PhysicsCollisionCapsule' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PhysAnimComp) == 0x001260, "Member 'APlayerCharacter::PhysAnimComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveBodyNameLeftLeg) == 0x001268, "Member 'APlayerCharacter::DiveBodyNameLeftLeg' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveBodyNameRightLeg) == 0x001270, "Member 'APlayerCharacter::DiveBodyNameRightLeg' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveBoneNameLeftLeg) == 0x001278, "Member 'APlayerCharacter::DiveBoneNameLeftLeg' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveBoneNameRightLeg) == 0x001280, "Member 'APlayerCharacter::DiveBoneNameRightLeg' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveProfileName) == 0x001288, "Member 'APlayerCharacter::DiveProfileName' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftArmBone1Name) == 0x001290, "Member 'APlayerCharacter::LeftArmBone1Name' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftArmBone2Name) == 0x001298, "Member 'APlayerCharacter::LeftArmBone2Name' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TYVCGameMode) == 0x001318, "Member 'APlayerCharacter::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickMontage) == 0x001320, "Member 'APlayerCharacter::KickMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunStartLeftMontage) == 0x001328, "Member 'APlayerCharacter::WallRunStartLeftMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunStartRightMontage) == 0x001330, "Member 'APlayerCharacter::WallRunStartRightMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThrowMontage) == 0x001338, "Member 'APlayerCharacter::ThrowMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThrowMontageProne) == 0x001340, "Member 'APlayerCharacter::ThrowMontageProne' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DropMontage) == 0x001348, "Member 'APlayerCharacter::DropMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DeathMontage) == 0x001350, "Member 'APlayerCharacter::DeathMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ActorDirectionArrow) == 0x001358, "Member 'APlayerCharacter::ActorDirectionArrow' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HandsDirectionArrow) == 0x001360, "Member 'APlayerCharacter::HandsDirectionArrow' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, QuatSlerpSpeed) == 0x001368, "Member 'APlayerCharacter::QuatSlerpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FirstPersonCamera) == 0x001390, "Member 'APlayerCharacter::FirstPersonCamera' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DebugCamera) == 0x001398, "Member 'APlayerCharacter::DebugCamera' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DebugSpringArm) == 0x0013A0, "Member 'APlayerCharacter::DebugSpringArm' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyTrackCameraSpeed) == 0x0013A8, "Member 'APlayerCharacter::BodyTrackCameraSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PickupReach) == 0x0013AC, "Member 'APlayerCharacter::PickupReach' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PickupReachDefault) == 0x0013B0, "Member 'APlayerCharacter::PickupReachDefault' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickReach) == 0x0013B4, "Member 'APlayerCharacter::KickReach' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AutoStandMaxTimer) == 0x0013B8, "Member 'APlayerCharacter::AutoStandMaxTimer' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VoxelInvokerComponent) == 0x0013C8, "Member 'APlayerCharacter::VoxelInvokerComponent' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Hands) == 0x0013D0, "Member 'APlayerCharacter::Hands' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StimSourceComp) == 0x0013D8, "Member 'APlayerCharacter::StimSourceComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MyCardinalDirection) == 0x0013E2, "Member 'APlayerCharacter::MyCardinalDirection' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentlyLookedAtInteractable) == 0x0013E8, "Member 'APlayerCharacter::CurrentlyLookedAtInteractable' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentlyEquippedWeapon) == 0x0013F0, "Member 'APlayerCharacter::CurrentlyEquippedWeapon' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MyAkimboWeapon) == 0x0013F8, "Member 'APlayerCharacter::MyAkimboWeapon' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PickingUpWeapon) == 0x001400, "Member 'APlayerCharacter::PickingUpWeapon' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickSweepOffset) == 0x001440, "Member 'APlayerCharacter::SlideKickSweepOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickSweepSize) == 0x001444, "Member 'APlayerCharacter::SlideKickSweepSize' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveSweepRadius) == 0x001448, "Member 'APlayerCharacter::DiveSweepRadius' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveSweepHalfHeight) == 0x00144C, "Member 'APlayerCharacter::DiveSweepHalfHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PickupTime) == 0x001454, "Member 'APlayerCharacter::PickupTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HolsteredWeapon) == 0x001460, "Member 'APlayerCharacter::HolsteredWeapon' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveZVector) == 0x001470, "Member 'APlayerCharacter::DiveZVector' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallKickZVector) == 0x001474, "Member 'APlayerCharacter::WallKickZVector' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallKickVelocity) == 0x001478, "Member 'APlayerCharacter::WallKickVelocity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DivePitchVelocityCurve) == 0x001480, "Member 'APlayerCharacter::DivePitchVelocityCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallJumpPitchZVector) == 0x001488, "Member 'APlayerCharacter::WallJumpPitchZVector' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveVelocityMultiplier) == 0x001490, "Member 'APlayerCharacter::DiveVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunJumpZVector) == 0x001494, "Member 'APlayerCharacter::WallRunJumpZVector' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunJumpMaxDiff) == 0x001498, "Member 'APlayerCharacter::WallRunJumpMaxDiff' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunJumpVelocityMultiplier) == 0x00149C, "Member 'APlayerCharacter::WallRunJumpVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunPushOffVelocityMultiplier) == 0x0014A0, "Member 'APlayerCharacter::WallRunPushOffVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraStandingPosition) == 0x0014A4, "Member 'APlayerCharacter::CameraStandingPosition' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraPronePosition) == 0x0014B0, "Member 'APlayerCharacter::CameraPronePosition' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunBoostCurve) == 0x0014C0, "Member 'APlayerCharacter::WallRunBoostCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunYawChangeMax) == 0x0014FC, "Member 'APlayerCharacter::WallRunYawChangeMax' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DistanceBetweenNormalSamples) == 0x001500, "Member 'APlayerCharacter::DistanceBetweenNormalSamples' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunFailedLeniancyTime) == 0x001504, "Member 'APlayerCharacter::WallRunFailedLeniancyTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DesiredCrouchCamHeight) == 0x00150C, "Member 'APlayerCharacter::DesiredCrouchCamHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DesiredSlideCamHeight) == 0x001510, "Member 'APlayerCharacter::DesiredSlideCamHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TargetCrouchCamHeight) == 0x001514, "Member 'APlayerCharacter::TargetCrouchCamHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CrouchCamInterpSpeed) == 0x001518, "Member 'APlayerCharacter::CrouchCamInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideCamInterpSpeed) == 0x00151C, "Member 'APlayerCharacter::SlideCamInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideSteepnessClamp) == 0x001520, "Member 'APlayerCharacter::SlideSteepnessClamp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunLaunchCameraInfluence) == 0x001528, "Member 'APlayerCharacter::WallRunLaunchCameraInfluence' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunGravityScale) == 0x001530, "Member 'APlayerCharacter::WallRunGravityScale' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, NormalGravityScale) == 0x001534, "Member 'APlayerCharacter::NormalGravityScale' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunMaxTime) == 0x001538, "Member 'APlayerCharacter::WallRunMaxTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerToWallDistance) == 0x00153C, "Member 'APlayerCharacter::PlayerToWallDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerToWallDistanceDuringRun) == 0x001540, "Member 'APlayerCharacter::PlayerToWallDistanceDuringRun' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunPushIntoWallForce) == 0x001544, "Member 'APlayerCharacter::WallRunPushIntoWallForce' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickPushIntoFloorForce) == 0x001548, "Member 'APlayerCharacter::SlideKickPushIntoFloorForce' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunFallingFriction) == 0x00154C, "Member 'APlayerCharacter::WallRunFallingFriction' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunAimLerpTime) == 0x001554, "Member 'APlayerCharacter::WallRunAimLerpTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunSpeedCurve) == 0x001558, "Member 'APlayerCharacter::WallRunSpeedCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CamWeaponSwayMaxPitch) == 0x001560, "Member 'APlayerCharacter::CamWeaponSwayMaxPitch' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CamWeaponSwayMaxYaw) == 0x001564, "Member 'APlayerCharacter::CamWeaponSwayMaxYaw' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MinCamMovementForSway) == 0x001568, "Member 'APlayerCharacter::MinCamMovementForSway' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CamWeaponSwaySpeed) == 0x00156C, "Member 'APlayerCharacter::CamWeaponSwaySpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentCamWeaponSwayPitch) == 0x001570, "Member 'APlayerCharacter::CurrentCamWeaponSwayPitch' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentCamWeaponSwayYaw) == 0x001574, "Member 'APlayerCharacter::CurrentCamWeaponSwayYaw' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponRollCurveV2) == 0x001578, "Member 'APlayerCharacter::WeaponRollCurveV2' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PitchOverrideCurve) == 0x001580, "Member 'APlayerCharacter::PitchOverrideCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponRollAdjustCurve) == 0x001588, "Member 'APlayerCharacter::WeaponRollAdjustCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PitchLimitCurve) == 0x001590, "Member 'APlayerCharacter::PitchLimitCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PitchAimCurve) == 0x001598, "Member 'APlayerCharacter::PitchAimCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingPitchMax) == 0x0015A0, "Member 'APlayerCharacter::StandingPitchMax' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingPitchMin) == 0x0015A4, "Member 'APlayerCharacter::StandingPitchMin' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponClippingDistance) == 0x0015A8, "Member 'APlayerCharacter::WeaponClippingDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, FadePitchThreshold) == 0x0015AC, "Member 'APlayerCharacter::FadePitchThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HoldTimeForKickSlide) == 0x0015B8, "Member 'APlayerCharacter::HoldTimeForKickSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbCapZ) == 0x0015BC, "Member 'APlayerCharacter::ClimbCapZ' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbCapFwd) == 0x0015C0, "Member 'APlayerCharacter::ClimbCapFwd' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PostClimbLaunch) == 0x0015C4, "Member 'APlayerCharacter::PostClimbLaunch' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Chameleon) == 0x0015C8, "Member 'APlayerCharacter::Chameleon' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HitsToWallRun) == 0x0015D0, "Member 'APlayerCharacter::HitsToWallRun' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunLaunchMinOffset) == 0x0015D4, "Member 'APlayerCharacter::WallRunLaunchMinOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlowMoPlaybackSpeed) == 0x0015DC, "Member 'APlayerCharacter::SlowMoPlaybackSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentAnimPlaybackSpeed) == 0x0015E0, "Member 'APlayerCharacter::CurrentAnimPlaybackSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultAirControl) == 0x0015E8, "Member 'APlayerCharacter::DefaultAirControl' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, EdgeBoostSfx) == 0x0015F0, "Member 'APlayerCharacter::EdgeBoostSfx' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CapsuleLerpSpeed) == 0x0015F8, "Member 'APlayerCharacter::CapsuleLerpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, EdgeBoostDetectionWindow) == 0x0015FC, "Member 'APlayerCharacter::EdgeBoostDetectionWindow' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, EdgeBoostUseWindow) == 0x001600, "Member 'APlayerCharacter::EdgeBoostUseWindow' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingCapsuleScale) == 0x001624, "Member 'APlayerCharacter::StandingCapsuleScale' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraLerpSpeed) == 0x001628, "Member 'APlayerCharacter::CameraLerpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HandsLerpSpeed) == 0x001630, "Member 'APlayerCharacter::HandsLerpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HandsRotLerpSpeed) == 0x001634, "Member 'APlayerCharacter::HandsRotLerpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RollingCapsuleSize) == 0x00167C, "Member 'APlayerCharacter::RollingCapsuleSize' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingHalfHeight) == 0x001684, "Member 'APlayerCharacter::StandingHalfHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CamMoveToHeadSpeed) == 0x001688, "Member 'APlayerCharacter::CamMoveToHeadSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneToStandMontageOnBelly) == 0x001690, "Member 'APlayerCharacter::ProneToStandMontageOnBelly' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneToStandMontageOnBack) == 0x001698, "Member 'APlayerCharacter::ProneToStandMontageOnBack' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneToStandCurveOnBack) == 0x0016A0, "Member 'APlayerCharacter::ProneToStandCurveOnBack' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneToStandCurveOnBelly) == 0x0016A8, "Member 'APlayerCharacter::ProneToStandCurveOnBelly' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StartSlideKickCurve) == 0x0016B0, "Member 'APlayerCharacter::StartSlideKickCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeaveSlideKickCurve) == 0x0016B8, "Member 'APlayerCharacter::LeaveSlideKickCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyRollOffset) == 0x0016CC, "Member 'APlayerCharacter::BodyRollOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraSwapTolerance) == 0x0016D8, "Member 'APlayerCharacter::CameraSwapTolerance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyOffsetSpeed) == 0x001710, "Member 'APlayerCharacter::BodyOffsetSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneHalfHeight) == 0x001714, "Member 'APlayerCharacter::ProneHalfHeight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneForwardsSpeed) == 0x001718, "Member 'APlayerCharacter::ProneForwardsSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneRollSpeed) == 0x00171C, "Member 'APlayerCharacter::ProneRollSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingSpeed) == 0x001720, "Member 'APlayerCharacter::StandingSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandingSpeedReduced) == 0x001724, "Member 'APlayerCharacter::StandingSpeedReduced' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveMontage) == 0x001728, "Member 'APlayerCharacter::DiveMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RollMontageForward) == 0x001730, "Member 'APlayerCharacter::RollMontageForward' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RollMontageRight) == 0x001738, "Member 'APlayerCharacter::RollMontageRight' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RollMontageBack) == 0x001740, "Member 'APlayerCharacter::RollMontageBack' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RollMontageLeft) == 0x001748, "Member 'APlayerCharacter::RollMontageLeft' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveSlidingTime) == 0x001750, "Member 'APlayerCharacter::DiveSlidingTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandFromProneCurve) == 0x001758, "Member 'APlayerCharacter::StandFromProneCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneFromStandCurve) == 0x001760, "Member 'APlayerCharacter::ProneFromStandCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StuntEndGraceCurve) == 0x001768, "Member 'APlayerCharacter::StuntEndGraceCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnDeathCameraSwivelCurve) == 0x001770, "Member 'APlayerCharacter::OnDeathCameraSwivelCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnWallRunCameraCurve) == 0x001778, "Member 'APlayerCharacter::OnWallRunCameraCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunZAndReleaseCurve) == 0x001780, "Member 'APlayerCharacter::WallRunZAndReleaseCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponPickupWidgetComp) == 0x001788, "Member 'APlayerCharacter::WeaponPickupWidgetComp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponPickupWidgetCompWidget) == 0x001790, "Member 'APlayerCharacter::WeaponPickupWidgetCompWidget' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickSlideVelocityCurve) == 0x001B38, "Member 'APlayerCharacter::KickSlideVelocityCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultCollisionDistance) == 0x001B40, "Member 'APlayerCharacter::DefaultCollisionDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CollisionImminentSphereRadius) == 0x001B48, "Member 'APlayerCharacter::CollisionImminentSphereRadius' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ActorsHitThisSlide) == 0x001B58, "Member 'APlayerCharacter::ActorsHitThisSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ActorsHitThisDive) == 0x001B68, "Member 'APlayerCharacter::ActorsHitThisDive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentCamCurve) == 0x001B78, "Member 'APlayerCharacter::CurrentCamCurve' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideKickYawOffset) == 0x001B84, "Member 'APlayerCharacter::SlideKickYawOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CamAttachToHeadSocketInterpSpeed) == 0x001B90, "Member 'APlayerCharacter::CamAttachToHeadSocketInterpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunTargetCameraRoll) == 0x001B98, "Member 'APlayerCharacter::WallRunTargetCameraRoll' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunCameraRollSpeed) == 0x001B9C, "Member 'APlayerCharacter::WallRunCameraRollSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StartingLuck) == 0x001BA0, "Member 'APlayerCharacter::StartingLuck' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LuckRestoreSpeed) == 0x001BA4, "Member 'APlayerCharacter::LuckRestoreSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CameraTiltSpeedDive) == 0x001BAC, "Member 'APlayerCharacter::CameraTiltSpeedDive' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AkimboOffset) == 0x001BB0, "Member 'APlayerCharacter::AkimboOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HandsAnimInstance) == 0x001BC0, "Member 'APlayerCharacter::HandsAnimInstance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AnimInstance_Post) == 0x001BC8, "Member 'APlayerCharacter::AnimInstance_Post' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShadowAnimInstance) == 0x001BD0, "Member 'APlayerCharacter::ShadowAnimInstance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShadowAnimInstance_Post) == 0x001BD8, "Member 'APlayerCharacter::ShadowAnimInstance_Post' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RotationRateKey) == 0x001C60, "Member 'APlayerCharacter::RotationRateKey' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AccelerationGyroKey) == 0x001C78, "Member 'APlayerCharacter::AccelerationGyroKey' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GyroDebugSensitivity) == 0x001C90, "Member 'APlayerCharacter::GyroDebugSensitivity' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PlayerHitSound) == 0x001CC8, "Member 'APlayerCharacter::PlayerHitSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HeadTarget3) == 0x001CD0, "Member 'APlayerCharacter::HeadTarget3' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TorsoTarget3) == 0x001CD8, "Member 'APlayerCharacter::TorsoTarget3' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LeftArmTarget3) == 0x001CE0, "Member 'APlayerCharacter::LeftArmTarget3' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RightArmTarget3) == 0x001CE8, "Member 'APlayerCharacter::RightArmTarget3' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LegsTarget3) == 0x001CF0, "Member 'APlayerCharacter::LegsTarget3' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnDiveLandCameraShake) == 0x001D00, "Member 'APlayerCharacter::OnDiveLandCameraShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnJumpLandCameraShake) == 0x001D08, "Member 'APlayerCharacter::OnJumpLandCameraShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnJumpLandCameraShakeHeavy) == 0x001D10, "Member 'APlayerCharacter::OnJumpLandCameraShakeHeavy' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShockwaveSystem) == 0x001D18, "Member 'APlayerCharacter::ShockwaveSystem' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnJumpCameraShake) == 0x001D20, "Member 'APlayerCharacter::OnJumpCameraShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnDiveCameraShake) == 0x001D28, "Member 'APlayerCharacter::OnDiveCameraShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnKickLandCameraShake) == 0x001D30, "Member 'APlayerCharacter::OnKickLandCameraShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnKickCameraShake) == 0x001D38, "Member 'APlayerCharacter::OnKickCameraShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, OnSpendLuckCameraShake) == 0x001D40, "Member 'APlayerCharacter::OnSpendLuckCameraShake' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ActiveCam) == 0x001D48, "Member 'APlayerCharacter::ActiveCam' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DebugSpendLuckAmount) == 0x001D50, "Member 'APlayerCharacter::DebugSpendLuckAmount' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AkimboFire) == 0x001D60, "Member 'APlayerCharacter::AkimboFire' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LevelStartTransform) == 0x001D70, "Member 'APlayerCharacter::LevelStartTransform' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CurrentlyLookedAtWeapon) == 0x001DA8, "Member 'APlayerCharacter::CurrentlyLookedAtWeapon' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AimSpeed) == 0x001DE0, "Member 'APlayerCharacter::AimSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CouchCamHideBodyThreshold) == 0x001DE4, "Member 'APlayerCharacter::CouchCamHideBodyThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SeethroughMat) == 0x001DE8, "Member 'APlayerCharacter::SeethroughMat' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultSkin) == 0x001DF0, "Member 'APlayerCharacter::DefaultSkin' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DefaultHair) == 0x001DF8, "Member 'APlayerCharacter::DefaultHair' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TrailerPawnClass) == 0x001E10, "Member 'APlayerCharacter::TrailerPawnClass' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Crosshair) == 0x001E20, "Member 'APlayerCharacter::Crosshair' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WholeOffsetTest) == 0x001E28, "Member 'APlayerCharacter::WholeOffsetTest' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TimeToRecoverLowLuck) == 0x001E2C, "Member 'APlayerCharacter::TimeToRecoverLowLuck' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, InitialRotationUnarmed) == 0x001E40, "Member 'APlayerCharacter::InitialRotationUnarmed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, TimeToLerpRightSideUp) == 0x001E9C, "Member 'APlayerCharacter::TimeToLerpRightSideUp' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ExpectedDiveTravelAtApex) == 0x001EA0, "Member 'APlayerCharacter::ExpectedDiveTravelAtApex' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HideBodyPosition) == 0x001EB4, "Member 'APlayerCharacter::HideBodyPosition' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HideBodyCompletionTime) == 0x001EC0, "Member 'APlayerCharacter::HideBodyCompletionTime' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickPitchLimit) == 0x001EEC, "Member 'APlayerCharacter::KickPitchLimit' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AnimInstance) == 0x001F00, "Member 'APlayerCharacter::AnimInstance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DebugMontage) == 0x001F08, "Member 'APlayerCharacter::DebugMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DebugCameraMode) == 0x001F10, "Member 'APlayerCharacter::DebugCameraMode' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, GunAvoidWallThreshold) == 0x001F18, "Member 'APlayerCharacter::GunAvoidWallThreshold' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AmountToMoveGunToAvoid) == 0x001F20, "Member 'APlayerCharacter::AmountToMoveGunToAvoid' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ProneCapsuleScale) == 0x001F24, "Member 'APlayerCharacter::ProneCapsuleScale' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThrowForce) == 0x001F28, "Member 'APlayerCharacter::ThrowForce' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThrowOrigin) == 0x001F30, "Member 'APlayerCharacter::ThrowOrigin' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ThrowAdjust) == 0x001F38, "Member 'APlayerCharacter::ThrowAdjust' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SphereCompList) == 0x001F48, "Member 'APlayerCharacter::SphereCompList' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, DiveAndProneCameraOffset) == 0x001F58, "Member 'APlayerCharacter::DiveAndProneCameraOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HandsDynMatJacket) == 0x001F70, "Member 'APlayerCharacter::HandsDynMatJacket' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HandsDynMatPants) == 0x001F78, "Member 'APlayerCharacter::HandsDynMatPants' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HandsDynMatSkin) == 0x001F80, "Member 'APlayerCharacter::HandsDynMatSkin' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyFacingRange) == 0x001F88, "Member 'APlayerCharacter::BodyFacingRange' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShoulderOffset) == 0x001F90, "Member 'APlayerCharacter::ShoulderOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AdjustedShoulderOffset) == 0x001F9C, "Member 'APlayerCharacter::AdjustedShoulderOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShoulderOffsetYMin) == 0x001FA8, "Member 'APlayerCharacter::ShoulderOffsetYMin' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShoulderOffsetYMax) == 0x001FB0, "Member 'APlayerCharacter::ShoulderOffsetYMax' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShoulderOffsetAdjustmentRatio) == 0x001FB4, "Member 'APlayerCharacter::ShoulderOffsetAdjustmentRatio' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponYawOffsetMin) == 0x001FC4, "Member 'APlayerCharacter::WeaponYawOffsetMin' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WeaponYawOffsetMax) == 0x001FC8, "Member 'APlayerCharacter::WeaponYawOffsetMax' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShoulderStiffness) == 0x001FCC, "Member 'APlayerCharacter::ShoulderStiffness' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ShoulderDampingFactor) == 0x001FD0, "Member 'APlayerCharacter::ShoulderDampingFactor' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bAbsoluteShoulder) == 0x001FD4, "Member 'APlayerCharacter::bAbsoluteShoulder' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ChargedWallRunSound) == 0x001FD8, "Member 'APlayerCharacter::ChargedWallRunSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SuperWallRunSound) == 0x001FE0, "Member 'APlayerCharacter::SuperWallRunSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, WallRunForceFeedback) == 0x001FE8, "Member 'APlayerCharacter::WallRunForceFeedback' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MeleeHitForceFeedback) == 0x001FF0, "Member 'APlayerCharacter::MeleeHitForceFeedback' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, AutoStaggeredAkimboDelay) == 0x002000, "Member 'APlayerCharacter::AutoStaggeredAkimboDelay' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbSoundCooldown) == 0x002008, "Member 'APlayerCharacter::ClimbSoundCooldown' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, MediumLanding) == 0x002018, "Member 'APlayerCharacter::MediumLanding' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, Dead) == 0x002020, "Member 'APlayerCharacter::Dead' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, PickupAnim) == 0x002038, "Member 'APlayerCharacter::PickupAnim' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, RestingFOV) == 0x002040, "Member 'APlayerCharacter::RestingFOV' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideFOVOffset) == 0x002044, "Member 'APlayerCharacter::SlideFOVOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickSlideMontage) == 0x002060, "Member 'APlayerCharacter::KickSlideMontage' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickSlideMontageStart) == 0x002068, "Member 'APlayerCharacter::KickSlideMontageStart' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickSlideMontageLoop) == 0x002070, "Member 'APlayerCharacter::KickSlideMontageLoop' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, KickSlideMontageStand) == 0x002078, "Member 'APlayerCharacter::KickSlideMontageStand' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, SlideDuration) == 0x002080, "Member 'APlayerCharacter::SlideDuration' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, HideHeadName) == 0x002084, "Member 'APlayerCharacter::HideHeadName' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CannonYawOffset) == 0x002098, "Member 'APlayerCharacter::CannonYawOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VelocityToLeaveSlide) == 0x00209C, "Member 'APlayerCharacter::VelocityToLeaveSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, VelocityToEndSlide) == 0x0020A0, "Member 'APlayerCharacter::VelocityToEndSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BreakingFrictionFactorSlide) == 0x0020A4, "Member 'APlayerCharacter::BreakingFrictionFactorSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BreakingDecelSlide) == 0x0020A8, "Member 'APlayerCharacter::BreakingDecelSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BreakingFrictionFactorKickSlide) == 0x0020AC, "Member 'APlayerCharacter::BreakingFrictionFactorKickSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BreakingDecelKickSlide) == 0x0020B0, "Member 'APlayerCharacter::BreakingDecelKickSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbForwardDistance) == 0x0020BC, "Member 'APlayerCharacter::ClimbForwardDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbUpCheckDistance) == 0x0020C0, "Member 'APlayerCharacter::ClimbUpCheckDistance' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, ClimbSpeed) == 0x0020F0, "Member 'APlayerCharacter::ClimbSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyXOffset) == 0x002104, "Member 'APlayerCharacter::BodyXOffset' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, LowHealthLoop) == 0x002108, "Member 'APlayerCharacter::LowHealthLoop' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, QueueActionSound) == 0x002110, "Member 'APlayerCharacter::QueueActionSound' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, BodyXOffsetCrouched) == 0x002120, "Member 'APlayerCharacter::BodyXOffsetCrouched' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, bGoProHead) == 0x002126, "Member 'APlayerCharacter::bGoProHead' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CapsuleScaleCurveProne) == 0x002128, "Member 'APlayerCharacter::CapsuleScaleCurveProne' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, CapsuleScaleCurveKickSlide) == 0x002130, "Member 'APlayerCharacter::CapsuleScaleCurveKickSlide' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, XOffsetLerpSpeed) == 0x0021D4, "Member 'APlayerCharacter::XOffsetLerpSpeed' has a wrong offset!");
static_assert(offsetof(APlayerCharacter, StandValidityOverflow) == 0x0021E0, "Member 'APlayerCharacter::StandValidityOverflow' has a wrong offset!");

// Class ThankYouVeryCool.PlayerPositionModel
// 0x0038 (0x0258 - 0x0220)
class APlayerPositionModel final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    StimSourceComp;                                    // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastSeenVelocity;                                  // 0x0230(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       SphereComp;                                        // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        ArrowComp;                                         // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AgeSinceLastUpdate;                                // 0x0250(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPositionModel">();
	}
	static class APlayerPositionModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerPositionModel>();
	}
};
static_assert(alignof(APlayerPositionModel) == 0x000008, "Wrong alignment on APlayerPositionModel");
static_assert(sizeof(APlayerPositionModel) == 0x000258, "Wrong size on APlayerPositionModel");
static_assert(offsetof(APlayerPositionModel, StimSourceComp) == 0x000228, "Member 'APlayerPositionModel::StimSourceComp' has a wrong offset!");
static_assert(offsetof(APlayerPositionModel, LastSeenVelocity) == 0x000230, "Member 'APlayerPositionModel::LastSeenVelocity' has a wrong offset!");
static_assert(offsetof(APlayerPositionModel, SphereComp) == 0x000240, "Member 'APlayerPositionModel::SphereComp' has a wrong offset!");
static_assert(offsetof(APlayerPositionModel, ArrowComp) == 0x000248, "Member 'APlayerPositionModel::ArrowComp' has a wrong offset!");
static_assert(offsetof(APlayerPositionModel, AgeSinceLastUpdate) == 0x000250, "Member 'APlayerPositionModel::AgeSinceLastUpdate' has a wrong offset!");

// Class ThankYouVeryCool.PoolableBlood
// 0x0008 (0x0290 - 0x0288)
class APoolableBlood : public APoolableActor
{
public:
	class UDecalComponent*                        DecalComp;                                         // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableBlood">();
	}
	static class APoolableBlood* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoolableBlood>();
	}
};
static_assert(alignof(APoolableBlood) == 0x000008, "Wrong alignment on APoolableBlood");
static_assert(sizeof(APoolableBlood) == 0x000290, "Wrong size on APoolableBlood");
static_assert(offsetof(APoolableBlood, DecalComp) == 0x000288, "Member 'APoolableBlood::DecalComp' has a wrong offset!");

// Class ThankYouVeryCool.PoolableDecal
// 0x0000 (0x0288 - 0x0288)
class APoolableDecal : public APoolableActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableDecal">();
	}
	static class APoolableDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoolableDecal>();
	}
};
static_assert(alignof(APoolableDecal) == 0x000008, "Wrong alignment on APoolableDecal");
static_assert(sizeof(APoolableDecal) == 0x000288, "Wrong size on APoolableDecal");

// Class ThankYouVeryCool.PoolableFire
// 0x0000 (0x0288 - 0x0288)
class APoolableFire : public APoolableActor
{
public:
	void MakeDormantBP();
	void StartBurning();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableFire">();
	}
	static class APoolableFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoolableFire>();
	}
};
static_assert(alignof(APoolableFire) == 0x000008, "Wrong alignment on APoolableFire");
static_assert(sizeof(APoolableFire) == 0x000288, "Wrong size on APoolableFire");

// Class ThankYouVeryCool.PoolableGlass
// 0x0020 (0x02A8 - 0x0288)
class APoolableGlass : public APoolableActor
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeToSleep;                                       // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             GlassHit;                                          // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnGlassSleep(class UPrimitiveComponent* SleepingComponent, class FName BoneName);
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableGlass">();
	}
	static class APoolableGlass* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoolableGlass>();
	}
};
static_assert(alignof(APoolableGlass) == 0x000008, "Wrong alignment on APoolableGlass");
static_assert(sizeof(APoolableGlass) == 0x0002A8, "Wrong size on APoolableGlass");
static_assert(offsetof(APoolableGlass, StaticMesh) == 0x000288, "Member 'APoolableGlass::StaticMesh' has a wrong offset!");
static_assert(offsetof(APoolableGlass, TimeToSleep) == 0x000298, "Member 'APoolableGlass::TimeToSleep' has a wrong offset!");
static_assert(offsetof(APoolableGlass, GlassHit) == 0x0002A0, "Member 'APoolableGlass::GlassHit' has a wrong offset!");

// Class ThankYouVeryCool.PoolInterface
// 0x0000 (0x0028 - 0x0028)
class IPoolInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolInterface">();
	}
	static class IPoolInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPoolInterface>();
	}
};
static_assert(alignof(IPoolInterface) == 0x000008, "Wrong alignment on IPoolInterface");
static_assert(sizeof(IPoolInterface) == 0x000028, "Wrong size on IPoolInterface");

// Class ThankYouVeryCool.PoolManager
// 0x00F8 (0x0318 - 0x0220)
class APoolManager : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class APoolableActor>, uint32> PooledActorsToSpawn;                               // 0x0228(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class UClass*, struct FPooledList>       PooledActors;                                      // 0x0278(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class UClass*, class UTYVCHISMComponent*> ProxyMap;                                          // 0x02C8(0x0050)(Edit, ExportObject, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	class UObject* GetPooledActorBP(TSubclassOf<class APoolableActor> InClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolManager">();
	}
	static class APoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoolManager>();
	}
};
static_assert(alignof(APoolManager) == 0x000008, "Wrong alignment on APoolManager");
static_assert(sizeof(APoolManager) == 0x000318, "Wrong size on APoolManager");
static_assert(offsetof(APoolManager, RootComp) == 0x000220, "Member 'APoolManager::RootComp' has a wrong offset!");
static_assert(offsetof(APoolManager, PooledActorsToSpawn) == 0x000228, "Member 'APoolManager::PooledActorsToSpawn' has a wrong offset!");
static_assert(offsetof(APoolManager, PooledActors) == 0x000278, "Member 'APoolManager::PooledActors' has a wrong offset!");
static_assert(offsetof(APoolManager, ProxyMap) == 0x0002C8, "Member 'APoolManager::ProxyMap' has a wrong offset!");

// Class ThankYouVeryCool.PreviewInterface
// 0x0000 (0x0028 - 0x0028)
class IPreviewInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewInterface">();
	}
	static class IPreviewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPreviewInterface>();
	}
};
static_assert(alignof(IPreviewInterface) == 0x000008, "Wrong alignment on IPreviewInterface");
static_assert(sizeof(IPreviewInterface) == 0x000028, "Wrong size on IPreviewInterface");

// Class ThankYouVeryCool.PrimaryVoxelWorld
// 0x0020 (0x0898 - 0x0878)
class APrimaryVoxelWorld final : public AVoxelWorld
{
public:
	bool                                          bIsCave;                                           // 0x0878(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_879[0x3];                                      // 0x0879(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelIntBox                           BoxBounds;                                         // 0x087C(0x0018)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelMaterial                                BoundsMaterial;                                    // 0x0894(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_895[0x3];                                      // 0x0895(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrimaryVoxelWorld">();
	}
	static class APrimaryVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<APrimaryVoxelWorld>();
	}
};
static_assert(alignof(APrimaryVoxelWorld) == 0x000008, "Wrong alignment on APrimaryVoxelWorld");
static_assert(sizeof(APrimaryVoxelWorld) == 0x000898, "Wrong size on APrimaryVoxelWorld");
static_assert(offsetof(APrimaryVoxelWorld, bIsCave) == 0x000878, "Member 'APrimaryVoxelWorld::bIsCave' has a wrong offset!");
static_assert(offsetof(APrimaryVoxelWorld, BoxBounds) == 0x00087C, "Member 'APrimaryVoxelWorld::BoxBounds' has a wrong offset!");
static_assert(offsetof(APrimaryVoxelWorld, BoundsMaterial) == 0x000894, "Member 'APrimaryVoxelWorld::BoundsMaterial' has a wrong offset!");

// Class ThankYouVeryCool.PropVoxelWorld
// 0x0198 (0x0A10 - 0x0878)
class APropVoxelWorld : public AVoxelWorld
{
public:
	uint8                                         Pad_878[0x19];                                     // 0x0878(0x0019)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOverrideBase;                                     // 0x0891(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoVoxelPhysics;                                   // 0x0892(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyPlayerCanDamage;                              // 0x0893(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGravThrown;                                     // 0x0894(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_895[0x20];                                     // 0x0895(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsGravGrabbed;                                    // 0x08B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B6[0x2];                                      // 0x08B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MyDataAsset;                                       // 0x08B8(0x0008)(Edit, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         SimpleShatter;                                     // 0x08C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCampaignOnly;                                     // 0x08C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C9[0x7];                                      // 0x08C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           ProjMoveComp;                                      // 0x08D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldCacheShatter;                               // 0x08D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D9[0x3];                                      // 0x08D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FractureDriftChance;                               // 0x08DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDeleteOnReset;                               // 0x08E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoor;                                           // 0x08E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E2[0x2];                                      // 0x08E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MyGUID;                                            // 0x08E4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTYVCIsDirty;                                      // 0x08F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F5[0xB];                                      // 0x08F5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollCooldownTime;                               // 0x0900(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialOverride;                                  // 0x0904(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideData;                                     // 0x0908(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_909[0x3];                                      // 0x0909(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MyCustomGUID;                                      // 0x090C(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCustomProp;                                     // 0x091C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91D[0x3];                                      // 0x091D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstance*                      ExtraExplosiveMat;                                 // 0x0920(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsExplosiveSubclass;                              // 0x0928(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPreview;                                        // 0x0929(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasPhysicsRoot;                                   // 0x092A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanShatter;                                       // 0x092B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoCnEdit;                                         // 0x092C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanExplode;                                       // 0x092D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInvuln;                                         // 0x092E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasManualShatter;                                 // 0x092F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyManuallyShatter;                              // 0x0930(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseIndexOverride;                                 // 0x0931(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_932[0x2];                                      // 0x0932(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShatterAngularForce;                               // 0x0934(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HP;                                                // 0x0938(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingHP;                                        // 0x093C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FractureDepth;                                     // 0x0940(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelPhysicsType                             MyPhysicsType;                                     // 0x0944(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_945[0x3];                                      // 0x0945(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CampaignID;                                        // 0x0948(0x0008)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveToID;                                          // 0x0950(0x0008)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           MoveToIDList;                                      // 0x0958(0x0010)(BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	float                                         MoveToSpeed;                                       // 0x0968(0x0004)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInteractable;                                   // 0x096C(0x0001)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanTip;                                           // 0x096D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLinearMove;                                       // 0x096E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighResolution;                                   // 0x096F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicTexture*                        MyExplosionTexture;                                // 0x0970(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_978[0x8];                                      // 0x0978(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UVoxelProceduralMeshComponent> HighlightedCompClass;                              // 0x0980(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UVoxelProceduralMeshComponent> NonHighlightedCompClass;                           // 0x0988(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class APropVoxelWorld*>                MyCachedChunks;                                    // 0x0990(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnMoveFinish;                                      // 0x09A0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	EPlayerInteractionType                        MyInteractionType;                                 // 0x09B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B1[0x7];                                      // 0x09B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x09B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HomingTarget;                                      // 0x09C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicalMaterial*                      SlidingPhysMat;                                    // 0x09C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotateSpeed;                                       // 0x09D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldMoveOnStart;                                // 0x09DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPropMoveStyle                                MoveStyle;                                         // 0x09DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldMove;                                       // 0x09DE(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9DF[0x1];                                      // 0x09DF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 MyPivotActor;                                      // 0x09E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     PivotActorClass;                                   // 0x09E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ShatterSound;                                      // 0x09F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAction>                        ActionsIndependent;                                // 0x09F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A08[0x1];                                      // 0x0A08(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFaceDirectionOfMovement;                          // 0x0A09(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartHidden;                                      // 0x0A0A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0B[0x5];                                      // 0x0A0B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplySelfToData();
	void Bounced(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void CacheShatteredChunks();
	bool CanCannonEdit();
	void CancelMoves();
	void DoMove(const struct FVector& RelativeMove, float TimeToMove);
	void DoMyActions();
	void DoShake();
	void DoShatter(const struct FVector& ShatterOrigin);
	void EditorModeChanged_Implementation(EEditMode NewMode);
	void Explode();
	void HitByWidePulse();
	void HomeOnTarget(class AActor* Target);
	void ImpulseIfPossible(const struct FVector& Impulse);
	void InterpRelative(const struct FVector& RelativeMove, float TimeToMove, TDelegate<void()> WhenDone);
	void LevelReady();
	void MoveDone();
	void Olap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSpawnedAtRuntime();
	void OnThrownHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnThrownStop(const struct FHitResult& ImpactResult);
	void ProcGenFractureLines();
	void RecreateRenderDelayed();
	void RemoveCompass();
	void RequestNavmeshUpdate();
	void SetCanTip(bool bInCanTip);
	void SetExplosionInfo(float EditRadius, float ShockwaveRadius);
	void SetHighlightedGrav(bool bHighlighted);
	void SetHighlightedHUD(bool bHighlighted);
	void SetHighRez(bool bIsHiRez);
	void SetLODEnabled(bool bInEnabled);
	void SetPlayerInteractionType(EPlayerInteractionType InType);
	void SetShake(bool bSet);
	void SetShouldMove(bool bInShouldMove);
	void TargetHomeSuccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropVoxelWorld">();
	}
	static class APropVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropVoxelWorld>();
	}
};
static_assert(alignof(APropVoxelWorld) == 0x000008, "Wrong alignment on APropVoxelWorld");
static_assert(sizeof(APropVoxelWorld) == 0x000A10, "Wrong size on APropVoxelWorld");
static_assert(offsetof(APropVoxelWorld, bOverrideBase) == 0x000891, "Member 'APropVoxelWorld::bOverrideBase' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bNoVoxelPhysics) == 0x000892, "Member 'APropVoxelWorld::bNoVoxelPhysics' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bOnlyPlayerCanDamage) == 0x000893, "Member 'APropVoxelWorld::bOnlyPlayerCanDamage' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bIsGravThrown) == 0x000894, "Member 'APropVoxelWorld::bIsGravThrown' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bIsGravGrabbed) == 0x0008B5, "Member 'APropVoxelWorld::bIsGravGrabbed' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MyDataAsset) == 0x0008B8, "Member 'APropVoxelWorld::MyDataAsset' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, SimpleShatter) == 0x0008C0, "Member 'APropVoxelWorld::SimpleShatter' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bCampaignOnly) == 0x0008C8, "Member 'APropVoxelWorld::bCampaignOnly' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, ProjMoveComp) == 0x0008D0, "Member 'APropVoxelWorld::ProjMoveComp' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bShouldCacheShatter) == 0x0008D8, "Member 'APropVoxelWorld::bShouldCacheShatter' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, FractureDriftChance) == 0x0008DC, "Member 'APropVoxelWorld::FractureDriftChance' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bForceDeleteOnReset) == 0x0008E0, "Member 'APropVoxelWorld::bForceDeleteOnReset' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bIsDoor) == 0x0008E1, "Member 'APropVoxelWorld::bIsDoor' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MyGUID) == 0x0008E4, "Member 'APropVoxelWorld::MyGUID' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bTYVCIsDirty) == 0x0008F4, "Member 'APropVoxelWorld::bTYVCIsDirty' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, RagdollCooldownTime) == 0x000900, "Member 'APropVoxelWorld::RagdollCooldownTime' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MaterialOverride) == 0x000904, "Member 'APropVoxelWorld::MaterialOverride' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bOverrideData) == 0x000908, "Member 'APropVoxelWorld::bOverrideData' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MyCustomGUID) == 0x00090C, "Member 'APropVoxelWorld::MyCustomGUID' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bIsCustomProp) == 0x00091C, "Member 'APropVoxelWorld::bIsCustomProp' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, ExtraExplosiveMat) == 0x000920, "Member 'APropVoxelWorld::ExtraExplosiveMat' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bIsExplosiveSubclass) == 0x000928, "Member 'APropVoxelWorld::bIsExplosiveSubclass' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bIsPreview) == 0x000929, "Member 'APropVoxelWorld::bIsPreview' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bHasPhysicsRoot) == 0x00092A, "Member 'APropVoxelWorld::bHasPhysicsRoot' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bCanShatter) == 0x00092B, "Member 'APropVoxelWorld::bCanShatter' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bNoCnEdit) == 0x00092C, "Member 'APropVoxelWorld::bNoCnEdit' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bCanExplode) == 0x00092D, "Member 'APropVoxelWorld::bCanExplode' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bIsInvuln) == 0x00092E, "Member 'APropVoxelWorld::bIsInvuln' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bHasManualShatter) == 0x00092F, "Member 'APropVoxelWorld::bHasManualShatter' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bOnlyManuallyShatter) == 0x000930, "Member 'APropVoxelWorld::bOnlyManuallyShatter' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bUseIndexOverride) == 0x000931, "Member 'APropVoxelWorld::bUseIndexOverride' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, ShatterAngularForce) == 0x000934, "Member 'APropVoxelWorld::ShatterAngularForce' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, HP) == 0x000938, "Member 'APropVoxelWorld::HP' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, StartingHP) == 0x00093C, "Member 'APropVoxelWorld::StartingHP' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, FractureDepth) == 0x000940, "Member 'APropVoxelWorld::FractureDepth' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MyPhysicsType) == 0x000944, "Member 'APropVoxelWorld::MyPhysicsType' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, CampaignID) == 0x000948, "Member 'APropVoxelWorld::CampaignID' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MoveToID) == 0x000950, "Member 'APropVoxelWorld::MoveToID' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MoveToIDList) == 0x000958, "Member 'APropVoxelWorld::MoveToIDList' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MoveToSpeed) == 0x000968, "Member 'APropVoxelWorld::MoveToSpeed' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bIsInteractable) == 0x00096C, "Member 'APropVoxelWorld::bIsInteractable' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bCanTip) == 0x00096D, "Member 'APropVoxelWorld::bCanTip' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bLinearMove) == 0x00096E, "Member 'APropVoxelWorld::bLinearMove' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bHighResolution) == 0x00096F, "Member 'APropVoxelWorld::bHighResolution' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MyExplosionTexture) == 0x000970, "Member 'APropVoxelWorld::MyExplosionTexture' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, HighlightedCompClass) == 0x000980, "Member 'APropVoxelWorld::HighlightedCompClass' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, NonHighlightedCompClass) == 0x000988, "Member 'APropVoxelWorld::NonHighlightedCompClass' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MyCachedChunks) == 0x000990, "Member 'APropVoxelWorld::MyCachedChunks' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, OnMoveFinish) == 0x0009A0, "Member 'APropVoxelWorld::OnMoveFinish' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MyInteractionType) == 0x0009B0, "Member 'APropVoxelWorld::MyInteractionType' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, TYVCGameMode) == 0x0009B8, "Member 'APropVoxelWorld::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, HomingTarget) == 0x0009C0, "Member 'APropVoxelWorld::HomingTarget' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, SlidingPhysMat) == 0x0009C8, "Member 'APropVoxelWorld::SlidingPhysMat' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, RotateSpeed) == 0x0009D0, "Member 'APropVoxelWorld::RotateSpeed' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bShouldMoveOnStart) == 0x0009DC, "Member 'APropVoxelWorld::bShouldMoveOnStart' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MoveStyle) == 0x0009DD, "Member 'APropVoxelWorld::MoveStyle' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bShouldMove) == 0x0009DE, "Member 'APropVoxelWorld::bShouldMove' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, MyPivotActor) == 0x0009E0, "Member 'APropVoxelWorld::MyPivotActor' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, PivotActorClass) == 0x0009E8, "Member 'APropVoxelWorld::PivotActorClass' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, ShatterSound) == 0x0009F0, "Member 'APropVoxelWorld::ShatterSound' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, ActionsIndependent) == 0x0009F8, "Member 'APropVoxelWorld::ActionsIndependent' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bFaceDirectionOfMovement) == 0x000A09, "Member 'APropVoxelWorld::bFaceDirectionOfMovement' has a wrong offset!");
static_assert(offsetof(APropVoxelWorld, bStartHidden) == 0x000A0A, "Member 'APropVoxelWorld::bStartHidden' has a wrong offset!");

// Class ThankYouVeryCool.PropVoxelWorld_Lift
// 0x0010 (0x0A20 - 0x0A10)
class APropVoxelWorld_Lift final : public APropVoxelWorld
{
public:
	TArray<struct FTransform>                     CallLocations;                                     // 0x0A10(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropVoxelWorld_Lift">();
	}
	static class APropVoxelWorld_Lift* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropVoxelWorld_Lift>();
	}
};
static_assert(alignof(APropVoxelWorld_Lift) == 0x000008, "Wrong alignment on APropVoxelWorld_Lift");
static_assert(sizeof(APropVoxelWorld_Lift) == 0x000A20, "Wrong size on APropVoxelWorld_Lift");
static_assert(offsetof(APropVoxelWorld_Lift, CallLocations) == 0x000A10, "Member 'APropVoxelWorld_Lift::CallLocations' has a wrong offset!");

// Class ThankYouVeryCool.QuadHP
// 0x0008 (0x0070 - 0x0068)
class UQuadHP final : public UBTDecorator
{
public:
	float                                         BeAboveThis;                                       // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuadHP">();
	}
	static class UQuadHP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuadHP>();
	}
};
static_assert(alignof(UQuadHP) == 0x000008, "Wrong alignment on UQuadHP");
static_assert(sizeof(UQuadHP) == 0x000070, "Wrong size on UQuadHP");
static_assert(offsetof(UQuadHP, BeAboveThis) == 0x000068, "Member 'UQuadHP::BeAboveThis' has a wrong offset!");

// Class ThankYouVeryCool.RichTextControlDecorator
// 0x0010 (0x0038 - 0x0028)
class URichTextControlDecorator : public URichTextBlockDecorator
{
public:
	TArray<struct FSlateBrush>                    MyBrush;                                           // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextControlDecorator">();
	}
	static class URichTextControlDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextControlDecorator>();
	}
};
static_assert(alignof(URichTextControlDecorator) == 0x000008, "Wrong alignment on URichTextControlDecorator");
static_assert(sizeof(URichTextControlDecorator) == 0x000038, "Wrong size on URichTextControlDecorator");
static_assert(offsetof(URichTextControlDecorator, MyBrush) == 0x000028, "Member 'URichTextControlDecorator::MyBrush' has a wrong offset!");

// Class ThankYouVeryCool.RogueManager
// 0x0388 (0x05A8 - 0x0220)
class ARogueManager : public AActor
{
public:
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERogueState                                   RogueState;                                        // 0x0228(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRogueLevelScore                       CurrentLevelScore;                                 // 0x022C(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CurrentRunScore;                                   // 0x0244(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalPreRunScore;                                  // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                PostLevelCompleteScreenClass;                      // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                RunCompleteClass;                                  // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                RunStartClass;                                     // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                RunContinueClass;                                  // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            PostLevelCompleteScreen;                           // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRogueLevel>                    LevelPoolT1;                                       // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRogueLevel>                    LevelPoolT2;                                       // 0x0288(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRogueLevel>                    LevelPoolT3;                                       // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRogueLevel>                    LevelPoolRogueOnly;                                // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x40];                                     // 0x02B8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCardData*>                      DeckT1;                                            // 0x02F8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      DeckT2;                                            // 0x0308(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      DeckT3;                                            // 0x0318(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      EdensysDeck;                                       // 0x0328(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      WeaponsDeck;                                       // 0x0338(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT1A;                                      // 0x0348(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT1B;                                      // 0x0358(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT1C;                                      // 0x0368(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT2A;                                      // 0x0378(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT2B;                                      // 0x0388(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT2C;                                      // 0x0398(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT3A;                                      // 0x03A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT3B;                                      // 0x03B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitDeckT3C;                                      // 0x03C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      EdensysDeckCached;                                 // 0x03D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      EdensysDeckCachedUncollected;                      // 0x03E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class AChapter>                   FirefightChapter;                                  // 0x03F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceArcade;                                      // 0x0400(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UTexture>>        LevelHistory;                                      // 0x0408(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bFlattenDecks;                                     // 0x0418(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCardData*>                      FlatDeck;                                          // 0x0420(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitFlatDeckA;                                    // 0x0430(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitFlatDeckB;                                    // 0x0440(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      SplitFlatDeckC;                                    // 0x0450(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FRogueLevel                            NextLevel;                                         // 0x0460(0x0010)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x1];                                      // 0x0470(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLastWasArcade;                                    // 0x0471(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_472[0x6];                                      // 0x0472(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCardData*>                      Hand;                                              // 0x0478(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                DefaultSpawnWeapon;                                // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                SpawnWeapon;                                       // 0x0490(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECannonMode                                   SpawnCannon;                                       // 0x0498(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0xB];                                      // 0x0499(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelStreak;                                       // 0x04A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxLuck;                                           // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCHPBoost;                                        // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                PlayerDiedWidgetClass;                             // 0x04B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            PlayerDiedWidget;                                  // 0x04B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRun;                                            // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreThisLevel;                                    // 0x04C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceLevel;                                       // 0x04C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRogueLevel                            ForcedLevel;                                       // 0x04D0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         TripleThreatThreshold;                             // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           DebugCollection;                                   // 0x04E8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F8[0x8];                                      // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCardData*>                      RecentlyUnlockedCards;                             // 0x0500(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<int32>                                 EdensysDrawIntervals;                              // 0x0510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ENPCType, struct FWeaponPool>            PoolOverrides;                                     // 0x0520(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UCardData*>                      DebugStartingCards;                                // 0x0570(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         Lives;                                             // 0x0580(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_584[0x4];                                      // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             JacketsDataTable;                                  // 0x0588(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CannonsDataTable;                                  // 0x0590(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ObjectivesBonus;                                   // 0x0598(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MoltenBonus;                                       // 0x059C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PermaBonus;                                        // 0x05A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CardSelected(class UCardData* InCard);
	void CheckNewCannon(int32 OldScore, int32 NewScore, bool* bFoundNew, int32* TilNext);
	void CheckNewJacket(int32 OldScore, int32 NewScore, bool* bFoundNew, int32* TilNext);
	void Continue();
	TArray<class UCardData*> DrawCards(int32 Count, int32 Tier);
	class UCardData* DrawEdensysCard();
	float GetCachedMultiplier();
	int32 GetCurrentCardsTier();
	void GetNextLevelInfo(TSoftObjectPtr<class UTexture>* LevelScreen, class FText* Name_0, bool* bIsArcade);
	bool HasCardBeenCollected(class UCardData* Card);
	bool HasSoftCardBeenCollected(TSoftClassPtr<class UClass> Card);
	bool IsCannonUnlocked(class FName RowName, int32 ForScore, int32* OutScore);
	bool IsJacketUnlocked(class FName RowName, int32 ForScore, int32* OutAtLevel);
	void NextLevelRequested();
	void Play(class UCardData* StartingCard);
	void PlayerRequestTryAgain();
	void PrepareForForcedMainMenu();
	void StupidAsyncCallback(const struct FRogueLevel& MP);
	void StupidAsyncCallbackForFF(TSubclassOf<class UArcadeLevelAsset> ClassIn, class AChapter* InC, class UCampaignDataAsset* CDA, class ULevelEditorSave* LoadedSave);
	void StupidAsyncLoadHack(const TSoftClassPtr<class UClass>& ClassIn, const struct FRogueLevel& MP);
	void StupidAsyncLoadHackForFirefight(TSubclassOf<class UArcadeLevelAsset> ClassIn, class AChapter* InC, class UCampaignDataAsset* CDA);

	int32 GetCollectedCards() const;
	int32 GetTotalCards() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RogueManager">();
	}
	static class ARogueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARogueManager>();
	}
};
static_assert(alignof(ARogueManager) == 0x000008, "Wrong alignment on ARogueManager");
static_assert(sizeof(ARogueManager) == 0x0005A8, "Wrong size on ARogueManager");
static_assert(offsetof(ARogueManager, TYVCGameMode) == 0x000220, "Member 'ARogueManager::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ARogueManager, RogueState) == 0x000228, "Member 'ARogueManager::RogueState' has a wrong offset!");
static_assert(offsetof(ARogueManager, CurrentLevelScore) == 0x00022C, "Member 'ARogueManager::CurrentLevelScore' has a wrong offset!");
static_assert(offsetof(ARogueManager, CurrentRunScore) == 0x000244, "Member 'ARogueManager::CurrentRunScore' has a wrong offset!");
static_assert(offsetof(ARogueManager, TotalPreRunScore) == 0x000248, "Member 'ARogueManager::TotalPreRunScore' has a wrong offset!");
static_assert(offsetof(ARogueManager, PostLevelCompleteScreenClass) == 0x000250, "Member 'ARogueManager::PostLevelCompleteScreenClass' has a wrong offset!");
static_assert(offsetof(ARogueManager, RunCompleteClass) == 0x000258, "Member 'ARogueManager::RunCompleteClass' has a wrong offset!");
static_assert(offsetof(ARogueManager, RunStartClass) == 0x000260, "Member 'ARogueManager::RunStartClass' has a wrong offset!");
static_assert(offsetof(ARogueManager, RunContinueClass) == 0x000268, "Member 'ARogueManager::RunContinueClass' has a wrong offset!");
static_assert(offsetof(ARogueManager, PostLevelCompleteScreen) == 0x000270, "Member 'ARogueManager::PostLevelCompleteScreen' has a wrong offset!");
static_assert(offsetof(ARogueManager, LevelPoolT1) == 0x000278, "Member 'ARogueManager::LevelPoolT1' has a wrong offset!");
static_assert(offsetof(ARogueManager, LevelPoolT2) == 0x000288, "Member 'ARogueManager::LevelPoolT2' has a wrong offset!");
static_assert(offsetof(ARogueManager, LevelPoolT3) == 0x000298, "Member 'ARogueManager::LevelPoolT3' has a wrong offset!");
static_assert(offsetof(ARogueManager, LevelPoolRogueOnly) == 0x0002A8, "Member 'ARogueManager::LevelPoolRogueOnly' has a wrong offset!");
static_assert(offsetof(ARogueManager, DeckT1) == 0x0002F8, "Member 'ARogueManager::DeckT1' has a wrong offset!");
static_assert(offsetof(ARogueManager, DeckT2) == 0x000308, "Member 'ARogueManager::DeckT2' has a wrong offset!");
static_assert(offsetof(ARogueManager, DeckT3) == 0x000318, "Member 'ARogueManager::DeckT3' has a wrong offset!");
static_assert(offsetof(ARogueManager, EdensysDeck) == 0x000328, "Member 'ARogueManager::EdensysDeck' has a wrong offset!");
static_assert(offsetof(ARogueManager, WeaponsDeck) == 0x000338, "Member 'ARogueManager::WeaponsDeck' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT1A) == 0x000348, "Member 'ARogueManager::SplitDeckT1A' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT1B) == 0x000358, "Member 'ARogueManager::SplitDeckT1B' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT1C) == 0x000368, "Member 'ARogueManager::SplitDeckT1C' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT2A) == 0x000378, "Member 'ARogueManager::SplitDeckT2A' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT2B) == 0x000388, "Member 'ARogueManager::SplitDeckT2B' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT2C) == 0x000398, "Member 'ARogueManager::SplitDeckT2C' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT3A) == 0x0003A8, "Member 'ARogueManager::SplitDeckT3A' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT3B) == 0x0003B8, "Member 'ARogueManager::SplitDeckT3B' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitDeckT3C) == 0x0003C8, "Member 'ARogueManager::SplitDeckT3C' has a wrong offset!");
static_assert(offsetof(ARogueManager, EdensysDeckCached) == 0x0003D8, "Member 'ARogueManager::EdensysDeckCached' has a wrong offset!");
static_assert(offsetof(ARogueManager, EdensysDeckCachedUncollected) == 0x0003E8, "Member 'ARogueManager::EdensysDeckCachedUncollected' has a wrong offset!");
static_assert(offsetof(ARogueManager, FirefightChapter) == 0x0003F8, "Member 'ARogueManager::FirefightChapter' has a wrong offset!");
static_assert(offsetof(ARogueManager, bForceArcade) == 0x000400, "Member 'ARogueManager::bForceArcade' has a wrong offset!");
static_assert(offsetof(ARogueManager, LevelHistory) == 0x000408, "Member 'ARogueManager::LevelHistory' has a wrong offset!");
static_assert(offsetof(ARogueManager, bFlattenDecks) == 0x000418, "Member 'ARogueManager::bFlattenDecks' has a wrong offset!");
static_assert(offsetof(ARogueManager, FlatDeck) == 0x000420, "Member 'ARogueManager::FlatDeck' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitFlatDeckA) == 0x000430, "Member 'ARogueManager::SplitFlatDeckA' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitFlatDeckB) == 0x000440, "Member 'ARogueManager::SplitFlatDeckB' has a wrong offset!");
static_assert(offsetof(ARogueManager, SplitFlatDeckC) == 0x000450, "Member 'ARogueManager::SplitFlatDeckC' has a wrong offset!");
static_assert(offsetof(ARogueManager, NextLevel) == 0x000460, "Member 'ARogueManager::NextLevel' has a wrong offset!");
static_assert(offsetof(ARogueManager, bLastWasArcade) == 0x000471, "Member 'ARogueManager::bLastWasArcade' has a wrong offset!");
static_assert(offsetof(ARogueManager, Hand) == 0x000478, "Member 'ARogueManager::Hand' has a wrong offset!");
static_assert(offsetof(ARogueManager, DefaultSpawnWeapon) == 0x000488, "Member 'ARogueManager::DefaultSpawnWeapon' has a wrong offset!");
static_assert(offsetof(ARogueManager, SpawnWeapon) == 0x000490, "Member 'ARogueManager::SpawnWeapon' has a wrong offset!");
static_assert(offsetof(ARogueManager, SpawnCannon) == 0x000498, "Member 'ARogueManager::SpawnCannon' has a wrong offset!");
static_assert(offsetof(ARogueManager, LevelStreak) == 0x0004A4, "Member 'ARogueManager::LevelStreak' has a wrong offset!");
static_assert(offsetof(ARogueManager, MaxLuck) == 0x0004A8, "Member 'ARogueManager::MaxLuck' has a wrong offset!");
static_assert(offsetof(ARogueManager, NPCHPBoost) == 0x0004AC, "Member 'ARogueManager::NPCHPBoost' has a wrong offset!");
static_assert(offsetof(ARogueManager, PlayerDiedWidgetClass) == 0x0004B0, "Member 'ARogueManager::PlayerDiedWidgetClass' has a wrong offset!");
static_assert(offsetof(ARogueManager, PlayerDiedWidget) == 0x0004B8, "Member 'ARogueManager::PlayerDiedWidget' has a wrong offset!");
static_assert(offsetof(ARogueManager, MaxRun) == 0x0004C0, "Member 'ARogueManager::MaxRun' has a wrong offset!");
static_assert(offsetof(ARogueManager, ScoreThisLevel) == 0x0004C4, "Member 'ARogueManager::ScoreThisLevel' has a wrong offset!");
static_assert(offsetof(ARogueManager, bForceLevel) == 0x0004C8, "Member 'ARogueManager::bForceLevel' has a wrong offset!");
static_assert(offsetof(ARogueManager, ForcedLevel) == 0x0004D0, "Member 'ARogueManager::ForcedLevel' has a wrong offset!");
static_assert(offsetof(ARogueManager, TripleThreatThreshold) == 0x0004E0, "Member 'ARogueManager::TripleThreatThreshold' has a wrong offset!");
static_assert(offsetof(ARogueManager, DebugCollection) == 0x0004E8, "Member 'ARogueManager::DebugCollection' has a wrong offset!");
static_assert(offsetof(ARogueManager, RecentlyUnlockedCards) == 0x000500, "Member 'ARogueManager::RecentlyUnlockedCards' has a wrong offset!");
static_assert(offsetof(ARogueManager, EdensysDrawIntervals) == 0x000510, "Member 'ARogueManager::EdensysDrawIntervals' has a wrong offset!");
static_assert(offsetof(ARogueManager, PoolOverrides) == 0x000520, "Member 'ARogueManager::PoolOverrides' has a wrong offset!");
static_assert(offsetof(ARogueManager, DebugStartingCards) == 0x000570, "Member 'ARogueManager::DebugStartingCards' has a wrong offset!");
static_assert(offsetof(ARogueManager, Lives) == 0x000580, "Member 'ARogueManager::Lives' has a wrong offset!");
static_assert(offsetof(ARogueManager, JacketsDataTable) == 0x000588, "Member 'ARogueManager::JacketsDataTable' has a wrong offset!");
static_assert(offsetof(ARogueManager, CannonsDataTable) == 0x000590, "Member 'ARogueManager::CannonsDataTable' has a wrong offset!");
static_assert(offsetof(ARogueManager, ObjectivesBonus) == 0x000598, "Member 'ARogueManager::ObjectivesBonus' has a wrong offset!");
static_assert(offsetof(ARogueManager, MoltenBonus) == 0x00059C, "Member 'ARogueManager::MoltenBonus' has a wrong offset!");
static_assert(offsetof(ARogueManager, PermaBonus) == 0x0005A0, "Member 'ARogueManager::PermaBonus' has a wrong offset!");

// Class ThankYouVeryCool.VoxelBodyPart
// 0x0008 (0x0880 - 0x0878)
class AVoxelBodyPart final : public AVoxelWorld
{
public:
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBodyPart">();
	}
	static class AVoxelBodyPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelBodyPart>();
	}
};
static_assert(alignof(AVoxelBodyPart) == 0x000008, "Wrong alignment on AVoxelBodyPart");
static_assert(sizeof(AVoxelBodyPart) == 0x000880, "Wrong size on AVoxelBodyPart");

// Class ThankYouVeryCool.ServerBuilder
// 0x0050 (0x0A68 - 0x0A18)
class AServerBuilder final : public AVoxelBuilder2
{
public:
	class UVoxelDataAsset*                        OuterMaterial;                                     // 0x0A18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVoxelDataAsset*                        InnerMaterial;                                     // 0x0A20(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UVoxelDataAsset*>                LightMaterials;                                    // 0x0A28(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATYVCLight>                 LightClass;                                        // 0x0A38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FIntVector                             Dimensions;                                        // 0x0A40(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TrimWidth;                                         // 0x0A4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           LightColor;                                        // 0x0A50(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LightBrightness;                                   // 0x0A60(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A64[0x4];                                      // 0x0A64(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerBuilder">();
	}
	static class AServerBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AServerBuilder>();
	}
};
static_assert(alignof(AServerBuilder) == 0x000008, "Wrong alignment on AServerBuilder");
static_assert(sizeof(AServerBuilder) == 0x000A68, "Wrong size on AServerBuilder");
static_assert(offsetof(AServerBuilder, OuterMaterial) == 0x000A18, "Member 'AServerBuilder::OuterMaterial' has a wrong offset!");
static_assert(offsetof(AServerBuilder, InnerMaterial) == 0x000A20, "Member 'AServerBuilder::InnerMaterial' has a wrong offset!");
static_assert(offsetof(AServerBuilder, LightMaterials) == 0x000A28, "Member 'AServerBuilder::LightMaterials' has a wrong offset!");
static_assert(offsetof(AServerBuilder, LightClass) == 0x000A38, "Member 'AServerBuilder::LightClass' has a wrong offset!");
static_assert(offsetof(AServerBuilder, Dimensions) == 0x000A40, "Member 'AServerBuilder::Dimensions' has a wrong offset!");
static_assert(offsetof(AServerBuilder, TrimWidth) == 0x000A4C, "Member 'AServerBuilder::TrimWidth' has a wrong offset!");
static_assert(offsetof(AServerBuilder, LightColor) == 0x000A50, "Member 'AServerBuilder::LightColor' has a wrong offset!");
static_assert(offsetof(AServerBuilder, LightBrightness) == 0x000A60, "Member 'AServerBuilder::LightBrightness' has a wrong offset!");

// Class ThankYouVeryCool.SettingsSave
// 0x01F8 (0x0220 - 0x0028)
class USettingsSave final : public USaveGame
{
public:
	struct FVisualSettings                        VisualSettings;                                    // 0x0028(0x0058)(NativeAccessSpecifierPublic)
	struct FControlSettings                       ControlSettings;                                   // 0x0080(0x000C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTYVCAudioSettings                     AudioSettings;                                     // 0x0090(0x0038)(NativeAccessSpecifierPublic)
	struct FGameSettings                          GameSettings;                                      // 0x00C8(0x0090)(NativeAccessSpecifierPublic)
	struct FControlSettingsGamepad                ControlSettingsGamepad;                            // 0x0158(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerInputMappings                   InputMappings;                                     // 0x0178(0x00A0)(NativeAccessSpecifierPublic)
	bool                                          bHasInputMappings;                                 // 0x0218(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsSave">();
	}
	static class USettingsSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsSave>();
	}
};
static_assert(alignof(USettingsSave) == 0x000008, "Wrong alignment on USettingsSave");
static_assert(sizeof(USettingsSave) == 0x000220, "Wrong size on USettingsSave");
static_assert(offsetof(USettingsSave, VisualSettings) == 0x000028, "Member 'USettingsSave::VisualSettings' has a wrong offset!");
static_assert(offsetof(USettingsSave, ControlSettings) == 0x000080, "Member 'USettingsSave::ControlSettings' has a wrong offset!");
static_assert(offsetof(USettingsSave, AudioSettings) == 0x000090, "Member 'USettingsSave::AudioSettings' has a wrong offset!");
static_assert(offsetof(USettingsSave, GameSettings) == 0x0000C8, "Member 'USettingsSave::GameSettings' has a wrong offset!");
static_assert(offsetof(USettingsSave, ControlSettingsGamepad) == 0x000158, "Member 'USettingsSave::ControlSettingsGamepad' has a wrong offset!");
static_assert(offsetof(USettingsSave, InputMappings) == 0x000178, "Member 'USettingsSave::InputMappings' has a wrong offset!");
static_assert(offsetof(USettingsSave, bHasInputMappings) == 0x000218, "Member 'USettingsSave::bHasInputMappings' has a wrong offset!");

// Class ThankYouVeryCool.RogueSave
// 0x00B8 (0x00E0 - 0x0028)
class URogueSave final : public USaveGame
{
public:
	int32                                         Score;                                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighScore;                                         // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MyAverageRun;                                      // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           CollectedCards;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FRogueConfig                           RogueConfig;                                       // 0x0048(0x0009)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SelectedJacket;                                    // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectedCannonSkin;                                // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RunsCompleted;                                     // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRogueProgressSave                     LastRogueProgress;                                 // 0x0068(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RogueSave">();
	}
	static class URogueSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<URogueSave>();
	}
};
static_assert(alignof(URogueSave) == 0x000008, "Wrong alignment on URogueSave");
static_assert(sizeof(URogueSave) == 0x0000E0, "Wrong size on URogueSave");
static_assert(offsetof(URogueSave, Score) == 0x000028, "Member 'URogueSave::Score' has a wrong offset!");
static_assert(offsetof(URogueSave, HighScore) == 0x00002C, "Member 'URogueSave::HighScore' has a wrong offset!");
static_assert(offsetof(URogueSave, MyAverageRun) == 0x000030, "Member 'URogueSave::MyAverageRun' has a wrong offset!");
static_assert(offsetof(URogueSave, CollectedCards) == 0x000038, "Member 'URogueSave::CollectedCards' has a wrong offset!");
static_assert(offsetof(URogueSave, RogueConfig) == 0x000048, "Member 'URogueSave::RogueConfig' has a wrong offset!");
static_assert(offsetof(URogueSave, SelectedJacket) == 0x000054, "Member 'URogueSave::SelectedJacket' has a wrong offset!");
static_assert(offsetof(URogueSave, SelectedCannonSkin) == 0x00005C, "Member 'URogueSave::SelectedCannonSkin' has a wrong offset!");
static_assert(offsetof(URogueSave, RunsCompleted) == 0x000064, "Member 'URogueSave::RunsCompleted' has a wrong offset!");
static_assert(offsetof(URogueSave, LastRogueProgress) == 0x000068, "Member 'URogueSave::LastRogueProgress' has a wrong offset!");

// Class ThankYouVeryCool.ShearVoxelWorld
// 0x0010 (0x0888 - 0x0878)
class AShearVoxelWorld final : public AVoxelWorld
{
public:
	uint8                                         Pad_878[0x10];                                     // 0x0878(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShearVoxelWorld">();
	}
	static class AShearVoxelWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShearVoxelWorld>();
	}
};
static_assert(alignof(AShearVoxelWorld) == 0x000008, "Wrong alignment on AShearVoxelWorld");
static_assert(sizeof(AShearVoxelWorld) == 0x000888, "Wrong size on AShearVoxelWorld");

// Class ThankYouVeryCool.VoxelWorldManager
// 0x0050 (0x0270 - 0x0220)
class AVoxelWorldManager final : public AActor
{
public:
	TMulticastInlineDelegate<void(const struct FVoxelUncompressedWorldSave& OutSave)> SavingDone;                                        // 0x0220(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APrimaryVoxelWorld*                     PrimaryVoxelWorld;                                 // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            CaveVoxelWorld;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               LUT;                                               // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LUTStrength;                                       // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATriggerVolume*>                 FreezeVolumes;                                     // 0x0258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class AVoxelWorld*                            FoamWorld;                                         // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClearAll();
	void GetWorldSave();
	void SetupLevel();
	void UpdateAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelWorldManager">();
	}
	static class AVoxelWorldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelWorldManager>();
	}
};
static_assert(alignof(AVoxelWorldManager) == 0x000008, "Wrong alignment on AVoxelWorldManager");
static_assert(sizeof(AVoxelWorldManager) == 0x000270, "Wrong size on AVoxelWorldManager");
static_assert(offsetof(AVoxelWorldManager, SavingDone) == 0x000220, "Member 'AVoxelWorldManager::SavingDone' has a wrong offset!");
static_assert(offsetof(AVoxelWorldManager, LevelName) == 0x000230, "Member 'AVoxelWorldManager::LevelName' has a wrong offset!");
static_assert(offsetof(AVoxelWorldManager, PrimaryVoxelWorld) == 0x000238, "Member 'AVoxelWorldManager::PrimaryVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelWorldManager, CaveVoxelWorld) == 0x000240, "Member 'AVoxelWorldManager::CaveVoxelWorld' has a wrong offset!");
static_assert(offsetof(AVoxelWorldManager, LUT) == 0x000248, "Member 'AVoxelWorldManager::LUT' has a wrong offset!");
static_assert(offsetof(AVoxelWorldManager, LUTStrength) == 0x000250, "Member 'AVoxelWorldManager::LUTStrength' has a wrong offset!");
static_assert(offsetof(AVoxelWorldManager, FreezeVolumes) == 0x000258, "Member 'AVoxelWorldManager::FreezeVolumes' has a wrong offset!");
static_assert(offsetof(AVoxelWorldManager, FoamWorld) == 0x000268, "Member 'AVoxelWorldManager::FoamWorld' has a wrong offset!");

// Class ThankYouVeryCool.SkyscraperGen
// 0x0000 (0x0028 - 0x0028)
class USkyscraperGen final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkyscraperGen">();
	}
	static class USkyscraperGen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkyscraperGen>();
	}
};
static_assert(alignof(USkyscraperGen) == 0x000008, "Wrong alignment on USkyscraperGen");
static_assert(sizeof(USkyscraperGen) == 0x000028, "Wrong size on USkyscraperGen");

// Class ThankYouVeryCool.SlowMoProjectile
// 0x0038 (0x0258 - 0x0220)
class ASlowMoProjectile final : public AActor
{
public:
	class UStaticMeshComponent*                   BulletMesh;                                        // 0x0220(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       CollisionSphere;                                   // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProjectileMovementComponent*           ProjectileComponent;                               // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AImpactManager*                         ImpactManager;                                     // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EImpactType                                   Caliber;                                           // 0x0240(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Shooter;                                           // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      Trace;                                             // 0x0250(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ResolveAsRaycast();
	void ResolveImpact(const struct FHitResult& ImpactResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlowMoProjectile">();
	}
	static class ASlowMoProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlowMoProjectile>();
	}
};
static_assert(alignof(ASlowMoProjectile) == 0x000008, "Wrong alignment on ASlowMoProjectile");
static_assert(sizeof(ASlowMoProjectile) == 0x000258, "Wrong size on ASlowMoProjectile");
static_assert(offsetof(ASlowMoProjectile, BulletMesh) == 0x000220, "Member 'ASlowMoProjectile::BulletMesh' has a wrong offset!");
static_assert(offsetof(ASlowMoProjectile, CollisionSphere) == 0x000228, "Member 'ASlowMoProjectile::CollisionSphere' has a wrong offset!");
static_assert(offsetof(ASlowMoProjectile, ProjectileComponent) == 0x000230, "Member 'ASlowMoProjectile::ProjectileComponent' has a wrong offset!");
static_assert(offsetof(ASlowMoProjectile, ImpactManager) == 0x000238, "Member 'ASlowMoProjectile::ImpactManager' has a wrong offset!");
static_assert(offsetof(ASlowMoProjectile, Caliber) == 0x000240, "Member 'ASlowMoProjectile::Caliber' has a wrong offset!");
static_assert(offsetof(ASlowMoProjectile, Shooter) == 0x000248, "Member 'ASlowMoProjectile::Shooter' has a wrong offset!");
static_assert(offsetof(ASlowMoProjectile, Trace) == 0x000250, "Member 'ASlowMoProjectile::Trace' has a wrong offset!");

// Class ThankYouVeryCool.SpeechBubbleComponent
// 0x0000 (0x00B0 - 0x00B0)
class USpeechBubbleComponent final : public UActorComponent
{
public:
	void CallSay(const class FString& Dialogue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpeechBubbleComponent">();
	}
	static class USpeechBubbleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpeechBubbleComponent>();
	}
};
static_assert(alignof(USpeechBubbleComponent) == 0x000008, "Wrong alignment on USpeechBubbleComponent");
static_assert(sizeof(USpeechBubbleComponent) == 0x0000B0, "Wrong size on USpeechBubbleComponent");

// Class ThankYouVeryCool.SpeechComponent
// 0x0090 (0x08F0 - 0x0860)
class USpeechComponent : public UAudioComponent
{
public:
	TMap<class FName, struct FWord>               SoundMap;                                          // 0x0860(0x0050)(Edit, NativeAccessSpecifierPrivate)
	TArray<class USoundBase*>                     OuchieList;                                        // 0x08B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USoundBase*>                     DeathList;                                         // 0x08C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D0[0x20];                                     // 0x08D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpeechComponent">();
	}
	static class USpeechComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpeechComponent>();
	}
};
static_assert(alignof(USpeechComponent) == 0x000010, "Wrong alignment on USpeechComponent");
static_assert(sizeof(USpeechComponent) == 0x0008F0, "Wrong size on USpeechComponent");
static_assert(offsetof(USpeechComponent, SoundMap) == 0x000860, "Member 'USpeechComponent::SoundMap' has a wrong offset!");
static_assert(offsetof(USpeechComponent, OuchieList) == 0x0008B0, "Member 'USpeechComponent::OuchieList' has a wrong offset!");
static_assert(offsetof(USpeechComponent, DeathList) == 0x0008C0, "Member 'USpeechComponent::DeathList' has a wrong offset!");

// Class ThankYouVeryCool.WindowBuilder
// 0x00A8 (0x0AC0 - 0x0A18)
class AWindowBuilder final : public AVoxelBuilder2
{
public:
	int32                                         WindowCount;                                       // 0x0A18(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1C[0x4];                                      // 0x0A1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RectangleOffsetCurve;                              // 0x0A20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SquareOffsetCurve;                                 // 0x0A28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATYVCActor>                 SquareWindowClass;                                 // 0x0A30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATYVCActor>                 RectangleWindowClass;                              // 0x0A38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     WindowMaterial;                                    // 0x0A40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRectangleWindows;                                 // 0x0A48(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WindowsVerticallyOriented;                         // 0x0A49(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4A[0x2];                                      // 0x0A4A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        WindowHeight;                                      // 0x0A4C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        WindowPaneWidth;                                   // 0x0A50(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        WindowDepth;                                       // 0x0A54(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVoxelWorld                                   CutIntoWorld;                                      // 0x0A58(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A59[0x7];                                      // 0x0A59(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVoxelDataAsset*                        HoleMaterial;                                      // 0x0A60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVoxelDataAsset*                        PaneMaterial;                                      // 0x0A68(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ATYVCActor*>                     SpawnedWindows;                                    // 0x0A70(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     SpawnedWindowTransforms;                           // 0x0A80(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTransform                             WindowSpawnTransform;                              // 0x0A90(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WindowBuilder">();
	}
	static class AWindowBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindowBuilder>();
	}
};
static_assert(alignof(AWindowBuilder) == 0x000010, "Wrong alignment on AWindowBuilder");
static_assert(sizeof(AWindowBuilder) == 0x000AC0, "Wrong size on AWindowBuilder");
static_assert(offsetof(AWindowBuilder, WindowCount) == 0x000A18, "Member 'AWindowBuilder::WindowCount' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, RectangleOffsetCurve) == 0x000A20, "Member 'AWindowBuilder::RectangleOffsetCurve' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, SquareOffsetCurve) == 0x000A28, "Member 'AWindowBuilder::SquareOffsetCurve' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, SquareWindowClass) == 0x000A30, "Member 'AWindowBuilder::SquareWindowClass' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, RectangleWindowClass) == 0x000A38, "Member 'AWindowBuilder::RectangleWindowClass' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, WindowMaterial) == 0x000A40, "Member 'AWindowBuilder::WindowMaterial' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, bRectangleWindows) == 0x000A48, "Member 'AWindowBuilder::bRectangleWindows' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, WindowsVerticallyOriented) == 0x000A49, "Member 'AWindowBuilder::WindowsVerticallyOriented' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, WindowHeight) == 0x000A4C, "Member 'AWindowBuilder::WindowHeight' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, WindowPaneWidth) == 0x000A50, "Member 'AWindowBuilder::WindowPaneWidth' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, WindowDepth) == 0x000A54, "Member 'AWindowBuilder::WindowDepth' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, CutIntoWorld) == 0x000A58, "Member 'AWindowBuilder::CutIntoWorld' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, HoleMaterial) == 0x000A60, "Member 'AWindowBuilder::HoleMaterial' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, PaneMaterial) == 0x000A68, "Member 'AWindowBuilder::PaneMaterial' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, SpawnedWindows) == 0x000A70, "Member 'AWindowBuilder::SpawnedWindows' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, SpawnedWindowTransforms) == 0x000A80, "Member 'AWindowBuilder::SpawnedWindowTransforms' has a wrong offset!");
static_assert(offsetof(AWindowBuilder, WindowSpawnTransform) == 0x000A90, "Member 'AWindowBuilder::WindowSpawnTransform' has a wrong offset!");

// Class ThankYouVeryCool.SpeedrunOverlay
// 0x0018 (0x0278 - 0x0260)
class USpeedrunOverlay : public UUserWidget
{
public:
	class UTextBlock*                             TimeDisplay;                                       // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             VersionNumber;                                     // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             SpeedDisplay;                                      // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void StartCountdown();
	void UpdateDisplayedGoal(float Time, EDifficulty Goal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpeedrunOverlay">();
	}
	static class USpeedrunOverlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpeedrunOverlay>();
	}
};
static_assert(alignof(USpeedrunOverlay) == 0x000008, "Wrong alignment on USpeedrunOverlay");
static_assert(sizeof(USpeedrunOverlay) == 0x000278, "Wrong size on USpeedrunOverlay");
static_assert(offsetof(USpeedrunOverlay, TimeDisplay) == 0x000260, "Member 'USpeedrunOverlay::TimeDisplay' has a wrong offset!");
static_assert(offsetof(USpeedrunOverlay, VersionNumber) == 0x000268, "Member 'USpeedrunOverlay::VersionNumber' has a wrong offset!");
static_assert(offsetof(USpeedrunOverlay, SpeedDisplay) == 0x000270, "Member 'USpeedrunOverlay::SpeedDisplay' has a wrong offset!");

// Class ThankYouVeryCool.SpentShell
// 0x0018 (0x02A0 - 0x0288)
class ASpentShell : public APoolableActor
{
public:
	class UStaticMeshComponent*                   StaticMesh;                                        // 0x0288(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      CollisionComp;                                     // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnStop(const struct FHitResult& ImpactResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpentShell">();
	}
	static class ASpentShell* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpentShell>();
	}
};
static_assert(alignof(ASpentShell) == 0x000008, "Wrong alignment on ASpentShell");
static_assert(sizeof(ASpentShell) == 0x0002A0, "Wrong size on ASpentShell");
static_assert(offsetof(ASpentShell, StaticMesh) == 0x000288, "Member 'ASpentShell::StaticMesh' has a wrong offset!");
static_assert(offsetof(ASpentShell, CollisionComp) == 0x000290, "Member 'ASpentShell::CollisionComp' has a wrong offset!");
static_assert(offsetof(ASpentShell, ProjectileMovementComponent) == 0x000298, "Member 'ASpentShell::ProjectileMovementComponent' has a wrong offset!");

// Class ThankYouVeryCool.SpreadingCrosshair
// 0x00C0 (0x0320 - 0x0260)
class USpreadingCrosshair : public UUserWidget
{
public:
	class UMaterialInstanceDynamic*               SlowMoInstance;                                    // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           BaseCanvas;                                        // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           HitMarkerCanvas;                                   // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                TopHair;                                           // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                RightHair;                                         // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                BottomHair;                                        // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                LeftHair;                                          // 0x0290(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       TopSlot;                                           // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       RightSlot;                                         // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       BottomSlot;                                        // 0x02A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       LeftSlot;                                          // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                TopMarker;                                         // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                RightMarker;                                       // 0x02C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                BottomMarker;                                      // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBorder*                                LeftMarker;                                        // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       TopMarkerSlot;                                     // 0x02D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       RightMarkerSlot;                                   // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       BottomMarkerSlot;                                  // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanelSlot*                       LeftMarkerSlot;                                    // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBorder*>                        HairList;                                          // 0x02F8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector2D                              HairDimensions;                                    // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HairColor;                                         // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void FadeInCrosshair();
	void FadeOutCrosshair();
	void Setup();
	void ShowMarker();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpreadingCrosshair">();
	}
	static class USpreadingCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpreadingCrosshair>();
	}
};
static_assert(alignof(USpreadingCrosshair) == 0x000008, "Wrong alignment on USpreadingCrosshair");
static_assert(sizeof(USpreadingCrosshair) == 0x000320, "Wrong size on USpreadingCrosshair");
static_assert(offsetof(USpreadingCrosshair, SlowMoInstance) == 0x000260, "Member 'USpreadingCrosshair::SlowMoInstance' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, BaseCanvas) == 0x000268, "Member 'USpreadingCrosshair::BaseCanvas' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, HitMarkerCanvas) == 0x000270, "Member 'USpreadingCrosshair::HitMarkerCanvas' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, TopHair) == 0x000278, "Member 'USpreadingCrosshair::TopHair' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, RightHair) == 0x000280, "Member 'USpreadingCrosshair::RightHair' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, BottomHair) == 0x000288, "Member 'USpreadingCrosshair::BottomHair' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, LeftHair) == 0x000290, "Member 'USpreadingCrosshair::LeftHair' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, TopSlot) == 0x000298, "Member 'USpreadingCrosshair::TopSlot' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, RightSlot) == 0x0002A0, "Member 'USpreadingCrosshair::RightSlot' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, BottomSlot) == 0x0002A8, "Member 'USpreadingCrosshair::BottomSlot' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, LeftSlot) == 0x0002B0, "Member 'USpreadingCrosshair::LeftSlot' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, TopMarker) == 0x0002B8, "Member 'USpreadingCrosshair::TopMarker' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, RightMarker) == 0x0002C0, "Member 'USpreadingCrosshair::RightMarker' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, BottomMarker) == 0x0002C8, "Member 'USpreadingCrosshair::BottomMarker' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, LeftMarker) == 0x0002D0, "Member 'USpreadingCrosshair::LeftMarker' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, TopMarkerSlot) == 0x0002D8, "Member 'USpreadingCrosshair::TopMarkerSlot' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, RightMarkerSlot) == 0x0002E0, "Member 'USpreadingCrosshair::RightMarkerSlot' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, BottomMarkerSlot) == 0x0002E8, "Member 'USpreadingCrosshair::BottomMarkerSlot' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, LeftMarkerSlot) == 0x0002F0, "Member 'USpreadingCrosshair::LeftMarkerSlot' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, HairList) == 0x0002F8, "Member 'USpreadingCrosshair::HairList' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, HairDimensions) == 0x000308, "Member 'USpreadingCrosshair::HairDimensions' has a wrong offset!");
static_assert(offsetof(USpreadingCrosshair, HairColor) == 0x000310, "Member 'USpreadingCrosshair::HairColor' has a wrong offset!");

// Class ThankYouVeryCool.Order
// 0x0038 (0x0258 - 0x0220)
class AOrder final : public AActor
{
public:
	class UBehaviorTree*                          BTAsset;                                           // 0x0220(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASquad*                                 MySquad;                                           // 0x0228(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USquadBT*                               Tree;                                              // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESituationContext                             ForContext;                                        // 0x0238(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlackboardComponent*                   BB;                                                // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ANPCController*>                 NPCList;                                           // 0x0248(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Order">();
	}
	static class AOrder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOrder>();
	}
};
static_assert(alignof(AOrder) == 0x000008, "Wrong alignment on AOrder");
static_assert(sizeof(AOrder) == 0x000258, "Wrong size on AOrder");
static_assert(offsetof(AOrder, BTAsset) == 0x000220, "Member 'AOrder::BTAsset' has a wrong offset!");
static_assert(offsetof(AOrder, MySquad) == 0x000228, "Member 'AOrder::MySquad' has a wrong offset!");
static_assert(offsetof(AOrder, Tree) == 0x000230, "Member 'AOrder::Tree' has a wrong offset!");
static_assert(offsetof(AOrder, ForContext) == 0x000238, "Member 'AOrder::ForContext' has a wrong offset!");
static_assert(offsetof(AOrder, BB) == 0x000240, "Member 'AOrder::BB' has a wrong offset!");
static_assert(offsetof(AOrder, NPCList) == 0x000248, "Member 'AOrder::NPCList' has a wrong offset!");

// Class ThankYouVeryCool.Squad
// 0x01B0 (0x0408 - 0x0258)
class ASquad final : public AVolume
{
public:
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrder*                                 CurrentSquadBaseOrder;                             // 0x0260(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SquadTickRate;                                     // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavModifierComponent*                  NavModifier;                                       // 0x0270(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavArea>                   NavAreaClass;                                      // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     SquadNavFilter;                                    // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     SquadNavFilterExo;                                 // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          SquadSleepBounds;                                  // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESquadColor                                   SquadColor;                                        // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AOrder*                                 TestOrder;                                         // 0x02A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USquadBT*>                       TestSquadBTCompList;                               // 0x02A8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UBlackboardComponent*>           TestSquadBBList;                                   // 0x02B8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          TestSquadBT;                                       // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BTForNewMembers;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             OrdersTable;                                       // 0x02D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugColor;                                        // 0x02E0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SquadOrderTag;                                     // 0x02E8(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenSpeech;                              // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTimeBetweenSpeech;                              // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanSquadSeePlayer;                                // 0x02F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPositionModelValid;                               // 0x02F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FA[0x16];                                     // 0x02FA(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SearchForPlayerThreshold;                          // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANPC*>                           KnownDead;                                         // 0x0318(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ANPCController*>                 Members;                                           // 0x0328(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class ASquadManager*                          SquadManager;                                      // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerPositionModel*                   PlayerPositionModel;                               // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       PlayerCharacter;                                   // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASquadBrain*                            SquadBrain;                                        // 0x0368(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASquadBrainController*                  SquadBrainController;                              // 0x0370(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SameNoiseThreshold;                                // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AOrder*>                         ActiveOrders;                                      // 0x0380(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_390[0x50];                                     // 0x0390(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNoiseData                             LastHeardNoise;                                    // 0x03E0(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          InvestigateSoundBT;                                // 0x03F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ANPCController* GetRandomMember(const TArray<class ANPCController*>& InList, const TArray<class ANPCController*>& ToIgnore, const TArray<ESituationContext>& SitRepsToIgnore);

	class ANPC* GetClosestToPlayer();
	class ANPC* GetClosestToPlayerWhoCanSee();
	int32 GetLivingCount();
	const TArray<class ANPCController*> GetMembers();
	TArray<class ANPCController*> GetMembersInRange(const struct FVector& Location, float Range, const TArray<class ANPCController*>& ListOfNPCs);
	class APlayerPositionModel* GetPlayerPositionModel();
	bool GetRandomMembers(TArray<class ANPCController*>* OutList, const TArray<class ANPCController*>& ToIgnore, int32 Count);
	bool GetRandomMembersClosestTo(const struct FVector& Location, TArray<class ANPCController*>* OutList, const TArray<class ANPCController*>& ToIgnore, int32 Count);
	void HaveClosestMemberSay(class FName ToSay);
	void HaveClosestMemberWhoCanSeeSay(class FName ToSay);
	bool IsPointInZone(const struct FVector& Location);
	void MaybeSaySomething();
	void OnLevelReady();
	void OnLevelUnload();
	void OnSleepBoundsBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSleepBoundsEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Reset();
	void SetPositionModelValidity(bool bIsValid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Squad">();
	}
	static class ASquad* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquad>();
	}
};
static_assert(alignof(ASquad) == 0x000008, "Wrong alignment on ASquad");
static_assert(sizeof(ASquad) == 0x000408, "Wrong size on ASquad");
static_assert(offsetof(ASquad, CurrentSquadBaseOrder) == 0x000260, "Member 'ASquad::CurrentSquadBaseOrder' has a wrong offset!");
static_assert(offsetof(ASquad, SquadTickRate) == 0x000268, "Member 'ASquad::SquadTickRate' has a wrong offset!");
static_assert(offsetof(ASquad, NavModifier) == 0x000270, "Member 'ASquad::NavModifier' has a wrong offset!");
static_assert(offsetof(ASquad, NavAreaClass) == 0x000278, "Member 'ASquad::NavAreaClass' has a wrong offset!");
static_assert(offsetof(ASquad, SquadNavFilter) == 0x000280, "Member 'ASquad::SquadNavFilter' has a wrong offset!");
static_assert(offsetof(ASquad, SquadNavFilterExo) == 0x000288, "Member 'ASquad::SquadNavFilterExo' has a wrong offset!");
static_assert(offsetof(ASquad, SquadSleepBounds) == 0x000290, "Member 'ASquad::SquadSleepBounds' has a wrong offset!");
static_assert(offsetof(ASquad, SquadColor) == 0x000298, "Member 'ASquad::SquadColor' has a wrong offset!");
static_assert(offsetof(ASquad, TestOrder) == 0x0002A0, "Member 'ASquad::TestOrder' has a wrong offset!");
static_assert(offsetof(ASquad, TestSquadBTCompList) == 0x0002A8, "Member 'ASquad::TestSquadBTCompList' has a wrong offset!");
static_assert(offsetof(ASquad, TestSquadBBList) == 0x0002B8, "Member 'ASquad::TestSquadBBList' has a wrong offset!");
static_assert(offsetof(ASquad, TestSquadBT) == 0x0002C8, "Member 'ASquad::TestSquadBT' has a wrong offset!");
static_assert(offsetof(ASquad, BTForNewMembers) == 0x0002D0, "Member 'ASquad::BTForNewMembers' has a wrong offset!");
static_assert(offsetof(ASquad, OrdersTable) == 0x0002D8, "Member 'ASquad::OrdersTable' has a wrong offset!");
static_assert(offsetof(ASquad, DebugColor) == 0x0002E0, "Member 'ASquad::DebugColor' has a wrong offset!");
static_assert(offsetof(ASquad, SquadOrderTag) == 0x0002E8, "Member 'ASquad::SquadOrderTag' has a wrong offset!");
static_assert(offsetof(ASquad, MinTimeBetweenSpeech) == 0x0002F0, "Member 'ASquad::MinTimeBetweenSpeech' has a wrong offset!");
static_assert(offsetof(ASquad, MaxTimeBetweenSpeech) == 0x0002F4, "Member 'ASquad::MaxTimeBetweenSpeech' has a wrong offset!");
static_assert(offsetof(ASquad, bCanSquadSeePlayer) == 0x0002F8, "Member 'ASquad::bCanSquadSeePlayer' has a wrong offset!");
static_assert(offsetof(ASquad, bPositionModelValid) == 0x0002F9, "Member 'ASquad::bPositionModelValid' has a wrong offset!");
static_assert(offsetof(ASquad, SearchForPlayerThreshold) == 0x000310, "Member 'ASquad::SearchForPlayerThreshold' has a wrong offset!");
static_assert(offsetof(ASquad, KnownDead) == 0x000318, "Member 'ASquad::KnownDead' has a wrong offset!");
static_assert(offsetof(ASquad, Members) == 0x000328, "Member 'ASquad::Members' has a wrong offset!");
static_assert(offsetof(ASquad, SquadManager) == 0x000338, "Member 'ASquad::SquadManager' has a wrong offset!");
static_assert(offsetof(ASquad, TYVCGameMode) == 0x000340, "Member 'ASquad::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ASquad, PlayerPositionModel) == 0x000350, "Member 'ASquad::PlayerPositionModel' has a wrong offset!");
static_assert(offsetof(ASquad, PlayerCharacter) == 0x000360, "Member 'ASquad::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(ASquad, SquadBrain) == 0x000368, "Member 'ASquad::SquadBrain' has a wrong offset!");
static_assert(offsetof(ASquad, SquadBrainController) == 0x000370, "Member 'ASquad::SquadBrainController' has a wrong offset!");
static_assert(offsetof(ASquad, SameNoiseThreshold) == 0x000378, "Member 'ASquad::SameNoiseThreshold' has a wrong offset!");
static_assert(offsetof(ASquad, ActiveOrders) == 0x000380, "Member 'ASquad::ActiveOrders' has a wrong offset!");
static_assert(offsetof(ASquad, LastHeardNoise) == 0x0003E0, "Member 'ASquad::LastHeardNoise' has a wrong offset!");
static_assert(offsetof(ASquad, InvestigateSoundBT) == 0x0003F8, "Member 'ASquad::InvestigateSoundBT' has a wrong offset!");

// Class ThankYouVeryCool.SquadBehaviorTree
// 0x0000 (0x0068 - 0x0068)
class USquadBehaviorTree final : public UBehaviorTree
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadBehaviorTree">();
	}
	static class USquadBehaviorTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadBehaviorTree>();
	}
};
static_assert(alignof(USquadBehaviorTree) == 0x000008, "Wrong alignment on USquadBehaviorTree");
static_assert(sizeof(USquadBehaviorTree) == 0x000068, "Wrong size on USquadBehaviorTree");

// Class ThankYouVeryCool.SquadBrain
// 0x0000 (0x0280 - 0x0280)
class ASquadBrain : public APawn
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadBrain">();
	}
	static class ASquadBrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquadBrain>();
	}
};
static_assert(alignof(ASquadBrain) == 0x000008, "Wrong alignment on ASquadBrain");
static_assert(sizeof(ASquadBrain) == 0x000280, "Wrong size on ASquadBrain");

// Class ThankYouVeryCool.SquadBrainController
// 0x0038 (0x0360 - 0x0328)
class ASquadBrainController : public AAIController
{
public:
	class ASquad*                                 MySquad;                                           // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           OrderTag;                                          // 0x0330(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          MainBT;                                            // 0x0338(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BasicSearchBT;                                     // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BasicSearchLeaderBT;                               // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BasicSearchFollowerBT;                             // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadBrainController">();
	}
	static class ASquadBrainController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquadBrainController>();
	}
};
static_assert(alignof(ASquadBrainController) == 0x000008, "Wrong alignment on ASquadBrainController");
static_assert(sizeof(ASquadBrainController) == 0x000360, "Wrong size on ASquadBrainController");
static_assert(offsetof(ASquadBrainController, MySquad) == 0x000328, "Member 'ASquadBrainController::MySquad' has a wrong offset!");
static_assert(offsetof(ASquadBrainController, OrderTag) == 0x000330, "Member 'ASquadBrainController::OrderTag' has a wrong offset!");
static_assert(offsetof(ASquadBrainController, MainBT) == 0x000338, "Member 'ASquadBrainController::MainBT' has a wrong offset!");
static_assert(offsetof(ASquadBrainController, BasicSearchBT) == 0x000340, "Member 'ASquadBrainController::BasicSearchBT' has a wrong offset!");
static_assert(offsetof(ASquadBrainController, BasicSearchLeaderBT) == 0x000348, "Member 'ASquadBrainController::BasicSearchLeaderBT' has a wrong offset!");
static_assert(offsetof(ASquadBrainController, BasicSearchFollowerBT) == 0x000350, "Member 'ASquadBrainController::BasicSearchFollowerBT' has a wrong offset!");

// Class ThankYouVeryCool.SquadManager
// 0x0028 (0x0248 - 0x0220)
class ASquadManager : public AActor
{
public:
	TArray<class ASquad*>                         ActiveSquadList;                                   // 0x0220(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FColor>                         DebugColorList;                                    // 0x0238(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadManager">();
	}
	static class ASquadManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASquadManager>();
	}
};
static_assert(alignof(ASquadManager) == 0x000008, "Wrong alignment on ASquadManager");
static_assert(sizeof(ASquadManager) == 0x000248, "Wrong size on ASquadManager");
static_assert(offsetof(ASquadManager, ActiveSquadList) == 0x000220, "Member 'ASquadManager::ActiveSquadList' has a wrong offset!");
static_assert(offsetof(ASquadManager, TYVCGameMode) == 0x000230, "Member 'ASquadManager::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ASquadManager, DebugColorList) == 0x000238, "Member 'ASquadManager::DebugColorList' has a wrong offset!");

// Class ThankYouVeryCool.SquadTask_AllChill
// 0x0008 (0x0080 - 0x0078)
class USquadTask_AllChill final : public USquadTask_Base
{
public:
	class UBehaviorTree*                          ChillBT;                                           // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SquadTask_AllChill">();
	}
	static class USquadTask_AllChill* GetDefaultObj()
	{
		return GetDefaultObjImpl<USquadTask_AllChill>();
	}
};
static_assert(alignof(USquadTask_AllChill) == 0x000008, "Wrong alignment on USquadTask_AllChill");
static_assert(sizeof(USquadTask_AllChill) == 0x000080, "Wrong size on USquadTask_AllChill");
static_assert(offsetof(USquadTask_AllChill, ChillBT) == 0x000078, "Member 'USquadTask_AllChill::ChillBT' has a wrong offset!");

// Class ThankYouVeryCool.StairsBuilder
// 0x0020 (0x0A38 - 0x0A18)
class AStairsBuilder final : public AVoxelBuilder2
{
public:
	EVoxelMaterial                                Mat;                                               // 0x0A18(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A19[0x3];                                      // 0x0A19(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color;                                             // 0x0A1C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StairWidth;                                        // 0x0A20(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepHeight;                                        // 0x0A24(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepLength;                                        // 0x0A28(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepCount;                                         // 0x0A2C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StepThickness;                                     // 0x0A30(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A34[0x4];                                      // 0x0A34(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StairsBuilder">();
	}
	static class AStairsBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStairsBuilder>();
	}
};
static_assert(alignof(AStairsBuilder) == 0x000008, "Wrong alignment on AStairsBuilder");
static_assert(sizeof(AStairsBuilder) == 0x000A38, "Wrong size on AStairsBuilder");
static_assert(offsetof(AStairsBuilder, Mat) == 0x000A18, "Member 'AStairsBuilder::Mat' has a wrong offset!");
static_assert(offsetof(AStairsBuilder, Color) == 0x000A1C, "Member 'AStairsBuilder::Color' has a wrong offset!");
static_assert(offsetof(AStairsBuilder, StairWidth) == 0x000A20, "Member 'AStairsBuilder::StairWidth' has a wrong offset!");
static_assert(offsetof(AStairsBuilder, StepHeight) == 0x000A24, "Member 'AStairsBuilder::StepHeight' has a wrong offset!");
static_assert(offsetof(AStairsBuilder, StepLength) == 0x000A28, "Member 'AStairsBuilder::StepLength' has a wrong offset!");
static_assert(offsetof(AStairsBuilder, StepCount) == 0x000A2C, "Member 'AStairsBuilder::StepCount' has a wrong offset!");
static_assert(offsetof(AStairsBuilder, StepThickness) == 0x000A30, "Member 'AStairsBuilder::StepThickness' has a wrong offset!");

// Class ThankYouVeryCool.Teleporter
// 0x0008 (0x0248 - 0x0240)
class ATeleporter : public ARechargeStation
{
public:
	class FName                                   LinkID;                                            // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void UpdateLinkID(class FName InID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Teleporter">();
	}
	static class ATeleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeleporter>();
	}
};
static_assert(alignof(ATeleporter) == 0x000008, "Wrong alignment on ATeleporter");
static_assert(sizeof(ATeleporter) == 0x000248, "Wrong size on ATeleporter");
static_assert(offsetof(ATeleporter, LinkID) == 0x000240, "Member 'ATeleporter::LinkID' has a wrong offset!");

// Class ThankYouVeryCool.ThankYouVeryCoolCharacter
// 0x0090 (0x0550 - 0x04C0)
class AThankYouVeryCoolCharacter final : public ACharacter
{
public:
	class USkeletalMeshComponent*                 Mesh1P;                                            // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 FP_Gun;                                            // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        FP_MuzzleLocation;                                 // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 VR_Gun;                                            // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        VR_MuzzleLocation;                                 // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FirstPersonCameraComponent;                        // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMotionControllerComponent*             R_MotionController;                                // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMotionControllerComponent*             L_MotionController;                                // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseTurnRate;                                      // 0x04F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x04FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GunOffset;                                         // 0x0500(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AThankYouVeryCoolProjectile> ProjectileClass;                                   // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FireSound;                                         // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireAnimation;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUsingMotionControllers : 1;                       // 0x0528(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_529[0x27];                                     // 0x0529(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThankYouVeryCoolCharacter">();
	}
	static class AThankYouVeryCoolCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThankYouVeryCoolCharacter>();
	}
};
static_assert(alignof(AThankYouVeryCoolCharacter) == 0x000010, "Wrong alignment on AThankYouVeryCoolCharacter");
static_assert(sizeof(AThankYouVeryCoolCharacter) == 0x000550, "Wrong size on AThankYouVeryCoolCharacter");
static_assert(offsetof(AThankYouVeryCoolCharacter, Mesh1P) == 0x0004B8, "Member 'AThankYouVeryCoolCharacter::Mesh1P' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, FP_Gun) == 0x0004C0, "Member 'AThankYouVeryCoolCharacter::FP_Gun' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, FP_MuzzleLocation) == 0x0004C8, "Member 'AThankYouVeryCoolCharacter::FP_MuzzleLocation' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, VR_Gun) == 0x0004D0, "Member 'AThankYouVeryCoolCharacter::VR_Gun' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, VR_MuzzleLocation) == 0x0004D8, "Member 'AThankYouVeryCoolCharacter::VR_MuzzleLocation' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, FirstPersonCameraComponent) == 0x0004E0, "Member 'AThankYouVeryCoolCharacter::FirstPersonCameraComponent' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, R_MotionController) == 0x0004E8, "Member 'AThankYouVeryCoolCharacter::R_MotionController' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, L_MotionController) == 0x0004F0, "Member 'AThankYouVeryCoolCharacter::L_MotionController' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, BaseTurnRate) == 0x0004F8, "Member 'AThankYouVeryCoolCharacter::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, BaseLookUpRate) == 0x0004FC, "Member 'AThankYouVeryCoolCharacter::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, GunOffset) == 0x000500, "Member 'AThankYouVeryCoolCharacter::GunOffset' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, ProjectileClass) == 0x000510, "Member 'AThankYouVeryCoolCharacter::ProjectileClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, FireSound) == 0x000518, "Member 'AThankYouVeryCoolCharacter::FireSound' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolCharacter, FireAnimation) == 0x000520, "Member 'AThankYouVeryCoolCharacter::FireAnimation' has a wrong offset!");

// Class ThankYouVeryCool.ThankYouVeryCoolGameMode
// 0x1420 (0x16E0 - 0x02C0)
class AThankYouVeryCoolGameMode : public AGameModeBase
{
public:
	bool                                          bSkipToLevel;                                      // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipToChapter;                                    // 0x02C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ApplyUpscaleHandle;                                // 0x02C8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCampaignDataAsset>         ChapterToSkipTo;                                   // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACampaignManager>           CampaignManagerClass;                              // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ARogueManager>              RogueManagerClass;                                 // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADailyManager>              DailyManagerClass;                                 // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayerGodMode;                                    // 0x02F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugItemCollisions;                              // 0x02F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F2[0x6];                                      // 0x02F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCampaignDataAsset>> CampaignListForStress;                             // 0x02F8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              TitleTrack;                                        // 0x0310(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x58];                                     // 0x0338(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           DifficultyCurve;                                   // 0x0390(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoadCamInterpSpeed;                                // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LoadCamExponent;                                   // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            SoundClassMaster;                                  // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            SoundClassMusic;                                   // 0x03A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            SoundClassArcade;                                  // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            SoundClassNPCs;                                    // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundClass*                            SoundClassGame;                                    // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundMix*                              SoundMixMaster;                                    // 0x03C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundMix*                              SoundMixMusic;                                     // 0x03D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundMix*                              SoundMixArcade;                                    // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundMix*                              SoundMixGame;                                      // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundMix*                              SoundMixGuns;                                      // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundMix*                              SoundMixNPCs;                                      // 0x03F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTask_ResetNodeToGen*           NodeResetTask;                                     // 0x03F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DebugLevelName;                                    // 0x0400(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x8];                                      // 0x0408(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APawn>                      PlayerMenuClass;                                   // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class APawn>                      PlayerGameplayClass;                               // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            PointsNeededToKillCurve;                           // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            PointsDrainPerSecondCurve;                         // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UVoxelGenerator>            EmptyVoxelClass;                                   // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x4];                                      // 0x0440(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoadInterpSpeed;                                   // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSkipCinematicLoad;                                // 0x0448(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_449[0xF];                                      // 0x0449(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AImpactManager>             ImpactManagerClass;                                // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AImpactManager*                         ImpactManager;                                     // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraSplineManager*                   CameraSplineManager;                               // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MutatorsDataTable;                                 // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             UnlocksDataTable;                                  // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             GenericUnlocksDataTable;                           // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            OnDeathSlowMoCurve;                                // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            FadeToBlackCurve;                                  // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            FadeInCurve;                                       // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x138];                                    // 0x04A0(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNdocRingWidget>            LoadWidgetClass;                                   // 0x05D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNdocRingWidget*                        ActiveLoadWidget;                                  // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0xF8];                                     // 0x05E8(0x00F8)(Fixing Size After Last Property [ Dumper-7 ])
	EDifficulty                                   Difficulty;                                        // 0x06E0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bKeepOverworldLoaded;                              // 0x06E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E2[0x2];                                      // 0x06E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverworldName;                                     // 0x06E4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6EC[0x4];                                      // 0x06EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundMix*                              BizarreMix;                                        // 0x06F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnNonReadyFire;                                    // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bForceConsoleWorkshopLevels;                       // 0x0708(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipIntro;                                        // 0x0709(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70A[0x6];                                      // 0x070A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameModifier>                         CheatList;                                         // 0x0710(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsDoingStressTest;                                // 0x0720(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoingPlaylist;                                  // 0x0721(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseCam;                                        // 0x0722(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoRTX;                                            // 0x0723(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_724[0x4];                                      // 0x0724(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EImpactType, float>                      CaliberShakeMap;                                   // 0x0728(0x0050)(Edit, NativeAccessSpecifierPublic)
	float                                         TimeBetweenStressLoads;                            // 0x0778(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77C[0x4];                                      // 0x077C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UArcadeLevelAsset*>              Playlist;                                          // 0x0780(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     XHairTextures;                                     // 0x0790(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A0[0xC];                                      // 0x07A0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentPlaylistIdx;                                // 0x07AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLeaveLevel;                                      // 0x07B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerDied;                                      // 0x07C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class ACampaignMarker*>                NPCSpawnPoints;                                    // 0x07D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class ACampaignMarker*>                SpecialSpawnPoints;                                // 0x07E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F0[0x38];                                     // 0x07F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ACampaignMarker*, float>           SpawnTimeStamps;                                   // 0x0828(0x0050)(NativeAccessSpecifierPublic)
	float                                         TimeToReuseSpawn;                                  // 0x0878(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_87C[0x4];                                      // 0x087C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ANPC>>               SpawnQueue;                                        // 0x0880(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_890[0x8];                                      // 0x0890(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ECannonMode                                   SelectedCannonMode;                                // 0x0898(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_899[0x7];                                      // 0x0899(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SlotSuffix;                                        // 0x08A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CloakedGunMat;                                     // 0x08B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ShineGoldMat;                                      // 0x08B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ShineSilverMat;                                    // 0x08C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ShineBronzeMat;                                    // 0x08C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ShineRoseGoldMat;                                  // 0x08D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SuperShadeRed;                                     // 0x08D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SuperShadeBlack;                                   // 0x08E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E8[0x20];                                     // 0x08E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             WeakpointSound;                                    // 0x0908(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCScanDistanceSquared;                            // 0x0910(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_914[0x4];                                      // 0x0914(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CurrentLevelDisplayName;                           // 0x0918(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class AMenuPawn*                              MenuPawn;                                          // 0x0930(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChallengesSave*                        ArcadeSave;                                        // 0x0938(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UChapterSaveV2*                         CampaignSave;                                      // 0x0940(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URogueSave*                             RogueSave;                                         // 0x0948(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EGameModifier, float>                    ModiferModAmounts;                                 // 0x0950(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A0[0x18];                                     // 0x09A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTYVCLBReadCachedResult>        LBReadCachedResults;                               // 0x09B8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        TeleportSystem;                                    // 0x09C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportPlaybackSpeed;                             // 0x09D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDelay;                                     // 0x09D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTimerHandle>                   TeleportHandles;                                   // 0x09D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E8[0x38];                                     // 0x09E8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTYVCSteamLeaderboardEntry>     CachedLBList;                                      // 0x0A20(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A30[0x48];                                     // 0x0A30(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLeaderboardEvent                      TimeLBEvent;                                       // 0x0A78(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FLeaderboardEvent                      ScoreLBEvent;                                      // 0x0A84(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A90[0x18];                                     // 0x0A90(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CachedUniqueID;                                    // 0x0AA8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EGameModifier>                         RunningModifiers;                                  // 0x0AB8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC8[0x58];                                     // 0x0AC8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ULevelEditorSave*>               ArcadeLevels;                                      // 0x0B20(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B30[0x8];                                      // 0x0B30(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool bIsController)> OnControllerSwap;                                  // 0x0B38(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& NewLoc)> OnLocalizationSwap;                                // 0x0B48(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bCurrentInputController;                           // 0x0B58(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTickSpeedrunTimer;                          // 0x0B59(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5A[0x2];                                      // 0x0B5A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CachedParScore;                                    // 0x0B5C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseLevel;                                     // 0x0B60(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B61[0x3];                                      // 0x0B61(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedRunTime;                                      // 0x0B64(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CampaignSpeedRunTime;                              // 0x0B68(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6C[0x2];                                      // 0x0B6C(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInCutscene;                                       // 0x0B6E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B6F[0x1];                                      // 0x0B6F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CorsairAmbientName;                                // 0x0B70(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B80[0x8];                                      // 0x0B80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         LevelActorMap;                                     // 0x0B88(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class AChameleon*                             Chameleon;                                         // 0x0B98(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EImpactType, class UForceFeedbackEffect*> ImpactFeedbackmap;                                 // 0x0BA0(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class ANPC*, uint8>                      FeedbackTracker;                                   // 0x0BF0(0x0050)(NativeAccessSpecifierPublic)
	float                                         MinTimeBetweenSpeech;                              // 0x0C40(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C44[0x4];                                      // 0x0C44(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AFeedbackActor>             FeedbackActorClass;                                // 0x0C48(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencyRules;                                  // 0x0C50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencyRulesNPC;                               // 0x0C58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      SoundAttenuationGuns;                              // 0x0C60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReverbEffect*                          GlobalReverbEffect;                                // 0x0C68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReverbEffect*                          VictoryReverbEffect;                               // 0x0C70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     RifleSounds;                                       // 0x0C78(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     SMGSounds;                                         // 0x0C88(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     HandgunSounds;                                     // 0x0C98(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     ShotgunSounds;                                     // 0x0CA8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class USoundBase*                             HeadshotCue;                                       // 0x0CB8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSteelLeftSpawn;                                  // 0x0CC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool bIsController)> OnSteelStuntSwap;                                  // 0x0CD0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USoundBase*                             KillCue;                                           // 0x0CE0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FinalShotCue;                                      // 0x0CE8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FadeOutOverDelegate;                               // 0x0CF0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              FadeInOverDelegate;                                // 0x0D00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D10[0x18];                                     // 0x0D10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class ULevelStreaming*>     LoadedLevelMap;                                    // 0x0D28(0x0050)(NativeAccessSpecifierPublic)
	class UVoxelBasicMaterialCollection*          DefaultVoxelMaterial;                              // 0x0D78(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACampaignManager*                       CampaignManager;                                   // 0x0D80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ARogueManager*                          RogueManager;                                      // 0x0D88(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADailyManager*                          DailyManager;                                      // 0x0D90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_LoadChapter*              LoadChapterPtr;                                    // 0x0D98(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MuzzleFlashCurve;                                  // 0x0DA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGlobalStatsUpdated;                              // 0x0DA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         GlobalKills;                                       // 0x0DB8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GlobalHS;                                          // 0x0DBC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LBAddon;                                           // 0x0DC0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ANPC*>                           RagdolledNPCList;                                  // 0x0DD0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE0[0x8];                                      // 0x0DE0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APropVoxelWorld*>                ShatterList;                                       // 0x0DE8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_DF8[0x18];                                     // 0x0DF8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowRolls;                                       // 0x0E10(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E11[0x7];                                      // 0x0E11(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VersionString;                                     // 0x0E18(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PatchPrefix;                                       // 0x0E28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PatchSuffix;                                       // 0x0E2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E30[0x1];                                      // 0x0E30(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceDeck;                                        // 0x0E31(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E32[0x6];                                      // 0x0E32(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             OrdersTable;                                       // 0x0E38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ShinyTable;                                        // 0x0E40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E48[0x8];                                      // 0x0E48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreaming*                        OverworldLevel;                                    // 0x0E50(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AVoxelWorld*>                    CurrentVoxelWorlds;                                // 0x0E58(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bNeverFade;                                        // 0x0E68(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugClimb;                                       // 0x0E69(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugNPCSpeech;                                   // 0x0E6A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E6B[0x5];                                      // 0x0E6B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             EmptySound;                                        // 0x0E70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EHudColor, struct FLinearColor>          HUDColorMap;                                       // 0x0E78(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class APoolableActor>             DefaultTraceClass;                                 // 0x0EC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APoolableActor>             DefaultShellClass;                                 // 0x0ED0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APoolManager>               PoolManagerClass;                                  // 0x0ED8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APoolManager*                           PoolManager;                                       // 0x0EE0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AMusicPlayer*                           MusicPlayer;                                       // 0x0EE8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FTimeTrophies>       TimeTrophiesPerMap;                                // 0x0EF0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FControlSettings                       CurrentControlSettings;                            // 0x0F40(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FControlSettings                       DefaultControlSettings;                            // 0x0F4C(0x000C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FControlSettingsGamepad                CurrentControlGamepadSettings;                     // 0x0F58(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FControlSettingsGamepad                DefaultControlGamepadSettings;                     // 0x0F74(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPlayerInputMappings                   CurrentInputMappings;                              // 0x0F90(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bCurrentHasInputMappings;                          // 0x1030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1031[0x7];                                     // 0x1031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTYVCAudioSettings                     CurrentAudioSettings;                              // 0x1038(0x0038)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTYVCAudioSettings                     DefaultAudioSettings;                              // 0x1070(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVisualSettings                        CurrentVisualSettings;                             // 0x10A8(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVisualSettings                        DefaultVisualSettings;                             // 0x1100(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FVisualSettings                        DefaultVisualSettingsDeck;                         // 0x1158(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bAutoStandFromSlide;                               // 0x11B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B1[0x7];                                     // 0x11B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             TeleportSound;                                     // 0x11B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugForceContinueChapter;                        // 0x11C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldHideUI;                                     // 0x11C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C2[0x6];                                     // 0x11C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACampaignMarker*>                SpawnHistory;                                      // 0x11C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FGameSettings                          CurrentGameSettings;                               // 0x11D8(0x0090)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FGameSettings                          DefaultGameSettings;                               // 0x1268(0x0090)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                PlayerSpawnWeapon;                                 // 0x12F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponPreview>             WeaponPreviewClass;                                // 0x1300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AWeaponPreview*                         WeaponPreviewActor;                                // 0x1308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                ForceNPCSpawnWeapon;                               // 0x1310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AWeaponBase>                ForcePlayerSpawnWeapon;                            // 0x1318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1320[0x11];                                    // 0x1320(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSpawnPlayerWeaponAsSuppressed;                    // 0x1331(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1332[0x6];                                     // 0x1332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponBase*                            PlayerSpawnedWeaponActor;                          // 0x1338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1340[0x1];                                     // 0x1340(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldShowPostCreditsMsg;                         // 0x1341(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1342[0x1E];                                    // 0x1342(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UVictoryWidget>             VictoryWidgetClass;                                // 0x1360(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVictoryWidget*                         DisplayedVictoryWidget;                            // 0x1368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerCharacter*                       GameplayCharacter;                                 // 0x1370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1378[0x20];                                    // 0x1378(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANPC*>                           NPCList;                                           // 0x1398(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AANPCSpawner*>                   SpawnerList;                                       // 0x13A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ASquadBrain>                SquadBrainClass;                                   // 0x13B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 LevelThresholds;                                   // 0x13C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DistanceBetweenStormParticles;                     // 0x13D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13D4[0x4];                                     // 0x13D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        StormParticleSystem;                               // 0x13D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ShootingSmokeSystem;                               // 0x13E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StormRightOffset;                                  // 0x13E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StormRandomOffsetRange;                            // 0x13EC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UParticleSystemComponent*>       StormEmitters;                                     // 0x13F8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bPlayAsNGP;                                        // 0x1408(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1409[0x7];                                     // 0x1409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelEditorSave*                       CurrentLevelSaveAsset;                             // 0x1410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArcadeLevelAsset*                      CurrentArcadeAsset;                                // 0x1418(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_StartArcade*              StartArcadeTask;                                   // 0x1420(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayTask_ResetArcade*              ResetArcadeTask;                                   // 0x1428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameplayGask_EndArcade*                EndArcadeTask;                                     // 0x1430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetComponent>           EmptyCompClass;                                    // 0x1438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameType                                     CurrentGameType;                                   // 0x1440(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHuntIsDaily;                                      // 0x1441(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGotTokenThisDaily;                                // 0x1442(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawCrosshair;                                    // 0x1443(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAI;                                        // 0x1444(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlockAll;                                        // 0x1445(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableIntro;                                     // 0x1446(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugMelee;                                       // 0x1447(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlimitedCannon;                                  // 0x1448(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSlide;                                       // 0x1449(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugHeadcam;                                     // 0x144A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugArmCannon;                                   // 0x144B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnPlayerWithArmCannon;                         // 0x144C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisablePooledActors;                              // 0x144D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugPlayerWeapon;                                // 0x144E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugCollisionImminent;                           // 0x144F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamShakeLevel                                CamShakeLevel;                                     // 0x1450(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCharacterDebug;                               // 0x1451(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTargetSphereDebug;                                // 0x1452(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LogPlayerDeath;                                    // 0x1453(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugWallRun;                                     // 0x1454(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImpactDebug;                                      // 0x1455(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableVoxelEdits;                                // 0x1456(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUnlimitedAmmo;                                    // 0x1457(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvincibleAI;                                     // 0x1458(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPuppetMasterAI;                                   // 0x1459(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPuppetMasterCoverAI;                              // 0x145A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugStumbleIK;                                   // 0x145B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSquads;                                      // 0x145C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugNPC;                                         // 0x145D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGravGunAkimbo;                                    // 0x145E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145F[0x1];                                     // 0x145F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ASquadManager*                          SquadManager;                                      // 0x1460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AStatsManager>              StatsManagerClass;                                 // 0x1468(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AStatsManager*                          StatsManager;                                      // 0x1470(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeToFreeze;                                      // 0x1478(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_147C[0x4];                                     // 0x147C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MultiKillThreshold;                                // 0x1480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1484[0x4];                                     // 0x1484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             DoubleKillSound;                                   // 0x1488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TripleKillSound;                                   // 0x1490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MultiKillSound;                                    // 0x1498(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MonsterKillSound;                                  // 0x14A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      StyleFeedbackConc;                                 // 0x14A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14B0[0x8];                                     // 0x14B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableImpactParticles;                           // 0x14B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTracerParticles;                           // 0x14B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14BA[0x6];                                     // 0x14BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MenuPawnStart;                                     // 0x14C0(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F0[0x28];                                    // 0x14F0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnLevelReady;                                      // 0x1518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1528[0x30];                                    // 0x1528(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UConsoleIconsDataAsset*                 ConsoleIconsDataAsset;                             // 0x1558(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoingPreGame;                                     // 0x1560(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1561[0x1F];                                    // 0x1561(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoverSystem*                           CoverSystem;                                       // 0x1580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AVoxelWorldManager*                     CurrentWorldManager;                               // 0x1588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APrimaryVoxelWorld*>             PrimaryWorldList;                                  // 0x1590(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ATutorialManager>           TutorialManagerClass;                              // 0x15A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALevelEditorManager>        LevelEditorManagerClass;                           // 0x15A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameMenuWidget>            GameMenuClass;                                     // 0x15B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameMenuWidget*                        GameMenu;                                          // 0x15B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USpeedrunOverlay>           SpeedrunOverlayClass;                              // 0x15C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERank                                         CachedRankForVictoryScreen;                        // 0x15C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C9[0x7];                                     // 0x15C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ANPC>>               WeightedNPCsForPool;                               // 0x15D0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGameSettingsChanged;                             // 0x15E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnVisualSettingsChanged;                           // 0x15F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1600[0x2];                                     // 0x1600(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsQuittingToRogueMenu;                            // 0x1602(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1603[0x5];                                     // 0x1603(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USpeedrunOverlay*                       SpeedrunOverlay;                                   // 0x1608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           GlobalMPC;                                         // 0x1610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1618[0x1];                                     // 0x1618(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          CoverDebugDraw;                                    // 0x1619(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugStats;                                       // 0x161A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161B[0x5];                                     // 0x161B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          BaseSquadBT;                                       // 0x1620(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ESituationContext, int32>                ThreatLevels;                                      // 0x1628(0x0050)(Edit, NativeAccessSpecifierPublic)
	bool                                          bNoSidearmMode;                                    // 0x1678(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoSlowMo;                                         // 0x1679(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeleeOnly;                                        // 0x167A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHeadshotsOnly;                                    // 0x167B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVeryHardEnemyCount;                               // 0x167C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_167D[0x3];                                     // 0x167D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ATutorialManager*                       TutorialManager;                                   // 0x1680(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelEditorManager*                    LevelEditorManager;                                // 0x1688(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   MapBounds;                                         // 0x1690(0x001C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bForcePlayCutscenes;                               // 0x16AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16AD[0xB];                                     // 0x16AD(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              PostActorsSpawned;                                 // 0x16B8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	TDelegate<void()>                             PostQuickReset;                                    // 0x16C8(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D8[0x8];                                     // 0x16D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UObject* ExtractDataClass(class UObject* InObject);
	static void SetBaseNPCScore(class UObject* InObject);

	void ApplyAudioSettings(const struct FTYVCAudioSettings& InSettings, bool Save);
	void ApplyControlSettings(const struct FControlSettings& InSettings, bool Save);
	void ApplyControlSettingsGamepad(const struct FControlSettingsGamepad& InSettings, bool Save);
	void ApplyGameSettings(const struct FGameSettings& InSettings, bool Save);
	void ApplyVisualSettings(const struct FVisualSettings& InSettings, bool Save);
	void ArcadeResetComplete(const struct FTYVCNodeMemory& NodeMemory);
	void AwakeAll();
	bool bShouldShowNVStuff();
	void BumpTimerHUD();
	void CacheOnSteamDeck();
	void CacheUncompressedWorld(bool bSholdCache);
	int32 CalcRankThreshold(int32 BaseScore, ERank ForRank);
	ERank CalculateCurrentRank(int32 ForScore);
	void CampaignRequestedFadeIn();
	void CampaignRequestedFadeOut(float SpeedModifier);
	bool CanDoLeaderboard(class FText* ReasonWhyNo);
	bool CanSaveRank(class FText* ReasonWhyNo);
	void CheckLevelLoadProgress();
	void CheckLevelResetProgress();
	void ClearAllCompassMarkers();
	void ClearLevel();
	void ClearRagdolls();
	class UArcadeLevelAssetWorkshop* CopyLevel(class UArcadeLevelAssetWorkshop* LevelAsset, const class FString& DesiredName);
	bool CopyLevelToCampaign(class UArcadeLevelAssetWorkshop* LevelAsset, const class FString& CampaignName);
	void CorsairForceEvent(const class FString& Event);
	void CorsairForceState(const class FString& State);
	void DebugCollection();
	void DebugGyro();
	void DebugShowCoverPoints();
	void DisableNPCsStocked();
	void DoCinematicCam();
	void DoCoverPostProcessing();
	void DumpFeats();
	void DumpRogueSave();
	void EnableConsoleCheats();
	void EnsureNoMap();
	void EnterPressed();
	void ExploitCheck(int32 In);
	void FadeInFromLoadOver();
	void FadeInOver();
	void FadeInTick();
	void FadeInToChallengesOver();
	void FadeInToResetOver();
	void FadeOutFromLoadOver();
	void FadeOutOver();
	void FadeOutToArcadeOver();
	void FadeOutToChallengesOver();
	void FadeOutToResetOver();
	void FlushCompassMarkers(bool bOnlyInvalidTargets);
	void FlushRogueCheevs();
	void ForceGC();
	void ForceLastStanding();
	void ForceLBOn();
	void ForceRandomDaily();
	void ForceVictory(int32 Score);
	void ForceYesterdayDaily();
	void GatherAndSaveInputMappings(bool Save);
	bool GetCachedSteamdeckValue();
	class UCampaignDataAsset* GetCampaignAssetFromPath(const struct FSoftClassPath& InPath);
	int32 GetCompletedChallenges();
	bool GetConsoleCheatsEnabled();
	class AVoxelWorldManager* GetCurrentVoxelWorldManager();
	class FName GetD3DApiLevel();
	TArray<int32> GetDataForRecord();
	struct FShinyData GetDataForShine(EShineLevel InShine);
	EShineLevel GetDesiredShiny();
	EDifficulty GetDifficulty();
	class FName GetDistroName();
	class FString GetFriendPersonaName(const class FString& FromID);
	class UGameMenuWidget* GetGameMenu();
	EGameState GetGameState();
	bool GetHDRAllowed();
	class UTYVCHUD* GetHUD();
	class AImpactManager* GetImpactManager();
	void GetInfoForUser(const class FString& InID, TDelegate<void()> OnFetched);
	bool GetIsFading();
	bool GetIsInVictoryScreen();
	bool GetIsLoadingWidgetVisible();
	bool GetIsPaused();
	void GetLeaderboardFor(const class FString& BoardName, TDelegate<void(ELeaderboardResult LeaderboardResult, TArray<struct FTYVCSteamLeaderboardEntry>& EntryList, const struct FTYVCSteamLeaderboardEntry& User, const struct FTYVCLBReadQueryParams& LBReadQueryParams)> OnDone, bool bFriendsOnly);
	int32 GetLevelForXP(int32 InLevel);
	float GetMultiplierForMutator(EGameModifier InMut);
	class FText GetNameForMutator(EGameModifier InMut);
	bool GetPlayerGodMode();
	class APrimaryVoxelWorld* GetPrimaryVoxelWorld();
	float GetRankingMultiplier(const TArray<EGameModifier>& Modifiers);
	struct FArcadeRecord GetRecordFromData(const TArray<int32>& InData);
	struct FMutatorData GetRowForMutator(EGameModifier InMut);
	class ASquad* GetTheSquad();
	float GetTotalMultiplier(EDifficulty ForDiff, const TArray<EGameModifier>& Modifiers, TSubclassOf<class AWeaponBase> WeaponClass);
	int32 GetTotalSRanks();
	TArray<struct FUnlockData> GetUnlocksForLevel(int32 Level);
	class UVictoryWidget* GetVictoryWidget();
	class FString GetVideoCutscene();
	int32 GetXPForLevel(int32 InLevel);
	void GiveBadCheevs();
	void GlobalStatsCB();
	void GodMode(bool bEnableGodMode);
	void InitUserTracks();
	bool IsGenericKeyUnlocked(class FName InKey, class FText* UnlockInfo, class FText* HowToUnlockInfo);
	bool IsKeyUnlocked(class FName InKey, int32* OutLevel);
	bool IsMutUnlocked(EGameModifier InKey, int32* OutLevel);
	bool IsRunningCheats();
	bool IsShineUnlocked(EShineLevel Shine);
	bool IsSpawningActive();
	bool IsSteamLoggedOn();
	void KillAll();
	void KnockdownAll(float WithForce);
	void LeaveGameToArcadeMenu();
	void LeaveGameToCredits();
	void LeaveGameToMainMenu();
	void LevelLoadFailsafeCheck();
	void LoadAllData();
	void LocalGyro();
	void LogGlobalStats();
	void LoginEpic(TDelegate<void()> OnDone);
	void MakeAllSleep();
	void MarkDemoComplete();
	void MaxLevel();
	void MovePawnAlongLoadingSpline(float DeltaTime);
	void NegateTutorialPrompt();
	bool NewGamePlusUnlocked();
	void NotifyCountdownOver();
	void NotifyCrosshairSettingsUpdated();
	void NotifyIndicatorSettingUpdated();
	void NotifyLocChanged(const class FString& NewLoc);
	void NotifyPropExploded(class APropVoxelWorld* Exploded);
	void NotifyWorldLoaded();
	void OnDeathSlowMoFinish();
	void OnDeathSlowMoTick();
	void OnLevelUnloadFinished();
	void OnLoadCameraInterpComplete();
	void OnOverworldLoaded();
	void PausePressed();
	void PlayerRequestQuickReset();
	void PostFadeArcadeReset();
	void PostFadeCampaignReset();
	void PostFadeRogueReset();
	void PostFadeSkippedCampaign();
	void PreCacheVoxelWorlds(bool bShouldCache);
	void QuickResetPostSpawn();
	void RequestResetArcadeScore();
	void ResetInputMappings(bool Save);
	void ResetLevelQuick(bool bForEditor);
	void RetryWriteToLeaderboard();
	void ReturnToEditor();
	bool SaveArcadeProgress(int32 NewScore, class ULevelEditorSave* ForLevel, int32 ScoreThisRound, float TimeThisRound, int32* OldScore, float* OldTime, ERank RankThisRound);
	void SaveArcadeSetup(bool bForCampaign);
	void SaveGameSettings(const struct FGameSettings& InSettings);
	void SaveJacketAndCannon(class FName JacketName, class FName CannonName);
	void SaveRogueConfig(const struct FRogueConfig& InConfig);
	void SetAllowGameplaySound(bool bAllow);
	void SetDifficult(EDifficulty InDiff);
	void SetGameNoise(bool bCanHear);
	void SetGameType(EGameType InType);
	void SetHighesLevel(int32 KeyName);
	void SetIsInVictoryScreen(bool IsInVictoryScreen);
	void SetIsPaused(bool IsPaused);
	void SetKeepNPCsStocked(const struct FRespawnConfig& InConfig);
	void SetMouseSensitivity(float NewSens);
	void SetNPCsToSpawnRed(bool bShouldDo);
	void SetPlayerGodMode(bool bEnableGodMode);
	void SetVideoCutscene(const class FString& videoName);
	bool ShouldRemovePatch2BigLevels();
	void ShowSpeed();
	void ShowUserProfile(const class FString& InPlatformOnlineID);
	void ShowVictoryData(bool bForCampaign);
	void SimulateLaunchPS5CampaignActivity();
	void SkipBonus();
	void SkipRogue();
	void StressTestAfterLoad();
	void TeleportInNPC(const struct FTransform& Transform, TSubclassOf<class ANPC> ClassToSpawn, class ACampaignMarker* MySpawnMarker, bool bSkipFX);
	void TickPlaylist();
	void TickStressTest();
	void TryNPCRefill();
	void tua();
	void TYVCDeadZone(float InZone);
	void TYVCJumpTime(float InTime);
	void UnlockAll();
	void UnlockCheev(const class FString& ToUnlock);
	void UnlockKeyAndSave(class FName KeyName);
	void UserChooseShiny(EShineLevel InLvl);
	void WriteToLeaderboard(class UArcadeLevelAsset* ForAsset, int32 Score, float Time, const TArray<int32>& RecordData);
	void WriteToLeaderboardC(class UArcadeLevelAsset* ForAsset, int32 Score, float Time, const TArray<int32>& RecordData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThankYouVeryCoolGameMode">();
	}
	static class AThankYouVeryCoolGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThankYouVeryCoolGameMode>();
	}
};
static_assert(alignof(AThankYouVeryCoolGameMode) == 0x000010, "Wrong alignment on AThankYouVeryCoolGameMode");
static_assert(sizeof(AThankYouVeryCoolGameMode) == 0x0016E0, "Wrong size on AThankYouVeryCoolGameMode");
static_assert(offsetof(AThankYouVeryCoolGameMode, bSkipToLevel) == 0x0002C0, "Member 'AThankYouVeryCoolGameMode::bSkipToLevel' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bSkipToChapter) == 0x0002C1, "Member 'AThankYouVeryCoolGameMode::bSkipToChapter' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ApplyUpscaleHandle) == 0x0002C8, "Member 'AThankYouVeryCoolGameMode::ApplyUpscaleHandle' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ChapterToSkipTo) == 0x0002D0, "Member 'AThankYouVeryCoolGameMode::ChapterToSkipTo' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CampaignManagerClass) == 0x0002D8, "Member 'AThankYouVeryCoolGameMode::CampaignManagerClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, RogueManagerClass) == 0x0002E0, "Member 'AThankYouVeryCoolGameMode::RogueManagerClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DailyManagerClass) == 0x0002E8, "Member 'AThankYouVeryCoolGameMode::DailyManagerClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bPlayerGodMode) == 0x0002F0, "Member 'AThankYouVeryCoolGameMode::bPlayerGodMode' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugItemCollisions) == 0x0002F1, "Member 'AThankYouVeryCoolGameMode::bDebugItemCollisions' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CampaignListForStress) == 0x0002F8, "Member 'AThankYouVeryCoolGameMode::CampaignListForStress' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TitleTrack) == 0x000310, "Member 'AThankYouVeryCoolGameMode::TitleTrack' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DifficultyCurve) == 0x000390, "Member 'AThankYouVeryCoolGameMode::DifficultyCurve' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LoadCamInterpSpeed) == 0x000398, "Member 'AThankYouVeryCoolGameMode::LoadCamInterpSpeed' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LoadCamExponent) == 0x00039C, "Member 'AThankYouVeryCoolGameMode::LoadCamExponent' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundClassMaster) == 0x0003A0, "Member 'AThankYouVeryCoolGameMode::SoundClassMaster' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundClassMusic) == 0x0003A8, "Member 'AThankYouVeryCoolGameMode::SoundClassMusic' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundClassArcade) == 0x0003B0, "Member 'AThankYouVeryCoolGameMode::SoundClassArcade' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundClassNPCs) == 0x0003B8, "Member 'AThankYouVeryCoolGameMode::SoundClassNPCs' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundClassGame) == 0x0003C0, "Member 'AThankYouVeryCoolGameMode::SoundClassGame' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundMixMaster) == 0x0003C8, "Member 'AThankYouVeryCoolGameMode::SoundMixMaster' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundMixMusic) == 0x0003D0, "Member 'AThankYouVeryCoolGameMode::SoundMixMusic' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundMixArcade) == 0x0003D8, "Member 'AThankYouVeryCoolGameMode::SoundMixArcade' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundMixGame) == 0x0003E0, "Member 'AThankYouVeryCoolGameMode::SoundMixGame' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundMixGuns) == 0x0003E8, "Member 'AThankYouVeryCoolGameMode::SoundMixGuns' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundMixNPCs) == 0x0003F0, "Member 'AThankYouVeryCoolGameMode::SoundMixNPCs' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, NodeResetTask) == 0x0003F8, "Member 'AThankYouVeryCoolGameMode::NodeResetTask' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DebugLevelName) == 0x000400, "Member 'AThankYouVeryCoolGameMode::DebugLevelName' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PlayerMenuClass) == 0x000410, "Member 'AThankYouVeryCoolGameMode::PlayerMenuClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PlayerGameplayClass) == 0x000418, "Member 'AThankYouVeryCoolGameMode::PlayerGameplayClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PointsNeededToKillCurve) == 0x000428, "Member 'AThankYouVeryCoolGameMode::PointsNeededToKillCurve' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PointsDrainPerSecondCurve) == 0x000430, "Member 'AThankYouVeryCoolGameMode::PointsDrainPerSecondCurve' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, EmptyVoxelClass) == 0x000438, "Member 'AThankYouVeryCoolGameMode::EmptyVoxelClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LoadInterpSpeed) == 0x000444, "Member 'AThankYouVeryCoolGameMode::LoadInterpSpeed' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bSkipCinematicLoad) == 0x000448, "Member 'AThankYouVeryCoolGameMode::bSkipCinematicLoad' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ImpactManagerClass) == 0x000458, "Member 'AThankYouVeryCoolGameMode::ImpactManagerClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ImpactManager) == 0x000460, "Member 'AThankYouVeryCoolGameMode::ImpactManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CameraSplineManager) == 0x000468, "Member 'AThankYouVeryCoolGameMode::CameraSplineManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MutatorsDataTable) == 0x000470, "Member 'AThankYouVeryCoolGameMode::MutatorsDataTable' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, UnlocksDataTable) == 0x000478, "Member 'AThankYouVeryCoolGameMode::UnlocksDataTable' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, GenericUnlocksDataTable) == 0x000480, "Member 'AThankYouVeryCoolGameMode::GenericUnlocksDataTable' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnDeathSlowMoCurve) == 0x000488, "Member 'AThankYouVeryCoolGameMode::OnDeathSlowMoCurve' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, FadeToBlackCurve) == 0x000490, "Member 'AThankYouVeryCoolGameMode::FadeToBlackCurve' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, FadeInCurve) == 0x000498, "Member 'AThankYouVeryCoolGameMode::FadeInCurve' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LoadWidgetClass) == 0x0005D8, "Member 'AThankYouVeryCoolGameMode::LoadWidgetClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ActiveLoadWidget) == 0x0005E0, "Member 'AThankYouVeryCoolGameMode::ActiveLoadWidget' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, Difficulty) == 0x0006E0, "Member 'AThankYouVeryCoolGameMode::Difficulty' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bKeepOverworldLoaded) == 0x0006E1, "Member 'AThankYouVeryCoolGameMode::bKeepOverworldLoaded' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OverworldName) == 0x0006E4, "Member 'AThankYouVeryCoolGameMode::OverworldName' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, BizarreMix) == 0x0006F0, "Member 'AThankYouVeryCoolGameMode::BizarreMix' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnNonReadyFire) == 0x0006F8, "Member 'AThankYouVeryCoolGameMode::OnNonReadyFire' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bForceConsoleWorkshopLevels) == 0x000708, "Member 'AThankYouVeryCoolGameMode::bForceConsoleWorkshopLevels' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bSkipIntro) == 0x000709, "Member 'AThankYouVeryCoolGameMode::bSkipIntro' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CheatList) == 0x000710, "Member 'AThankYouVeryCoolGameMode::CheatList' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bIsDoingStressTest) == 0x000720, "Member 'AThankYouVeryCoolGameMode::bIsDoingStressTest' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bIsDoingPlaylist) == 0x000721, "Member 'AThankYouVeryCoolGameMode::bIsDoingPlaylist' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bCanUseCam) == 0x000722, "Member 'AThankYouVeryCoolGameMode::bCanUseCam' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bNoRTX) == 0x000723, "Member 'AThankYouVeryCoolGameMode::bNoRTX' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CaliberShakeMap) == 0x000728, "Member 'AThankYouVeryCoolGameMode::CaliberShakeMap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TimeBetweenStressLoads) == 0x000778, "Member 'AThankYouVeryCoolGameMode::TimeBetweenStressLoads' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, Playlist) == 0x000780, "Member 'AThankYouVeryCoolGameMode::Playlist' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, XHairTextures) == 0x000790, "Member 'AThankYouVeryCoolGameMode::XHairTextures' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentPlaylistIdx) == 0x0007AC, "Member 'AThankYouVeryCoolGameMode::CurrentPlaylistIdx' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnLeaveLevel) == 0x0007B0, "Member 'AThankYouVeryCoolGameMode::OnLeaveLevel' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnPlayerDied) == 0x0007C0, "Member 'AThankYouVeryCoolGameMode::OnPlayerDied' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, NPCSpawnPoints) == 0x0007D0, "Member 'AThankYouVeryCoolGameMode::NPCSpawnPoints' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SpecialSpawnPoints) == 0x0007E0, "Member 'AThankYouVeryCoolGameMode::SpecialSpawnPoints' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SpawnTimeStamps) == 0x000828, "Member 'AThankYouVeryCoolGameMode::SpawnTimeStamps' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TimeToReuseSpawn) == 0x000878, "Member 'AThankYouVeryCoolGameMode::TimeToReuseSpawn' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SpawnQueue) == 0x000880, "Member 'AThankYouVeryCoolGameMode::SpawnQueue' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SelectedCannonMode) == 0x000898, "Member 'AThankYouVeryCoolGameMode::SelectedCannonMode' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SlotSuffix) == 0x0008A0, "Member 'AThankYouVeryCoolGameMode::SlotSuffix' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CloakedGunMat) == 0x0008B0, "Member 'AThankYouVeryCoolGameMode::CloakedGunMat' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ShineGoldMat) == 0x0008B8, "Member 'AThankYouVeryCoolGameMode::ShineGoldMat' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ShineSilverMat) == 0x0008C0, "Member 'AThankYouVeryCoolGameMode::ShineSilverMat' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ShineBronzeMat) == 0x0008C8, "Member 'AThankYouVeryCoolGameMode::ShineBronzeMat' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ShineRoseGoldMat) == 0x0008D0, "Member 'AThankYouVeryCoolGameMode::ShineRoseGoldMat' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SuperShadeRed) == 0x0008D8, "Member 'AThankYouVeryCoolGameMode::SuperShadeRed' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SuperShadeBlack) == 0x0008E0, "Member 'AThankYouVeryCoolGameMode::SuperShadeBlack' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, WeakpointSound) == 0x000908, "Member 'AThankYouVeryCoolGameMode::WeakpointSound' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, NPCScanDistanceSquared) == 0x000910, "Member 'AThankYouVeryCoolGameMode::NPCScanDistanceSquared' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentLevelDisplayName) == 0x000918, "Member 'AThankYouVeryCoolGameMode::CurrentLevelDisplayName' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MenuPawn) == 0x000930, "Member 'AThankYouVeryCoolGameMode::MenuPawn' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ArcadeSave) == 0x000938, "Member 'AThankYouVeryCoolGameMode::ArcadeSave' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CampaignSave) == 0x000940, "Member 'AThankYouVeryCoolGameMode::CampaignSave' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, RogueSave) == 0x000948, "Member 'AThankYouVeryCoolGameMode::RogueSave' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ModiferModAmounts) == 0x000950, "Member 'AThankYouVeryCoolGameMode::ModiferModAmounts' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LBReadCachedResults) == 0x0009B8, "Member 'AThankYouVeryCoolGameMode::LBReadCachedResults' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TeleportSystem) == 0x0009C8, "Member 'AThankYouVeryCoolGameMode::TeleportSystem' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TeleportPlaybackSpeed) == 0x0009D0, "Member 'AThankYouVeryCoolGameMode::TeleportPlaybackSpeed' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TeleportDelay) == 0x0009D4, "Member 'AThankYouVeryCoolGameMode::TeleportDelay' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TeleportHandles) == 0x0009D8, "Member 'AThankYouVeryCoolGameMode::TeleportHandles' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CachedLBList) == 0x000A20, "Member 'AThankYouVeryCoolGameMode::CachedLBList' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TimeLBEvent) == 0x000A78, "Member 'AThankYouVeryCoolGameMode::TimeLBEvent' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ScoreLBEvent) == 0x000A84, "Member 'AThankYouVeryCoolGameMode::ScoreLBEvent' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CachedUniqueID) == 0x000AA8, "Member 'AThankYouVeryCoolGameMode::CachedUniqueID' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, RunningModifiers) == 0x000AB8, "Member 'AThankYouVeryCoolGameMode::RunningModifiers' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ArcadeLevels) == 0x000B20, "Member 'AThankYouVeryCoolGameMode::ArcadeLevels' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnControllerSwap) == 0x000B38, "Member 'AThankYouVeryCoolGameMode::OnControllerSwap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnLocalizationSwap) == 0x000B48, "Member 'AThankYouVeryCoolGameMode::OnLocalizationSwap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bCurrentInputController) == 0x000B58, "Member 'AThankYouVeryCoolGameMode::bCurrentInputController' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bShouldTickSpeedrunTimer) == 0x000B59, "Member 'AThankYouVeryCoolGameMode::bShouldTickSpeedrunTimer' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CachedParScore) == 0x000B5C, "Member 'AThankYouVeryCoolGameMode::CachedParScore' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bReverseLevel) == 0x000B60, "Member 'AThankYouVeryCoolGameMode::bReverseLevel' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SpeedRunTime) == 0x000B64, "Member 'AThankYouVeryCoolGameMode::SpeedRunTime' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CampaignSpeedRunTime) == 0x000B68, "Member 'AThankYouVeryCoolGameMode::CampaignSpeedRunTime' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bInCutscene) == 0x000B6E, "Member 'AThankYouVeryCoolGameMode::bInCutscene' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CorsairAmbientName) == 0x000B70, "Member 'AThankYouVeryCoolGameMode::CorsairAmbientName' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LevelActorMap) == 0x000B88, "Member 'AThankYouVeryCoolGameMode::LevelActorMap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, Chameleon) == 0x000B98, "Member 'AThankYouVeryCoolGameMode::Chameleon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ImpactFeedbackmap) == 0x000BA0, "Member 'AThankYouVeryCoolGameMode::ImpactFeedbackmap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, FeedbackTracker) == 0x000BF0, "Member 'AThankYouVeryCoolGameMode::FeedbackTracker' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MinTimeBetweenSpeech) == 0x000C40, "Member 'AThankYouVeryCoolGameMode::MinTimeBetweenSpeech' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, FeedbackActorClass) == 0x000C48, "Member 'AThankYouVeryCoolGameMode::FeedbackActorClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ConcurrencyRules) == 0x000C50, "Member 'AThankYouVeryCoolGameMode::ConcurrencyRules' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ConcurrencyRulesNPC) == 0x000C58, "Member 'AThankYouVeryCoolGameMode::ConcurrencyRulesNPC' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SoundAttenuationGuns) == 0x000C60, "Member 'AThankYouVeryCoolGameMode::SoundAttenuationGuns' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, GlobalReverbEffect) == 0x000C68, "Member 'AThankYouVeryCoolGameMode::GlobalReverbEffect' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, VictoryReverbEffect) == 0x000C70, "Member 'AThankYouVeryCoolGameMode::VictoryReverbEffect' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, RifleSounds) == 0x000C78, "Member 'AThankYouVeryCoolGameMode::RifleSounds' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SMGSounds) == 0x000C88, "Member 'AThankYouVeryCoolGameMode::SMGSounds' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, HandgunSounds) == 0x000C98, "Member 'AThankYouVeryCoolGameMode::HandgunSounds' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ShotgunSounds) == 0x000CA8, "Member 'AThankYouVeryCoolGameMode::ShotgunSounds' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, HeadshotCue) == 0x000CB8, "Member 'AThankYouVeryCoolGameMode::HeadshotCue' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnSteelLeftSpawn) == 0x000CC0, "Member 'AThankYouVeryCoolGameMode::OnSteelLeftSpawn' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnSteelStuntSwap) == 0x000CD0, "Member 'AThankYouVeryCoolGameMode::OnSteelStuntSwap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, KillCue) == 0x000CE0, "Member 'AThankYouVeryCoolGameMode::KillCue' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, FinalShotCue) == 0x000CE8, "Member 'AThankYouVeryCoolGameMode::FinalShotCue' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, FadeOutOverDelegate) == 0x000CF0, "Member 'AThankYouVeryCoolGameMode::FadeOutOverDelegate' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, FadeInOverDelegate) == 0x000D00, "Member 'AThankYouVeryCoolGameMode::FadeInOverDelegate' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LoadedLevelMap) == 0x000D28, "Member 'AThankYouVeryCoolGameMode::LoadedLevelMap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultVoxelMaterial) == 0x000D78, "Member 'AThankYouVeryCoolGameMode::DefaultVoxelMaterial' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CampaignManager) == 0x000D80, "Member 'AThankYouVeryCoolGameMode::CampaignManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, RogueManager) == 0x000D88, "Member 'AThankYouVeryCoolGameMode::RogueManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DailyManager) == 0x000D90, "Member 'AThankYouVeryCoolGameMode::DailyManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LoadChapterPtr) == 0x000D98, "Member 'AThankYouVeryCoolGameMode::LoadChapterPtr' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MuzzleFlashCurve) == 0x000DA0, "Member 'AThankYouVeryCoolGameMode::MuzzleFlashCurve' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnGlobalStatsUpdated) == 0x000DA8, "Member 'AThankYouVeryCoolGameMode::OnGlobalStatsUpdated' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, GlobalKills) == 0x000DB8, "Member 'AThankYouVeryCoolGameMode::GlobalKills' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, GlobalHS) == 0x000DBC, "Member 'AThankYouVeryCoolGameMode::GlobalHS' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LBAddon) == 0x000DC0, "Member 'AThankYouVeryCoolGameMode::LBAddon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, RagdolledNPCList) == 0x000DD0, "Member 'AThankYouVeryCoolGameMode::RagdolledNPCList' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ShatterList) == 0x000DE8, "Member 'AThankYouVeryCoolGameMode::ShatterList' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bAllowRolls) == 0x000E10, "Member 'AThankYouVeryCoolGameMode::bAllowRolls' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, VersionString) == 0x000E18, "Member 'AThankYouVeryCoolGameMode::VersionString' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PatchPrefix) == 0x000E28, "Member 'AThankYouVeryCoolGameMode::PatchPrefix' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PatchSuffix) == 0x000E2C, "Member 'AThankYouVeryCoolGameMode::PatchSuffix' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bForceDeck) == 0x000E31, "Member 'AThankYouVeryCoolGameMode::bForceDeck' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OrdersTable) == 0x000E38, "Member 'AThankYouVeryCoolGameMode::OrdersTable' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ShinyTable) == 0x000E40, "Member 'AThankYouVeryCoolGameMode::ShinyTable' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OverworldLevel) == 0x000E50, "Member 'AThankYouVeryCoolGameMode::OverworldLevel' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentVoxelWorlds) == 0x000E58, "Member 'AThankYouVeryCoolGameMode::CurrentVoxelWorlds' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bNeverFade) == 0x000E68, "Member 'AThankYouVeryCoolGameMode::bNeverFade' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugClimb) == 0x000E69, "Member 'AThankYouVeryCoolGameMode::bDebugClimb' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugNPCSpeech) == 0x000E6A, "Member 'AThankYouVeryCoolGameMode::bDebugNPCSpeech' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, EmptySound) == 0x000E70, "Member 'AThankYouVeryCoolGameMode::EmptySound' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, HUDColorMap) == 0x000E78, "Member 'AThankYouVeryCoolGameMode::HUDColorMap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultTraceClass) == 0x000EC8, "Member 'AThankYouVeryCoolGameMode::DefaultTraceClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultShellClass) == 0x000ED0, "Member 'AThankYouVeryCoolGameMode::DefaultShellClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PoolManagerClass) == 0x000ED8, "Member 'AThankYouVeryCoolGameMode::PoolManagerClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PoolManager) == 0x000EE0, "Member 'AThankYouVeryCoolGameMode::PoolManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MusicPlayer) == 0x000EE8, "Member 'AThankYouVeryCoolGameMode::MusicPlayer' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TimeTrophiesPerMap) == 0x000EF0, "Member 'AThankYouVeryCoolGameMode::TimeTrophiesPerMap' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentControlSettings) == 0x000F40, "Member 'AThankYouVeryCoolGameMode::CurrentControlSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultControlSettings) == 0x000F4C, "Member 'AThankYouVeryCoolGameMode::DefaultControlSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentControlGamepadSettings) == 0x000F58, "Member 'AThankYouVeryCoolGameMode::CurrentControlGamepadSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultControlGamepadSettings) == 0x000F74, "Member 'AThankYouVeryCoolGameMode::DefaultControlGamepadSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentInputMappings) == 0x000F90, "Member 'AThankYouVeryCoolGameMode::CurrentInputMappings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bCurrentHasInputMappings) == 0x001030, "Member 'AThankYouVeryCoolGameMode::bCurrentHasInputMappings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentAudioSettings) == 0x001038, "Member 'AThankYouVeryCoolGameMode::CurrentAudioSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultAudioSettings) == 0x001070, "Member 'AThankYouVeryCoolGameMode::DefaultAudioSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentVisualSettings) == 0x0010A8, "Member 'AThankYouVeryCoolGameMode::CurrentVisualSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultVisualSettings) == 0x001100, "Member 'AThankYouVeryCoolGameMode::DefaultVisualSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultVisualSettingsDeck) == 0x001158, "Member 'AThankYouVeryCoolGameMode::DefaultVisualSettingsDeck' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bAutoStandFromSlide) == 0x0011B0, "Member 'AThankYouVeryCoolGameMode::bAutoStandFromSlide' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TeleportSound) == 0x0011B8, "Member 'AThankYouVeryCoolGameMode::TeleportSound' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugForceContinueChapter) == 0x0011C0, "Member 'AThankYouVeryCoolGameMode::bDebugForceContinueChapter' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bShouldHideUI) == 0x0011C1, "Member 'AThankYouVeryCoolGameMode::bShouldHideUI' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SpawnHistory) == 0x0011C8, "Member 'AThankYouVeryCoolGameMode::SpawnHistory' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentGameSettings) == 0x0011D8, "Member 'AThankYouVeryCoolGameMode::CurrentGameSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DefaultGameSettings) == 0x001268, "Member 'AThankYouVeryCoolGameMode::DefaultGameSettings' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PlayerSpawnWeapon) == 0x0012F8, "Member 'AThankYouVeryCoolGameMode::PlayerSpawnWeapon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, WeaponPreviewClass) == 0x001300, "Member 'AThankYouVeryCoolGameMode::WeaponPreviewClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, WeaponPreviewActor) == 0x001308, "Member 'AThankYouVeryCoolGameMode::WeaponPreviewActor' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ForceNPCSpawnWeapon) == 0x001310, "Member 'AThankYouVeryCoolGameMode::ForceNPCSpawnWeapon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ForcePlayerSpawnWeapon) == 0x001318, "Member 'AThankYouVeryCoolGameMode::ForcePlayerSpawnWeapon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bSpawnPlayerWeaponAsSuppressed) == 0x001331, "Member 'AThankYouVeryCoolGameMode::bSpawnPlayerWeaponAsSuppressed' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PlayerSpawnedWeaponActor) == 0x001338, "Member 'AThankYouVeryCoolGameMode::PlayerSpawnedWeaponActor' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bShouldShowPostCreditsMsg) == 0x001341, "Member 'AThankYouVeryCoolGameMode::bShouldShowPostCreditsMsg' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, VictoryWidgetClass) == 0x001360, "Member 'AThankYouVeryCoolGameMode::VictoryWidgetClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DisplayedVictoryWidget) == 0x001368, "Member 'AThankYouVeryCoolGameMode::DisplayedVictoryWidget' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, GameplayCharacter) == 0x001370, "Member 'AThankYouVeryCoolGameMode::GameplayCharacter' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, NPCList) == 0x001398, "Member 'AThankYouVeryCoolGameMode::NPCList' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SpawnerList) == 0x0013A8, "Member 'AThankYouVeryCoolGameMode::SpawnerList' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SquadBrainClass) == 0x0013B8, "Member 'AThankYouVeryCoolGameMode::SquadBrainClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LevelThresholds) == 0x0013C0, "Member 'AThankYouVeryCoolGameMode::LevelThresholds' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DistanceBetweenStormParticles) == 0x0013D0, "Member 'AThankYouVeryCoolGameMode::DistanceBetweenStormParticles' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, StormParticleSystem) == 0x0013D8, "Member 'AThankYouVeryCoolGameMode::StormParticleSystem' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ShootingSmokeSystem) == 0x0013E0, "Member 'AThankYouVeryCoolGameMode::ShootingSmokeSystem' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, StormRightOffset) == 0x0013E8, "Member 'AThankYouVeryCoolGameMode::StormRightOffset' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, StormRandomOffsetRange) == 0x0013EC, "Member 'AThankYouVeryCoolGameMode::StormRandomOffsetRange' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, StormEmitters) == 0x0013F8, "Member 'AThankYouVeryCoolGameMode::StormEmitters' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bPlayAsNGP) == 0x001408, "Member 'AThankYouVeryCoolGameMode::bPlayAsNGP' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentLevelSaveAsset) == 0x001410, "Member 'AThankYouVeryCoolGameMode::CurrentLevelSaveAsset' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentArcadeAsset) == 0x001418, "Member 'AThankYouVeryCoolGameMode::CurrentArcadeAsset' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, StartArcadeTask) == 0x001420, "Member 'AThankYouVeryCoolGameMode::StartArcadeTask' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ResetArcadeTask) == 0x001428, "Member 'AThankYouVeryCoolGameMode::ResetArcadeTask' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, EndArcadeTask) == 0x001430, "Member 'AThankYouVeryCoolGameMode::EndArcadeTask' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, EmptyCompClass) == 0x001438, "Member 'AThankYouVeryCoolGameMode::EmptyCompClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentGameType) == 0x001440, "Member 'AThankYouVeryCoolGameMode::CurrentGameType' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bHuntIsDaily) == 0x001441, "Member 'AThankYouVeryCoolGameMode::bHuntIsDaily' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bGotTokenThisDaily) == 0x001442, "Member 'AThankYouVeryCoolGameMode::bGotTokenThisDaily' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDrawCrosshair) == 0x001443, "Member 'AThankYouVeryCoolGameMode::bDrawCrosshair' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDisableAI) == 0x001444, "Member 'AThankYouVeryCoolGameMode::bDisableAI' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bUnlockAll) == 0x001445, "Member 'AThankYouVeryCoolGameMode::bUnlockAll' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDisableIntro) == 0x001446, "Member 'AThankYouVeryCoolGameMode::bDisableIntro' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugMelee) == 0x001447, "Member 'AThankYouVeryCoolGameMode::bDebugMelee' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bUnlimitedCannon) == 0x001448, "Member 'AThankYouVeryCoolGameMode::bUnlimitedCannon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugSlide) == 0x001449, "Member 'AThankYouVeryCoolGameMode::bDebugSlide' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugHeadcam) == 0x00144A, "Member 'AThankYouVeryCoolGameMode::bDebugHeadcam' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugArmCannon) == 0x00144B, "Member 'AThankYouVeryCoolGameMode::bDebugArmCannon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bSpawnPlayerWithArmCannon) == 0x00144C, "Member 'AThankYouVeryCoolGameMode::bSpawnPlayerWithArmCannon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDisablePooledActors) == 0x00144D, "Member 'AThankYouVeryCoolGameMode::bDisablePooledActors' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugPlayerWeapon) == 0x00144E, "Member 'AThankYouVeryCoolGameMode::bDebugPlayerWeapon' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugCollisionImminent) == 0x00144F, "Member 'AThankYouVeryCoolGameMode::bDebugCollisionImminent' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CamShakeLevel) == 0x001450, "Member 'AThankYouVeryCoolGameMode::CamShakeLevel' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bShowCharacterDebug) == 0x001451, "Member 'AThankYouVeryCoolGameMode::bShowCharacterDebug' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bTargetSphereDebug) == 0x001452, "Member 'AThankYouVeryCoolGameMode::bTargetSphereDebug' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LogPlayerDeath) == 0x001453, "Member 'AThankYouVeryCoolGameMode::LogPlayerDeath' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugWallRun) == 0x001454, "Member 'AThankYouVeryCoolGameMode::bDebugWallRun' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bImpactDebug) == 0x001455, "Member 'AThankYouVeryCoolGameMode::bImpactDebug' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDisableVoxelEdits) == 0x001456, "Member 'AThankYouVeryCoolGameMode::bDisableVoxelEdits' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bUnlimitedAmmo) == 0x001457, "Member 'AThankYouVeryCoolGameMode::bUnlimitedAmmo' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bInvincibleAI) == 0x001458, "Member 'AThankYouVeryCoolGameMode::bInvincibleAI' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bPuppetMasterAI) == 0x001459, "Member 'AThankYouVeryCoolGameMode::bPuppetMasterAI' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bPuppetMasterCoverAI) == 0x00145A, "Member 'AThankYouVeryCoolGameMode::bPuppetMasterCoverAI' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugStumbleIK) == 0x00145B, "Member 'AThankYouVeryCoolGameMode::bDebugStumbleIK' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugSquads) == 0x00145C, "Member 'AThankYouVeryCoolGameMode::bDebugSquads' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugNPC) == 0x00145D, "Member 'AThankYouVeryCoolGameMode::bDebugNPC' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bGravGunAkimbo) == 0x00145E, "Member 'AThankYouVeryCoolGameMode::bGravGunAkimbo' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SquadManager) == 0x001460, "Member 'AThankYouVeryCoolGameMode::SquadManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, StatsManagerClass) == 0x001468, "Member 'AThankYouVeryCoolGameMode::StatsManagerClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, StatsManager) == 0x001470, "Member 'AThankYouVeryCoolGameMode::StatsManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TimeToFreeze) == 0x001478, "Member 'AThankYouVeryCoolGameMode::TimeToFreeze' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MultiKillThreshold) == 0x001480, "Member 'AThankYouVeryCoolGameMode::MultiKillThreshold' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, DoubleKillSound) == 0x001488, "Member 'AThankYouVeryCoolGameMode::DoubleKillSound' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TripleKillSound) == 0x001490, "Member 'AThankYouVeryCoolGameMode::TripleKillSound' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MultiKillSound) == 0x001498, "Member 'AThankYouVeryCoolGameMode::MultiKillSound' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MonsterKillSound) == 0x0014A0, "Member 'AThankYouVeryCoolGameMode::MonsterKillSound' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, StyleFeedbackConc) == 0x0014A8, "Member 'AThankYouVeryCoolGameMode::StyleFeedbackConc' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDisableImpactParticles) == 0x0014B8, "Member 'AThankYouVeryCoolGameMode::bDisableImpactParticles' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDisableTracerParticles) == 0x0014B9, "Member 'AThankYouVeryCoolGameMode::bDisableTracerParticles' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MenuPawnStart) == 0x0014C0, "Member 'AThankYouVeryCoolGameMode::MenuPawnStart' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnLevelReady) == 0x001518, "Member 'AThankYouVeryCoolGameMode::OnLevelReady' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ConsoleIconsDataAsset) == 0x001558, "Member 'AThankYouVeryCoolGameMode::ConsoleIconsDataAsset' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDoingPreGame) == 0x001560, "Member 'AThankYouVeryCoolGameMode::bDoingPreGame' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CoverSystem) == 0x001580, "Member 'AThankYouVeryCoolGameMode::CoverSystem' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CurrentWorldManager) == 0x001588, "Member 'AThankYouVeryCoolGameMode::CurrentWorldManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PrimaryWorldList) == 0x001590, "Member 'AThankYouVeryCoolGameMode::PrimaryWorldList' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TutorialManagerClass) == 0x0015A0, "Member 'AThankYouVeryCoolGameMode::TutorialManagerClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LevelEditorManagerClass) == 0x0015A8, "Member 'AThankYouVeryCoolGameMode::LevelEditorManagerClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, GameMenuClass) == 0x0015B0, "Member 'AThankYouVeryCoolGameMode::GameMenuClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, GameMenu) == 0x0015B8, "Member 'AThankYouVeryCoolGameMode::GameMenu' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SpeedrunOverlayClass) == 0x0015C0, "Member 'AThankYouVeryCoolGameMode::SpeedrunOverlayClass' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CachedRankForVictoryScreen) == 0x0015C8, "Member 'AThankYouVeryCoolGameMode::CachedRankForVictoryScreen' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, WeightedNPCsForPool) == 0x0015D0, "Member 'AThankYouVeryCoolGameMode::WeightedNPCsForPool' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnGameSettingsChanged) == 0x0015E0, "Member 'AThankYouVeryCoolGameMode::OnGameSettingsChanged' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, OnVisualSettingsChanged) == 0x0015F0, "Member 'AThankYouVeryCoolGameMode::OnVisualSettingsChanged' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bIsQuittingToRogueMenu) == 0x001602, "Member 'AThankYouVeryCoolGameMode::bIsQuittingToRogueMenu' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, SpeedrunOverlay) == 0x001608, "Member 'AThankYouVeryCoolGameMode::SpeedrunOverlay' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, GlobalMPC) == 0x001610, "Member 'AThankYouVeryCoolGameMode::GlobalMPC' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, CoverDebugDraw) == 0x001619, "Member 'AThankYouVeryCoolGameMode::CoverDebugDraw' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bDebugStats) == 0x00161A, "Member 'AThankYouVeryCoolGameMode::bDebugStats' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, BaseSquadBT) == 0x001620, "Member 'AThankYouVeryCoolGameMode::BaseSquadBT' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, ThreatLevels) == 0x001628, "Member 'AThankYouVeryCoolGameMode::ThreatLevels' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bNoSidearmMode) == 0x001678, "Member 'AThankYouVeryCoolGameMode::bNoSidearmMode' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bNoSlowMo) == 0x001679, "Member 'AThankYouVeryCoolGameMode::bNoSlowMo' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bMeleeOnly) == 0x00167A, "Member 'AThankYouVeryCoolGameMode::bMeleeOnly' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bHeadshotsOnly) == 0x00167B, "Member 'AThankYouVeryCoolGameMode::bHeadshotsOnly' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bVeryHardEnemyCount) == 0x00167C, "Member 'AThankYouVeryCoolGameMode::bVeryHardEnemyCount' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, TutorialManager) == 0x001680, "Member 'AThankYouVeryCoolGameMode::TutorialManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, LevelEditorManager) == 0x001688, "Member 'AThankYouVeryCoolGameMode::LevelEditorManager' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, MapBounds) == 0x001690, "Member 'AThankYouVeryCoolGameMode::MapBounds' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, bForcePlayCutscenes) == 0x0016AC, "Member 'AThankYouVeryCoolGameMode::bForcePlayCutscenes' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PostActorsSpawned) == 0x0016B8, "Member 'AThankYouVeryCoolGameMode::PostActorsSpawned' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolGameMode, PostQuickReset) == 0x0016C8, "Member 'AThankYouVeryCoolGameMode::PostQuickReset' has a wrong offset!");

// Class ThankYouVeryCool.ThankYouVeryCoolProjectile
// 0x0010 (0x0230 - 0x0220)
class AThankYouVeryCoolProjectile final : public AActor
{
public:
	class USphereComponent*                       CollisionComp;                                     // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProjectileMovementComponent*           ProjectileMovement;                                // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThankYouVeryCoolProjectile">();
	}
	static class AThankYouVeryCoolProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThankYouVeryCoolProjectile>();
	}
};
static_assert(alignof(AThankYouVeryCoolProjectile) == 0x000008, "Wrong alignment on AThankYouVeryCoolProjectile");
static_assert(sizeof(AThankYouVeryCoolProjectile) == 0x000230, "Wrong size on AThankYouVeryCoolProjectile");
static_assert(offsetof(AThankYouVeryCoolProjectile, CollisionComp) == 0x000220, "Member 'AThankYouVeryCoolProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AThankYouVeryCoolProjectile, ProjectileMovement) == 0x000228, "Member 'AThankYouVeryCoolProjectile::ProjectileMovement' has a wrong offset!");

// Class ThankYouVeryCool.TriPrism
// 0x0030 (0x0058 - 0x0028)
class UTriPrism final : public UVoxelGenerator
{
public:
	TArray<struct FShape>                         Shapes;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDefaultToFull;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBoxBounds;                                     // 0x0039(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVoxelIntBox                           BoxBounds;                                         // 0x003C(0x0018)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasSky;                                           // 0x0054(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BoundsMaterialIndex;                               // 0x0055(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56[0x2];                                       // 0x0056(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriPrism">();
	}
	static class UTriPrism* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriPrism>();
	}
};
static_assert(alignof(UTriPrism) == 0x000008, "Wrong alignment on UTriPrism");
static_assert(sizeof(UTriPrism) == 0x000058, "Wrong size on UTriPrism");
static_assert(offsetof(UTriPrism, Shapes) == 0x000028, "Member 'UTriPrism::Shapes' has a wrong offset!");
static_assert(offsetof(UTriPrism, bDefaultToFull) == 0x000038, "Member 'UTriPrism::bDefaultToFull' has a wrong offset!");
static_assert(offsetof(UTriPrism, bUseBoxBounds) == 0x000039, "Member 'UTriPrism::bUseBoxBounds' has a wrong offset!");
static_assert(offsetof(UTriPrism, BoxBounds) == 0x00003C, "Member 'UTriPrism::BoxBounds' has a wrong offset!");
static_assert(offsetof(UTriPrism, bHasSky) == 0x000054, "Member 'UTriPrism::bHasSky' has a wrong offset!");
static_assert(offsetof(UTriPrism, BoundsMaterialIndex) == 0x000055, "Member 'UTriPrism::BoundsMaterialIndex' has a wrong offset!");

// Class ThankYouVeryCool.TurretHead
// 0x0010 (0x0250 - 0x0240)
class ATurretHead : public ARechargeStation
{
public:
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AImpactManager*                         ImpactManager;                                     // 0x0248(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Shoot(class AActor* Target, const struct FVector& Origin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurretHead">();
	}
	static class ATurretHead* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATurretHead>();
	}
};
static_assert(alignof(ATurretHead) == 0x000008, "Wrong alignment on ATurretHead");
static_assert(sizeof(ATurretHead) == 0x000250, "Wrong size on ATurretHead");
static_assert(offsetof(ATurretHead, TYVCGameMode) == 0x000240, "Member 'ATurretHead::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(ATurretHead, ImpactManager) == 0x000248, "Member 'ATurretHead::ImpactManager' has a wrong offset!");

// Class ThankYouVeryCool.TutorialManager
// 0x0068 (0x0288 - 0x0220)
class ATutorialManager : public AActor
{
public:
	uint8                                         Pad_220[0x18];                                     // 0x0220(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMediaPlayer*                           WallJumpTutorialVideo;                             // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFileMediaSource*                       WallJumpTutorialSource;                            // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATutorialPickup*>                TutorialPickups;                                   // 0x0250(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ATutorialGuide*>                 TutorialGuides;                                    // 0x0260(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         PickupCount;                                       // 0x0270(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTutorialWidget>            TutorialWidgetClass;                               // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTutorialWidget*                        TutorialWidget;                                    // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialManager">();
	}
	static class ATutorialManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialManager>();
	}
};
static_assert(alignof(ATutorialManager) == 0x000008, "Wrong alignment on ATutorialManager");
static_assert(sizeof(ATutorialManager) == 0x000288, "Wrong size on ATutorialManager");
static_assert(offsetof(ATutorialManager, WallJumpTutorialVideo) == 0x000238, "Member 'ATutorialManager::WallJumpTutorialVideo' has a wrong offset!");
static_assert(offsetof(ATutorialManager, WallJumpTutorialSource) == 0x000240, "Member 'ATutorialManager::WallJumpTutorialSource' has a wrong offset!");
static_assert(offsetof(ATutorialManager, TutorialPickups) == 0x000250, "Member 'ATutorialManager::TutorialPickups' has a wrong offset!");
static_assert(offsetof(ATutorialManager, TutorialGuides) == 0x000260, "Member 'ATutorialManager::TutorialGuides' has a wrong offset!");
static_assert(offsetof(ATutorialManager, PickupCount) == 0x000270, "Member 'ATutorialManager::PickupCount' has a wrong offset!");
static_assert(offsetof(ATutorialManager, TutorialWidgetClass) == 0x000278, "Member 'ATutorialManager::TutorialWidgetClass' has a wrong offset!");
static_assert(offsetof(ATutorialManager, TutorialWidget) == 0x000280, "Member 'ATutorialManager::TutorialWidget' has a wrong offset!");

// Class ThankYouVeryCool.TutorialPickup
// 0x0018 (0x0238 - 0x0220)
class ATutorialPickup final : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ETutorialPickupType                           PickupType;                                        // 0x0228(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NeededCompletions;                                 // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CompletionCount;                                   // 0x0230(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MarkComplete();
	void OnFound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialPickup">();
	}
	static class ATutorialPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialPickup>();
	}
};
static_assert(alignof(ATutorialPickup) == 0x000008, "Wrong alignment on ATutorialPickup");
static_assert(sizeof(ATutorialPickup) == 0x000238, "Wrong size on ATutorialPickup");
static_assert(offsetof(ATutorialPickup, PickupType) == 0x000228, "Member 'ATutorialPickup::PickupType' has a wrong offset!");
static_assert(offsetof(ATutorialPickup, NeededCompletions) == 0x00022C, "Member 'ATutorialPickup::NeededCompletions' has a wrong offset!");
static_assert(offsetof(ATutorialPickup, CompletionCount) == 0x000230, "Member 'ATutorialPickup::CompletionCount' has a wrong offset!");

// Class ThankYouVeryCool.TutorialWidget
// 0x0000 (0x0260 - 0x0260)
class UTutorialWidget : public UUserWidget
{
public:
	void SetCompleted(int32 Num);
	void SetTotal(int32 Total);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialWidget">();
	}
	static class UTutorialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialWidget>();
	}
};
static_assert(alignof(UTutorialWidget) == 0x000008, "Wrong alignment on UTutorialWidget");
static_assert(sizeof(UTutorialWidget) == 0x000260, "Wrong size on UTutorialWidget");

// Class ThankYouVeryCool.TYVCAnimInstance
// 0x04F0 (0x0B80 - 0x0690)
class UTYVCAnimInstance : public UALSCharacterAnimInstance
{
public:
	struct FVector                                WorldFocusPoint;                                   // 0x0688(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_694[0x4];                                      // 0x0694(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VelocityC;                                         // 0x0698(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAkimbo;                                       // 0x06A4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A5[0x3];                                      // 0x06A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AkimboOffset;                                      // 0x06A8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CharacterRotationC;                                // 0x06B4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ArmCannonIdleSeq;                                  // 0x06C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendSlideKick;                                   // 0x06C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrailer;                                        // 0x06C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponReady;                                      // 0x06CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6CB[0x1];                                      // 0x06CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponSprintSpeed;                                 // 0x06CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmShoulderBlend;                                 // 0x06D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasArmCannon;                                     // 0x06D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D2[0x2];                                      // 0x06D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               SlidePelvisRotation;                               // 0x06D4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               SlidePelvisRotationInv;                            // 0x06E0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SlidePelvisRotationTest;                           // 0x06EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmCannonBlend;                                    // 0x06F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmCannonBlend;                                   // 0x06F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F5[0x3];                                      // 0x06F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LastVelocityRotationC;                             // 0x06F8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LastMovementInputRotationC;                        // 0x0704(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LookingRotationC;                                  // 0x0710(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DirectionC;                                        // 0x071C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionC2;                                       // 0x0720(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetCharacterRotationDifferenceC;                // 0x0724(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementInputVelocityDifferenceC;                  // 0x0728(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimYawDeltaC;                                      // 0x072C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimYawRateC;                                       // 0x0730(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchC;                                            // 0x0734(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMovingC;                                         // 0x0738(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasMovementInputC;                                 // 0x0739(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73A[0x6];                                      // 0x073A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          IdleSequence;                                      // 0x0740(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkingSequence;                                   // 0x0748(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WalkingSequenceReady;                              // 0x0750(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_758[0x8];                                      // 0x0758(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ComponentTransform;                                // 0x0760(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsDiving;                                         // 0x0790(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x0791(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_792[0x2];                                      // 0x0792(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZVelocity;                                         // 0x0794(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSliding;                                        // 0x0798(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInRoll;                                         // 0x0799(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsProne;                                          // 0x079A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79B[0x1];                                      // 0x079B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiveAngle;                                         // 0x079C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiveActorTangent;                                  // 0x07A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiveLookTangentPitchAdjusted;                      // 0x07A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               PelvisRot;                                         // 0x07A8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsWallRunning;                                    // 0x07B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWallRunningLeft;                                // 0x07B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENPCGripType                                  HeldWeaponGriptype;                                // 0x07B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B7[0x1];                                      // 0x07B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class AWeaponBase*                            HeldWeapon;                                        // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FPLGrip;                                           // 0x07C0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FPLGripRotator;                                    // 0x07CC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FPBarrelLocation;                                  // 0x07D8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FPGripWorld;                                       // 0x07E4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsResetting;                                      // 0x07F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldLockShoulder;                               // 0x07F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F2[0x2];                                      // 0x07F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RightShoulderLocation;                             // 0x07F4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftShoulderLocation;                              // 0x0800(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightShoulderLocationComponentSpace;               // 0x080C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightShoulderRotation;                             // 0x0818(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LeftShoulderRotation;                              // 0x0824(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                FPElbowLocation;                                   // 0x0830(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GrabIKWorldLocation;                               // 0x083C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               FPBarrelRotation;                                  // 0x0848(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightClavicleWorldRotation;                        // 0x0854(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RightClavicleComponentRotation;                    // 0x0860(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LeftClavicleComponentRotation;                     // 0x086C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotateTest;                                        // 0x0878(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotateTest2;                                       // 0x0884(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RotateTest3;                                       // 0x0890(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               AimAdjustWithRoll;                                 // 0x089C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         WeaponRoll;                                        // 0x08A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WholeOffset;                                       // 0x08AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldRaiseCannon;                                // 0x08B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldArmCannonMoveWithCam;                       // 0x08B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B2[0x2];                                      // 0x08B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IKBlend;                                           // 0x08B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IKBlendLeftHand;                                   // 0x08B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IKBlendRightHand;                                  // 0x08BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DiveMeshUnwindRot;                                 // 0x08C0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BarrelLookAtRot;                                   // 0x08CC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldPlayGunWalkLoop;                            // 0x08D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D9[0x7];                                      // 0x08D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 HandsMesh;                                         // 0x08E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldAnimateAsProne;                             // 0x08E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldIKAim;                                      // 0x08E9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHandToHandShowShoulder;                           // 0x08EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8EB[0x1];                                      // 0x08EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FPCameraWorldRotation;                             // 0x08EC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               FPCameraSkeletonRotation;                          // 0x08F8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldAnimTorso;                                  // 0x0904(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_905[0x3];                                      // 0x0905(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                KickIKTargetWorld;                                 // 0x0908(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PunchIKTargetWorld;                                // 0x0914(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PronePitch;                                        // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_924[0xC];                                      // 0x0924(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformTest;                                     // 0x0930(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              Interp2D;                                          // 0x0960(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandGripLocation;                             // 0x0968(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ElbowOffset;                                       // 0x0974(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightHandBoneLocation;                             // 0x0980(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98C[0x4];                                      // 0x098C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CameraWorldTransform;                              // 0x0990(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                CameraComponentLocation;                           // 0x09C0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraComponentRotation;                           // 0x09CC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseSnapshot                          PreRollSnapshot;                                   // 0x09D8(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bShouldBlendOutOfRoll;                             // 0x0A10(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInHandToHand;                                   // 0x0A11(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGettingUp;                                      // 0x0A12(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSnapshotPose;                                  // 0x0A13(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A14[0x4];                                      // 0x0A14(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          MySnapshotPose;                                    // 0x0A18(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FTransform                             RightHandTransform;                                // 0x0A50(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsInReload;                                       // 0x0A80(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A81[0xF];                                      // 0x0A81(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftHandReloadTransform;                           // 0x0A90(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LeftHandReloadLocation;                            // 0x0AC0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LeftHandReloadRotation;                            // 0x0ACC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RightHandLocationIKRoot;                           // 0x0AD8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RightHandRotationIKRoot;                           // 0x0AE4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             RightHandTransformIKRoot;                          // 0x0AF0(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   RightHandIKRootName;                               // 0x0B20(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftHandGripIKRootName;                            // 0x0B28(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldGunBeIK;                                    // 0x0B30(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B31[0x3];                                      // 0x0B31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallRunCamDifference;                              // 0x0B34(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurningInPlace;                                   // 0x0B38(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurningRight;                                     // 0x0B39(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldTurnInPlace;                                // 0x0B3A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3B[0x1];                                      // 0x0B3B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimYawLimit;                                       // 0x0B3C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TurnLAnim;                                         // 0x0B40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TurnRAnim;                                         // 0x0B48(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ClavicleRotation;                                  // 0x0B50(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BaseClavicleRotation;                              // 0x0B5C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BaseClavicleRotationSpineSpace;                    // 0x0B68(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ClavicleRotationSpineSpace;                        // 0x0B74(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	void SetALSMovementModeC(EMovementMode MovementMode);
	void SetWeaponReadyOnMesh(bool bIsReady);
	void UpdateAnimationProperties(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCAnimInstance">();
	}
	static class UTYVCAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCAnimInstance>();
	}
};
static_assert(alignof(UTYVCAnimInstance) == 0x000010, "Wrong alignment on UTYVCAnimInstance");
static_assert(sizeof(UTYVCAnimInstance) == 0x000B80, "Wrong size on UTYVCAnimInstance");
static_assert(offsetof(UTYVCAnimInstance, WorldFocusPoint) == 0x000688, "Member 'UTYVCAnimInstance::WorldFocusPoint' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, VelocityC) == 0x000698, "Member 'UTYVCAnimInstance::VelocityC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsInAkimbo) == 0x0006A4, "Member 'UTYVCAnimInstance::bIsInAkimbo' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, AkimboOffset) == 0x0006A8, "Member 'UTYVCAnimInstance::AkimboOffset' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, CharacterRotationC) == 0x0006B4, "Member 'UTYVCAnimInstance::CharacterRotationC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, ArmCannonIdleSeq) == 0x0006C0, "Member 'UTYVCAnimInstance::ArmCannonIdleSeq' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bBlendSlideKick) == 0x0006C8, "Member 'UTYVCAnimInstance::bBlendSlideKick' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsTrailer) == 0x0006C9, "Member 'UTYVCAnimInstance::bIsTrailer' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bWeaponReady) == 0x0006CA, "Member 'UTYVCAnimInstance::bWeaponReady' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, WeaponSprintSpeed) == 0x0006CC, "Member 'UTYVCAnimInstance::WeaponSprintSpeed' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bArmShoulderBlend) == 0x0006D0, "Member 'UTYVCAnimInstance::bArmShoulderBlend' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bHasArmCannon) == 0x0006D1, "Member 'UTYVCAnimInstance::bHasArmCannon' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, SlidePelvisRotation) == 0x0006D4, "Member 'UTYVCAnimInstance::SlidePelvisRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, SlidePelvisRotationInv) == 0x0006E0, "Member 'UTYVCAnimInstance::SlidePelvisRotationInv' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, SlidePelvisRotationTest) == 0x0006EC, "Member 'UTYVCAnimInstance::SlidePelvisRotationTest' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, ArmCannonBlend) == 0x0006F0, "Member 'UTYVCAnimInstance::ArmCannonBlend' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bArmCannonBlend) == 0x0006F4, "Member 'UTYVCAnimInstance::bArmCannonBlend' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LastVelocityRotationC) == 0x0006F8, "Member 'UTYVCAnimInstance::LastVelocityRotationC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LastMovementInputRotationC) == 0x000704, "Member 'UTYVCAnimInstance::LastMovementInputRotationC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LookingRotationC) == 0x000710, "Member 'UTYVCAnimInstance::LookingRotationC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, DirectionC) == 0x00071C, "Member 'UTYVCAnimInstance::DirectionC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, DirectionC2) == 0x000720, "Member 'UTYVCAnimInstance::DirectionC2' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, TargetCharacterRotationDifferenceC) == 0x000724, "Member 'UTYVCAnimInstance::TargetCharacterRotationDifferenceC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, MovementInputVelocityDifferenceC) == 0x000728, "Member 'UTYVCAnimInstance::MovementInputVelocityDifferenceC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, AimYawDeltaC) == 0x00072C, "Member 'UTYVCAnimInstance::AimYawDeltaC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, AimYawRateC) == 0x000730, "Member 'UTYVCAnimInstance::AimYawRateC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, PitchC) == 0x000734, "Member 'UTYVCAnimInstance::PitchC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, IsMovingC) == 0x000738, "Member 'UTYVCAnimInstance::IsMovingC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, HasMovementInputC) == 0x000739, "Member 'UTYVCAnimInstance::HasMovementInputC' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, IdleSequence) == 0x000740, "Member 'UTYVCAnimInstance::IdleSequence' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, WalkingSequence) == 0x000748, "Member 'UTYVCAnimInstance::WalkingSequence' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, WalkingSequenceReady) == 0x000750, "Member 'UTYVCAnimInstance::WalkingSequenceReady' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, ComponentTransform) == 0x000760, "Member 'UTYVCAnimInstance::ComponentTransform' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsDiving) == 0x000790, "Member 'UTYVCAnimInstance::bIsDiving' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsFalling) == 0x000791, "Member 'UTYVCAnimInstance::bIsFalling' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, ZVelocity) == 0x000794, "Member 'UTYVCAnimInstance::ZVelocity' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsSliding) == 0x000798, "Member 'UTYVCAnimInstance::bIsSliding' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsInRoll) == 0x000799, "Member 'UTYVCAnimInstance::bIsInRoll' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsProne) == 0x00079A, "Member 'UTYVCAnimInstance::bIsProne' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, DiveAngle) == 0x00079C, "Member 'UTYVCAnimInstance::DiveAngle' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, DiveActorTangent) == 0x0007A0, "Member 'UTYVCAnimInstance::DiveActorTangent' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, DiveLookTangentPitchAdjusted) == 0x0007A4, "Member 'UTYVCAnimInstance::DiveLookTangentPitchAdjusted' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, PelvisRot) == 0x0007A8, "Member 'UTYVCAnimInstance::PelvisRot' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsWallRunning) == 0x0007B4, "Member 'UTYVCAnimInstance::bIsWallRunning' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsWallRunningLeft) == 0x0007B5, "Member 'UTYVCAnimInstance::bIsWallRunningLeft' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, HeldWeaponGriptype) == 0x0007B6, "Member 'UTYVCAnimInstance::HeldWeaponGriptype' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, HeldWeapon) == 0x0007B8, "Member 'UTYVCAnimInstance::HeldWeapon' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, FPLGrip) == 0x0007C0, "Member 'UTYVCAnimInstance::FPLGrip' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, FPLGripRotator) == 0x0007CC, "Member 'UTYVCAnimInstance::FPLGripRotator' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, FPBarrelLocation) == 0x0007D8, "Member 'UTYVCAnimInstance::FPBarrelLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, FPGripWorld) == 0x0007E4, "Member 'UTYVCAnimInstance::FPGripWorld' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsResetting) == 0x0007F0, "Member 'UTYVCAnimInstance::bIsResetting' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldLockShoulder) == 0x0007F1, "Member 'UTYVCAnimInstance::bShouldLockShoulder' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightShoulderLocation) == 0x0007F4, "Member 'UTYVCAnimInstance::RightShoulderLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LeftShoulderLocation) == 0x000800, "Member 'UTYVCAnimInstance::LeftShoulderLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightShoulderLocationComponentSpace) == 0x00080C, "Member 'UTYVCAnimInstance::RightShoulderLocationComponentSpace' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightShoulderRotation) == 0x000818, "Member 'UTYVCAnimInstance::RightShoulderRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LeftShoulderRotation) == 0x000824, "Member 'UTYVCAnimInstance::LeftShoulderRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, FPElbowLocation) == 0x000830, "Member 'UTYVCAnimInstance::FPElbowLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, GrabIKWorldLocation) == 0x00083C, "Member 'UTYVCAnimInstance::GrabIKWorldLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, FPBarrelRotation) == 0x000848, "Member 'UTYVCAnimInstance::FPBarrelRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightClavicleWorldRotation) == 0x000854, "Member 'UTYVCAnimInstance::RightClavicleWorldRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightClavicleComponentRotation) == 0x000860, "Member 'UTYVCAnimInstance::RightClavicleComponentRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LeftClavicleComponentRotation) == 0x00086C, "Member 'UTYVCAnimInstance::LeftClavicleComponentRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RotateTest) == 0x000878, "Member 'UTYVCAnimInstance::RotateTest' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RotateTest2) == 0x000884, "Member 'UTYVCAnimInstance::RotateTest2' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RotateTest3) == 0x000890, "Member 'UTYVCAnimInstance::RotateTest3' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, AimAdjustWithRoll) == 0x00089C, "Member 'UTYVCAnimInstance::AimAdjustWithRoll' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, WeaponRoll) == 0x0008A8, "Member 'UTYVCAnimInstance::WeaponRoll' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, WholeOffset) == 0x0008AC, "Member 'UTYVCAnimInstance::WholeOffset' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldRaiseCannon) == 0x0008B0, "Member 'UTYVCAnimInstance::bShouldRaiseCannon' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldArmCannonMoveWithCam) == 0x0008B1, "Member 'UTYVCAnimInstance::bShouldArmCannonMoveWithCam' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, IKBlend) == 0x0008B4, "Member 'UTYVCAnimInstance::IKBlend' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, IKBlendLeftHand) == 0x0008B8, "Member 'UTYVCAnimInstance::IKBlendLeftHand' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, IKBlendRightHand) == 0x0008BC, "Member 'UTYVCAnimInstance::IKBlendRightHand' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, DiveMeshUnwindRot) == 0x0008C0, "Member 'UTYVCAnimInstance::DiveMeshUnwindRot' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, BarrelLookAtRot) == 0x0008CC, "Member 'UTYVCAnimInstance::BarrelLookAtRot' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldPlayGunWalkLoop) == 0x0008D8, "Member 'UTYVCAnimInstance::bShouldPlayGunWalkLoop' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, HandsMesh) == 0x0008E0, "Member 'UTYVCAnimInstance::HandsMesh' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldAnimateAsProne) == 0x0008E8, "Member 'UTYVCAnimInstance::bShouldAnimateAsProne' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldIKAim) == 0x0008E9, "Member 'UTYVCAnimInstance::bShouldIKAim' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bHandToHandShowShoulder) == 0x0008EA, "Member 'UTYVCAnimInstance::bHandToHandShowShoulder' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, FPCameraWorldRotation) == 0x0008EC, "Member 'UTYVCAnimInstance::FPCameraWorldRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, FPCameraSkeletonRotation) == 0x0008F8, "Member 'UTYVCAnimInstance::FPCameraSkeletonRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldAnimTorso) == 0x000904, "Member 'UTYVCAnimInstance::bShouldAnimTorso' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, KickIKTargetWorld) == 0x000908, "Member 'UTYVCAnimInstance::KickIKTargetWorld' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, PunchIKTargetWorld) == 0x000914, "Member 'UTYVCAnimInstance::PunchIKTargetWorld' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, PronePitch) == 0x000920, "Member 'UTYVCAnimInstance::PronePitch' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, TransformTest) == 0x000930, "Member 'UTYVCAnimInstance::TransformTest' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, Interp2D) == 0x000960, "Member 'UTYVCAnimInstance::Interp2D' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightHandGripLocation) == 0x000968, "Member 'UTYVCAnimInstance::RightHandGripLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, ElbowOffset) == 0x000974, "Member 'UTYVCAnimInstance::ElbowOffset' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightHandBoneLocation) == 0x000980, "Member 'UTYVCAnimInstance::RightHandBoneLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, CameraWorldTransform) == 0x000990, "Member 'UTYVCAnimInstance::CameraWorldTransform' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, CameraComponentLocation) == 0x0009C0, "Member 'UTYVCAnimInstance::CameraComponentLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, CameraComponentRotation) == 0x0009CC, "Member 'UTYVCAnimInstance::CameraComponentRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, PreRollSnapshot) == 0x0009D8, "Member 'UTYVCAnimInstance::PreRollSnapshot' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldBlendOutOfRoll) == 0x000A10, "Member 'UTYVCAnimInstance::bShouldBlendOutOfRoll' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsInHandToHand) == 0x000A11, "Member 'UTYVCAnimInstance::bIsInHandToHand' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsGettingUp) == 0x000A12, "Member 'UTYVCAnimInstance::bIsGettingUp' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bUseSnapshotPose) == 0x000A13, "Member 'UTYVCAnimInstance::bUseSnapshotPose' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, MySnapshotPose) == 0x000A18, "Member 'UTYVCAnimInstance::MySnapshotPose' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightHandTransform) == 0x000A50, "Member 'UTYVCAnimInstance::RightHandTransform' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bIsInReload) == 0x000A80, "Member 'UTYVCAnimInstance::bIsInReload' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LeftHandReloadTransform) == 0x000A90, "Member 'UTYVCAnimInstance::LeftHandReloadTransform' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LeftHandReloadLocation) == 0x000AC0, "Member 'UTYVCAnimInstance::LeftHandReloadLocation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LeftHandReloadRotation) == 0x000ACC, "Member 'UTYVCAnimInstance::LeftHandReloadRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightHandLocationIKRoot) == 0x000AD8, "Member 'UTYVCAnimInstance::RightHandLocationIKRoot' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightHandRotationIKRoot) == 0x000AE4, "Member 'UTYVCAnimInstance::RightHandRotationIKRoot' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightHandTransformIKRoot) == 0x000AF0, "Member 'UTYVCAnimInstance::RightHandTransformIKRoot' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, RightHandIKRootName) == 0x000B20, "Member 'UTYVCAnimInstance::RightHandIKRootName' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, LeftHandGripIKRootName) == 0x000B28, "Member 'UTYVCAnimInstance::LeftHandGripIKRootName' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldGunBeIK) == 0x000B30, "Member 'UTYVCAnimInstance::bShouldGunBeIK' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, WallRunCamDifference) == 0x000B34, "Member 'UTYVCAnimInstance::WallRunCamDifference' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bTurningInPlace) == 0x000B38, "Member 'UTYVCAnimInstance::bTurningInPlace' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bTurningRight) == 0x000B39, "Member 'UTYVCAnimInstance::bTurningRight' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, bShouldTurnInPlace) == 0x000B3A, "Member 'UTYVCAnimInstance::bShouldTurnInPlace' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, AimYawLimit) == 0x000B3C, "Member 'UTYVCAnimInstance::AimYawLimit' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, TurnLAnim) == 0x000B40, "Member 'UTYVCAnimInstance::TurnLAnim' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, TurnRAnim) == 0x000B48, "Member 'UTYVCAnimInstance::TurnRAnim' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, ClavicleRotation) == 0x000B50, "Member 'UTYVCAnimInstance::ClavicleRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, BaseClavicleRotation) == 0x000B5C, "Member 'UTYVCAnimInstance::BaseClavicleRotation' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, BaseClavicleRotationSpineSpace) == 0x000B68, "Member 'UTYVCAnimInstance::BaseClavicleRotationSpineSpace' has a wrong offset!");
static_assert(offsetof(UTYVCAnimInstance, ClavicleRotationSpineSpace) == 0x000B74, "Member 'UTYVCAnimInstance::ClavicleRotationSpineSpace' has a wrong offset!");

// Class ThankYouVeryCool.TYVCConsoleFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTYVCConsoleFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EPlatformName GetCurrentPlatform();
	static EPlatformRegion GetCurrentPlatformRegion();
	static class UTexture2D* GetGamepadButtonIcon(const class UObject* WorldContextObject, const struct FKey& Key);
	static bool IsDemo();
	static bool IsEnterButtonSwapped();
	static bool IsPlatform(EPlatformName PlatformName);
	static bool IsPlatformRegion(EPlatformRegion PlatformRegion);
	static bool IsSwitchPortable();
	static bool IsXboxSeriesS();
	static EPlatformName PlatformNameFromString(const class FString& PlatformNameString);
	static class FString PlatformNameToString(EPlatformName PlatformName);
	static EPlatformRegion PlatformRegionFromString(const class FString& PlatformRegionString);
	static class FString PlatformRegionToString(EPlatformRegion PlatformRegion);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCConsoleFunctionLibrary">();
	}
	static class UTYVCConsoleFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCConsoleFunctionLibrary>();
	}
};
static_assert(alignof(UTYVCConsoleFunctionLibrary) == 0x000008, "Wrong alignment on UTYVCConsoleFunctionLibrary");
static_assert(sizeof(UTYVCConsoleFunctionLibrary) == 0x000028, "Wrong size on UTYVCConsoleFunctionLibrary");

// Class ThankYouVeryCool.TYVCLeaderboardWriteData
// 0x0038 (0x0060 - 0x0028)
class UTYVCLeaderboardWriteData final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCLeaderboardWriteData">();
	}
	static class UTYVCLeaderboardWriteData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCLeaderboardWriteData>();
	}
};
static_assert(alignof(UTYVCLeaderboardWriteData) == 0x000008, "Wrong alignment on UTYVCLeaderboardWriteData");
static_assert(sizeof(UTYVCLeaderboardWriteData) == 0x000060, "Wrong size on UTYVCLeaderboardWriteData");

// Class ThankYouVeryCool.TYVCLeaderboardReadData
// 0x0048 (0x0070 - 0x0028)
class UTYVCLeaderboardReadData final : public UObject
{
public:
	uint8                                         Pad_28[0x48];                                      // 0x0028(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCLeaderboardReadData">();
	}
	static class UTYVCLeaderboardReadData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCLeaderboardReadData>();
	}
};
static_assert(alignof(UTYVCLeaderboardReadData) == 0x000008, "Wrong alignment on UTYVCLeaderboardReadData");
static_assert(sizeof(UTYVCLeaderboardReadData) == 0x000070, "Wrong size on UTYVCLeaderboardReadData");

// Class ThankYouVeryCool.TYVCGameInstance
// 0x0000 (0x01A8 - 0x01A8)
class UTYVCGameInstance : public UGameInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCGameInstance">();
	}
	static class UTYVCGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCGameInstance>();
	}
};
static_assert(alignof(UTYVCGameInstance) == 0x000008, "Wrong alignment on UTYVCGameInstance");
static_assert(sizeof(UTYVCGameInstance) == 0x0001A8, "Wrong size on UTYVCGameInstance");

// Class ThankYouVeryCool.TYVCHISMComponent
// 0x0000 (0x0680 - 0x0680)
class UTYVCHISMComponent final : public UHierarchicalInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCHISMComponent">();
	}
	static class UTYVCHISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCHISMComponent>();
	}
};
static_assert(alignof(UTYVCHISMComponent) == 0x000010, "Wrong alignment on UTYVCHISMComponent");
static_assert(sizeof(UTYVCHISMComponent) == 0x000680, "Wrong size on UTYVCHISMComponent");

// Class ThankYouVeryCool.TYVCLight_Point
// 0x0008 (0x0398 - 0x0390)
class ATYVCLight_Point final : public ATYVCLight
{
public:
	class UPointLightComponent*                   PointLight;                                        // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCLight_Point">();
	}
	static class ATYVCLight_Point* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCLight_Point>();
	}
};
static_assert(alignof(ATYVCLight_Point) == 0x000008, "Wrong alignment on ATYVCLight_Point");
static_assert(sizeof(ATYVCLight_Point) == 0x000398, "Wrong size on ATYVCLight_Point");
static_assert(offsetof(ATYVCLight_Point, PointLight) == 0x000390, "Member 'ATYVCLight_Point::PointLight' has a wrong offset!");

// Class ThankYouVeryCool.TYVCNoClippingComponent
// 0x0000 (0x0280 - 0x0280)
class UTYVCNoClippingComponent final : public UVoxelNoClippingComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCNoClippingComponent">();
	}
	static class UTYVCNoClippingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCNoClippingComponent>();
	}
};
static_assert(alignof(UTYVCNoClippingComponent) == 0x000010, "Wrong alignment on UTYVCNoClippingComponent");
static_assert(sizeof(UTYVCNoClippingComponent) == 0x000280, "Wrong size on UTYVCNoClippingComponent");

// Class ThankYouVeryCool.TYVCPhysicsVolume
// 0x0000 (0x0268 - 0x0268)
class ATYVCPhysicsVolume final : public APhysicsVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCPhysicsVolume">();
	}
	static class ATYVCPhysicsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCPhysicsVolume>();
	}
};
static_assert(alignof(ATYVCPhysicsVolume) == 0x000008, "Wrong alignment on ATYVCPhysicsVolume");
static_assert(sizeof(ATYVCPhysicsVolume) == 0x000268, "Wrong size on ATYVCPhysicsVolume");

// Class ThankYouVeryCool.TYVCProbeLight
// 0x0000 (0x0220 - 0x0220)
class ATYVCProbeLight final : public AActor
{
public:
	void UpdateLight(const struct FLinearColor& Color, float Brightness);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCProbeLight">();
	}
	static class ATYVCProbeLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCProbeLight>();
	}
};
static_assert(alignof(ATYVCProbeLight) == 0x000008, "Wrong alignment on ATYVCProbeLight");
static_assert(sizeof(ATYVCProbeLight) == 0x000220, "Wrong size on ATYVCProbeLight");

// Class ThankYouVeryCool.TYVCProjectile
// 0x0010 (0x01E0 - 0x01D0)
class UTYVCProjectile final : public UProjectileMovementComponent
{
public:
	TMulticastInlineDelegate<void(struct FHitResult& ImpactResult)> OnProjectileImpact;                                // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCProjectile">();
	}
	static class UTYVCProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCProjectile>();
	}
};
static_assert(alignof(UTYVCProjectile) == 0x000010, "Wrong alignment on UTYVCProjectile");
static_assert(sizeof(UTYVCProjectile) == 0x0001E0, "Wrong size on UTYVCProjectile");
static_assert(offsetof(UTYVCProjectile, OnProjectileImpact) == 0x0001D0, "Member 'UTYVCProjectile::OnProjectileImpact' has a wrong offset!");

// Class ThankYouVeryCool.TYVCSaveController
// 0x01A0 (0x01D0 - 0x0030)
class UTYVCSaveController final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnInitialLoadComplete;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& SlotName, class USaveGame* SaveGame)> OnPreloadComplete;                                 // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& SlotName)> OnSaveComplete;                                    // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x168];                                     // 0x0068(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoInitialLoad(const TArray<class FString>& SlotsToLoad);
	bool GetAnySaveInProgress();
	bool GetInitialLoadComplete();
	bool GetSaveExists(const class FString& SlotName);
	bool GetSaveInProgress(const class FString& SlotName);
	bool GetSaveLoaded(const class FString& SlotName);
	class USaveGame* Load(const class FString& SlotName);
	void Preload(const class FString& SlotName);
	bool ResetSaveController();
	bool Save(const class FString& SlotName, class USaveGame* SaveGame);
	bool SaveWithMetaData(const class FString& SlotName, class USaveGame* SaveGame, const class FText& DisplayName, const class FText& DisplaySubtitle, const class FText& DisplayDescription, const class FString& IconPath, int32 MaxBytes, bool KeepMetaData);
	void SetSaveMetadata(const class FString& SlotName, const class FText& DisplayName, const class FText& DisplaySubtitle, const class FText& DisplayDescription, const class FString& IconPath, int32 MaxBytes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCSaveController">();
	}
	static class UTYVCSaveController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCSaveController>();
	}
};
static_assert(alignof(UTYVCSaveController) == 0x000008, "Wrong alignment on UTYVCSaveController");
static_assert(sizeof(UTYVCSaveController) == 0x0001D0, "Wrong size on UTYVCSaveController");
static_assert(offsetof(UTYVCSaveController, OnInitialLoadComplete) == 0x000038, "Member 'UTYVCSaveController::OnInitialLoadComplete' has a wrong offset!");
static_assert(offsetof(UTYVCSaveController, OnPreloadComplete) == 0x000048, "Member 'UTYVCSaveController::OnPreloadComplete' has a wrong offset!");
static_assert(offsetof(UTYVCSaveController, OnSaveComplete) == 0x000058, "Member 'UTYVCSaveController::OnSaveComplete' has a wrong offset!");

// Class ThankYouVeryCool.TYVCSky
// 0x0000 (0x0220 - 0x0220)
class ATYVCSky : public AActor
{
public:
	float GetTime();
	float SetTime(float InTime);
	void SetUseSkylight(bool bUse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCSky">();
	}
	static class ATYVCSky* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATYVCSky>();
	}
};
static_assert(alignof(ATYVCSky) == 0x000008, "Wrong alignment on ATYVCSky");
static_assert(sizeof(ATYVCSky) == 0x000220, "Wrong size on ATYVCSky");

// Class ThankYouVeryCool.TYVCSonyPrivilegeManager
// 0x0018 (0x0048 - 0x0030)
class UTYVCSonyPrivilegeManager final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void()>              OnSonyPrivilegeCheckComplete;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckOnlinePrivilege();
	bool GetAllowedOnline();
	bool GetNeedsOnlineCheck();
	void ResetNeedsCheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TYVCSonyPrivilegeManager">();
	}
	static class UTYVCSonyPrivilegeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTYVCSonyPrivilegeManager>();
	}
};
static_assert(alignof(UTYVCSonyPrivilegeManager) == 0x000008, "Wrong alignment on UTYVCSonyPrivilegeManager");
static_assert(sizeof(UTYVCSonyPrivilegeManager) == 0x000048, "Wrong size on UTYVCSonyPrivilegeManager");
static_assert(offsetof(UTYVCSonyPrivilegeManager, OnSonyPrivilegeCheckComplete) == 0x000030, "Member 'UTYVCSonyPrivilegeManager::OnSonyPrivilegeCheckComplete' has a wrong offset!");

// Class ThankYouVeryCool.UIKeyListener
// 0x0058 (0x0160 - 0x0108)
class UUIKeyListener final : public UWidget
{
public:
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartActive;                                      // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bListenForAllKeys;                                 // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_112[0x6];                                      // 0x0112(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKey>                           ListenForKeys;                                     // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FKey& Key)> OnUIKeyListenerKeyDown;                            // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FKey& Key)> OnUIKeyListenerKeyUp;                              // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActive(bool bInIsActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIKeyListener">();
	}
	static class UUIKeyListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIKeyListener>();
	}
};
static_assert(alignof(UUIKeyListener) == 0x000008, "Wrong alignment on UUIKeyListener");
static_assert(sizeof(UUIKeyListener) == 0x000160, "Wrong size on UUIKeyListener");
static_assert(offsetof(UUIKeyListener, bStartActive) == 0x000110, "Member 'UUIKeyListener::bStartActive' has a wrong offset!");
static_assert(offsetof(UUIKeyListener, bListenForAllKeys) == 0x000111, "Member 'UUIKeyListener::bListenForAllKeys' has a wrong offset!");
static_assert(offsetof(UUIKeyListener, ListenForKeys) == 0x000118, "Member 'UUIKeyListener::ListenForKeys' has a wrong offset!");
static_assert(offsetof(UUIKeyListener, OnUIKeyListenerKeyDown) == 0x000128, "Member 'UUIKeyListener::OnUIKeyListenerKeyDown' has a wrong offset!");
static_assert(offsetof(UUIKeyListener, OnUIKeyListenerKeyUp) == 0x000138, "Member 'UUIKeyListener::OnUIKeyListenerKeyUp' has a wrong offset!");

// Class ThankYouVeryCool.VictoryWidget
// 0x0010 (0x0270 - 0x0260)
class UVictoryWidget : public UUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnVictoryWidgetReturnToLevelSelect;                // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DoArcadeVictory(int32 StartingPoints, int32 EndPoints, int32 ScoreThisRound, float TimeThisRound, bool bBeatOldScore, int32 OldScore, bool bBeatOldTime, float OldTime);
	void DoCampaignVictory(float TimeThisRound, float OldTime);
	void FinishReturnToLevelSelect();
	void K2_ReturnToLevelSelect();
	void MattsSuperSpecialLeaderboardComplete(bool bSuccess);
	void ReturnToLevelSelect();
	void ShowUploadResult(ELeaderboardResult LeaderboardResult, bool bWriteLeaderboardEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictoryWidget">();
	}
	static class UVictoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVictoryWidget>();
	}
};
static_assert(alignof(UVictoryWidget) == 0x000008, "Wrong alignment on UVictoryWidget");
static_assert(sizeof(UVictoryWidget) == 0x000270, "Wrong size on UVictoryWidget");
static_assert(offsetof(UVictoryWidget, OnVictoryWidgetReturnToLevelSelect) == 0x000260, "Member 'UVictoryWidget::OnVictoryWidgetReturnToLevelSelect' has a wrong offset!");

// Class ThankYouVeryCool.VoxelBodyProceduralMeshComponent
// 0x0000 (0x0630 - 0x0630)
class UVoxelBodyProceduralMeshComponent final : public UVoxelProceduralMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelBodyProceduralMeshComponent">();
	}
	static class UVoxelBodyProceduralMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoxelBodyProceduralMeshComponent>();
	}
};
static_assert(alignof(UVoxelBodyProceduralMeshComponent) == 0x000010, "Wrong alignment on UVoxelBodyProceduralMeshComponent");
static_assert(sizeof(UVoxelBodyProceduralMeshComponent) == 0x000630, "Wrong size on UVoxelBodyProceduralMeshComponent");

// Class ThankYouVeryCool.VoxelLight
// 0x0008 (0x0A20 - 0x0A18)
class AVoxelLight final : public AVoxelBuilder2
{
public:
	class ULightComponent*                        LightComponent;                                    // 0x0A18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddSpotlightAtTurtle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoxelLight">();
	}
	static class AVoxelLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoxelLight>();
	}
};
static_assert(alignof(AVoxelLight) == 0x000008, "Wrong alignment on AVoxelLight");
static_assert(sizeof(AVoxelLight) == 0x000A20, "Wrong size on AVoxelLight");
static_assert(offsetof(AVoxelLight, LightComponent) == 0x000A18, "Member 'AVoxelLight::LightComponent' has a wrong offset!");

// Class ThankYouVeryCool.WeaponBase
// 0x04C0 (0x06E0 - 0x0220)
class AWeaponBase : public AActor
{
public:
	uint8                                         Pad_220[0x20];                                     // 0x0220(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UnlockKey;                                         // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0248(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x4];                                      // 0x0260(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HolsteredOffset;                                   // 0x0264(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       EmptyComp;                                         // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnAsEmpty;                                     // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0xF];                                      // 0x0281(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PreviewTransform;                                  // 0x0290(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EWeaponCategory                               WeaponCategory;                                    // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x1];                                      // 0x02C1(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanBeSuppressed;                                  // 0x02C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSuppressed;                                     // 0x02C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   WeaponName;                                        // 0x02C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x9];                                      // 0x02E0(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsSprawlGun;                                      // 0x02E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EA[0x2];                                      // 0x02EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprawlForce;                                       // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASpentShell>                ShellClass;                                        // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       GunDynMaterials;                                   // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       ShinyDynMaterials;                                 // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_318[0x18];                                     // 0x0318(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EALSOverlayState                              NPCGripType;                                       // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGunAnimInstance*                       GunAnimInstance;                                   // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UArrowComponent*                        MagEjectArrow;                                     // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPointLightComponent*                   MuzzleFlashPointLight;                             // 0x0358(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        ShellEjectArrow;                                   // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UStaticMeshComponent*>           AttachmentMeshes;                                  // 0x0368(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   CachedFeedback;                                    // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFireModeType                                 FireMode;                                          // 0x0388(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatineeCameraShake>        RecoilCameraShake;                                 // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrosshairSpreadOnShot;                             // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 GunMesh;                                           // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAmmoIndicatorComponent*>        AmmoIndicators;                                    // 0x03A8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EImpactType                                   Caliber;                                           // 0x03B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      PickupCapsule;                                     // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasLoopingReload;                                 // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         TracerEffect;                                      // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x4];                                      // 0x03D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlashBrightness;                                   // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AImpactManager*                         ImpactManager;                                     // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimeline                              RecoilTimeline;                                    // 0x03F0(0x0098)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimeline                              MuzzleFlashTimeline;                               // 0x0488(0x0098)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FTimeline>                      RecoilTimelines;                                   // 0x0520(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            RecoilCurve;                                       // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_538[0x8];                                      // 0x0538(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ANPC*                                   NPC;                                               // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCharacter*                       Player;                                            // 0x0550(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireAnimationMontage;                              // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireAnimationMontageLastShot;                      // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FireAnimationMontageForHands;                      // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DrawAnimationForHands;                             // 0x0570(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleAnim;                                          // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          MovingAnim;                                        // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          MovingReadyAnim;                                   // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThirdPersonReloadAnim;                             // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThirdPersonLoopingReloadAnim;                      // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           NPCFireMontage;                                    // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LevelStartTransform;                               // 0x05B0(0x0030)(IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                             FireSound;                                         // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             FireSoundSuppressed;                               // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MuzzleFlash;                                       // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RoundsPerMinute;                                   // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x1];                                      // 0x05FC(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsShotgun;                                        // 0x05FD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSMG;                                            // 0x05FE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHideFromConsoles;                                 // 0x05FF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLauncher;                                       // 0x0600(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_601[0x7];                                      // 0x0601(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AM203_Round>                LaunchedClass;                                     // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ShotPelletCount;                                   // 0x0610(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_614[0x4];                                      // 0x0614(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundConcurrency*                      ConcurrencyRules;                                  // 0x0618(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundConcurrency*                      ConcurrencyRulesNPC;                               // 0x0620(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundAttenuation*                      Attenuation;                                       // 0x0628(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MagazineSize;                                      // 0x0630(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoundsInMagazine;                                  // 0x0634(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        AudioComponent;                                    // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AThankYouVeryCoolGameMode*              TYVCGameMode;                                      // 0x0640(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             ChorusFireSound;                                   // 0x0650(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CustomOffset;                                      // 0x0658(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinBulletSpread;                                   // 0x0664(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_668[0x4];                                      // 0x0668(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxBulletSpread;                                   // 0x066C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        FireSoundNPCAuto;                                  // 0x0670(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        FireSoundNPCTrail;                                 // 0x0678(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AkimboModifier;                                    // 0x0680(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AkimboLocationOffset;                              // 0x068C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_698[0x2C];                                     // 0x0698(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HandsAttachSocket;                                 // 0x06C4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6CC[0x14];                                     // 0x06CC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FHitResult GetNPCHit(class UObject* Context, const struct FVector& BulletOrigin, const struct FVector& InVector, float InAccuracy, float InRange, bool bMustMissPlayer);

	bool ActorRequestPickUp(class AActor* Actor, bool AsSideArm);
	void AddRecoil();
	void CycleComplete();
	void DrawComplete();
	void DroppedEvent();
	void EmptyEvent();
	void FinishMuzzleFlash();
	EImpactType GetCaliber();
	EFireModeType GetFireModeType();
	class AActor* GetHolder();
	struct FLinearColor GetIndicatorColor();
	void HolsterComplete();
	bool IsHeld();
	void IterateReloadLoop();
	void LevelReady();
	void MakePreview();
	void OnThrownHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnThrownOverlappedSomething(class UPrimitiveComponent* OverlapComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnThrownStop(const struct FHitResult& ImpactResult);
	void PullTrigger();
	void Randomize();
	void ReleaseTrigger();
	void ReloadFinished(class UAnimMontage* AnimMontage, bool bInterrupted);
	void SetAsCloaked(bool bCloaked);
	void SetAsShiny(EShineLevel ForShineLevel);
	void SetupAsSuppressed(bool bSuppressed);
	void ShootEvent();
	void StartReloadLoop();
	void StopRecoil();
	void TickMuzzleFlash(float Value);
	void TriggerReleasedEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponBase">();
	}
	static class AWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponBase>();
	}
};
static_assert(alignof(AWeaponBase) == 0x000010, "Wrong alignment on AWeaponBase");
static_assert(sizeof(AWeaponBase) == 0x0006E0, "Wrong size on AWeaponBase");
static_assert(offsetof(AWeaponBase, UnlockKey) == 0x000240, "Member 'AWeaponBase::UnlockKey' has a wrong offset!");
static_assert(offsetof(AWeaponBase, Description) == 0x000248, "Member 'AWeaponBase::Description' has a wrong offset!");
static_assert(offsetof(AWeaponBase, HolsteredOffset) == 0x000264, "Member 'AWeaponBase::HolsteredOffset' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MaxRange) == 0x000270, "Member 'AWeaponBase::MaxRange' has a wrong offset!");
static_assert(offsetof(AWeaponBase, EmptyComp) == 0x000278, "Member 'AWeaponBase::EmptyComp' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bSpawnAsEmpty) == 0x000280, "Member 'AWeaponBase::bSpawnAsEmpty' has a wrong offset!");
static_assert(offsetof(AWeaponBase, PreviewTransform) == 0x000290, "Member 'AWeaponBase::PreviewTransform' has a wrong offset!");
static_assert(offsetof(AWeaponBase, WeaponCategory) == 0x0002C0, "Member 'AWeaponBase::WeaponCategory' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bCanBeSuppressed) == 0x0002C2, "Member 'AWeaponBase::bCanBeSuppressed' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bIsSuppressed) == 0x0002C3, "Member 'AWeaponBase::bIsSuppressed' has a wrong offset!");
static_assert(offsetof(AWeaponBase, WeaponName) == 0x0002C8, "Member 'AWeaponBase::WeaponName' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bIsSprawlGun) == 0x0002E9, "Member 'AWeaponBase::bIsSprawlGun' has a wrong offset!");
static_assert(offsetof(AWeaponBase, SprawlForce) == 0x0002EC, "Member 'AWeaponBase::SprawlForce' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ShellClass) == 0x0002F0, "Member 'AWeaponBase::ShellClass' has a wrong offset!");
static_assert(offsetof(AWeaponBase, GunDynMaterials) == 0x0002F8, "Member 'AWeaponBase::GunDynMaterials' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ShinyDynMaterials) == 0x000308, "Member 'AWeaponBase::ShinyDynMaterials' has a wrong offset!");
static_assert(offsetof(AWeaponBase, NPCGripType) == 0x000330, "Member 'AWeaponBase::NPCGripType' has a wrong offset!");
static_assert(offsetof(AWeaponBase, GunAnimInstance) == 0x000338, "Member 'AWeaponBase::GunAnimInstance' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MagEjectArrow) == 0x000350, "Member 'AWeaponBase::MagEjectArrow' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MuzzleFlashPointLight) == 0x000358, "Member 'AWeaponBase::MuzzleFlashPointLight' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ShellEjectArrow) == 0x000360, "Member 'AWeaponBase::ShellEjectArrow' has a wrong offset!");
static_assert(offsetof(AWeaponBase, AttachmentMeshes) == 0x000368, "Member 'AWeaponBase::AttachmentMeshes' has a wrong offset!");
static_assert(offsetof(AWeaponBase, CachedFeedback) == 0x000378, "Member 'AWeaponBase::CachedFeedback' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ProjectileMovementComponent) == 0x000380, "Member 'AWeaponBase::ProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FireMode) == 0x000388, "Member 'AWeaponBase::FireMode' has a wrong offset!");
static_assert(offsetof(AWeaponBase, RecoilCameraShake) == 0x000390, "Member 'AWeaponBase::RecoilCameraShake' has a wrong offset!");
static_assert(offsetof(AWeaponBase, CrosshairSpreadOnShot) == 0x000398, "Member 'AWeaponBase::CrosshairSpreadOnShot' has a wrong offset!");
static_assert(offsetof(AWeaponBase, GunMesh) == 0x0003A0, "Member 'AWeaponBase::GunMesh' has a wrong offset!");
static_assert(offsetof(AWeaponBase, AmmoIndicators) == 0x0003A8, "Member 'AWeaponBase::AmmoIndicators' has a wrong offset!");
static_assert(offsetof(AWeaponBase, Caliber) == 0x0003B8, "Member 'AWeaponBase::Caliber' has a wrong offset!");
static_assert(offsetof(AWeaponBase, PickupCapsule) == 0x0003C0, "Member 'AWeaponBase::PickupCapsule' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bHasLoopingReload) == 0x0003C8, "Member 'AWeaponBase::bHasLoopingReload' has a wrong offset!");
static_assert(offsetof(AWeaponBase, TracerEffect) == 0x0003D0, "Member 'AWeaponBase::TracerEffect' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FlashBrightness) == 0x0003DC, "Member 'AWeaponBase::FlashBrightness' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ImpactManager) == 0x0003E8, "Member 'AWeaponBase::ImpactManager' has a wrong offset!");
static_assert(offsetof(AWeaponBase, RecoilTimeline) == 0x0003F0, "Member 'AWeaponBase::RecoilTimeline' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MuzzleFlashTimeline) == 0x000488, "Member 'AWeaponBase::MuzzleFlashTimeline' has a wrong offset!");
static_assert(offsetof(AWeaponBase, RecoilTimelines) == 0x000520, "Member 'AWeaponBase::RecoilTimelines' has a wrong offset!");
static_assert(offsetof(AWeaponBase, RecoilCurve) == 0x000530, "Member 'AWeaponBase::RecoilCurve' has a wrong offset!");
static_assert(offsetof(AWeaponBase, NPC) == 0x000540, "Member 'AWeaponBase::NPC' has a wrong offset!");
static_assert(offsetof(AWeaponBase, Player) == 0x000550, "Member 'AWeaponBase::Player' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FireAnimationMontage) == 0x000558, "Member 'AWeaponBase::FireAnimationMontage' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FireAnimationMontageLastShot) == 0x000560, "Member 'AWeaponBase::FireAnimationMontageLastShot' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FireAnimationMontageForHands) == 0x000568, "Member 'AWeaponBase::FireAnimationMontageForHands' has a wrong offset!");
static_assert(offsetof(AWeaponBase, DrawAnimationForHands) == 0x000570, "Member 'AWeaponBase::DrawAnimationForHands' has a wrong offset!");
static_assert(offsetof(AWeaponBase, IdleAnim) == 0x000578, "Member 'AWeaponBase::IdleAnim' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MovingAnim) == 0x000580, "Member 'AWeaponBase::MovingAnim' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MovingReadyAnim) == 0x000588, "Member 'AWeaponBase::MovingReadyAnim' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ThirdPersonReloadAnim) == 0x000590, "Member 'AWeaponBase::ThirdPersonReloadAnim' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ThirdPersonLoopingReloadAnim) == 0x000598, "Member 'AWeaponBase::ThirdPersonLoopingReloadAnim' has a wrong offset!");
static_assert(offsetof(AWeaponBase, NPCFireMontage) == 0x0005A0, "Member 'AWeaponBase::NPCFireMontage' has a wrong offset!");
static_assert(offsetof(AWeaponBase, LevelStartTransform) == 0x0005B0, "Member 'AWeaponBase::LevelStartTransform' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FireSound) == 0x0005E0, "Member 'AWeaponBase::FireSound' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FireSoundSuppressed) == 0x0005E8, "Member 'AWeaponBase::FireSoundSuppressed' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MuzzleFlash) == 0x0005F0, "Member 'AWeaponBase::MuzzleFlash' has a wrong offset!");
static_assert(offsetof(AWeaponBase, RoundsPerMinute) == 0x0005F8, "Member 'AWeaponBase::RoundsPerMinute' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bIsShotgun) == 0x0005FD, "Member 'AWeaponBase::bIsShotgun' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bIsSMG) == 0x0005FE, "Member 'AWeaponBase::bIsSMG' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bHideFromConsoles) == 0x0005FF, "Member 'AWeaponBase::bHideFromConsoles' has a wrong offset!");
static_assert(offsetof(AWeaponBase, bIsLauncher) == 0x000600, "Member 'AWeaponBase::bIsLauncher' has a wrong offset!");
static_assert(offsetof(AWeaponBase, LaunchedClass) == 0x000608, "Member 'AWeaponBase::LaunchedClass' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ShotPelletCount) == 0x000610, "Member 'AWeaponBase::ShotPelletCount' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ConcurrencyRules) == 0x000618, "Member 'AWeaponBase::ConcurrencyRules' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ConcurrencyRulesNPC) == 0x000620, "Member 'AWeaponBase::ConcurrencyRulesNPC' has a wrong offset!");
static_assert(offsetof(AWeaponBase, Attenuation) == 0x000628, "Member 'AWeaponBase::Attenuation' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MagazineSize) == 0x000630, "Member 'AWeaponBase::MagazineSize' has a wrong offset!");
static_assert(offsetof(AWeaponBase, RoundsInMagazine) == 0x000634, "Member 'AWeaponBase::RoundsInMagazine' has a wrong offset!");
static_assert(offsetof(AWeaponBase, AudioComponent) == 0x000638, "Member 'AWeaponBase::AudioComponent' has a wrong offset!");
static_assert(offsetof(AWeaponBase, TYVCGameMode) == 0x000640, "Member 'AWeaponBase::TYVCGameMode' has a wrong offset!");
static_assert(offsetof(AWeaponBase, ChorusFireSound) == 0x000650, "Member 'AWeaponBase::ChorusFireSound' has a wrong offset!");
static_assert(offsetof(AWeaponBase, CustomOffset) == 0x000658, "Member 'AWeaponBase::CustomOffset' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MinBulletSpread) == 0x000664, "Member 'AWeaponBase::MinBulletSpread' has a wrong offset!");
static_assert(offsetof(AWeaponBase, MaxBulletSpread) == 0x00066C, "Member 'AWeaponBase::MaxBulletSpread' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FireSoundNPCAuto) == 0x000670, "Member 'AWeaponBase::FireSoundNPCAuto' has a wrong offset!");
static_assert(offsetof(AWeaponBase, FireSoundNPCTrail) == 0x000678, "Member 'AWeaponBase::FireSoundNPCTrail' has a wrong offset!");
static_assert(offsetof(AWeaponBase, AkimboModifier) == 0x000680, "Member 'AWeaponBase::AkimboModifier' has a wrong offset!");
static_assert(offsetof(AWeaponBase, AkimboLocationOffset) == 0x00068C, "Member 'AWeaponBase::AkimboLocationOffset' has a wrong offset!");
static_assert(offsetof(AWeaponBase, HandsAttachSocket) == 0x0006C4, "Member 'AWeaponBase::HandsAttachSocket' has a wrong offset!");

// Class ThankYouVeryCool.WeaponPreview
// 0x0038 (0x0258 - 0x0220)
class AWeaponPreview : public AActor
{
public:
	class USceneComponent*                        RootComp;                                          // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        MeshRoot;                                          // 0x0228(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               CapComp;                                           // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               CapCompDepth;                                      // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentShown;                                      // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AArmCannon>                 ArmCannonClass;                                    // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableRotate();
	void EnableRotate();
	class AActor* GetCurrentShown();
	float GetYawOffset();
	void LevelReady();
	void Preview(TSubclassOf<class AActor> ToPreview);
	void PreviewCannon(ECannonMode ForMode);
	void SetLivePreview(bool bin);
	void SetRenderActive(bool bActive);
	void SetYawOffset(float In);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponPreview">();
	}
	static class AWeaponPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponPreview>();
	}
};
static_assert(alignof(AWeaponPreview) == 0x000008, "Wrong alignment on AWeaponPreview");
static_assert(sizeof(AWeaponPreview) == 0x000258, "Wrong size on AWeaponPreview");
static_assert(offsetof(AWeaponPreview, RootComp) == 0x000220, "Member 'AWeaponPreview::RootComp' has a wrong offset!");
static_assert(offsetof(AWeaponPreview, MeshRoot) == 0x000228, "Member 'AWeaponPreview::MeshRoot' has a wrong offset!");
static_assert(offsetof(AWeaponPreview, CapComp) == 0x000230, "Member 'AWeaponPreview::CapComp' has a wrong offset!");
static_assert(offsetof(AWeaponPreview, CapCompDepth) == 0x000238, "Member 'AWeaponPreview::CapCompDepth' has a wrong offset!");
static_assert(offsetof(AWeaponPreview, CurrentShown) == 0x000240, "Member 'AWeaponPreview::CurrentShown' has a wrong offset!");
static_assert(offsetof(AWeaponPreview, ArmCannonClass) == 0x000248, "Member 'AWeaponPreview::ArmCannonClass' has a wrong offset!");

// Class ThankYouVeryCool.WirelessPowerNode
// 0x0018 (0x0238 - 0x0220)
class AWirelessPowerNode final : public AActor
{
public:
	TArray<class ATYVCActor*>                     PoweredActors;                                     // 0x0220(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UBoxComponent*                          BoxComp;                                           // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerUse();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WirelessPowerNode">();
	}
	static class AWirelessPowerNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWirelessPowerNode>();
	}
};
static_assert(alignof(AWirelessPowerNode) == 0x000008, "Wrong alignment on AWirelessPowerNode");
static_assert(sizeof(AWirelessPowerNode) == 0x000238, "Wrong size on AWirelessPowerNode");
static_assert(offsetof(AWirelessPowerNode, PoweredActors) == 0x000220, "Member 'AWirelessPowerNode::PoweredActors' has a wrong offset!");
static_assert(offsetof(AWirelessPowerNode, BoxComp) == 0x000230, "Member 'AWirelessPowerNode::BoxComp' has a wrong offset!");

// Class ThankYouVeryCool.WorkshopChapter
// 0x00D0 (0x0418 - 0x0348)
class AWorkshopChapter : public AChapter
{
public:
	TArray<struct FStage>                         Stages;                                            // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FChapterMusicInfo                      MusicInfo;                                         // 0x0358(0x0008)(Edit, BlueprintVisible, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CurrentStage;                                      // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWorkshopChapterData                   CachedData;                                        // 0x0368(0x0020)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   NextChapterAsset;                                  // 0x0398(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoEdenMap;                                        // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDidSimulatedMusicPlay;                            // 0x03C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C2[0x2];                                      // 0x03C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EdenFrom;                                          // 0x03C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EdenTo;                                            // 0x03CC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomEnd;                                        // 0x03D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighestCheckpointReached;                          // 0x03D8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomCampaignText                    TextToShow;                                        // 0x03E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsInCustomCampaign;                               // 0x03F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrentCustomSublevel;                             // 0x03F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorkshopID;                                        // 0x0408(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void DoAction(const struct FAction& InAction, bool bSimulated);
	void DoActionsForStage(int32 ForStage, bool bSimulated);
	void DoCustomEnd();
	void ForceSkip();
	void MarkAllGoalsIncomplete();
	void NotifyEnd();
	bool NotifyGoalComplete(class FName ForID, EGoalType ForGoal);
	void NotifyNextStage();
	void SimulateGoalComplete(class FName ForID, EGoalType ForGoal);
	void SteelDiedInternal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorkshopChapter">();
	}
	static class AWorkshopChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorkshopChapter>();
	}
};
static_assert(alignof(AWorkshopChapter) == 0x000008, "Wrong alignment on AWorkshopChapter");
static_assert(sizeof(AWorkshopChapter) == 0x000418, "Wrong size on AWorkshopChapter");
static_assert(offsetof(AWorkshopChapter, Stages) == 0x000348, "Member 'AWorkshopChapter::Stages' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, MusicInfo) == 0x000358, "Member 'AWorkshopChapter::MusicInfo' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, CurrentStage) == 0x000360, "Member 'AWorkshopChapter::CurrentStage' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, CachedData) == 0x000368, "Member 'AWorkshopChapter::CachedData' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, NextChapterAsset) == 0x000398, "Member 'AWorkshopChapter::NextChapterAsset' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, bDoEdenMap) == 0x0003C0, "Member 'AWorkshopChapter::bDoEdenMap' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, bDidSimulatedMusicPlay) == 0x0003C1, "Member 'AWorkshopChapter::bDidSimulatedMusicPlay' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, EdenFrom) == 0x0003C4, "Member 'AWorkshopChapter::EdenFrom' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, EdenTo) == 0x0003CC, "Member 'AWorkshopChapter::EdenTo' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, bCustomEnd) == 0x0003D4, "Member 'AWorkshopChapter::bCustomEnd' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, HighestCheckpointReached) == 0x0003D8, "Member 'AWorkshopChapter::HighestCheckpointReached' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, TextToShow) == 0x0003E0, "Member 'AWorkshopChapter::TextToShow' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, bIsInCustomCampaign) == 0x0003F0, "Member 'AWorkshopChapter::bIsInCustomCampaign' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, CurrentCustomSublevel) == 0x0003F8, "Member 'AWorkshopChapter::CurrentCustomSublevel' has a wrong offset!");
static_assert(offsetof(AWorkshopChapter, WorkshopID) == 0x000408, "Member 'AWorkshopChapter::WorkshopID' has a wrong offset!");

// Class ThankYouVeryCool.WorldBoundsDisplay
// 0x0008 (0x0228 - 0x0220)
class AWorldBoundsDisplay : public AActor
{
public:
	class UStaticMeshComponent*                   VizMesh;                                           // 0x0220(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldBoundsDisplay">();
	}
	static class AWorldBoundsDisplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldBoundsDisplay>();
	}
};
static_assert(alignof(AWorldBoundsDisplay) == 0x000008, "Wrong alignment on AWorldBoundsDisplay");
static_assert(sizeof(AWorldBoundsDisplay) == 0x000228, "Wrong size on AWorldBoundsDisplay");
static_assert(offsetof(AWorldBoundsDisplay, VizMesh) == 0x000220, "Member 'AWorldBoundsDisplay::VizMesh' has a wrong offset!");

}

