#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPF_PPT_ProjectilePathTracer

#include "Basic.hpp"

#include "BPF_PPT_ProjectilePathTracer_classes.hpp"
#include "BPF_PPT_ProjectilePathTracer_parameters.hpp"


namespace SDK
{

// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Spawn Trajectory Beam with Points
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Beam_Size                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture*                         Beam_Point_Texture                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture*                         Marker_Texture                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UMaterialInstanceDynamic*> MID_Array_Reference                                    (Parm, OutParm)
// TArray<class UParticleSystemComponent*> Trajectory_Beam_Reference                              (Parm, OutParm, ContainsInstancedReference)
// class UParticleSystemComponent*         TrajectoryMarker_Reference                             (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPF_PPT_ProjectilePathTracer_C::Spawn_Trajectory_Beam_with_Points(int32 Divisions, float Beam_Size, const struct FLinearColor& Color, class UTexture* Beam_Point_Texture, class UTexture* Marker_Texture, class UObject* __WorldContext, TArray<class UMaterialInstanceDynamic*>* MID_Array_Reference, TArray<class UParticleSystemComponent*>* Trajectory_Beam_Reference, class UParticleSystemComponent** TrajectoryMarker_Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Spawn Trajectory Beam with Points");

	Params::BPF_PPT_ProjectilePathTracer_C_Spawn_Trajectory_Beam_with_Points Parms{};

	Parms.Divisions = Divisions;
	Parms.Beam_Size = Beam_Size;
	Parms.Color = std::move(Color);
	Parms.Beam_Point_Texture = Beam_Point_Texture;
	Parms.Marker_Texture = Marker_Texture;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (MID_Array_Reference != nullptr)
		*MID_Array_Reference = std::move(Parms.MID_Array_Reference);

	if (Trajectory_Beam_Reference != nullptr)
		*Trajectory_Beam_Reference = std::move(Parms.Trajectory_Beam_Reference);

	if (TrajectoryMarker_Reference != nullptr)
		*TrajectoryMarker_Reference = Parms.TrajectoryMarker_Reference;
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Set Trajectory Beam Color
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMaterialInstanceDynamic*> MID_Array_Reference                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FLinearColor                     Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPF_PPT_ProjectilePathTracer_C::Set_Trajectory_Beam_Color(TArray<class UMaterialInstanceDynamic*>& MID_Array_Reference, const struct FLinearColor& Color, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Set Trajectory Beam Color");

	Params::BPF_PPT_ProjectilePathTracer_C_Set_Trajectory_Beam_Color Parms{};

	Parms.MID_Array_Reference = std::move(MID_Array_Reference);
	Parms.Color = std::move(Color);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	MID_Array_Reference = std::move(Parms.MID_Array_Reference);
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Place Trajectory Beam
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  Trajectory_Points                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class UParticleSystemComponent*> Trajectory_Beam_Reference                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UParticleSystemComponent*         Trajectory_Marker_Reference                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Out_Hit                                                (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPF_PPT_ProjectilePathTracer_C::Place_Trajectory_Beam(TArray<struct FVector>& Trajectory_Points, TArray<class UParticleSystemComponent*>& Trajectory_Beam_Reference, class UParticleSystemComponent* Trajectory_Marker_Reference, const struct FHitResult& Out_Hit, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Place Trajectory Beam");

	Params::BPF_PPT_ProjectilePathTracer_C_Place_Trajectory_Beam Parms{};

	Parms.Trajectory_Points = std::move(Trajectory_Points);
	Parms.Trajectory_Beam_Reference = std::move(Trajectory_Beam_Reference);
	Parms.Trajectory_Marker_Reference = Trajectory_Marker_Reference;
	Parms.Out_Hit = std::move(Out_Hit);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Trajectory_Points = std::move(Parms.Trajectory_Points);
	Trajectory_Beam_Reference = std::move(Parms.Trajectory_Beam_Reference);
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Set Trajectory Beam Textures
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMaterialInstanceDynamic*> MID_Array_Reference                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UTexture*                         Beam_Point_Texture                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture*                         Marker_Texture                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPF_PPT_ProjectilePathTracer_C::Set_Trajectory_Beam_Textures(TArray<class UMaterialInstanceDynamic*>& MID_Array_Reference, class UTexture* Beam_Point_Texture, class UTexture* Marker_Texture, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Set Trajectory Beam Textures");

	Params::BPF_PPT_ProjectilePathTracer_C_Set_Trajectory_Beam_Textures Parms{};

	Parms.MID_Array_Reference = std::move(MID_Array_Reference);
	Parms.Beam_Point_Texture = Beam_Point_Texture;
	Parms.Marker_Texture = Marker_Texture;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	MID_Array_Reference = std::move(Parms.MID_Array_Reference);
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Calculate Line Trajectory
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Max_bounces                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Restitution                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Friction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Gravity_Scale                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<EObjectTypeQuery>                Object_Type                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Trace_Complex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<class AActor*>                   Actors_to_ignore                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EDrawDebugTrace                         Draw_Debug_Type                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Projectile_Movement                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Trajectory_Points                                      (Parm, OutParm)
// struct FHitResult                       Out_Hit                                                (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UBPF_PPT_ProjectilePathTracer_C::Calculate_Line_Trajectory(float Duration, int32 Divisions, const struct FVector& Location, const struct FVector& Velocity, int32 Max_bounces, float Restitution, float Friction, float Gravity_Scale, TArray<EObjectTypeQuery>& Object_Type, bool Trace_Complex, TArray<class AActor*>& Actors_to_ignore, EDrawDebugTrace Draw_Debug_Type, bool Projectile_Movement, class UObject* __WorldContext, TArray<struct FVector>* Trajectory_Points, struct FHitResult* Out_Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Calculate Line Trajectory");

	Params::BPF_PPT_ProjectilePathTracer_C_Calculate_Line_Trajectory Parms{};

	Parms.Duration = Duration;
	Parms.Divisions = Divisions;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.Max_bounces = Max_bounces;
	Parms.Restitution = Restitution;
	Parms.Friction = Friction;
	Parms.Gravity_Scale = Gravity_Scale;
	Parms.Object_Type = std::move(Object_Type);
	Parms.Trace_Complex = Trace_Complex;
	Parms.Actors_to_ignore = std::move(Actors_to_ignore);
	Parms.Draw_Debug_Type = Draw_Debug_Type;
	Parms.Projectile_Movement = Projectile_Movement;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Object_Type = std::move(Parms.Object_Type);
	Actors_to_ignore = std::move(Parms.Actors_to_ignore);

	if (Trajectory_Points != nullptr)
		*Trajectory_Points = std::move(Parms.Trajectory_Points);

	if (Out_Hit != nullptr)
		*Out_Hit = std::move(Parms.Out_Hit);
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Calculate Sphere Trajectory
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Max_bounces                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Restitution                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Friction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Gravity_Scale                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<EObjectTypeQuery>                Object_Type                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Trace_Complex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<class AActor*>                   Actors_to_ignore                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EDrawDebugTrace                         Draw_Debug_Type                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Projectile_Movement                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Trajectory_Points                                      (Parm, OutParm)
// struct FHitResult                       Out_Hit                                                (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UBPF_PPT_ProjectilePathTracer_C::Calculate_Sphere_Trajectory(float Duration, int32 Divisions, const struct FVector& Location, const struct FVector& Velocity, int32 Max_bounces, float Restitution, float Friction, float Gravity_Scale, TArray<EObjectTypeQuery>& Object_Type, bool Trace_Complex, TArray<class AActor*>& Actors_to_ignore, EDrawDebugTrace Draw_Debug_Type, float Radius, bool Projectile_Movement, class UObject* __WorldContext, TArray<struct FVector>* Trajectory_Points, struct FHitResult* Out_Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Calculate Sphere Trajectory");

	Params::BPF_PPT_ProjectilePathTracer_C_Calculate_Sphere_Trajectory Parms{};

	Parms.Duration = Duration;
	Parms.Divisions = Divisions;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.Max_bounces = Max_bounces;
	Parms.Restitution = Restitution;
	Parms.Friction = Friction;
	Parms.Gravity_Scale = Gravity_Scale;
	Parms.Object_Type = std::move(Object_Type);
	Parms.Trace_Complex = Trace_Complex;
	Parms.Actors_to_ignore = std::move(Actors_to_ignore);
	Parms.Draw_Debug_Type = Draw_Debug_Type;
	Parms.Radius = Radius;
	Parms.Projectile_Movement = Projectile_Movement;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Object_Type = std::move(Parms.Object_Type);
	Actors_to_ignore = std::move(Parms.Actors_to_ignore);

	if (Trajectory_Points != nullptr)
		*Trajectory_Points = std::move(Parms.Trajectory_Points);

	if (Out_Hit != nullptr)
		*Out_Hit = std::move(Parms.Out_Hit);
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Calculate Capsule Trajectory
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Max_bounces                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Restitution                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Friction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Gravity_Scale                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<EObjectTypeQuery>                Object_Type                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Trace_Complex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<class AActor*>                   Actors_to_ignore                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EDrawDebugTrace                         Draw_Debug_Type                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Half_Height                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Projectile_Movement                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Trajectory_Points                                      (Parm, OutParm)
// struct FHitResult                       Out_Hit                                                (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UBPF_PPT_ProjectilePathTracer_C::Calculate_Capsule_Trajectory(float Duration, int32 Divisions, const struct FVector& Location, const struct FVector& Velocity, int32 Max_bounces, float Restitution, float Friction, float Gravity_Scale, TArray<EObjectTypeQuery>& Object_Type, bool Trace_Complex, TArray<class AActor*>& Actors_to_ignore, EDrawDebugTrace Draw_Debug_Type, float Radius, float Half_Height, bool Projectile_Movement, class UObject* __WorldContext, TArray<struct FVector>* Trajectory_Points, struct FHitResult* Out_Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Calculate Capsule Trajectory");

	Params::BPF_PPT_ProjectilePathTracer_C_Calculate_Capsule_Trajectory Parms{};

	Parms.Duration = Duration;
	Parms.Divisions = Divisions;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.Max_bounces = Max_bounces;
	Parms.Restitution = Restitution;
	Parms.Friction = Friction;
	Parms.Gravity_Scale = Gravity_Scale;
	Parms.Object_Type = std::move(Object_Type);
	Parms.Trace_Complex = Trace_Complex;
	Parms.Actors_to_ignore = std::move(Actors_to_ignore);
	Parms.Draw_Debug_Type = Draw_Debug_Type;
	Parms.Radius = Radius;
	Parms.Half_Height = Half_Height;
	Parms.Projectile_Movement = Projectile_Movement;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Object_Type = std::move(Parms.Object_Type);
	Actors_to_ignore = std::move(Parms.Actors_to_ignore);

	if (Trajectory_Points != nullptr)
		*Trajectory_Points = std::move(Parms.Trajectory_Points);

	if (Out_Hit != nullptr)
		*Out_Hit = std::move(Parms.Out_Hit);
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Calculate Box Trajectory
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Max_bounces                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Restitution                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Friction                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Gravity_Scale                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<EObjectTypeQuery>                Object_Type                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Trace_Complex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<class AActor*>                   Actors_to_ignore                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// EDrawDebugTrace                         Draw_Debug_Type                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Half_Size                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Orientation                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Projectile_Movement                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>                  Trajectory_Points                                      (Parm, OutParm)
// struct FHitResult                       Out_Hit                                                (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UBPF_PPT_ProjectilePathTracer_C::Calculate_Box_Trajectory(float Duration, int32 Divisions, const struct FVector& Location, const struct FVector& Velocity, int32 Max_bounces, float Restitution, float Friction, float Gravity_Scale, TArray<EObjectTypeQuery>& Object_Type, bool Trace_Complex, TArray<class AActor*>& Actors_to_ignore, EDrawDebugTrace Draw_Debug_Type, const struct FVector& Half_Size, const struct FRotator& Orientation, bool Projectile_Movement, class UObject* __WorldContext, TArray<struct FVector>* Trajectory_Points, struct FHitResult* Out_Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Calculate Box Trajectory");

	Params::BPF_PPT_ProjectilePathTracer_C_Calculate_Box_Trajectory Parms{};

	Parms.Duration = Duration;
	Parms.Divisions = Divisions;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.Max_bounces = Max_bounces;
	Parms.Restitution = Restitution;
	Parms.Friction = Friction;
	Parms.Gravity_Scale = Gravity_Scale;
	Parms.Object_Type = std::move(Object_Type);
	Parms.Trace_Complex = Trace_Complex;
	Parms.Actors_to_ignore = std::move(Actors_to_ignore);
	Parms.Draw_Debug_Type = Draw_Debug_Type;
	Parms.Half_Size = std::move(Half_Size);
	Parms.Orientation = std::move(Orientation);
	Parms.Projectile_Movement = Projectile_Movement;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Object_Type = std::move(Parms.Object_Type);
	Actors_to_ignore = std::move(Parms.Actors_to_ignore);

	if (Trajectory_Points != nullptr)
		*Trajectory_Points = std::move(Parms.Trajectory_Points);

	if (Out_Hit != nullptr)
		*Out_Hit = std::move(Parms.Out_Hit);
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Spawn Trajectory Beam Only
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Beam_Size                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture*                         Marker_Texture                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UMaterialInstanceDynamic*> MID_Array_Reference                                    (Parm, OutParm)
// TArray<class UParticleSystemComponent*> Trajectory_Beam_Reference                              (Parm, OutParm, ContainsInstancedReference)
// class UParticleSystemComponent*         TrajectoryMarker_Reference                             (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPF_PPT_ProjectilePathTracer_C::Spawn_Trajectory_Beam_Only(int32 Divisions, float Beam_Size, const struct FLinearColor& Color, class UTexture* Marker_Texture, class UObject* __WorldContext, TArray<class UMaterialInstanceDynamic*>* MID_Array_Reference, TArray<class UParticleSystemComponent*>* Trajectory_Beam_Reference, class UParticleSystemComponent** TrajectoryMarker_Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Spawn Trajectory Beam Only");

	Params::BPF_PPT_ProjectilePathTracer_C_Spawn_Trajectory_Beam_Only Parms{};

	Parms.Divisions = Divisions;
	Parms.Beam_Size = Beam_Size;
	Parms.Color = std::move(Color);
	Parms.Marker_Texture = Marker_Texture;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (MID_Array_Reference != nullptr)
		*MID_Array_Reference = std::move(Parms.MID_Array_Reference);

	if (Trajectory_Beam_Reference != nullptr)
		*Trajectory_Beam_Reference = std::move(Parms.Trajectory_Beam_Reference);

	if (TrajectoryMarker_Reference != nullptr)
		*TrajectoryMarker_Reference = Parms.TrajectoryMarker_Reference;
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Spawn Trajectory Points Only
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Divisions                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Point_Size                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture*                         Point_Texture                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture*                         Marker_Texture                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Points_face_up                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UMaterialInstanceDynamic*> MID_Array_Reference                                    (Parm, OutParm)
// TArray<class UParticleSystemComponent*> Trajectory_Beam_Reference                              (Parm, OutParm, ContainsInstancedReference)
// class UParticleSystemComponent*         TrajectoryMarker_Reference                             (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPF_PPT_ProjectilePathTracer_C::Spawn_Trajectory_Points_Only(int32 Divisions, float Point_Size, const struct FLinearColor& Color, class UTexture* Point_Texture, class UTexture* Marker_Texture, bool Points_face_up, class UObject* __WorldContext, TArray<class UMaterialInstanceDynamic*>* MID_Array_Reference, TArray<class UParticleSystemComponent*>* Trajectory_Beam_Reference, class UParticleSystemComponent** TrajectoryMarker_Reference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Spawn Trajectory Points Only");

	Params::BPF_PPT_ProjectilePathTracer_C_Spawn_Trajectory_Points_Only Parms{};

	Parms.Divisions = Divisions;
	Parms.Point_Size = Point_Size;
	Parms.Color = std::move(Color);
	Parms.Point_Texture = Point_Texture;
	Parms.Marker_Texture = Marker_Texture;
	Parms.Points_face_up = Points_face_up;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (MID_Array_Reference != nullptr)
		*MID_Array_Reference = std::move(Parms.MID_Array_Reference);

	if (Trajectory_Beam_Reference != nullptr)
		*Trajectory_Beam_Reference = std::move(Parms.Trajectory_Beam_Reference);

	if (TrajectoryMarker_Reference != nullptr)
		*TrajectoryMarker_Reference = Parms.TrajectoryMarker_Reference;
}


// Function BPF_PPT_ProjectilePathTracer.BPF_PPT_ProjectilePathTracer_C.Place Trajectory Points Only
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector>                  Trajectory_Points                                      (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class UParticleSystemComponent*> Trajectory_Beam_Reference                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UParticleSystemComponent*         Trajectory_Marker_Reference                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Out_Hit                                                (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    Points_face_up                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBPF_PPT_ProjectilePathTracer_C::Place_Trajectory_Points_Only(TArray<struct FVector>& Trajectory_Points, TArray<class UParticleSystemComponent*>& Trajectory_Beam_Reference, class UParticleSystemComponent* Trajectory_Marker_Reference, const struct FHitResult& Out_Hit, bool Points_face_up, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPF_PPT_ProjectilePathTracer_C", "Place Trajectory Points Only");

	Params::BPF_PPT_ProjectilePathTracer_C_Place_Trajectory_Points_Only Parms{};

	Parms.Trajectory_Points = std::move(Trajectory_Points);
	Parms.Trajectory_Beam_Reference = std::move(Trajectory_Beam_Reference);
	Parms.Trajectory_Marker_Reference = Trajectory_Marker_Reference;
	Parms.Out_Hit = std::move(Out_Hit);
	Parms.Points_face_up = Points_face_up;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Trajectory_Points = std::move(Parms.Trajectory_Points);
	Trajectory_Beam_Reference = std::move(Parms.Trajectory_Beam_Reference);
}

}

